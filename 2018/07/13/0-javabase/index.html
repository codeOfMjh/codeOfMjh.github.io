<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>0.JavaBase | No weal without woe!</title><meta name="keywords" content="Java,集合"><meta name="author" content="mjh"><meta name="copyright" content="mjh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java理论1. Java基础1.1 基础1.1.1 数据类型 基础数据类型    类型 byte short int char float long double boolean    位 8 16 32 16 32 64 64 ~    注意 boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定 JVM 会在编译时期将 boolean 类型的">
<meta property="og:type" content="article">
<meta property="og:title" content="0.JavaBase">
<meta property="og:url" content="https://codeofmjh.github.com/2018/07/13/0-javabase/index.html">
<meta property="og:site_name" content="No weal without woe!">
<meta property="og:description" content="Java理论1. Java基础1.1 基础1.1.1 数据类型 基础数据类型    类型 byte short int char float long double boolean    位 8 16 32 16 32 64 64 ~    注意 boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定 JVM 会在编译时期将 boolean 类型的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2018-07-13T07:10:40.000Z">
<meta property="article:modified_time" content="2021-10-31T14:16:41.190Z">
<meta property="article:author" content="mjh">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://codeofmjh.github.com/2018/07/13/0-javabase/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '0.JavaBase',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-31 22:16:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="No weal without woe!" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">No weal without woe!</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">0.JavaBase</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-07-13T07:10:40.000Z" title="发表于 2018-07-13 15:10:40">2018-07-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-31T14:16:41.190Z" title="更新于 2021-10-31 22:16:41">2021-10-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="0.JavaBase"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java理论"><a href="#Java理论" class="headerlink" title="Java理论"></a>Java理论</h1><h2 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1. Java基础"></a>1. Java基础</h2><h3 id="1-1-基础"><a href="#1-1-基础" class="headerlink" title="1.1 基础"></a>1.1 基础</h3><h4 id="1-1-1-数据类型"><a href="#1-1-1-数据类型" class="headerlink" title="1.1.1 数据类型"></a>1.1.1 数据类型</h4><ol>
<li><p>基础数据类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>byte</th>
<th>short</th>
<th>int</th>
<th>char</th>
<th>float</th>
<th>long</th>
<th>double</th>
<th>boolean</th>
</tr>
</thead>
<tbody><tr>
<td>位</td>
<td>8</td>
<td>16</td>
<td>32</td>
<td>16</td>
<td>32</td>
<td>64</td>
<td>64</td>
<td>~</td>
</tr>
</tbody></table>
<ul>
<li>注意<ul>
<li>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定</li>
<li>JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false</li>
<li>JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的</li>
</ul>
</li>
</ul>
</li>
<li><p>包装类型</p>
<blockquote>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成</p>
</blockquote>
<pre class=" language-java"><code class="language-java">Integer x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 装箱 调用了 Integer.valueOf(2)</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 拆箱 调用了 X.intValue()</span></code></pre>
</li>
</ol>
<h4 id="1-1-2-缓存池"><a href="#1-1-2-缓存池" class="headerlink" title="1.1.2 缓存池"></a>1.1.2 缓存池</h4><ol>
<li><p>new Integer(123) 与 Integer.valueOf(123) 的区别</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用</li>
</ul>
</li>
<li><p>valueOf() 方法的实现</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>
        <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>Java 8 中，Integer 缓存池的大小默认为 -128~127</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> Integer cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// high value may be configured by property</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
    String integerCacheHighPropValue <span class="token operator">=</span>
        sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>VM<span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">"java.lang.Integer.IntegerCache.high"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
            i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// Maximum array size is Integer.MAX_VALUE</span>
            h <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> NumberFormatException nfe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// If the property cannot be parsed into an int, ignore it.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    high <span class="token operator">=</span> h<span class="token punctuation">;</span>

    cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
        cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// range [-128, 127] must be interned (JLS7 5.1.7)</span>
    <span class="token keyword">assert</span> IntegerCache<span class="token punctuation">.</span>high <span class="token operator">>=</span> <span class="token number">127</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象</p>
<pre class=" language-java"><code class="language-java">Integer m <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
Integer n <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre>
</li>
<li><p>基本类型对应的缓冲池</p>
<blockquote>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>boolean</th>
<th>byte</th>
<th>short</th>
<th>int</th>
<th>char</th>
</tr>
</thead>
<tbody><tr>
<td>范围</td>
<td>values true and false</td>
<td>all byte values</td>
<td>values between -128 and 127</td>
<td>values between -128 and 127</td>
<td>in the range \u0000 to \u007F</td>
</tr>
</tbody></table>
<ul>
<li>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127</li>
<li>但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=&lt;size&gt; 来指定这个缓冲池的大小</li>
<li>该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界</li>
</ul>
</li>
</ol>
<h4 id="1-1-3-字符串"><a href="#1-1-3-字符串" class="headerlink" title="1.1.3 字符串"></a>1.1.3 字符串</h4><ul>
<li><p>概述</p>
<blockquote>
<p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p>
</blockquote>
</li>
<li><p>在 Java 8 中，String 内部使用 char 数组存储数据</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>
    <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>
    <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/** The identifier of the encoding used to encode the bytes in {@code value}. */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span> coder<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>不可变的优势</p>
<ul>
<li><p>可以缓存 hash 值</p>
<blockquote>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算</p>
</blockquote>
</li>
<li><p>String Pool 的需要</p>
<blockquote>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool</p>
</blockquote>
</li>
<li><p>安全性</p>
<blockquote>
<p>String 经常作为参数，String 不可变性可以保证参数不可变</p>
<p>例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是</p>
</blockquote>
</li>
<li><p>线程安全</p>
<blockquote>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用</p>
</blockquote>
</li>
</ul>
</li>
<li><p>小结</p>
<ul>
<li>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组</li>
<li>并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变</li>
</ul>
</li>
<li><p>String, StringBuffer and StringBuilder</p>
<ul>
<li>可变性<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
</li>
<li>线程安全<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
</li>
</ul>
</li>
<li><p>String Pool</p>
<blockquote>
<p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定</p>
<p>不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用</p>
<p>否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用</p>
</blockquote>
<pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// false</span>
String s3 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
String s4 <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// true</span></code></pre>
</li>
<li><p>采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中</p>
<pre class=" language-java"><code class="language-java">String s5 <span class="token operator">=</span> <span class="token string">"bbb"</span><span class="token punctuation">;</span>
String s6 <span class="token operator">=</span> <span class="token string">"bbb"</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s5 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true</span></code></pre>
</li>
<li><p>String Pool历史</p>
<ul>
<li>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代</li>
<li>在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误</li>
</ul>
</li>
<li><p>new String(“abc”)</p>
<blockquote>
<p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）</p>
</blockquote>
<ul>
<li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量</li>
<li>使用 new 的方式会在堆中创建一个字符串对象</li>
</ul>
</li>
<li><p>解释new String(“abc”)</p>
<ul>
<li><p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewStringTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>使用 javap -verbose 进行反编译，得到以下内容</p>
<blockquote>
<p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量</p>
<p>在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ...</span>
Constant pool<span class="token operator">:</span>
<span class="token comment" spellcheck="true">// ...</span>
   #<span class="token number">2</span> <span class="token operator">=</span> Class              #<span class="token number">18</span>            <span class="token comment" spellcheck="true">// java/lang/String</span>
   #<span class="token number">3</span> <span class="token operator">=</span> String             #<span class="token number">19</span>            <span class="token comment" spellcheck="true">// abc</span>
<span class="token comment" spellcheck="true">// ...</span>
  #<span class="token number">18</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>String
  #<span class="token number">19</span> <span class="token operator">=</span> Utf8               abc
<span class="token comment" spellcheck="true">// ...</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V
    flags<span class="token operator">:</span> ACC_PUBLIC<span class="token punctuation">,</span> ACC_STATIC
    Code<span class="token operator">:</span>
      stack<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>
         <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// class java/lang/String</span>
         <span class="token number">3</span><span class="token operator">:</span> dup
         <span class="token number">4</span><span class="token operator">:</span> ldc           #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// String abc</span>
         <span class="token number">6</span><span class="token operator">:</span> invokespecial #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/lang/String."&lt;init>":(Ljava/lang/String;)V</span>
         <span class="token number">9</span><span class="token operator">:</span> astore_1
<span class="token comment" spellcheck="true">// ...</span></code></pre>
</li>
<li><p>String 构造函数的源码</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组</span>
<span class="token keyword">public</span> <span class="token function">String</span><span class="token punctuation">(</span>String original<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> original<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> original<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="1-1-4-运算符"><a href="#1-1-4-运算符" class="headerlink" title="1.1.4 运算符"></a>1.1.4 运算符</h4><ol>
<li><p>参数传递</p>
<blockquote>
<p>Java 的参数是以值传递的形式传入方法中，而不是引用传递</p>
<p>将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中</p>
<p>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象</p>
</blockquote>
</li>
<li><p>特殊情形</p>
<blockquote>
<p>在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象</p>
<p>在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// A和B互不影响</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PassByValueExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Dog dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getObjectAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Dog@4554617c</span>
        <span class="token function">func</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getObjectAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Dog@4554617c</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// A</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Dog dog<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getObjectAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Dog@4554617c</span>
        dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getObjectAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Dog@74a14482</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// B</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>float 与 double</p>
<blockquote>
<p>Java 不能隐式执行向下转型，因为这会使得精度降低</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型</span>
<span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">1.1f</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确定义</span>
<span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">1.1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误定义</span></code></pre>
</li>
<li><p>隐式类型转换</p>
<blockquote>
<p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">short</span> s1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// s1 = s1 + 1;</span>

<span class="token comment" spellcheck="true">// 使用 += 或者 ++ 运算符会执行隐式类型转换</span>
s1 <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
s1<span class="token operator">++</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 上面的语句相当于将 s1 + 1 的计算结果进行了向下转型</span>
s1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>s1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>switch</p>
<blockquote>
<p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象</p>
<p>switch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断</p>
<p>如果值过于复杂，那么还是用 if 比较合适</p>
</blockquote>
</li>
</ol>
<h4 id="1-1-5-关键字"><a href="#1-1-5-关键字" class="headerlink" title="1.1.5 关键字"></a>1.1.5 关键字</h4><ol>
<li><p>final</p>
<ul>
<li><p>数据</p>
<blockquote>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量</p>
</blockquote>
<ul>
<li>对于基本类型，final 使数值不变</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// x = 2;  // cannot assign value to final variable 'x'</span>
<span class="token keyword">final</span> A y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
y<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>方法</p>
<ul>
<li>声明方法不能被子类重写</li>
<li>private 方法隐式地被指定为 final</li>
<li>子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法</li>
</ul>
</li>
<li><p>类</p>
<blockquote>
<p>声明类不允许被继承</p>
</blockquote>
</li>
</ul>
</li>
<li><p>static</p>
<ul>
<li><p>静态变量</p>
<blockquote>
<p>又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它</p>
<p>静态变量在内存中只存在一份</p>
</blockquote>
</li>
<li><p>实例变量</p>
<blockquote>
<p>每创建一个实例就会产生一个实例变量，它与该实例同生共死</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 实例变量</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 静态变量</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// int x = A.x;  // Non-static field 'x' cannot be referenced from a static context</span>
        A a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> a<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
        <span class="token keyword">int</span> y <span class="token operator">=</span> A<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>静态方法</p>
<blockquote>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例</p>
<p>静态方法必须有实现，也就是说它不能是抽象方法</p>
<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联</p>
</blockquote>
</li>
<li><p>静态代码块</p>
<blockquote>
<p>静态语句块在类初始化时运行一次</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        A a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        A a2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>静态内部类</p>
<blockquote>
<p>非静态内部类依赖于外部类的实例</p>
<p>需要先创建外部类实例，才能用这个实例去创建非静态内部类</p>
<p>静态内部类不能访问外部类的非静态的变量和方法</p>
</blockquote>
</li>
<li><p>静态包</p>
<blockquote>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低</p>
</blockquote>
<pre class=" language-jav"><code class="language-jav">import static com.xxx.ClassName.*</code></pre>
</li>
<li><p>初始化顺序</p>
<blockquote>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String staticField <span class="token operator">=</span> <span class="token string">"静态变量"</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态语句块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> String field <span class="token operator">=</span> <span class="token string">"实例变量"</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通语句块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 最后才是构造函数的初始化</span>
<span class="token keyword">public</span> <span class="token function">InitialOrderTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>存在继承的情况下，初始化顺序为</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="1-1-6-对象方法"><a href="#1-1-6-对象方法" class="headerlink" title="1.1.6 对象方法"></a>1.1.6 对象方法</h4><ul>
<li><p>通用方法</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>

<span class="token keyword">protected</span> <span class="token keyword">native</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException

<span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token keyword">int</span> nanos<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException</code></pre>
</li>
<li><p>equals()</p>
<ul>
<li>等价关系，满足以下条件<ul>
<li>自反性</li>
<li>对称性</li>
<li>传递性</li>
<li>一致性</li>
<li>任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</li>
</ul>
</li>
<li>等价与相等<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价</li>
</ul>
</li>
<li>实现<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true</li>
<li>检查是否是同一个类型，如果不是，直接返回 false</li>
<li>将 Object 对象进行转型</li>
<li>判断每个关键域是否相等</li>
</ul>
</li>
</ul>
</li>
<li><p>hashCode()</p>
<blockquote>
<p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价</p>
<p>等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价</p>
<p>因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值</p>
</blockquote>
<ul>
<li><p>注意</p>
<ul>
<li>覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等</li>
<li>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法</li>
</ul>
</li>
<li><p>泊松分布</p>
<blockquote>
<p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上,要求了哈希函数要把所有域的值都考虑进来,可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数</p>
<p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失</p>
<p>一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化</p>
</blockquote>
</li>
</ul>
</li>
<li><p>toString()</p>
<blockquote>
<p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示</p>
</blockquote>
</li>
<li><p>clone()</p>
<blockquote>
<p>是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法</p>
<p>clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法</p>
<p>Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException</p>
</blockquote>
<ul>
<li><p>浅拷贝</p>
<blockquote>
<p>拷贝对象和原始对象的引用类型引用同一个对象</p>
</blockquote>
</li>
<li><p>深拷贝</p>
<blockquote>
<p>拷贝对象和原始对象的引用类型引用不同对象</p>
</blockquote>
</li>
<li><p>clone()的替代方案</p>
<blockquote>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换</p>
<p>最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="1-1-7-面向对象"><a href="#1-1-7-面向对象" class="headerlink" title="1.1.7 面向对象"></a>1.1.7 面向对象</h4><ol>
<li><p>继承</p>
<ul>
<li><p>访问权限</p>
<blockquote>
<p>三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见</p>
<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来</p>
<p>模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装</p>
<p>因此访问权限应当尽可能地使每个类或者成员不被外界访问</p>
<p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别;这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则</p>
</blockquote>
</li>
<li><p>类可见表示其它类可以用这个类创建实例对象</p>
</li>
<li><p>成员可见表示其它类可以用这个类的实例对象访问到该成员</p>
</li>
<li><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改</p>
</li>
</ul>
</li>
<li><p>抽象类和接口</p>
<ul>
<li><p>抽象类</p>
<blockquote>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明</p>
<p>一个类中包含抽象方法，那么这个类必须声明为抽象类</p>
<p>抽象类不能被实例化，只能被继承</p>
</blockquote>
</li>
<li><p>接口</p>
<blockquote>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现</p>
<p>Java 8 开始，接口也可以拥有默认的方法实现</p>
<p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected</p>
<p>Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去</p>
<p>接口的字段默认都是 static 和 final 的</p>
</blockquote>
</li>
</ul>
</li>
<li><p>super</p>
<blockquote>
<p>可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作</p>
<p>子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数</p>
<p>使用 super 关键字来引用父类的方法实现</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">protected</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">SuperExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperExample.func()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperExtendExample</span> <span class="token keyword">extends</span> <span class="token class-name">SuperExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> z<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">SuperExtendExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 委托父类完成一些初始化工作</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>z <span class="token operator">=</span> z<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用super关键字来引用父类方法的实现</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperExtendExample.func()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

SuperExample e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperExtendExample</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
e<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// SuperExample.func()</span>
          <span class="token comment" spellcheck="true">// SuperExtendExample.func()</span></code></pre>
</li>
<li><p>重写与重载</p>
<ul>
<li><p>重写</p>
<blockquote>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法</p>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件</p>
</blockquote>
<ul>
<li><p>限制</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</li>
</ul>
</li>
<li><p>方法调用</p>
<blockquote>
<p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承</p>
<p>否则就要对参数进行转型，转成父类之后看是否有对应的方法</p>
</blockquote>
</li>
<li><p>方法调用优先级</p>
<p><code>this.func(this)</code>&gt;<code>super.func(this)</code>&gt;<code>this.func(super)</code>&gt;<code>super.func(super)</code></p>
</li>
</ul>
</li>
<li><p>重载</p>
<blockquote>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同</p>
<p>返回值不同，其它都相同不算是重载</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="1-1-8-反射"><a href="#1-1-8-反射" class="headerlink" title="1.1.8 反射"></a>1.1.8 反射</h4><ol>
<li><p>概述</p>
<blockquote>
<p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息</p>
<p>当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中</p>
<p>使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象</p>
</blockquote>
</li>
<li><p>作用</p>
<blockquote>
<p>提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来</p>
</blockquote>
</li>
<li><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类</p>
<ul>
<li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段</li>
<li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法</li>
<li><strong>Constructor</strong> ：可以用 Constructor 的 newInstance() 创建新的对象</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>可扩展性</p>
<blockquote>
<p>应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类</p>
</blockquote>
</li>
<li><p>类浏览器和可视化开发环境</p>
<blockquote>
<p>一个类浏览器需要可以枚举类的成员</p>
<p>可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码</p>
</blockquote>
</li>
<li><p>调试器和测试工具</p>
<blockquote>
<p>调试器需要能够检查一个类里的私有成员</p>
<p>测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率</p>
</blockquote>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>性能开销</p>
<blockquote>
<p>反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化</p>
</blockquote>
</li>
<li><p>安全限制</p>
<blockquote>
<p>使用反射技术要求程序必须在一个没有安全限制的环境中运行</p>
</blockquote>
</li>
<li><p>内部暴露</p>
<blockquote>
<p>使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性</p>
<p>反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="1-1-9-其他"><a href="#1-1-9-其他" class="headerlink" title="1.1.9 其他"></a>1.1.9 其他</h4><ol>
<li><p>异常</p>
<blockquote>
<p>Throwable 可以用来表示任何可以作为异常抛出的类</p>
<p>Error 和 Exception</p>
</blockquote>
<ul>
<li>Error 用来表示 JVM 无法处理的错误</li>
<li>Exception<ul>
<li>受检异常 ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复</li>
<li>非受检异常 ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception</li>
</ul>
</li>
</ul>
</li>
<li><p>泛型</p>
<blockquote>
<p>即“参数化类型”,将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）</p>
<p>在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型</p>
</blockquote>
</li>
<li><p>新特性</p>
<ul>
<li><p>注解</p>
<blockquote>
<p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能</p>
</blockquote>
</li>
<li><p>新特性</p>
<table>
<thead>
<tr>
<th align="left">Java8</th>
<th align="left">Lambda Expressions</th>
<th align="left">Pipelines and Streams</th>
<th align="left">Date and Time API</th>
<th align="left">Default Methods</th>
<th align="left">Type Annotations</th>
<th align="left">Nashhorn JavaScript Engine</th>
<th align="left">Concurrent Accumulators</th>
<th align="left">Parallel operations</th>
<th align="left">PermGen Error Removed</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Java7</td>
<td align="left">Strings in Switch Statement</td>
<td align="left">Type Inference for Generic Instance Creation</td>
<td align="left">Multiple Exception Handling</td>
<td align="left">Support for Dynamic Languages</td>
<td align="left">Try with Resources</td>
<td align="left">Java nio Package</td>
<td align="left">Binary Literals, Underscore in literals</td>
<td align="left">Diamond Syntax</td>
<td align="left"></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>JRE or JDK</p>
<ul>
<li>JRE：Java 运行环境的简称，为 Java 的运行提供了所需的环境</li>
<li>JDK：Java 开发工具包，提供了 Java 的开发及运行环境；Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac</li>
</ul>
</li>
</ol>
<h3 id="1-2-容器"><a href="#1-2-容器" class="headerlink" title="1.2 容器"></a>1.2 容器</h3><ol>
<li><p>概述</p>
<blockquote>
<p>主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表</p>
</blockquote>
</li>
</ol>
<h4 id="1-2-1-接口"><a href="#1-2-1-接口" class="headerlink" title="1.2.1 接口"></a>1.2.1 接口</h4><ol>
<li>Collection<ol>
<li>Set<ul>
<li>TreeSet：基于红黑树实现，支持有序性操作，查找的时间复杂度为O(logN)</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作；失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序</li>
</ul>
</li>
<li>List<ul>
<li>ArrayList：基于动态数组实现，支持随机访问</li>
<li>Vector：和 ArrayList 类似，但它是线程安全的</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元</li>
</ul>
</li>
<li>Queue<ul>
<li>LinkedList：可以用它来实现双向队列</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列</li>
</ul>
</li>
</ol>
</li>
<li>Map<ul>
<li>TreeMap：基于红黑树实现</li>
<li>HashMap：基于哈希表实现</li>
<li>HashTable：和 HashMap 类似，但它是线程安全的，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序</li>
</ul>
</li>
</ol>
<h4 id="1-2-2-设计模式"><a href="#1-2-2-设计模式" class="headerlink" title="1.2.2 设计模式"></a>1.2.2 设计模式</h4><ol>
<li><p>迭代器模式</p>
<blockquote>
<p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元</p>
</blockquote>
</li>
<li><p>适配器模式</p>
<blockquote>
<p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型</p>
<p>asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组</p>
</blockquote>
</li>
</ol>
<h4 id="1-2-3-源码分析"><a href="#1-2-3-源码分析" class="headerlink" title="1.2.3 源码分析"></a>1.2.3 源码分析</h4><ol>
<li><p>概述</p>
<blockquote>
<p>源码分析基于 JDK 1.8</p>
</blockquote>
</li>
<li><p>分析</p>
<ul>
<li><p>ArrayList</p>
<ul>
<li><p>概述</p>
<blockquote>
<p>基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span>
        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> RandomAccess<span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</code></pre>
</li>
<li><p>扩容</p>
<blockquote>
<p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，即 oldCapacity+oldCapacity/2</p>
<p>其中 oldCapacity &gt;&gt; 1 需要取整，所以新容量大约是旧容量的 1.5 倍左右</p>
<p>oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 数组的默认大小为 10</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>
    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        minCapacity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// overflow-conscious code</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// overflow-conscious code</span>
    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>
    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>删除</p>
<blockquote>
<p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>
    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>
    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>序列化</p>
<blockquote>
<p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化</p>
<p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化</p>
<p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// non-private to simplify nested class access</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectInputStream s<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>
    elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Read in size, and any hidden stuff</span>
    s<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Read in capacity</span>
    s<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ignored</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// be like clone(), allocate array based upon size not capacity</span>
        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>

        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> elementData<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// Read in all elements in the proper order.</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectOutputStream s<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Write out element count, and any hidden stuff</span>
    <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
    s<span class="token punctuation">.</span><span class="token function">defaultWriteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Write out size as capacity for behavioural compatibility with clone()</span>
    s<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Write out all elements in the proper order.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        s<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>序列化操作</p>
<blockquote>
<p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似</p>
</blockquote>
<pre class=" language-java"><code class="language-java">ArrayList list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ObjectOutputStream oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>Fail-Fast</p>
<blockquote>
<p>modCount 用来记录 ArrayList 结构发生变化的次数</p>
<p>结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException</p>
</blockquote>
</li>
</ul>
</li>
<li><p>HashMap</p>
<ul>
<li><p>存储结构</p>
<blockquote>
<p>内部包含了一个 Entry 类型的数组 table</p>
<p>Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表</p>
<p>数组中的每个位置被当成一个桶，一个桶存放一个链表</p>
<p>HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>
    V value<span class="token punctuation">;</span>
    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>
    <span class="token keyword">int</span> hash<span class="token punctuation">;</span>

    <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">=</span> v<span class="token punctuation">;</span>
        next <span class="token operator">=</span> n<span class="token punctuation">;</span>
        key <span class="token operator">=</span> k<span class="token punctuation">;</span>
        hash <span class="token operator">=</span> h<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>
        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        Map<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token punctuation">)</span>o<span class="token punctuation">;</span>
        Object k1 <span class="token operator">=</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Object k2 <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k1 <span class="token operator">==</span> k2 <span class="token operator">||</span> <span class="token punctuation">(</span>k1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> k1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Object v1 <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Object v2 <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>v1 <span class="token operator">==</span> v2 <span class="token operator">||</span> <span class="token punctuation">(</span>v1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> v1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>拉链法原理</p>
<blockquote>
<p>查找</p>
<ul>
<li>计算键值对所在的桶</li>
<li>在链表上顺序查找，时间复杂度显然和链表的长度成正比</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 新建一个 HashMap，默认大小为 16</span>
<span class="token comment" spellcheck="true">// 插入&lt;K1,V1> 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</span>
<span class="token comment" spellcheck="true">// 插入&lt;K2,V2> 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</span>
<span class="token comment" spellcheck="true">// 插入&lt;K3,V3> 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2> 前面。</span>
<span class="token comment" spellcheck="true">// 应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3> 不是插在 &lt;K2,V2> 后面，而是插入在链表头部</span>

HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"K1"</span><span class="token punctuation">,</span> <span class="token string">"V1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"K2"</span><span class="token punctuation">,</span> <span class="token string">"V2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"K3"</span><span class="token punctuation">,</span> <span class="token string">"V3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>put操作</p>
<blockquote>
<p>HashMap 允许插入键为 null 的键值对</p>
<p>因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放</p>
<p>HashMap 使用第 0 个桶存放键为 null 的键值对</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 键为 null 单独处理</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 确定桶下标</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Object k<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 插入新键值对</span>
    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
        bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 头插法，链表头部指向新的键值对</span>
    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    value <span class="token operator">=</span> v<span class="token punctuation">;</span>
    next <span class="token operator">=</span> n<span class="token punctuation">;</span>
    key <span class="token operator">=</span> k<span class="token punctuation">;</span>
    hash <span class="token operator">=</span> h<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li><p>确定桶下标</p>
<blockquote>
<p>很多操作都需要先确定一个键值对所在的桶下标</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>计算hash值</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> h <span class="token operator">&amp;&amp;</span> k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Hashing<span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>
    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>
    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>
    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>取模</p>
<ul>
<li><p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质</p>
<pre class=" language-java"><code class="language-java">x   <span class="token operator">:</span> <span class="token number">00010000</span>
x<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">00001111</span></code></pre>
</li>
<li><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数</p>
<pre class=" language-java"><code class="language-java">y       <span class="token operator">:</span> <span class="token number">10110010</span>
x<span class="token operator">-</span><span class="token number">1</span>     <span class="token operator">:</span> <span class="token number">00001111</span>
y<span class="token operator">&amp;</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">00000010</span></code></pre>
</li>
<li><p>这个性质和 y 对 x 取模效果是一样的</p>
<pre class=" language-java"><code class="language-java">y   <span class="token operator">:</span> <span class="token number">10110010</span>
x   <span class="token operator">:</span> <span class="token number">00010000</span>
y<span class="token operator">%</span>x <span class="token operator">:</span> <span class="token number">00000010</span></code></pre>
</li>
<li><p>位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能</p>
</li>
</ul>
</li>
<li><p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>扩容-基本原理</p>
<blockquote>
<p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)</p>
<p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大</p>
<p>HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证</p>
</blockquote>
</li>
<li><p>扩容-主要参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>capacity</td>
<td>table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td>size</td>
<td>键值对数量。</td>
</tr>
<tr>
<td>threshold</td>
<td>size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td>
</tr>
<tr>
<td>loadFactor</td>
<td>装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</td>
</tr>
</tbody></table>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>

<span class="token keyword">transient</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

<span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>

<span class="token keyword">int</span> threshold<span class="token punctuation">;</span>

<span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>

<span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span></code></pre>
<blockquote>
<p>需要扩容时，令 capacity 为原来的两倍</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size<span class="token operator">++</span> <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">)</span><span class="token punctuation">;</span>
    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>
    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> src <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> src<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> src<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            src<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>
            <span class="token keyword">do</span> <span class="token punctuation">{</span>
                Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
                e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                e <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>扩容-重新计算桶下标</p>
<blockquote>
<p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上</p>
<p>HashMap 使用 hash%capacity 来确定桶下标</p>
<p>HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32</span>
capacity     <span class="token operator">:</span> <span class="token number">00010000</span>
<span class="token keyword">new</span> <span class="token class-name">capacity</span> <span class="token operator">:</span> <span class="token number">00100000</span></code></pre>
<p>对于一个key，它的哈希值hash在第5位</p>
<ul>
<li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致</li>
<li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16</li>
</ul>
</li>
<li><p>计算数组容量</p>
<blockquote>
<p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到</span>

mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">1</span>    <span class="token number">11011000</span>
mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">2</span>    <span class="token number">11111110</span>
mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">4</span>    <span class="token number">11111111</span>

<span class="token comment" spellcheck="true">// mask+1 是大于原始数字的最小的 2 的 n 次方</span>
num     <span class="token number">10010000</span>
mask<span class="token operator">+</span><span class="token number">1</span> <span class="token number">100000000</span></code></pre>
</li>
<li><p>HashMap中计算数组容量的代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>链表转红黑树</p>
<blockquote>
<p>从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树</p>
</blockquote>
</li>
<li><p>比较</p>
<ul>
<li>Hashtable 使用 synchronized 来进行同步</li>
<li>HashMap 可以插入键为 null 的 Entry</li>
<li>HashMap 的迭代器是 fail-fast 迭代器</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>LinkedList</p>
<ul>
<li><p>概述</p>
<blockquote>
<p>基于双向链表实现，使用 Node 存储链表节点信息</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    E item<span class="token punctuation">;</span>
    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>
    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 每个链表存储了 first 和 last 指针</span>
<span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first<span class="token punctuation">;</span>
<span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span></code></pre>
</li>
<li><p>比较</p>
<blockquote>
<p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现</p>
</blockquote>
<ul>
<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素</li>
<li>链表不支持随机访问，但插入删除只需要改变指针</li>
</ul>
</li>
</ul>
</li>
<li><p>LinkedHashMap</p>
<ul>
<li><p>存储结构</p>
<blockquote>
<p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性</p>
<p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span>

<span class="token comment" spellcheck="true">/**
 * The head (eldest) of the doubly linked list.
 */</span>
<span class="token keyword">transient</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> head<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * The tail (youngest) of the doubly linked list.
 */</span>
<span class="token keyword">transient</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> tail<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序</span>
<span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用</span>
<span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre>
</li>
<li><p>afterNodeAccess()</p>
<blockquote>
<p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// move node to last</span>
    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> last<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span>
            <span class="token punctuation">(</span>LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>after <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> null<span class="token punctuation">)</span>
            head <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> null<span class="token punctuation">)</span>
            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            last <span class="token operator">=</span> b<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> null<span class="token punctuation">)</span>
            head <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>
            last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        tail <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>afterNodeInsertion()</p>
<blockquote>
<p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true</p>
<p>removeEldestEntry() 默认为false，如果需要让它为 true，需要继承LinkedHashMap 并且覆盖这个方法的实现</p>
<p>实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// possibly remove eldest</span>
    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        K key <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
        <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>LRU缓存</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES 为 3</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ENTRIES <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> MAX_ENTRIES<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>MAX_ENTRIES<span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    LRUCache<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LRUCache</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ul>
</li>
<li><p>ConcurrentHashMap</p>
<ul>
<li><p>存储结构</p>
<blockquote>
<p>ConcurrentHashMap 和 HashMap 实现上类似</p>
<p>ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> V value<span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Segment 继承自 ReentrantLock</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 2249069246763182397L<span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_SCAN_RETRIES <span class="token operator">=</span>
        Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">64</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">transient</span> <span class="token keyword">volatile</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

    <span class="token keyword">transient</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>

    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>

    <span class="token keyword">transient</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>

    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 默认的并发级别为 16，也就是说默认创建 16 个 Segment</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CONCURRENCY_LEVEL <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>size操作</p>
<blockquote>
<p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数</p>
<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * The number of elements. Accessed only either within locks
 * or among other volatile reads that maintain visibility.
 */</span>
<span class="token keyword">transient</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * Number of unsynchronized retries in size and containsValue
 * methods before resorting to locking. This is used to avoid
 * unbounded retries if tables undergo continuous modification
 * which would make it impossible to obtain an accurate result.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RETRIES_BEFORE_LOCK <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Try a few times to get accurate count. On failure due to</span>
    <span class="token comment" spellcheck="true">// continuous async changes in table, resort to locking.</span>
    <span class="token keyword">final</span> Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>segments<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> overflow<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true if size overflows 32 bits</span>
    <span class="token keyword">long</span> sum<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// sum of modCounts</span>
    <span class="token keyword">long</span> last <span class="token operator">=</span> 0L<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// previous sum</span>
    <span class="token keyword">int</span> retries <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// first iteration isn't retry</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 超过尝试次数，则对每个 Segment 加锁</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>retries<span class="token operator">++</span> <span class="token operator">==</span> RETRIES_BEFORE_LOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
                    <span class="token function">ensureSegment</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// force creation</span>
            <span class="token punctuation">}</span>
            sum <span class="token operator">=</span> 0L<span class="token punctuation">;</span>
            size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            overflow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> seg <span class="token operator">=</span> <span class="token function">segmentAt</span><span class="token punctuation">(</span>segments<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>seg <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    sum <span class="token operator">+=</span> seg<span class="token punctuation">.</span>modCount<span class="token punctuation">;</span>
                    <span class="token keyword">int</span> c <span class="token operator">=</span> seg<span class="token punctuation">.</span>count<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>size <span class="token operator">+=</span> c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        overflow <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 连续两次得到的结果一致，则认为这个结果是正确的</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> last<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            last <span class="token operator">=</span> sum<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>retries <span class="token operator">></span> RETRIES_BEFORE_LOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
                <span class="token function">segmentAt</span><span class="token punctuation">(</span>segments<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> overflow <span class="token operator">?</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> size<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>1.8改进</p>
<ul>
<li>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等</li>
<li>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized</li>
<li>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树</li>
</ul>
</li>
</ul>
</li>
<li><p>Vector</p>
<ul>
<li><p>同步</p>
<blockquote>
<p>实现与 ArrayList 类似，但是使用了 synchronized 进行同步</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">ensureCapacityHelper</span><span class="token punctuation">(</span>elementCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    elementData<span class="token punctuation">[</span>elementCount<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">synchronized</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> elementCount<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>扩容</p>
<blockquote>
<p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement</p>
<p>如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">int</span> capacityIncrement<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>
                                           initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>capacityIncrement <span class="token operator">=</span> capacityIncrement<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// overflow-conscious code</span>
    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>capacityIncrement <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                                     capacityIncrement <span class="token operator">:</span> oldCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>比较</p>
<ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制</li>
<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍</li>
</ul>
</li>
<li><p>替代方案</p>
<blockquote>
<p>使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList</p>
<p>使用 concurrent 并发包下的 CopyOnWriteArrayList 类</p>
</blockquote>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> synList <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>

List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ul>
</li>
<li><p>CopyOnWriteArrayList</p>
<ul>
<li><p>读写分离</p>
<blockquote>
<p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失</p>
<p>写操作结束之后需要把原始数组指向新的复制数组</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setArray</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    array <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> E <span class="token function">get</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>应用场景</p>
<blockquote>
<p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景</p>
<p>不适合内存敏感以及对实时性要求很高的场景</p>
</blockquote>
</li>
<li><p>缺陷</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中</li>
</ul>
</li>
</ul>
</li>
<li><p>WeakHashMap</p>
<ul>
<li><p>存储结构</p>
<blockquote>
<p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span></code></pre>
</li>
<li><p>ConcurrentCache</p>
<blockquote>
<p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能</p>
</blockquote>
</li>
<li><p>ConcurrentCache采取的是分代缓存</p>
<ul>
<li>经常使用的对象放入eden中，eden使用ConcurrentHashMap实现，不用担心会被回收（伊甸园）</li>
<li>不常用的对象放入longterm，longterm使用WeakHashMap实现，这些老对象会被垃圾收集器回收</li>
<li>当调用get()方法时，会先从eden区获取，如果没有找到的话再到longterm获取，当从longterm获取到就把对象放入eden中，从而保证经常被访问的节点不容易被回收</li>
<li>当调用put()方法时，如果eden的大小超过了size，那么就将eden中的所有对象都放入longterm中，利用虚拟机回收掉一部分不经常使用的对象</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentCache</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> eden<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> longterm<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">ConcurrentCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>eden <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>longterm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>K k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        V v <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            v <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>longterm<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> v<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>K k<span class="token punctuation">,</span> V v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>longterm<span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-3-IO"><a href="#1-3-IO" class="headerlink" title="1.3 IO"></a>1.3 IO</h3><h4 id="1-3-1-基础"><a href="#1-3-1-基础" class="headerlink" title="1.3.1 基础"></a>1.3.1 基础</h4><ul>
<li><p>磁盘操作：File</p>
<blockquote>
<p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容</p>
</blockquote>
</li>
<li><p>字节操作：InputStream 和 OutputStream</p>
<ul>
<li><p>装饰者模式</p>
<blockquote>
<p>Java I/O 使用了装饰者模式来实现</p>
</blockquote>
</li>
<li><p>InputStream 是抽象组件</p>
</li>
<li><p>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作</p>
</li>
<li><p>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能</p>
<ul>
<li>例如 BufferedInputStream 为 FileInputStream 提供缓存的功能</li>
</ul>
</li>
<li><p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可</p>
</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型</span>
FileInputStream fileInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
BufferedInputStream bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>fileInputStream<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>字符操作：Reader 和 Writer</p>
<ul>
<li><p>编码与解码</p>
<blockquote>
<p>编码就是把字符转换为字节，而解码是把字节重新组合成字符</p>
<p>如果编码和解码过程使用不同的编码方式那么就出现了乱码</p>
</blockquote>
</li>
<li><p>常见编码方式</p>
<ul>
<li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节</li>
<li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节</li>
<li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节</li>
</ul>
</li>
<li><p>java内存编码</p>
<blockquote>
<p>UTF-16be 中的 be 指的是 Big Endian，也就是大端</p>
<p>UTF-16le中的le 指的是 Little Endian，也就是小端</p>
<p>Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码</p>
<p>char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储</p>
</blockquote>
</li>
<li><p>String的编码方式</p>
<blockquote>
<p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String</p>
</blockquote>
<pre class=" language-java"><code class="language-java">String str1 <span class="token operator">=</span> <span class="token string">"中文"</span><span class="token punctuation">;</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<blockquote>
<p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>Reader与Writer</p>
<blockquote>
<p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符</p>
<p>在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法</p>
</blockquote>
<ul>
<li>InputStreamReader 实现从字节流解码成字符流</li>
<li>OutputStreamWriter 实现字符流编码成为字节流</li>
</ul>
</li>
</ul>
</li>
<li><p>对象操作：Serializable</p>
<blockquote>
<p>序列化就是将一个对象转换成字节序列，方便存储和传输</p>
<p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态</p>
</blockquote>
<ul>
<li><p>序列化：ObjectOutputStream.writeObject()</p>
</li>
<li><p>反序列化：ObjectInputStream.readObject()</p>
</li>
<li><p>Serializable</p>
<blockquote>
<p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常</p>
</blockquote>
</li>
<li><p>transient</p>
<blockquote>
<p>transient 关键字可以使一些属性不会被序列化</p>
<p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span></code></pre>
</li>
</ul>
</li>
<li><p>网络操作：Socket</p>
<ul>
<li><p>InetAddress：用于表示网络上的硬件资源，即 IP 地址</p>
<blockquote>
<p>没有公有的构造函数，只能通过静态方法来创建实例</p>
</blockquote>
</li>
<li><p>URL：统一资源定位符</p>
<blockquote>
<p>可以直接从 URL 中读取字节流数据</p>
</blockquote>
</li>
<li><p>Sockets：使用 TCP 协议实现网络通信</p>
<ul>
<li><p>ServerSocket：服务器端类</p>
</li>
<li><p>Socket：客户端类</p>
</li>
<li><p>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出</p>
</li>
<li><p>通信示意</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/2018/07/13/0-javabase/githubblog\source_posts\notes\001.Sockets通信.png" alt="Sockets通信"></p>
</li>
</ul>
</li>
<li><p>Datagram：使用 UDP 协议实现网络通信</p>
<ul>
<li>DatagramSocket：通信类</li>
<li>DatagramPacket：数据包类</li>
</ul>
</li>
</ul>
</li>
<li><p>新的输入/输出：NIO</p>
<blockquote>
<p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O</p>
</blockquote>
<ul>
<li><p>流与块</p>
<blockquote>
<p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据</p>
</blockquote>
<ul>
<li>面向流的 I/O 一次处理一个字节数据<ul>
<li>优点<ul>
<li>一个输入流产生一个字节数据，一个输出流消费一个字节数据</li>
<li>为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分</li>
</ul>
</li>
<li>缺点<ul>
<li>面向流的 I/O 通常相当慢</li>
</ul>
</li>
</ul>
</li>
<li>面向块的 I/O 一次处理一个数据块<ul>
<li>优点<ul>
<li>按块处理数据比按流处理数据要快得多</li>
</ul>
</li>
<li>缺点<ul>
<li>面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>通道与缓冲区</p>
<blockquote>
<p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据</p>
<p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写</p>
</blockquote>
<ul>
<li><p>类型</p>
<ul>
<li>FileChannel：从文件中读写数据</li>
<li>DatagramChannel：通过UDP读写网络中数据</li>
<li>SocketChannel：通过TCP读写网络中数据</li>
<li>ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel</li>
</ul>
</li>
<li><p>缓冲区</p>
<blockquote>
<p>发送给一个通道的所有数据都必须首先放到缓冲区中</p>
<p>从通道中读取的任何数据都要先读到缓冲区中</p>
<p>不会直接对通道进行读写数据，而是要先经过缓冲区</p>
<p><font color="red">缓冲区实质上是一个数组，但它不仅仅是一个数组</font></p>
<p>缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程</p>
</blockquote>
</li>
<li><p>类型</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
</li>
</ul>
</li>
<li><p>缓冲区状态变量</p>
<ul>
<li>capacity：最大容量</li>
<li>position：当前已经读写的字节数</li>
<li>limit：还可以读写的字节数</li>
<li>状态变量的改变过程举例<ul>
<li>新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8，capacity 变量不会改变</li>
<li>从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变</li>
<li>在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0</li>
<li>从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4</li>
<li>最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置</li>
</ul>
</li>
</ul>
</li>
<li><p>选择器</p>
<blockquote>
<p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用</p>
</blockquote>
<ul>
<li>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件</li>
<li>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行</li>
<li>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能</li>
<li>只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义</li>
</ul>
</li>
<li><p>内存映射文件</p>
<blockquote>
<p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多</p>
<p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件</p>
<p>修改数据与将数据保存到磁盘是没有分开的</p>
</blockquote>
</li>
<li><p>NIO与普通I/O的区别</p>
<ul>
<li>NIO 是非阻塞的</li>
<li>NIO 面向块，I/O 面向流</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-3-2-基础操作"><a href="#1-3-2-基础操作" class="headerlink" title="1.3.2 基础操作"></a>1.3.2 基础操作</h4><ol>
<li><p>磁盘操作</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归地列出一个目录下所有文件</span>
<span class="token comment" spellcheck="true">// 从 Java7 开始，可以使用 Paths 和 Files 代替 File</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">listAllFiles</span><span class="token punctuation">(</span>File dir<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dir <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>dir<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dir<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dir<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>File file <span class="token operator">:</span> dir<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">listAllFiles</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>字节操作</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 文件复制</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">copyFile</span><span class="token punctuation">(</span>String src<span class="token punctuation">,</span> String dist<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
    FileInputStream in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
    FileOutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>dist<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">20</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> cnt<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// read() 最多读取 buffer.length 个字节</span>
    <span class="token comment" spellcheck="true">// 返回的是实际读取的个数</span>
    <span class="token comment" spellcheck="true">// 返回 -1 的时候表示读到 eof，即文件尾</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cnt <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>字符操作</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 逐行输出文本文件的内容</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">readFileContent</span><span class="token punctuation">(</span>String filePath<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>

    FileReader fileReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
    BufferedReader bufferedReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>fileReader<span class="token punctuation">)</span><span class="token punctuation">;</span>

    String line<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> bufferedReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span>
    <span class="token comment" spellcheck="true">// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法</span>
    <span class="token comment" spellcheck="true">// 因此只要一个 close() 调用即可</span>
    bufferedReader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>序列化</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>

    A a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    String objectFile <span class="token operator">=</span> <span class="token string">"file/a1"</span><span class="token punctuation">;</span>

    ObjectOutputStream objectOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>objectFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    objectOutputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    ObjectInputStream objectInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>objectFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    A a2 <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span> objectInputStream<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    objectInputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String y<span class="token punctuation">;</span>

    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> String y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"x = "</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">"  "</span> <span class="token operator">+</span> <span class="token string">"y = "</span> <span class="token operator">+</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>InetAddress</p>
<pre class=" language-java"><code class="language-java">InetAddress<span class="token punctuation">.</span><span class="token function">getByName</span><span class="token punctuation">(</span>String host<span class="token punctuation">)</span><span class="token punctuation">;</span>
InetAddress<span class="token punctuation">.</span><span class="token function">getByAddress</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>URL</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>

    URL url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"http://www.baidu.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* 字节流 */</span>
    InputStream is <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">openStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* 字符流 */</span>
    InputStreamReader isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* 提供缓存功能 */</span>
    BufferedReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>isr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    String line<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>文件NIO实例</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fastCopy</span><span class="token punctuation">(</span>String src<span class="token punctuation">,</span> String dist<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/* 获得源文件的输入字节流 */</span>
    FileInputStream fin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* 获取输入字节流的文件通道 */</span>
    FileChannel fcin <span class="token operator">=</span> fin<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* 获取目标文件的输出字节流 */</span>
    FileOutputStream fout <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>dist<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* 获取输出字节流的文件通道 */</span>
    FileChannel fcout <span class="token operator">=</span> fout<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* 为缓冲区分配 1024 个字节 */</span>
    ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">/* 从输入通道中读取数据到缓冲区中 */</span>
        <span class="token keyword">int</span> r <span class="token operator">=</span> fcin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/* read() 返回 -1 表示 EOF */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">/* 切换读写 */</span>
        buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/* 把缓冲区的内容写入输出文件中 */</span>
        fcout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/* 清空缓冲区 */</span>
        buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>选择器使用</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. 创建选择器</span>
Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 2. 将通道注册到选择器上</span>
ServerSocketChannel ssChannel <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ssChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ssChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰</span>

<span class="token comment" spellcheck="true">// 在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类</span>
<span class="token comment" spellcheck="true">// SelectionKey.OP_CONNECT</span>
<span class="token comment" spellcheck="true">// SelectionKey.OP_ACCEPT</span>
<span class="token comment" spellcheck="true">// SelectionKey.OP_READ</span>
<span class="token comment" spellcheck="true">// SelectionKey.OP_WRITE</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_READ <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_WRITE <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_CONNECT <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_ACCEPT <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 每个事件可以被当成一个位域，从而组成事件集整数</span>
<span class="token keyword">int</span> interestSet <span class="token operator">=</span> SelectionKey<span class="token punctuation">.</span>OP_READ <span class="token operator">|</span> SelectionKey<span class="token punctuation">.</span>OP_WRITE<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 3. 监听事件</span>
<span class="token keyword">int</span> num <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 4. 获取到达的事件</span>
Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keyIterator <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    SelectionKey key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// ...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// ...</span>
    <span class="token punctuation">}</span>
    keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 5. 事件循环 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keyIterator <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        SelectionKey key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// ...</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// ...</span>
        <span class="token punctuation">}</span>
        keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>套接字NIO实例</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NIOServer</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>

        Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        ServerSocketChannel ssChannel <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ssChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ssChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span>

        ServerSocket serverSocket <span class="token operator">=</span> ssChannel<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        InetSocketAddress address <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        serverSocket<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keyIterator <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                SelectionKey key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                    ServerSocketChannel ssChannel1 <span class="token operator">=</span> <span class="token punctuation">(</span>ServerSocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// 服务器会为每个新连接创建一个 SocketChannel</span>
                    SocketChannel sChannel <span class="token operator">=</span> ssChannel1<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    sChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// 这个新连接主要用于从客户端读取数据</span>
                    sChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                    SocketChannel sChannel <span class="token operator">=</span> <span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">readDataFromSocketChannel</span><span class="token punctuation">(</span>sChannel<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    sChannel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> String <span class="token function">readDataFromSocketChannel</span><span class="token punctuation">(</span>SocketChannel sChannel<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>

        ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        StringBuilder data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> sChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> limit <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>limit<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> limit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                dst<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            data<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
            buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NIOClient</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
        Socket socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        OutputStream out <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String s <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ol>
<h3 id="1-4-并发-amp-多线程"><a href="#1-4-并发-amp-多线程" class="headerlink" title="1.4 并发&amp;多线程"></a>1.4 并发&amp;多线程</h3><h4 id="1-4-1-使用线程"><a href="#1-4-1-使用线程" class="headerlink" title="1.4.1 使用线程"></a>1.4.1 使用线程</h4><ol>
<li><p>实现线程的三种方式</p>
<ul>
<li>实现 Runnable 接口</li>
<li>实现 Callable 接口</li>
<li>继承 Thread 类</li>
</ul>
<blockquote>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用</p>
<p>可以理解为任务是通过线程驱动从而执行的</p>
</blockquote>
</li>
<li><p>实现 Runnable 接口</p>
<blockquote>
<p>需要实现接口中的 run() 方法</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    MyRunnable instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>实现 Callable 接口</p>
<blockquote>
<p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>
    MyCallable mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>mc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ft<span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ft<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>继承 Thread 类</p>
<blockquote>
<p>需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    MyThread mt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mt<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>实现接口 VS 继承 Thread</p>
<blockquote>
<p>实现接口会更好一些</p>
</blockquote>
<ul>
<li>Java 不支持多重继承，但是可以实现多个接口</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大</li>
</ul>
</li>
</ol>
<h4 id="1-4-2-基础线程机制"><a href="#1-4-2-基础线程机制" class="headerlink" title="1.4.2 基础线程机制"></a>1.4.2 基础线程机制</h4><ol>
<li><p>Executor</p>
<blockquote>
<p>管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期</p>
<p>这里的异步是指多个任务的执行互不干扰，不需要进行同步操作</p>
</blockquote>
<ul>
<li><p>类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CachedThreadPool</td>
<td>一个任务创建一个线程</td>
</tr>
<tr>
<td>FixedThreadPool</td>
<td>所有任务只能使用固定大小的线程</td>
</tr>
<tr>
<td>SingleThreadExecutor</td>
<td>相当于大小为 1 的 FixedThreadPool</td>
</tr>
</tbody></table>
</li>
<li><p>示例</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ul>
</li>
<li><p>Daemon</p>
<blockquote>
<p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分</p>
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程</p>
<p>main() 属于非守护线程</p>
<p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>sleep()</p>
<blockquote>
<p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒</p>
<p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理</p>
<p>线程中抛出的其它异常也同样需要在本地进行处理</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>yield()</p>
<blockquote>
<p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行</p>
<p>该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ol>
<h4 id="1-4-3-中断"><a href="#1-4-3-中断" class="headerlink" title="1.4.3 中断"></a>1.4.3 中断</h4><ol>
<li><p>概述</p>
<blockquote>
<p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束</p>
</blockquote>
</li>
<li><p>InterruptedException</p>
<blockquote>
<p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException</p>
<p>从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterruptExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread1<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Main run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>interrupted()</p>
<blockquote>
<p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束</p>
<p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true</p>
<p>因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterruptExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread2</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// ..</span>
            <span class="token punctuation">}</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread2<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>Executor 的中断操作</p>
<blockquote>
<p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 Lambda 创建线程，相当于创建了一个匿名内部线程</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Main run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?> 对象，通过调用该对象的 cancel(true) 方法就可以中断线程</span>
Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> future <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ..</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
future<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
<h4 id="1-4-4-互斥同步"><a href="#1-4-4-互斥同步" class="headerlink" title="1.4.4 互斥同步"></a>1.4.4 互斥同步</h4><ol>
<li><p>概述</p>
<blockquote>
<p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock</p>
</blockquote>
</li>
<li><p>synchronized</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. 同一个代码块</span>
<span class="token comment" spellcheck="true">// 只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    SynchronizedExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e1<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e1<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步，从输出结果可以看出，两个线程交叉执行</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    SynchronizedExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    SynchronizedExample e2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e1<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e2<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 2. 同步一个方法</span>
<span class="token comment" spellcheck="true">// 和同步代码块一样，作用于同一个对象</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 3. 同步一个类</span>
<span class="token comment" spellcheck="true">// 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SynchronizedExample<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SynchronizedExample<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    SynchronizedExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    SynchronizedExample e2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e1<span class="token punctuation">.</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e2<span class="token punctuation">.</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 4. 同步一个静态方法</span>
<span class="token comment" spellcheck="true">// 作用于整个类</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>ReentrantLock</p>
<blockquote>
<p>java.util.concurrent（J.U.C）包中的锁</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 确保释放锁，从而避免发生死锁。</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    LockExample lockExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LockExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> lockExample<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> lockExample<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>比较</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>实现</th>
<th>性能</th>
<th>等待可中断</th>
<th>公平锁</th>
<th>锁绑定多个条件</th>
</tr>
</thead>
<tbody><tr>
<td>synchronized</td>
<td>JVM 实现</td>
<td>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，大致相同</td>
<td>synchronized 不能中断</td>
<td>synchronized 中的锁是非公平的</td>
<td></td>
</tr>
<tr>
<td>ReentrantLock</td>
<td>JDK 实现</td>
<td>大致相同</td>
<td>ReentrantLock 可中断</td>
<td>eentrantLock 默认情况下也是非公平的，但是也可以是公平</td>
<td>一个 ReentrantLock 可以同时绑定多个 Condition 对象</td>
</tr>
</tbody></table>
<p>解释</p>
<ul>
<li><p>等待可中断</p>
<blockquote>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情</p>
</blockquote>
</li>
<li><p>公平锁</p>
<blockquote>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</p>
</blockquote>
</li>
</ul>
</li>
<li><p>使用选择</p>
<blockquote>
<p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized</p>
<p>是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持</p>
<p>并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放</p>
</blockquote>
</li>
</ol>
<h4 id="1-4-5-线程之间的协作"><a href="#1-4-5-线程之间的协作" class="headerlink" title="1.4.5 线程之间的协作"></a>1.4.5 线程之间的协作</h4><ol>
<li><p>概述</p>
<blockquote>
<p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调</p>
</blockquote>
</li>
<li><p>join()</p>
<blockquote>
<p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JoinExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>

        <span class="token keyword">private</span> A a<span class="token punctuation">;</span>

        <span class="token function">B</span><span class="token punctuation">(</span>A a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        A a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        B b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        b<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    JoinExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JoinExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    example<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>wait() notify() notifyAll()</p>
<blockquote>
<p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程</p>
<p>都属于 Object 的一部分，而不属于 Thread</p>
<p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException</p>
<p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁</p>
<p>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法</p>
<p>wait() 会释放锁，sleep() 不会</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WaitNotifyExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    WaitNotifyExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WaitNotifyExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>await() signal() signalAll()</p>
<blockquote>
<p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程</p>
<p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 Lock 来获取一个 Condition 对象</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AwaitSignalExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> Condition condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    AwaitSignalExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AwaitSignalExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ol>
<h4 id="1-4-6-线程状态"><a href="#1-4-6-线程状态" class="headerlink" title="1.4.6 线程状态"></a>1.4.6 线程状态</h4><ol>
<li><p>概述</p>
<blockquote>
<p>一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态</p>
</blockquote>
</li>
<li><p>新建（NEW）</p>
<blockquote>
<p>创建后尚未启动</p>
</blockquote>
</li>
<li><p>可运行（RUNABLE）</p>
<blockquote>
<p>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度</p>
</blockquote>
</li>
<li><p>阻塞（BLOCKED）</p>
<blockquote>
<p>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock</p>
</blockquote>
</li>
<li><p>无限期等待（WAITING）</p>
<blockquote>
<p>等待其它线程显式地唤醒</p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock</p>
<p>而等待是主动的，通过调用 Object.wait() 等方法进入</p>
</blockquote>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置 Timeout 参数的 Object.wait() 方法</td>
<td>Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join() 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
</li>
<li><p>限期等待（TIMED_WAITING）</p>
<blockquote>
<p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒</p>
<p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述</p>
<p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态</p>
</blockquote>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep() 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Object.wait() 方法</td>
<td>时间结束 / Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join() 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td>LockSupport.parkUntil() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
</li>
<li><p>死亡（TERMINATED）</p>
<blockquote>
<p>可以是线程结束任务之后自己结束，或者产生了异常而结束</p>
</blockquote>
</li>
</ol>
<h4 id="1-4-7-J-U-C-AQS"><a href="#1-4-7-J-U-C-AQS" class="headerlink" title="1.4.7 J.U.C - AQS"></a>1.4.7 J.U.C - AQS</h4><ol>
<li><p>概述</p>
<blockquote>
<p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心</p>
</blockquote>
</li>
<li><p>CountDownLatch</p>
<blockquote>
<p>用来控制一个或者多个线程等待多个线程</p>
<p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountdownLatchExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> totalThread <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>totalThread<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> totalThread<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"run.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>CyclicBarrier</p>
<blockquote>
<p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行</p>
<p>和 CountdownLatch 相似，都是通过维护计数器来实现的</p>
<p>线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行</p>
<p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障</p>
<p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">,</span> Runnable barrierAction<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parties <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>parties <span class="token operator">=</span> parties<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> parties<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>barrierCommand <span class="token operator">=</span> barrierAction<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span>parties<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> totalThread <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        CyclicBarrier cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span>totalThread<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> totalThread<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"before.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> BrokenBarrierException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"after.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>Semaphore</p>
<blockquote>
<p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> clientCount <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> totalRequestCount <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span>clientCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> totalRequestCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>semaphore<span class="token punctuation">.</span><span class="token function">availablePermits</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ol>
<h4 id="1-4-8-J-U-C-其它组件"><a href="#1-4-8-J-U-C-其它组件" class="headerlink" title="1.4.8 J.U.C - 其它组件"></a>1.4.8 J.U.C - 其它组件</h4><ol>
<li><p>FutureTask</p>
<blockquote>
<p>Callable 可以有返回值，返回值通过 Future<V> 进行封装</V></p>
<p>FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future<V> 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值</V></p>
<p>FutureTask 可用于异步获取执行结果或取消执行任务的场景</p>
<p>当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">RunnableFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RunnableFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Runnable</span><span class="token punctuation">,</span> Future<span class="token operator">&lt;</span>V<span class="token operator">></span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureTaskExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>
        FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
                <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    result <span class="token operator">+=</span> i<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> result<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Thread computeThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        computeThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Thread otherThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"other task is running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        otherThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>BlockingQueue</p>
<blockquote>
<p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置</p>
</blockquote>
<ul>
<li>FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li>
<li>优先级队列 ：PriorityBlockingQueue</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 BlockingQueue 实现生产者消费者问题</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProducerConsumer</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"product"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"produce.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                String product <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"consume.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Producer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Consumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Producer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>ForkJoin</p>
<blockquote>
<p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForkJoinExample</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threshold <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> first<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> last<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">ForkJoinExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>last <span class="token operator">=</span> last<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> Integer <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first <span class="token operator">&lt;=</span> threshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 任务足够小则直接计算</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> first<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> last<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                result <span class="token operator">+=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 拆分成小任务</span>
            <span class="token keyword">int</span> middle <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            ForkJoinExample leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinExample</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ForkJoinExample rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinExample</span><span class="token punctuation">(</span>middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span>
            leftTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            rightTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result <span class="token operator">=</span> leftTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> rightTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>
    ForkJoinExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinExample</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ForkJoinPool forkJoinPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Future result <span class="token operator">=</span> forkJoinPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>example<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForkJoinPool</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span>

<span class="token comment" spellcheck="true">// ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率</span>
<span class="token comment" spellcheck="true">// 每个线程都维护了一个双端队列，用来存储需要执行的任务</span>
<span class="token comment" spellcheck="true">// 工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行</span>
<span class="token comment" spellcheck="true">// 窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争</span></code></pre>
</li>
</ol>
<h4 id="1-4-9-线程不安全示例"><a href="#1-4-9-线程不安全示例" class="headerlink" title="1.4.9 线程不安全示例"></a>1.4.9 线程不安全示例</h4><ul>
<li><p>概述</p>
<blockquote>
<p>多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致</p>
</blockquote>
</li>
<li><p>示例</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadUnsafeExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cnt<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
    ThreadUnsafeExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadUnsafeExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            example<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ul>
<h4 id="1-4-10-Java-内存模型"><a href="#1-4-10-Java-内存模型" class="headerlink" title="1.4.10 Java 内存模型"></a>1.4.10 Java 内存模型</h4><ol>
<li><p>概述</p>
<blockquote>
<p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果</p>
</blockquote>
</li>
<li><p>主内存与工作内存</p>
<blockquote>
<p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p>
<p>加入高速缓存带来了一个新的问题：缓存一致性</p>
<p>如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题</p>
<p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝</p>
<p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成</p>
</blockquote>
</li>
<li><p>内存间交互操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>read</td>
<td>把一个变量的值从主内存传输到工作内存中</td>
</tr>
<tr>
<td>load</td>
<td>在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</td>
</tr>
<tr>
<td>use</td>
<td>把工作内存中一个变量的值传递给执行引擎</td>
</tr>
<tr>
<td>assign</td>
<td>把一个从执行引擎接收到的值赋给工作内存的变量</td>
</tr>
<tr>
<td>store</td>
<td>把工作内存的一个变量的值传送到主内存中</td>
</tr>
<tr>
<td>write</td>
<td>在 store 之后执行，把 store 得到的值放入主内存的变量中</td>
</tr>
<tr>
<td>lock</td>
<td>作用于主内存的变量</td>
</tr>
<tr>
<td>unlock</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>内存模型三大特性</p>
<ol>
<li><p>原子性</p>
<blockquote>
<p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性</p>
<p>但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性</p>
<p>AtomicInteger 能保证多个线程修改的原子性</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> AtomicInteger cnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cnt<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> cnt<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
    AtomicExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只修改这条语句</span>
    <span class="token keyword">final</span> CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            example<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicSynchronizedExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cnt<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
    AtomicSynchronizedExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicSynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            example<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>可见性</p>
<blockquote>
<p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的</p>
<p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性</p>
</blockquote>
<p>实现可见性</p>
<ul>
<li>volatile</li>
<li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li>
<li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li>
</ul>
</li>
<li><p>有序性</p>
<blockquote>
<p>在本线程内观察，所有操作都是有序的</p>
<p>在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序</p>
<p>在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性</p>
<p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前</p>
<p>通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码</p>
</blockquote>
</li>
</ol>
</li>
<li><p>先行发生原则</p>
<blockquote>
<p>JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成</p>
</blockquote>
<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>单一线程原则</td>
<td>在一个线程内，在程序前面的操作先行发生于后面的操作</td>
</tr>
<tr>
<td>管程锁定规则</td>
<td>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</td>
</tr>
<tr>
<td>volatile 变量规则</td>
<td>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作</td>
</tr>
<tr>
<td>线程启动规则</td>
<td>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作</td>
</tr>
<tr>
<td>线程加入规则</td>
<td>Thread 对象的结束先行发生于 join() 方法返回</td>
</tr>
<tr>
<td>线程中断规则</td>
<td>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生</td>
</tr>
<tr>
<td>对象终结规则</td>
<td>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始</td>
</tr>
<tr>
<td>传递性</td>
<td>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="1-4-11-线程安全"><a href="#1-4-11-线程安全" class="headerlink" title="1.4.11 线程安全"></a>1.4.11 线程安全</h4><ol>
<li><p>概述</p>
<blockquote>
<p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为</p>
</blockquote>
</li>
<li><p>不可变</p>
<blockquote>
<p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施</p>
<p>只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态</p>
<p>多线程环境下，应当尽量使对象成为不可变，来满足线程安全</p>
</blockquote>
<p>类型</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImmutableExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> unmodifiableMap <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
        unmodifiableMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常</span>
<span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>互斥同步</p>
<blockquote>
<p>synchronized 和 ReentrantLock</p>
</blockquote>
</li>
<li><p>非阻塞同步</p>
<blockquote>
<p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题</p>
<p>无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作</p>
<p>基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）</p>
<p>这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
</blockquote>
<ul>
<li><p>CAS</p>
<blockquote>
<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成</p>
<p>硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）</p>
<p>CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B</p>
<p>当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
</blockquote>
</li>
<li><p>AtomicInteger</p>
<blockquote>
<p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 以下代码使用了 AtomicInteger 执行了自增的操作</span>
<span class="token keyword">private</span> AtomicInteger cnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cnt<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() </span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> var5<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> var5<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</span></code></pre>
</li>
<li><p>ABA</p>
<blockquote>
<p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过</p>
<p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性</p>
<p>大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效</p>
</blockquote>
</li>
</ul>
</li>
<li><p>无同步方案</p>
<blockquote>
<p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性</p>
</blockquote>
<ol>
<li><p>栈封闭</p>
<blockquote>
<p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackClosedExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add100</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            cnt<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    StackClosedExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackClosedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">add100</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">add100</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>线程本地存储（Thread Local Storage）</p>
<blockquote>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。<br>其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ThreadLocal threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            threadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            threadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 为了理解 ThreadLocal，先看以下代码</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalExample1</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ThreadLocal threadLocal1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ThreadLocal threadLocal2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            threadLocal1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            threadLocal2<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            threadLocal1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            threadLocal2<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象</span>
<span class="token comment" spellcheck="true">/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */</span>
ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap threadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal->value 键值对插入到该 Map 中</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>
        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// get() 方法类似</span>
<span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ThreadLocalMap<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
            T result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争<br>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险</p>
</blockquote>
</li>
<li><p>可重入代码（Reentrant Code）</p>
<blockquote>
<p>也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h4 id="1-4-12-锁优化"><a href="#1-4-12-锁优化" class="headerlink" title="1.4.12 锁优化"></a>1.4.12 锁优化</h4><ol>
<li><p>概述</p>
<blockquote>
<p>主要是指 JVM 对 synchronized 的优化</p>
</blockquote>
</li>
<li><p>自旋锁</p>
<blockquote>
<p>互斥同步进入阻塞状态的开销都很大，应该尽量避免</p>
<p>在许多应用中，共享数据的锁定状态只会持续很短的一段时间</p>
<p>自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景</p>
<p>自适应的自旋锁，自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定</p>
</blockquote>
</li>
<li><p>锁消除</p>
<blockquote>
<p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对于一些看起来没有加锁的代码，其实隐式的加了很多锁</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">concatString</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> String s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> s1 <span class="token operator">+</span> s2 <span class="token operator">+</span> s3<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作</span>
<span class="token comment" spellcheck="true">// 每个 append() 方法中都有一个同步块</span>
<span class="token comment" spellcheck="true">// 虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部</span>
<span class="token comment" spellcheck="true">// 也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">concatString</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> String s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>锁粗化</p>
<blockquote>
<p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗</p>
<p>对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了</p>
</blockquote>
</li>
<li><p>轻量级锁</p>
<blockquote>
<p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）</p>
<p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销</p>
</blockquote>
</li>
<li><p>偏向锁</p>
<blockquote>
<p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要</p>
</blockquote>
</li>
</ol>
<h4 id="1-4-13-小结"><a href="#1-4-13-小结" class="headerlink" title="1.4.13 小结"></a>1.4.13 小结</h4><ul>
<li>给线程起个有意义的名字，这样可以方便找 Bug。</li>
<li>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</li>
<li>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</li>
<li>使用 BlockingQueue 实现生产者消费者问题。</li>
<li>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</li>
<li>使用本地变量和不可变类来保证线程安全。</li>
<li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li>
</ul>
<h3 id="1-5-虚拟机"><a href="#1-5-虚拟机" class="headerlink" title="1.5 虚拟机"></a>1.5 虚拟机</h3><h4 id="1-5-1-运行时数据区域"><a href="#1-5-1-运行时数据区域" class="headerlink" title="1.5.1 运行时数据区域"></a>1.5.1 运行时数据区域</h4><ol>
<li><p>程序计数器</p>
<blockquote>
<p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）</p>
</blockquote>
</li>
<li><p>Java 虚拟机栈</p>
<blockquote>
<p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M</span>
java <span class="token operator">-</span>Xss2M HackTheJava
<span class="token comment" spellcheck="true">// 该区域可能抛出以下异常：</span>
    <span class="token comment" spellcheck="true">// 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</span>
    <span class="token comment" spellcheck="true">// 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</span></code></pre>
</li>
<li><p>本地方法栈</p>
<blockquote>
<p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务</p>
</blockquote>
</li>
<li><p>堆</p>
<blockquote>
<p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）</p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法，分为新生代和老年代</p>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值</span>
java <span class="token operator">-</span>Xms1M <span class="token operator">-</span>Xmx2M HackTheJava</code></pre>
</li>
<li><p>方法区</p>
<blockquote>
<p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现</p>
<p>HotSpot 虚拟机把它当成永久代来进行垃圾回收</p>
<p>很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常</p>
<p>为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中</p>
<p><font color="red">方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式</font></p>
</blockquote>
</li>
<li><p>运行时常量池</p>
<blockquote>
<p>运行时常量池是方法区的一部分</p>
<p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域</p>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()</p>
</blockquote>
</li>
<li><p>直接内存</p>
<blockquote>
<p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作</p>
<p>这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据</p>
</blockquote>
</li>
</ol>
<h4 id="1-5-2-垃圾收集"><a href="#1-5-2-垃圾收集" class="headerlink" title="1.5.2 垃圾收集"></a>1.5.2 垃圾收集</h4><ol>
<li><p>概述</p>
<blockquote>
<p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收</p>
</blockquote>
</li>
<li><p>判断一个对象是否可被回收</p>
<ol>
<li><p>引用记数法</p>
<blockquote>
<p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1</p>
<p>引用计数为 0 的对象可被回收</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> Object instance <span class="token operator">=</span> null<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Test a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Test b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a<span class="token punctuation">.</span>instance <span class="token operator">=</span> b<span class="token punctuation">;</span>
        b<span class="token punctuation">.</span>instance <span class="token operator">=</span> a<span class="token punctuation">;</span>
        a <span class="token operator">=</span> null<span class="token punctuation">;</span>
        b <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收</span></code></pre>
</li>
<li><p>可达性分析算法</p>
<blockquote>
<p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收</p>
</blockquote>
<ul>
<li>GC Roots 一般包含以下内容<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
</li>
</ul>
</li>
<li><p>方法区的回收</p>
<blockquote>
<p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高</p>
<p>主要是对常量池的回收和对类的卸载</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能</p>
</blockquote>
</li>
<li><p>类卸载条件</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例</li>
<li>加载该类的 ClassLoader 已经被回收</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法</li>
</ul>
</li>
<li><p>finalize()</p>
<blockquote>
<p>类似 C++ 的析构函数，用于关闭外部资源</p>
<p>但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用</p>
<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救</p>
<p>自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法</p>
</blockquote>
</li>
</ol>
</li>
<li><p>引用类型</p>
<blockquote>
<p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有</p>
</blockquote>
<ul>
<li><p>强引用</p>
<blockquote>
<p>被强引用关联的对象不会被回收</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 new 一个新对象的方式来创建强引用</span>
Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>软引用</p>
<blockquote>
<p>被软引用关联的对象只有在内存不够的情况下才会被回</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 SoftReference 类来创建软引用</span>
Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
SoftReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 使对象只被软引用关联</span></code></pre>
</li>
<li><p>弱引用</p>
<blockquote>
<p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 WeakReference 类来创建弱引用</span>
Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
WeakReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> wf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre>
</li>
<li><p>虚引用</p>
<blockquote>
<p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 PhantomReference 来创建虚引</span>
Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
PhantomReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre>
</li>
</ul>
</li>
<li><p>垃圾收集算法</p>
<ol>
<li><p>标记-清除</p>
<blockquote>
<p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记</p>
<p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块</p>
<p>回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表</p>
</blockquote>
<ul>
<li>不足<ul>
<li>标记和清除过程效率都不高</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存</li>
</ul>
</li>
</ul>
</li>
<li><p>标记-整理</p>
<blockquote>
<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
</blockquote>
<ul>
<li>优点:<ul>
<li>不会产生内存碎片</li>
</ul>
</li>
<li>不足:<ul>
<li>需要移动大量对象，处理效率比较低</li>
</ul>
</li>
</ul>
</li>
<li><p>复制</p>
<blockquote>
<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理</p>
<p>主要不足是只使用了内存的一半</p>
<p>在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%</p>
</blockquote>
</li>
<li><p>分代收集</p>
<blockquote>
<p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法</p>
</blockquote>
<ul>
<li>一般将堆分为新生代和老年代<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>垃圾收集器</p>
<ol>
<li><p>概述</p>
<ol>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ol>
</li>
<li><p>Serial 收集器</p>
<blockquote>
<p>Serial 翻译为串行，也就是说它以串行的方式执行</p>
<p>单线程的收集器，只会使用一个线程进行垃圾收集工作</p>
<p>优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率</p>
</blockquote>
</li>
<li><p>ParNew 收集器</p>
<blockquote>
<p>是 Serial 收集器的多线程版本</p>
<p>是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用</p>
</blockquote>
</li>
<li><p>Parallel Scavenge 收集器</p>
<blockquote>
<p>与 ParNew 一样是多线程收集器</p>
<p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器</p>
<p>这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降</p>
<p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
</blockquote>
</li>
<li><p>Serial Old 收集器</p>
<blockquote>
<p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
</blockquote>
</li>
<li><p>Parallel Old 收集器</p>
<blockquote>
<p>是 Parallel Scavenge 收集器的老年代版本</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器</p>
</blockquote>
</li>
<li><p>CMS 收集器</p>
<blockquote>
<p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法</p>
</blockquote>
<ul>
<li>分为以下四个流程：<ul>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ul>
</li>
<li>具有以下缺点：<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
</li>
</ul>
</li>
<li><p>G1 收集器</p>
<blockquote>
<p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收</p>
<p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离</p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
</blockquote>
<ul>
<li>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
</li>
<li>具备如下特点：<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="1-5-3-内存分配与回收策略"><a href="#1-5-3-内存分配与回收策略" class="headerlink" title="1.5.3 内存分配与回收策略"></a>1.5.3 内存分配与回收策略</h4><ol>
<li><p>Minor GC 和 Full GC</p>
<ul>
<li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li>
</ul>
</li>
<li><p>内存分配策略</p>
<ol>
<li><p>对象优先在Eden分配</p>
<blockquote>
<p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC</p>
</blockquote>
</li>
<li><p>大对象直接进入老年代</p>
<blockquote>
<p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制</p>
</blockquote>
</li>
<li><p>长期存活的对象进入老年代</p>
<blockquote>
<p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值</p>
</blockquote>
</li>
<li><p>动态对象年龄判定</p>
<blockquote>
<p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄</p>
</blockquote>
</li>
<li><p>空间分配担保</p>
<blockquote>
<p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC</p>
</blockquote>
</li>
</ol>
</li>
<li><p>Full GC 的触发条件</p>
<blockquote>
<p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件</p>
</blockquote>
<ul>
<li><p>调用 System.gc()</p>
<blockquote>
<p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
</blockquote>
</li>
<li><p>老年代空间不足</p>
<blockquote>
<p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
</blockquote>
</li>
<li><p>空间分配担保失败</p>
<blockquote>
<p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC</p>
</blockquote>
</li>
<li><p>JDK 1.7 及以前的永久代空间不足</p>
<blockquote>
<p>JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC</p>
</blockquote>
</li>
<li><p>Concurrent Mode Failure</p>
<blockquote>
<p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="1-5-4-类加载机制"><a href="#1-5-4-类加载机制" class="headerlink" title="1.5.4 类加载机制"></a>1.5.4 类加载机制</h4><ol>
<li><p>概述</p>
<blockquote>
<p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存</p>
</blockquote>
</li>
<li><p>类的生命周期</p>
<ul>
<li>加载（Loading）</li>
<li>验证（Verification）</li>
<li>准备（Preparation）</li>
<li>解析（Resolution）</li>
<li>初始化（Initialization）</li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
</li>
<li><p>类加载过程</p>
<blockquote>
<p>包含了加载、验证、准备、解析和初始化这 5 个阶段</p>
</blockquote>
<ul>
<li><p>加载（Loading）</p>
<blockquote>
<p>加载是类加载的一个阶段，注意不要混淆</p>
</blockquote>
<ul>
<li>加载过程完成以下三件事：<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
</li>
<li>其中二进制字节流可以从以下方式中获取：<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
</ul>
</li>
</ul>
</li>
<li><p>验证（Verification）</p>
<blockquote>
<p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p>
</blockquote>
</li>
<li><p>准备（Preparation）</p>
<blockquote>
<p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>解析（Resolution）</p>
<blockquote>
<p>将常量池的符号引用替换为直接引用的过程</p>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定</p>
</blockquote>
</li>
<li><p>初始化（Initialization）</p>
<blockquote>
<p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p><clinit>() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问</clinit></p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 给变量赋值可以正常编译通过</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这句编译器会提示“非法向前引用”</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 由于父类的 &lt;clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        A <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> B <span class="token operator">=</span> A<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Sub<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 2</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 虚拟机会保证一个类的 &lt;clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit>() 方法完毕。如果在一个类的 &lt;clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽</span></code></pre>
</li>
</ul>
</li>
<li><p>类初始化时机</p>
<ol>
<li><p>主动引用</p>
<blockquote>
<p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）</p>
</blockquote>
<ul>
<li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</li>
</ul>
</li>
<li><p>被动引用</p>
<blockquote>
<p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 通过子类引用父类的静态字段，不会导致子类初始化</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// value 字段在 SuperClass 中定义</span>

<span class="token comment" spellcheck="true">// 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法</span>
SuperClass<span class="token punctuation">[</span><span class="token punctuation">]</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ConstClass<span class="token punctuation">.</span>HELLOWORLD<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>类与类加载器</p>
<blockquote>
<p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间</p>
<p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true</p>
</blockquote>
</li>
<li><p>类加载器分类</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；</li>
<li>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</li>
</ul>
<p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</JRE_HOME></li>
<li>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</JAVA_HOME></li>
<li>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</li>
</ul>
</li>
<li><p>双亲委派模型</p>
<blockquote>
<p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器</p>
<p>双亲委派模型（Parents Delegation Model）要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）</p>
</blockquote>
<ul>
<li><p>工作过程</p>
<blockquote>
<p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载</p>
</blockquote>
</li>
<li><p>好处</p>
<blockquote>
<p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一</p>
</blockquote>
</li>
<li><p>实现</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// The parent class loader for delegation</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> ClassLoader parent<span class="token punctuation">;</span>

    <span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// First, check if the class has already been loaded</span>
            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// ClassNotFoundException thrown if class not found</span>
                    <span class="token comment" spellcheck="true">// from the non-null parent class loader</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// If still not found, then invoke findClass in order</span>
                    <span class="token comment" spellcheck="true">// to find the class.</span>
                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> c<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ul>
</li>
<li><p>自定义类加载器实现</p>
<blockquote>
<p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p>
<p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileSystemClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> String rootDir<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">FileSystemClassLoader</span><span class="token punctuation">(</span>String rootDir<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>rootDir <span class="token operator">=</span> rootDir<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classData <span class="token operator">=</span> <span class="token function">getClassData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>classData <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> classData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> classData<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getClassData</span><span class="token punctuation">(</span>String className<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String path <span class="token operator">=</span> <span class="token function">classNameToPath</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            InputStream ins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ByteArrayOutputStream baos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> bufferSize <span class="token operator">=</span> <span class="token number">4096</span><span class="token punctuation">;</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>bufferSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> bytesNumRead<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytesNumRead <span class="token operator">=</span> ins<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                baos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytesNumRead<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> baos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> String <span class="token function">classNameToPath</span><span class="token punctuation">(</span>String className<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> rootDir <span class="token operator">+</span> File<span class="token punctuation">.</span>separatorChar
                <span class="token operator">+</span> className<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span> File<span class="token punctuation">.</span>separatorChar<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ol>
<h2 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2. 数据库"></a>2. 数据库</h2><h3 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h3><h4 id="2-1-1-事务"><a href="#2-1-1-事务" class="headerlink" title="2.1.1 事务"></a>2.1.1 事务</h4><ol>
<li><p>概念</p>
<blockquote>
<p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚</p>
</blockquote>
</li>
<li><p>ACID</p>
<ol>
<li><p>原子性</p>
<blockquote>
<p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚</p>
<p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可</p>
</blockquote>
</li>
<li><p>一致性</p>
<blockquote>
<p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的</p>
</blockquote>
</li>
<li><p>隔离性</p>
<blockquote>
<p>一个事务所做的修改在最终提交以前，对其它事务是不可见的</p>
</blockquote>
</li>
<li><p>持久性</p>
<blockquote>
<p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失</p>
<p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性</p>
<p>与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改</p>
</blockquote>
</li>
<li><p>小结</p>
<ol>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ol>
</li>
</ol>
</li>
<li><p>AUTOCOMMIT</p>
<blockquote>
<p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交</p>
</blockquote>
</li>
</ol>
<h4 id="2-1-2-并发一致性问题"><a href="#2-1-2-并发一致性问题" class="headerlink" title="2.1.2 并发一致性问题"></a>2.1.2 并发一致性问题</h4><ol>
<li><p>概述</p>
<blockquote>
<p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题</p>
</blockquote>
</li>
<li><p>丢失修改</p>
<blockquote>
<p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换</p>
</blockquote>
</li>
<li><p>读脏数据</p>
<blockquote>
<p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据</p>
</blockquote>
</li>
<li><p>不可重复读</p>
<blockquote>
<p>不可重复读指在一个事务内多次读取同一数据集合</p>
</blockquote>
</li>
<li><p>幻影读</p>
<blockquote>
<p>幻读本质上也属于不可重复读的情况</p>
</blockquote>
</li>
<li><p>小结</p>
<blockquote>
<p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题</p>
</blockquote>
</li>
</ol>
<h4 id="2-1-3-封锁"><a href="#2-1-3-封锁" class="headerlink" title="2.1.3 封锁"></a>2.1.3 封锁</h4><ol>
<li><p>封锁粒度</p>
<blockquote>
<p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>
<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>
<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
</blockquote>
</li>
<li><p>封锁类型</p>
<ol>
<li><p>读写锁</p>
<ul>
<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
</li>
<li><p>规定</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
</li>
<li><p>意向锁</p>
<blockquote>
<p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁</p>
<p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁</p>
</blockquote>
<ul>
<li>规定<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>封锁协议</p>
<ol>
<li><p>一级封锁协议</p>
<blockquote>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖</p>
</blockquote>
</li>
<li><p>二级封锁协议</p>
<blockquote>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
</blockquote>
</li>
<li><p>三级封锁协议</p>
<blockquote>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
</blockquote>
</li>
<li><p>两段锁协议</p>
<blockquote>
<p>加锁和解锁分为两个阶段进行</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">lock</span><span class="token operator">-</span>x<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">lock</span><span class="token operator">-</span>s<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">lock</span><span class="token operator">-</span>s<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>unlock<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>unlock<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>unlock<span class="token punctuation">(</span>B<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">-- 但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</span>
<span class="token keyword">lock</span><span class="token operator">-</span>x<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>unlock<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">lock</span><span class="token operator">-</span>s<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>unlock<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">lock</span><span class="token operator">-</span>s<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>unlock<span class="token punctuation">(</span>C<span class="token punctuation">)</span></code></pre>
</li>
</ol>
</li>
<li><p>MySQL 隐式与显式锁定</p>
<blockquote>
<p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- InnoDB 也可以使用特定的语句进行显示锁定</span>
<span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">In</span> <span class="token keyword">SHARE MODE</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
<h4 id="2-1-4-隔离级别"><a href="#2-1-4-隔离级别" class="headerlink" title="2.1.4 隔离级别"></a>2.1.4 隔离级别</h4><ol>
<li><p>未提交读（READ UNCOMMITTED）</p>
<blockquote>
<p>事务中的修改，即使没有提交，对其它事务也是可见的</p>
</blockquote>
</li>
<li><p>提交读（READ COMMITTED）</p>
<blockquote>
<p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的</p>
</blockquote>
</li>
<li><p>可重复读（REPEATABLE READ）</p>
<blockquote>
<p>保证在同一个事务中多次读取同一数据的结果是一样的</p>
</blockquote>
</li>
<li><p>可串行化（SERIALIZABLE）</p>
<blockquote>
<p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>
<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>
</blockquote>
</li>
</ol>
<h4 id="2-1-5-多版本并发控制"><a href="#2-1-5-多版本并发控制" class="headerlink" title="2.1.5 多版本并发控制"></a>2.1.5 多版本并发控制</h4><ol>
<li><p>基本思想</p>
<blockquote>
<p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照</p>
<p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读</p>
</blockquote>
</li>
<li><p>版本号</p>
<blockquote>
<p>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。<br>事务版本号 TRX_ID ：事务开始时的系统版本号。</p>
</blockquote>
</li>
<li><p>Undo 日志</p>
<blockquote>
<p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作</span>
INSERT INTO <span class="token function">t</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token function">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
UPDATE t SET x<span class="token operator">=</span><span class="token string">"b"</span> WHERE id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
UPDATE t SET x<span class="token operator">=</span><span class="token string">"c"</span> WHERE id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>ReadView</p>
<blockquote>
<p>MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, …}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX</p>
</blockquote>
<p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p>
<ul>
<li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</li>
<li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li>
<li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：<ul>
<li>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
</ul>
</li>
</ul>
<p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断</p>
</li>
<li><p>快照读与当前读</p>
<ol>
<li><p>快照读</p>
<p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>当前读</p>
<p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span><span class="token punctuation">;</span>
<span class="token keyword">DELETE</span><span class="token punctuation">;</span></code></pre>
<p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p>
<pre class=" language-sql"><code class="language-sql">
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> ? <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> ? <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="2-1-6-Next-Key-Locks"><a href="#2-1-6-Next-Key-Locks" class="headerlink" title="2.1.6 Next-Key Locks"></a>2.1.6 Next-Key Locks</h4><ol>
<li><p>概述</p>
<blockquote>
<p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
</blockquote>
</li>
<li><p>Record Locks</p>
<blockquote>
<p>锁定一个记录上的索引，而不是记录本身。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
</blockquote>
</li>
<li><p>Gap Locks</p>
<blockquote>
<p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token number">c</span> <span class="token keyword">FROM</span> t <span class="token keyword">WHERE</span> <span class="token number">c</span> <span class="token operator">BETWEEN</span> <span class="token number">10</span> <span class="token operator">and</span> <span class="token number">20</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>Next-Key Locks</p>
<blockquote>
<p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token punctuation">(</span><span class="token operator">-</span>∞<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token operator">+</span>∞<span class="token punctuation">)</span></code></pre>
</li>
</ol>
<h4 id="2-1-7-关系数据库设计理论"><a href="#2-1-7-关系数据库设计理论" class="headerlink" title="2.1.7 关系数据库设计理论"></a>2.1.7 关系数据库设计理论</h4><ol>
<li><p>函数依赖</p>
<blockquote>
<p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖</p>
</blockquote>
</li>
<li><p>异常</p>
<blockquote>
<p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息</p>
</blockquote>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody></table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
</li>
<li><p>范式</p>
<blockquote>
<p>范式理论是为了解决以上提到四种异常。</p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
</blockquote>
<ul>
<li><p>第一范式 (1NF)</p>
<blockquote>
<p>属性不可分</p>
</blockquote>
</li>
<li><p>第二范式 (2NF)</p>
<blockquote>
<p>每个非主属性完全函数依赖于键码。</p>
<p>可以通过分解来满足。</p>
</blockquote>
</li>
<li><p>分解前</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody></table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据</p>
</li>
<li><p>分解后</p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
</tr>
</tbody></table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody></table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt; Grade</li>
</ul>
</li>
<li><p>第三范式 (3NF)</p>
<blockquote>
<p>非主属性不传递函数依赖于键码。</p>
</blockquote>
<p>上面的 关系-1 中存在以下传递函数依赖：</p>
<ul>
<li>Sno -&gt; Sdept -&gt; Mname</li>
</ul>
<p>可以进行以下分解：</p>
<p>关系-11</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
</tr>
</tbody></table>
<p>关系-12</p>
<table>
<thead>
<tr>
<th>Sdept</th>
<th>Mname</th>
</tr>
</thead>
<tbody><tr>
<td>学院-1</td>
<td>院长-1</td>
</tr>
<tr>
<td>学院-2</td>
<td>院长-2</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
<h4 id="2-1-8-ER-图"><a href="#2-1-8-ER-图" class="headerlink" title="2.1.8 ER 图"></a>2.1.8 ER 图</h4><ol>
<li><p>实体的三种联系</p>
<blockquote>
<p>包含一对一，一对多，多对多三种</p>
</blockquote>
<ul>
<li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li>
<li>如果是一对一，画两个带箭头的线段；</li>
<li>如果是多对多，画两个不带箭头的线段。</li>
</ul>
</li>
<li><p>表示出现多次的关系</p>
<ul>
<li>一个实体在联系出现几次，就要用几条线连接</li>
<li>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系</li>
</ul>
</li>
<li><p>联系的多向性</p>
<blockquote>
<p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系</p>
</blockquote>
</li>
<li><p>表示子类</p>
<blockquote>
<p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上</p>
</blockquote>
</li>
</ol>
<h3 id="2-2-语法"><a href="#2-2-语法" class="headerlink" title="2.2 语法"></a>2.2 语法</h3><h4 id="2-2-1-基础"><a href="#2-2-1-基础" class="headerlink" title="2.2.1 基础"></a>2.2.1 基础</h4><ol>
<li><p>概述</p>
<blockquote>
<p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式</p>
<p>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）</p>
<p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL</p>
<p>各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等</p>
<p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置</p>
</blockquote>
</li>
<li><p>注释</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">## 注释</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 注释</span>
<span class="token comment" spellcheck="true">/* 注释1
   注释2 */</span></code></pre>
</li>
<li><p>创建与使用</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> test<span class="token punctuation">;</span>
<span class="token keyword">USE</span> test<span class="token punctuation">;</span></code></pre>
</li>
</ol>
<h4 id="2-2-2-表的基础操作"><a href="#2-2-2-表的基础操作" class="headerlink" title="2.2.2 表的基础操作"></a>2.2.2 表的基础操作</h4><ol>
<li><p>创建表</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mytable <span class="token punctuation">(</span>
  <span class="token comment" spellcheck="true">-- int 类型，不为空，自增</span>
  id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">-- int 类型，不可为空，默认值为 1，不为空</span>
  col1 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">-- 变长字符串类型，最长为 45 个字符，可以为空</span>
  col2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">-- 日期类型，可为空</span>
  col3 <span class="token keyword">DATE</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">-- 设置主键为 id</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>修改表</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 添加列</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> mytable
<span class="token keyword">ADD</span> col CHAR<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 删除列</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> mytable
<span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> col<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 删除表</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">;</span></code></pre>
</li>
<li><p>插入</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 普通插入</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> mytable<span class="token punctuation">(</span>col1<span class="token punctuation">,</span> col2<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 插入检索出来的数据</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> mytable1<span class="token punctuation">(</span>col1<span class="token punctuation">,</span> col2<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2
<span class="token keyword">FROM</span> mytable2<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 将一个表的内容插入到一个新表</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> newtable <span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span></code></pre>
</li>
<li><p>更新</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> mytable
<span class="token keyword">SET</span> col <span class="token operator">=</span> val
<span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>删除</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> mytable
<span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- TRUNCATE TABLE 可以清空表，也就是删除所有行</span>
<span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏;可以先用 SELECT 语句进行测试，防止错误删除</span></code></pre>
</li>
<li><p>查询</p>
<ol>
<li><p>DISTINCT</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 相同值只会出现一次;它作用于所有列，也就是说所有列的值都相同才算相同</span>
<span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> col1<span class="token punctuation">,</span> col2
<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span></code></pre>
</li>
<li><p>LIMIT</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</span>
<span class="token comment" spellcheck="true">-- 返回前 5 行</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> mytable
<span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> mytable
<span class="token keyword">LIMIT</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 返回第 3 ~ 5 行</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> mytable
<span class="token keyword">LIMIT</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>排序</p>
<ul>
<li>ASC ：升序（默认）</li>
<li>DESC ：降序</li>
</ul>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 可以按多个列进行排序，并且为每个列指定不同的排序方式</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> mytable
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col1 <span class="token keyword">DESC</span><span class="token punctuation">,</span> col2 <span class="token keyword">ASC</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>过滤</p>
<blockquote>
<p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽</p>
<p>因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> mytable
<span class="token keyword">WHERE</span> col <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><p>下表显示了 WHERE 子句可用的操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;&gt; !=</td>
<td>不等于</td>
</tr>
<tr>
<td>&lt;= !&gt;</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;= !&lt;</td>
<td>大于等于</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>在两个值之间</td>
</tr>
<tr>
<td>IS NULL</td>
<td>为 NULL 值</td>
</tr>
</tbody></table>
</li>
<li><p>注意</p>
<ul>
<li>应该注意到，NULL 与 0、空字符串都不同。</li>
<li><strong>AND 和 OR</strong> 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</li>
<li><strong>IN</strong> 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</li>
<li><strong>NOT</strong> 操作符用于否定一个条件。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-2-3-表的高级操作"><a href="#2-2-3-表的高级操作" class="headerlink" title="2.2.3 表的高级操作"></a>2.2.3 表的高级操作</h4><ol>
<li><p>通配符</p>
<blockquote>
<p>通配符也是用在过滤语句中，但它只能用于文本字段</p>
<p>不要滥用通配符，通配符位于开头处匹配会非常慢</p>
</blockquote>
<ul>
<li><p>类型</p>
<ul>
<li><strong>%</strong> 匹配 &gt;=0 个任意字符；</li>
<li><strong>_</strong> 匹配 ==1 个任意字符；</li>
<li><strong>[ ]</strong> 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</li>
</ul>
</li>
<li><p>示例</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 使用 Like 来进行通配符匹配</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> mytable
<span class="token keyword">WHERE</span> col <span class="token operator">LIKE</span> <span class="token string">'[^AB]%'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 不以 A 和 B 开头的任意文本</span></code></pre>
</li>
</ul>
</li>
<li><p>计算字段</p>
<blockquote>
<p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式</span>
<span class="token keyword">SELECT</span> col1 <span class="token operator">*</span> col2 <span class="token keyword">AS</span> alias
<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- CONCAT() 用于连接两个字段；许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格</span>
<span class="token keyword">SELECT</span> CONCAT<span class="token punctuation">(</span>TRIM<span class="token punctuation">(</span>col1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> TRIM<span class="token punctuation">(</span>col2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> concat_col
<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span></code></pre>
</li>
<li><p>函数</p>
<ol>
<li><p>概述</p>
<blockquote>
<p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数</p>
</blockquote>
</li>
<li><p>汇总</p>
<table>
<thead>
<tr>
<th>函 数</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>AVG()</td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>返回某列的行数</td>
</tr>
<tr>
<td>MAX()</td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回某列值之和</td>
</tr>
</tbody></table>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- AVG() 会忽略 NULL 行。</span>
<span class="token comment" spellcheck="true">-- 使用 DISTINCT 可以汇总不同的值。</span>
<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> col1<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_col
<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span></code></pre>
</li>
<li><p>文本处理</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LEFT()</td>
<td>左边的字符</td>
</tr>
<tr>
<td>RIGHT()</td>
<td>右边的字符</td>
</tr>
<tr>
<td>LOWER()</td>
<td>转换为小写字符</td>
</tr>
<tr>
<td>UPPER()</td>
<td>转换为大写字符</td>
</tr>
<tr>
<td>LTRIM()</td>
<td>去除左边的空格</td>
</tr>
<tr>
<td>RTRIM()</td>
<td>去除右边的空格</td>
</tr>
<tr>
<td>LENGTH()</td>
<td>长度</td>
</tr>
<tr>
<td>SOUNDEX()</td>
<td>转换为语音值</td>
</tr>
</tbody></table>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> mytable
<span class="token keyword">WHERE</span> SOUNDEX<span class="token punctuation">(</span>col1<span class="token punctuation">)</span> <span class="token operator">=</span> SOUNDEX<span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span></code></pre>
</li>
<li><p>日期和时间处理</p>
<ul>
<li>日期格式：YYYY-MM-DD</li>
<li>时间格式：HH:<zero-width space>MM:SS</zero-width></li>
</ul>
<table>
<thead>
<tr>
<th>函 数</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>ADDDATE()</td>
<td>增加一个日期（天、周等）</td>
</tr>
<tr>
<td>ADDTIME()</td>
<td>增加一个时间（时、分等）</td>
</tr>
<tr>
<td>CURDATE()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>DATE()</td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td>DATEDIFF()</td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td>DATE_ADD()</td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr>
<td>DATE_FORMAT()</td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td>DAY()</td>
<td>返回一个日期的天数部分</td>
</tr>
<tr>
<td>DAYOFWEEK()</td>
<td>对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td>HOUR()</td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td>MINUTE()</td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td>MONTH()</td>
<td>返回一个日期的月份部分</td>
</tr>
<tr>
<td>NOW()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>SECOND()</td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td>TIME()</td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td>YEAR()</td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody></table>
<pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>数值处理</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SIN()</td>
<td>正弦</td>
</tr>
<tr>
<td>COS()</td>
<td>余弦</td>
</tr>
<tr>
<td>TAN()</td>
<td>正切</td>
</tr>
<tr>
<td>ABS()</td>
<td>绝对值</td>
</tr>
<tr>
<td>SQRT()</td>
<td>平方根</td>
</tr>
<tr>
<td>MOD()</td>
<td>余数</td>
</tr>
<tr>
<td>EXP()</td>
<td>指数</td>
</tr>
<tr>
<td>PI()</td>
<td>圆周率</td>
</tr>
<tr>
<td>RAND()</td>
<td>随机数</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>分组</p>
<blockquote>
<p>把具有相同的数据值的行放在同一组中。</p>
<p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</span>
<span class="token keyword">SELECT</span> col<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num
<span class="token keyword">FROM</span> mytable
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> col<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</span>
<span class="token keyword">SELECT</span> col<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num
<span class="token keyword">FROM</span> mytable
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> col
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> num<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</span>
<span class="token keyword">SELECT</span> col<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num
<span class="token keyword">FROM</span> mytable
<span class="token keyword">WHERE</span> col <span class="token operator">></span> <span class="token number">2</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> col
<span class="token keyword">HAVING</span> num <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre>
<p>分组规定</p>
<ul>
<li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li>
<li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li>
<li>NULL 的行会单独分为一组；</li>
<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型</li>
</ul>
</li>
<li><p>子查询</p>
<blockquote>
<p>子查询中只能返回一个字段的数据</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 可以将子查询的结果作为 WHRER 语句的过滤条件：</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> mytable1
<span class="token keyword">WHERE</span> col1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> col2
               <span class="token keyword">FROM</span> mytable2<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次</span>
<span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
                   <span class="token keyword">FROM</span> Orders
                   <span class="token keyword">WHERE</span> Orders<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> Customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">)</span>
                   <span class="token keyword">AS</span> orders_num
<span class="token keyword">FROM</span> Customers
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> cust_name<span class="token punctuation">;</span></code></pre>
</li>
<li><p>连接</p>
<ol>
<li><p>概述</p>
<blockquote>
<p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE</p>
<p>连接可以替换子查询，并且比子查询的效率一般会更快</p>
<p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表</p>
</blockquote>
</li>
<li><p>内连接</p>
<blockquote>
<p>内连接又称等值连接，使用 INNER JOIN 关键字</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> A<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span><span class="token keyword">value</span>
<span class="token keyword">FROM</span> tablea <span class="token keyword">AS</span> A <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> tableb <span class="token keyword">AS</span> B
<span class="token keyword">ON</span> A<span class="token punctuation">.</span><span class="token keyword">key</span> <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token keyword">key</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</span>
<span class="token keyword">SELECT</span> A<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span><span class="token keyword">value</span>
<span class="token keyword">FROM</span> tablea <span class="token keyword">AS</span> A<span class="token punctuation">,</span> tableb <span class="token keyword">AS</span> B
<span class="token keyword">WHERE</span> A<span class="token punctuation">.</span><span class="token keyword">key</span> <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token keyword">key</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>自连接</p>
<blockquote>
<p>自连接可以看成内连接的一种，只是连接的表是自身而已</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</span>
<span class="token comment" spellcheck="true">-- 子查询版本</span>
<span class="token keyword">SELECT</span> name
<span class="token keyword">FROM</span> employee
<span class="token keyword">WHERE</span> department <span class="token operator">=</span> <span class="token punctuation">(</span>
      <span class="token keyword">SELECT</span> department
      <span class="token keyword">FROM</span> employee
      <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">"Jim"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 自连接版本</span>
<span class="token keyword">SELECT</span> <span class="token number">e1</span><span class="token punctuation">.</span>name
<span class="token keyword">FROM</span> employee <span class="token keyword">AS</span> <span class="token number">e1</span> <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> employee <span class="token keyword">AS</span> <span class="token number">e2</span>
<span class="token keyword">ON</span> <span class="token number">e1</span><span class="token punctuation">.</span>department <span class="token operator">=</span> <span class="token number">e2</span><span class="token punctuation">.</span>department
      <span class="token operator">AND</span> <span class="token number">e2</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Jim"</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>自然连接</p>
<blockquote>
<p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个</p>
<p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> A<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span><span class="token keyword">value</span>
<span class="token keyword">FROM</span> tablea <span class="token keyword">AS</span> A <span class="token keyword">NATURAL</span> <span class="token keyword">JOIN</span> tableb <span class="token keyword">AS</span> B<span class="token punctuation">;</span></code></pre>
</li>
<li><p>外连接</p>
<blockquote>
<p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 检索所有顾客的订单信息，包括还没有订单信息的顾客</span>
<span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span> Customer<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>order_id
<span class="token keyword">FROM</span> Customers <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> Orders
<span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> Orders<span class="token punctuation">.</span>cust_id<span class="token punctuation">;</span></code></pre>
<p>customers 表：</p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>cust_name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
</tr>
</tbody></table>
<p>orders 表：</p>
<table>
<thead>
<tr>
<th>order_id</th>
<th>cust_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
</tr>
</tbody></table>
<p>结果：</p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>cust_name</th>
<th>order_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>a</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>Null</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>组合查询</p>
<blockquote>
<p>使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行</p>
<p>每个查询必须包含相同的列、表达式和聚集函数。</p>
<p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p>
<p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> col
<span class="token keyword">FROM</span> mytable
<span class="token keyword">WHERE</span> col <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">UNION</span>
<span class="token keyword">SELECT</span> col
<span class="token keyword">FROM</span> mytable
<span class="token keyword">WHERE</span> col <span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
<h4 id="2-2-4-其他"><a href="#2-2-4-其他" class="headerlink" title="2.2.4 其他"></a>2.2.4 其他</h4><ol>
<li><p>视图</p>
<blockquote>
<p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p>
<p>对视图的操作和对普通表的操作一样。</p>
</blockquote>
<p>优势</p>
<ul>
<li>简化复杂的 SQL 操作，比如复杂的连接；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>更改数据格式和表示</li>
</ul>
<p>示例</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> myview <span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> Concat<span class="token punctuation">(</span>col1<span class="token punctuation">,</span> col2<span class="token punctuation">)</span> <span class="token keyword">AS</span> concat_col<span class="token punctuation">,</span> col3<span class="token operator">*</span>col4 <span class="token keyword">AS</span> compute_col
<span class="token keyword">FROM</span> mytable
<span class="token keyword">WHERE</span> col5 <span class="token operator">=</span> val<span class="token punctuation">;</span></code></pre>
</li>
<li><p>存储过程</p>
<blockquote>
<p>存储过程可以看成是对一系列 SQL 操作的批处理</p>
<p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误</p>
<p>包含 in、out 和 inout 三种参数。</p>
<p>给变量赋值都需要用 select into 语句。</p>
<p>每次只能给一个变量赋值，不支持集合的操作。</p>
</blockquote>
<p>优势</p>
<ul>
<li>代码封装，保证了一定的安全性；</li>
<li>代码复用；</li>
<li>由于是预先编译，因此具有很高的性能。</li>
</ul>
<p>示例</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">delimiter</span> <span class="token comment" spellcheck="true">//</span>

<span class="token keyword">create</span> <span class="token keyword">procedure</span> myprocedure<span class="token punctuation">(</span> <span class="token keyword">out</span> ret <span class="token keyword">int</span> <span class="token punctuation">)</span>
    <span class="token keyword">begin</span>
        <span class="token keyword">declare</span> y <span class="token keyword">int</span><span class="token punctuation">;</span>
        <span class="token keyword">select</span> <span class="token function">sum</span><span class="token punctuation">(</span>col1<span class="token punctuation">)</span>
        <span class="token keyword">from</span> mytable
        <span class="token keyword">into</span> y<span class="token punctuation">;</span>
        <span class="token keyword">select</span> y<span class="token operator">*</span>y <span class="token keyword">into</span> ret<span class="token punctuation">;</span>
    <span class="token keyword">end</span> <span class="token comment" spellcheck="true">//</span>

<span class="token keyword">delimiter</span> <span class="token punctuation">;</span>

<span class="token keyword">call</span> myprocedure<span class="token punctuation">(</span><span class="token variable">@ret</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token variable">@ret</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>游标</p>
<blockquote>
<p>在存储过程中使用游标可以对一个结果集进行移动遍历</p>
<p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改</p>
</blockquote>
<p>步骤</p>
<ul>
<li>声明游标，这个过程没有实际检索出数据；</li>
<li>打开游标；</li>
<li>取出数据；</li>
<li>关闭游标；</li>
</ul>
<p>示例</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">delimiter</span> <span class="token comment" spellcheck="true">//</span>
<span class="token keyword">create</span> <span class="token keyword">procedure</span> myprocedure<span class="token punctuation">(</span><span class="token keyword">out</span> ret <span class="token keyword">int</span><span class="token punctuation">)</span>
    <span class="token keyword">begin</span>
        <span class="token keyword">declare</span> done <span class="token keyword">boolean</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">declare</span> mycursor <span class="token keyword">cursor</span> <span class="token keyword">for</span>
        <span class="token keyword">select</span> col1 <span class="token keyword">from</span> mytable<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true"># 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1</span>
        <span class="token keyword">declare</span> <span class="token keyword">continue</span> <span class="token keyword">handler</span> <span class="token keyword">for</span> sqlstate <span class="token string">'02000'</span> <span class="token keyword">set</span> done <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">open</span> mycursor<span class="token punctuation">;</span>

        repeat
            <span class="token keyword">fetch</span> mycursor <span class="token keyword">into</span> ret<span class="token punctuation">;</span>
            <span class="token keyword">select</span> ret<span class="token punctuation">;</span>
        until done <span class="token keyword">end</span> repeat<span class="token punctuation">;</span>

        <span class="token keyword">close</span> mycursor<span class="token punctuation">;</span>
    <span class="token keyword">end</span> <span class="token comment" spellcheck="true">//</span>
 <span class="token keyword">delimiter</span> <span class="token punctuation">;</span></code></pre>
</li>
<li><p>触发器</p>
<blockquote>
<p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDAT</p>
<p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字</p>
<p>BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中</p>
<p>INSERT 触发器包含一个名为 NEW 的虚拟表</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</span>
<span class="token comment" spellcheck="true">-- UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</span>
<span class="token comment" spellcheck="true">-- MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> mytrigger <span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> mytable
<span class="token keyword">FOR EACH ROW</span> <span class="token keyword">SELECT</span> NEW<span class="token punctuation">.</span>col <span class="token keyword">into</span> <span class="token variable">@result</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token variable">@result</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 获取结果</span></code></pre>
</li>
<li><p>事务管理</p>
<ul>
<li><p>概述</p>
<blockquote>
<p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句</p>
<p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交</p>
<p>出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交</p>
<p>设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的</p>
<p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点</p>
</blockquote>
</li>
<li><p>术语</p>
<ul>
<li>事务（transaction）指一组 SQL 语句；</li>
<li>回退（rollback）指撤销指定 SQL 语句的过程；</li>
<li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li>
<li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）</li>
</ul>
</li>
<li><p>示例</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span>
<span class="token comment" spellcheck="true">// ...</span>
<span class="token keyword">SAVEPOINT</span> delete1
<span class="token comment" spellcheck="true">// ...</span>
<span class="token keyword">ROLLBACK</span> <span class="token keyword">TO</span> delete1
<span class="token comment" spellcheck="true">// ...</span>
<span class="token keyword">COMMIT</span></code></pre>
</li>
</ul>
</li>
<li><p>字符集</p>
<ul>
<li><p>术语</p>
<ul>
<li>字符集为字母和符号的集合；</li>
<li>编码为某个字符集成员的内部表示；</li>
<li>校对字符指定如何比较，主要用于排序和分组。</li>
</ul>
</li>
<li><p>示例</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 除了给表指定字符集和校对外，也可以给列指定</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mytable
<span class="token punctuation">(</span>col <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER SET</span> latin <span class="token keyword">COLLATE</span> latin1_general_ci <span class="token punctuation">)</span>
<span class="token keyword">DEFAULT</span> <span class="token keyword">CHARACTER SET</span> hebrew <span class="token keyword">COLLATE</span> hebrew_general_ci<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 可以在排序、分组时指定校对</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> mytable
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col <span class="token keyword">COLLATE</span> latin1_general_ci<span class="token punctuation">;</span></code></pre>
</li>
</ul>
</li>
<li><p>权限管理</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- MySQL 的账户信息保存在 mysql 这个数据库中</span>
<span class="token keyword">USE</span> mysql<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token keyword">user</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 创建账户</span>
<span class="token comment" spellcheck="true">-- 新创建的账户没有任何权限</span>
<span class="token keyword">CREATE</span> <span class="token keyword">USER</span> myuser IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'mypassword'</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 修改账户名</span>
<span class="token keyword">RENAME</span> <span class="token keyword">USER</span> myuser <span class="token keyword">TO</span> newuser<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 删除账户</span>
<span class="token keyword">DROP</span> <span class="token keyword">USER</span> myuser<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 查看权限</span>
<span class="token keyword">SHOW</span> GRANTS <span class="token keyword">FOR</span> myuser<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 授予权限</span>
<span class="token comment" spellcheck="true">-- 账户用 username@host 的形式定义，username@% 使用的是默认主机名</span>
<span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span><span class="token punctuation">,</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> mydatabase<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> myuser<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 删除权限</span>
<span class="token comment" spellcheck="true">-- GRANT 和 REVOKE 可在几个层次上控制访问权限：</span>
    <span class="token comment" spellcheck="true">-- 整个服务器，使用 GRANT ALL 和 REVOKE ALL；</span>
    <span class="token comment" spellcheck="true">-- 整个数据库，使用 ON database.*；</span>
    <span class="token comment" spellcheck="true">-- 特定的表，使用 ON database.table；</span>
    <span class="token comment" spellcheck="true">-- 特定的列；</span>
    <span class="token comment" spellcheck="true">-- 特定的存储过程。</span>
<span class="token keyword">REVOKE</span> <span class="token keyword">SELECT</span><span class="token punctuation">,</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> mydatabase<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> myuser<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 更改密码</span>
<span class="token comment" spellcheck="true">-- 必须使用 Password() 函数进行加密。</span>
<span class="token keyword">SET</span> PASSWROD <span class="token keyword">FOR</span> myuser <span class="token operator">=</span> Password<span class="token punctuation">(</span><span class="token string">'new_password'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
<h3 id="2-3-练习"><a href="#2-3-练习" class="headerlink" title="2.3 练习"></a>2.3 练习</h3><ol>
<li><p>Big Countries(595)</p>
<ol>
<li><p>题述</p>
<table>
<thead>
<tr>
<th>name</th>
<th>continent</th>
<th>area</th>
<th>population</th>
<th>gdp</th>
</tr>
</thead>
<tbody><tr>
<td>Afghanistan</td>
<td>Asia</td>
<td>652230</td>
<td>25500100</td>
<td>20343000</td>
</tr>
<tr>
<td>Albania</td>
<td>Europe</td>
<td>28748</td>
<td>2831741</td>
<td>12960000</td>
</tr>
<tr>
<td>Algeria</td>
<td>Africa</td>
<td>2381741</td>
<td>37100000</td>
<td>188681000</td>
</tr>
<tr>
<td>Andorra</td>
<td>Europe</td>
<td>468</td>
<td>78115</td>
<td>3712000</td>
</tr>
<tr>
<td>Angola</td>
<td>Africa</td>
<td>1246700</td>
<td>20609294</td>
<td>100990000</td>
</tr>
</tbody></table>
<p>查找面积超过 3,000,000 或者人口数超过 25,000,000 的国家</p>
<table>
<thead>
<tr>
<th>name</th>
<th>population</th>
<th>area</th>
</tr>
</thead>
<tbody><tr>
<td>Afghanistan</td>
<td>25500100</td>
<td>652230</td>
</tr>
<tr>
<td>Algeria</td>
<td>37100000</td>
<td>2381741</td>
</tr>
</tbody></table>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span>
    population<span class="token punctuation">,</span>
    area
<span class="token keyword">FROM</span>
    World
<span class="token keyword">WHERE</span>
    area <span class="token operator">></span> <span class="token number">3000000</span>
    <span class="token operator">OR</span> population <span class="token operator">></span> <span class="token number">25000000</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- SQL Schema 用于在本地环境下创建表结构并导入数据，从而方便在本地环境调试</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span>
<span class="token keyword">IF</span>
    <span class="token keyword">EXISTS</span> World<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> World <span class="token punctuation">(</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> continent <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> area <span class="token keyword">INT</span><span class="token punctuation">,</span> population <span class="token keyword">INT</span><span class="token punctuation">,</span> gdp <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> World <span class="token punctuation">(</span> NAME<span class="token punctuation">,</span> continent<span class="token punctuation">,</span> area<span class="token punctuation">,</span> population<span class="token punctuation">,</span> gdp <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token string">'Afghanistan'</span><span class="token punctuation">,</span> <span class="token string">'Asia'</span><span class="token punctuation">,</span> <span class="token string">'652230'</span><span class="token punctuation">,</span> <span class="token string">'25500100'</span><span class="token punctuation">,</span> <span class="token string">'203430000'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'Albania'</span><span class="token punctuation">,</span> <span class="token string">'Europe'</span><span class="token punctuation">,</span> <span class="token string">'28748'</span><span class="token punctuation">,</span> <span class="token string">'2831741'</span><span class="token punctuation">,</span> <span class="token string">'129600000'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'Algeria'</span><span class="token punctuation">,</span> <span class="token string">'Africa'</span><span class="token punctuation">,</span> <span class="token string">'2381741'</span><span class="token punctuation">,</span> <span class="token string">'37100000'</span><span class="token punctuation">,</span> <span class="token string">'1886810000'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'Andorra'</span><span class="token punctuation">,</span> <span class="token string">'Europe'</span><span class="token punctuation">,</span> <span class="token string">'468'</span><span class="token punctuation">,</span> <span class="token string">'78115'</span><span class="token punctuation">,</span> <span class="token string">'37120000'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'Angola'</span><span class="token punctuation">,</span> <span class="token string">'Africa'</span><span class="token punctuation">,</span> <span class="token string">'1246700'</span><span class="token punctuation">,</span> <span class="token string">'20609294'</span><span class="token punctuation">,</span> <span class="token string">'1009900000'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>Swap Salary(627)</p>
<ol>
<li><p>题述</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>sex</th>
<th>salary</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A</td>
<td>m</td>
<td>2500</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>f</td>
<td>1500</td>
</tr>
<tr>
<td>3</td>
<td>C</td>
<td>m</td>
<td>5500</td>
</tr>
<tr>
<td>4</td>
<td>D</td>
<td>f</td>
<td>500</td>
</tr>
</tbody></table>
<p>只用一个 SQL 查询，将 sex 字段反转</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>sex</th>
<th>salary</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A</td>
<td>f</td>
<td>2500</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>m</td>
<td>1500</td>
</tr>
<tr>
<td>3</td>
<td>C</td>
<td>f</td>
<td>5500</td>
</tr>
<tr>
<td>4</td>
<td>D</td>
<td>m</td>
<td>500</td>
</tr>
</tbody></table>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 两个相等的数异或的结果为 0，而 0 与任何一个数异或的结果为这个数。</span>
<span class="token comment" spellcheck="true">-- sex 字段只有两个取值：'f' 和 'm'，并且有以下规律：</span>
    <span class="token comment" spellcheck="true">-- 'f' ^ ('m' ^ 'f') = 'm' ^ ('f' ^ 'f') = 'm'</span>
    <span class="token comment" spellcheck="true">-- 'm' ^ ('m' ^ 'f') = 'f' ^ ('m' ^ 'm') = 'f'</span>

<span class="token comment" spellcheck="true">-- 因此将 sex 字段和 'm' ^ 'f' 进行异或操作，最后就能反转 sex 字段</span>
<span class="token keyword">UPDATE</span> salary
<span class="token keyword">SET</span> sex <span class="token operator">=</span> CHAR <span class="token punctuation">(</span> ASCII<span class="token punctuation">(</span>sex<span class="token punctuation">)</span> <span class="token operator">^</span> ASCII<span class="token punctuation">(</span> <span class="token string">'m'</span> <span class="token punctuation">)</span> <span class="token operator">^</span> ASCII<span class="token punctuation">(</span> <span class="token string">'f'</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- SQL Schema</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span>
<span class="token keyword">IF</span>
    <span class="token keyword">EXISTS</span> salary<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> salary <span class="token punctuation">(</span> id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> sex CHAR <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> salary <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> salary <span class="token punctuation">(</span> id<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> sex<span class="token punctuation">,</span> salary <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token string">'2500'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'1500'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token string">'5500'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'500'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>Not Boring Movies(620)</p>
<ol>
<li><p>题述</p>
<table>
<thead>
<tr>
<th>id</th>
<th>movie</th>
<th>description</th>
<th>rating</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>War</td>
<td>great 3D</td>
<td>8.9</td>
</tr>
<tr>
<td>2</td>
<td>Science</td>
<td>fiction</td>
<td>8.5</td>
</tr>
<tr>
<td>3</td>
<td>irish</td>
<td>boring</td>
<td>6.2</td>
</tr>
<tr>
<td>4</td>
<td>Ice song</td>
<td>Fantacy</td>
<td>8.6</td>
</tr>
<tr>
<td>5</td>
<td>House card</td>
<td>Interesting</td>
<td>9.1</td>
</tr>
</tbody></table>
<p>查找 id 为奇数，并且 description 不是 boring 的电影，按 rating 降序</p>
<table>
<thead>
<tr>
<th>id</th>
<th>movie</th>
<th>description</th>
<th>rating</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>House card</td>
<td>Interesting</td>
<td>9.1</td>
</tr>
<tr>
<td>1</td>
<td>War</td>
<td>great 3D</td>
<td>8.9</td>
</tr>
</tbody></table>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>
    <span class="token operator">*</span>
<span class="token keyword">FROM</span>
    cinema
<span class="token keyword">WHERE</span>
    id <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token operator">AND</span> description <span class="token operator">!=</span> <span class="token string">'boring'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>
    rating <span class="token keyword">DESC</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- SQL Schema</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span>
<span class="token keyword">IF</span>
    <span class="token keyword">EXISTS</span> cinema<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> cinema <span class="token punctuation">(</span> id <span class="token keyword">INT</span><span class="token punctuation">,</span> movie <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> description <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> rating <span class="token keyword">FLOAT</span> <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> cinema <span class="token punctuation">(</span> id<span class="token punctuation">,</span> movie<span class="token punctuation">,</span> description<span class="token punctuation">,</span> rating <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'War'</span><span class="token punctuation">,</span> <span class="token string">'great 3D'</span><span class="token punctuation">,</span> <span class="token number">8.9</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Science'</span><span class="token punctuation">,</span> <span class="token string">'fiction'</span><span class="token punctuation">,</span> <span class="token number">8.5</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'irish'</span><span class="token punctuation">,</span> <span class="token string">'boring'</span><span class="token punctuation">,</span> <span class="token number">6.2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'Ice song'</span><span class="token punctuation">,</span> <span class="token string">'Fantacy'</span><span class="token punctuation">,</span> <span class="token number">8.6</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'House card'</span><span class="token punctuation">,</span> <span class="token string">'Interesting'</span><span class="token punctuation">,</span> <span class="token number">9.1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>Classes More Than 5 Students(596)</p>
<ol>
<li><p>题述</p>
<table>
<thead>
<tr>
<th>student</th>
<th>class</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>Math</td>
</tr>
<tr>
<td>B</td>
<td>English</td>
</tr>
<tr>
<td>C</td>
<td>Math</td>
</tr>
<tr>
<td>D</td>
<td>Biology</td>
</tr>
<tr>
<td>E</td>
<td>Math</td>
</tr>
<tr>
<td>F</td>
<td>Computer</td>
</tr>
<tr>
<td>G</td>
<td>Math</td>
</tr>
<tr>
<td>H</td>
<td>Math</td>
</tr>
<tr>
<td>I</td>
<td>Math</td>
</tr>
</tbody></table>
<p>查找有五名及以上 student 的 class</p>
<table>
<thead>
<tr>
<th>class</th>
</tr>
</thead>
<tbody><tr>
<td>Math</td>
</tr>
</tbody></table>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 对 class 列进行分组之后，再使用 count 汇总函数统计每个分组的记录个数，之后使用 HAVING 进行筛选。HAVING 针对分组进行筛选，而 WHERE 针对每个记录（行）进行筛选</span>
<span class="token keyword">SELECT</span>
    class
<span class="token keyword">FROM</span>
    courses
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>
    class
<span class="token keyword">HAVING</span>
    <span class="token function">count</span><span class="token punctuation">(</span> <span class="token keyword">DISTINCT</span> student <span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- SQL Schema</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span>
<span class="token keyword">IF</span>
    <span class="token keyword">EXISTS</span> courses<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> courses <span class="token punctuation">(</span> student <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> class <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> courses <span class="token punctuation">(</span> student<span class="token punctuation">,</span> class <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'English'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'Biology'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'F'</span><span class="token punctuation">,</span> <span class="token string">'Computer'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'G'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'H'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'I'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>Duplicate Emails(182)</p>
<ol>
<li><p>题述</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a href="mailto:&#x61;&#x40;&#98;&#x2e;&#99;&#x6f;&#x6d;">&#x61;&#x40;&#98;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>2</td>
<td><a href="mailto:&#x63;&#64;&#x64;&#x2e;&#99;&#x6f;&#x6d;">&#x63;&#64;&#x64;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>3</td>
<td><a href="mailto:&#97;&#x40;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#97;&#x40;&#x62;&#46;&#x63;&#x6f;&#x6d;</a></td>
</tr>
</tbody></table>
<p>查找重复的邮件地址</p>
<table>
<thead>
<tr>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td><a href="mailto:&#x61;&#64;&#98;&#x2e;&#x63;&#111;&#x6d;">&#x61;&#64;&#98;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
</tbody></table>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 对 Email 进行分组，如果并使用 COUNT 进行计数统计，结果大于等于 2 的表示 Email 重复</span>
<span class="token keyword">SELECT</span>
    Email
<span class="token keyword">FROM</span>
    Person
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>
    Email
<span class="token keyword">HAVING</span>
    <span class="token function">COUNT</span><span class="token punctuation">(</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- SQL Schema</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span>
<span class="token keyword">IF</span>
    <span class="token keyword">EXISTS</span> Person<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Person <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> Email <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Person <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> Email <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'a@b.com'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'c@d.com'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'a@b.com'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>Delete Duplicate Emails(196)</p>
<ol>
<li><p>题述</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a href="mailto:&#x6a;&#x6f;&#104;&#x6e;&#64;&#101;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#111;&#109;">&#x6a;&#x6f;&#104;&#x6e;&#64;&#101;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>2</td>
<td><a href="mailto:&#x62;&#111;&#x62;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;">&#x62;&#111;&#x62;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>3</td>
<td><a href="mailto:&#x6a;&#111;&#104;&#x6e;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#109;">&#x6a;&#111;&#104;&#x6e;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
</tbody></table>
<p>删除重复的邮件地址</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a href="mailto:&#106;&#x6f;&#x68;&#110;&#x40;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#111;&#109;">&#106;&#x6f;&#x68;&#110;&#x40;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>2</td>
<td><a href="mailto:&#98;&#x6f;&#x62;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#109;">&#98;&#x6f;&#x62;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#109;</a></td>
</tr>
</tbody></table>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 只保留相同 Email 中 Id 最小的那一个，然后删除其它的</span>
<span class="token comment" spellcheck="true">-- 连接查询</span>
<span class="token keyword">DELETE</span> p1
<span class="token keyword">FROM</span>
    Person p1<span class="token punctuation">,</span>
    Person p2
<span class="token keyword">WHERE</span>
    p1<span class="token punctuation">.</span>Email <span class="token operator">=</span> p2<span class="token punctuation">.</span>Email
    <span class="token operator">AND</span> p1<span class="token punctuation">.</span>Id <span class="token operator">></span> p2<span class="token punctuation">.</span>Id

<span class="token comment" spellcheck="true">-- 子查询</span>
<span class="token keyword">DELETE</span>
<span class="token keyword">FROM</span>
    Person
<span class="token keyword">WHERE</span>
    id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span>
        <span class="token keyword">SELECT</span> id 
        <span class="token keyword">FROM</span> <span class="token punctuation">(</span> 
            <span class="token keyword">SELECT</span> <span class="token function">min</span><span class="token punctuation">(</span> id <span class="token punctuation">)</span> <span class="token keyword">AS</span> id 
            <span class="token keyword">FROM</span> Person
            <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> email
        <span class="token punctuation">)</span> <span class="token keyword">AS</span> m
    <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 额外嵌套了一个 SELECT 语句，如果不这么做，会出现错误：You can't specify target table 'Person' for update in FROM clause</span></code></pre>
</li>
</ol>
</li>
<li><p>Combine Two Tables(175)</p>
<ol>
<li><p>题述</p>
<p>Person 表</p>
<table>
<thead>
<tr>
<th>Column Name</th>
<th>Type</th>
</tr>
</thead>
<tbody><tr>
<td>PersonId</td>
<td>int</td>
</tr>
<tr>
<td>FirstName</td>
<td>varchar</td>
</tr>
<tr>
<td>LastName</td>
<td>varchar</td>
</tr>
</tbody></table>
<p>Address 表</p>
<table>
<thead>
<tr>
<th>Column Name</th>
<th>Type</th>
</tr>
</thead>
<tbody><tr>
<td>AddressId</td>
<td>int</td>
</tr>
<tr>
<td>PersonId</td>
<td>int</td>
</tr>
<tr>
<td>City</td>
<td>varchar</td>
</tr>
<tr>
<td>State</td>
<td>varchar</td>
</tr>
</tbody></table>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 查找 FirstName, LastName, City, State 数据，而不管一个用户有没有填地址信息</span>
<span class="token comment" spellcheck="true">-- 涉及到 Person 和 Address 两个表，在对这两个表执行连接操作时，因为要保留 Person 表中的信息，即使在 Address 表中没有关联的信息也要保留。此时可以用左外连接，将 Person 表放在 LEFT JOIN 的左边</span>
<span class="token keyword">SELECT</span>
    FirstName<span class="token punctuation">,</span>
    LastName<span class="token punctuation">,</span>
    City<span class="token punctuation">,</span>
    State
<span class="token keyword">FROM</span>
    Person P
    <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Address A
    <span class="token keyword">ON</span> P<span class="token punctuation">.</span>PersonId <span class="token operator">=</span> A<span class="token punctuation">.</span>PersonId<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- SQL Schema</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span>
<span class="token keyword">IF</span>
    <span class="token keyword">EXISTS</span> Person<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Person <span class="token punctuation">(</span> PersonId <span class="token keyword">INT</span><span class="token punctuation">,</span> FirstName <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> LastName <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span>
<span class="token keyword">IF</span>
    <span class="token keyword">EXISTS</span> Address<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Address <span class="token punctuation">(</span> AddressId <span class="token keyword">INT</span><span class="token punctuation">,</span> PersonId <span class="token keyword">INT</span><span class="token punctuation">,</span> City <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> State <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Person <span class="token punctuation">(</span> PersonId<span class="token punctuation">,</span> LastName<span class="token punctuation">,</span> FirstName <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Wang'</span><span class="token punctuation">,</span> <span class="token string">'Allen'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Address <span class="token punctuation">(</span> AddressId<span class="token punctuation">,</span> PersonId<span class="token punctuation">,</span> City<span class="token punctuation">,</span> State <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'New York City'</span><span class="token punctuation">,</span> <span class="token string">'New York'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>Employees Earning More Than Their Managers(181)</p>
<ol>
<li><p>题述</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Name</th>
<th>Salary</th>
<th>ManagerId</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Joe</td>
<td>70000</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>Henry</td>
<td>80000</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>Sam</td>
<td>60000</td>
<td>NULL</td>
</tr>
<tr>
<td>4</td>
<td>Max</td>
<td>90000</td>
<td>NULL</td>
</tr>
</tbody></table>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 查找薪资大于其经理薪资的员工信息</span>
<span class="token keyword">SELECT</span>
    E1<span class="token punctuation">.</span>NAME <span class="token keyword">AS</span> Employee
<span class="token keyword">FROM</span>
    Employee E1
    <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Employee E2
    <span class="token keyword">ON</span> E1<span class="token punctuation">.</span>ManagerId <span class="token operator">=</span> E2<span class="token punctuation">.</span>Id
    <span class="token operator">AND</span> E1<span class="token punctuation">.</span>Salary <span class="token operator">></span> E2<span class="token punctuation">.</span>Salary<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- SQL Schema</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span>
<span class="token keyword">IF</span>
    <span class="token keyword">EXISTS</span> Employee<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Employee <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> Salary <span class="token keyword">INT</span><span class="token punctuation">,</span> ManagerId <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Employee <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> Salary<span class="token punctuation">,</span> ManagerId <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Joe'</span><span class="token punctuation">,</span> <span class="token number">70000</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Henry'</span><span class="token punctuation">,</span> <span class="token number">80000</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Sam'</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'Max'</span><span class="token punctuation">,</span> <span class="token number">90000</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>Customers Who Never Order(183)</p>
<ol>
<li><p>题述</p>
<p>Customers 表</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Joe</td>
</tr>
<tr>
<td>2</td>
<td>Henry</td>
</tr>
<tr>
<td>3</td>
<td>Sam</td>
</tr>
<tr>
<td>4</td>
<td>Max</td>
</tr>
</tbody></table>
<p>Orders 表</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>CustomerId</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p>查找没有订单的顾客信息</p>
<table>
<thead>
<tr>
<th>Customers</th>
</tr>
</thead>
<tbody><tr>
<td>Henry</td>
</tr>
<tr>
<td>Max</td>
</tr>
</tbody></table>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 左外链接</span>
<span class="token keyword">SELECT</span>
    C<span class="token punctuation">.</span>Name <span class="token keyword">AS</span> Customers
<span class="token keyword">FROM</span>
    Customers C
    <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Orders O
    <span class="token keyword">ON</span> C<span class="token punctuation">.</span>Id <span class="token operator">=</span> O<span class="token punctuation">.</span>CustomerId
<span class="token keyword">WHERE</span>
    O<span class="token punctuation">.</span>CustomerId <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- 子查询</span>
<span class="token keyword">SELECT</span>
    Name <span class="token keyword">AS</span> Customers
<span class="token keyword">FROM</span>
    Customers
<span class="token keyword">WHERE</span>
    Id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span> 
        <span class="token keyword">SELECT</span> CustomerId 
        <span class="token keyword">FROM</span> Orders 
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- SQL Schema</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span>
<span class="token keyword">IF</span>
    <span class="token keyword">EXISTS</span> Customers<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Customers <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span>
<span class="token keyword">IF</span>
    <span class="token keyword">EXISTS</span> Orders<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Orders <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> CustomerId <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Customers <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> NAME <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Joe'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Henry'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Sam'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'Max'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Orders <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> CustomerId <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>Department Highest Salary(184)</p>
<ol>
<li><p>题述</p>
<p>Employee 表</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Name</th>
<th>Salary</th>
<th>DepartmentId</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Joe</td>
<td>70000</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>Henry</td>
<td>80000</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>Sam</td>
<td>60000</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>Max</td>
<td>90000</td>
<td>1</td>
</tr>
</tbody></table>
<p>Department 表</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>IT</td>
</tr>
<tr>
<td>2</td>
<td>Sales</td>
</tr>
</tbody></table>
<p>查找一个 Department 中收入最高者的信息</p>
<table>
<thead>
<tr>
<th>Department</th>
<th>Salary</th>
<th>Salary</th>
</tr>
</thead>
<tbody><tr>
<td>IT</td>
<td>Max</td>
<td>90000</td>
</tr>
<tr>
<td>Sales</td>
<td>Henry</td>
<td>80000</td>
</tr>
</tbody></table>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 创建一个临时表，包含了部门员工的最大薪资。可以对部门进行分组，然后使用 MAX() 汇总函数取得最大薪资</span>
<span class="token comment" spellcheck="true">-- 之后使用连接找到一个部门中薪资等于临时表中最大薪资的员工</span>
<span class="token keyword">SELECT</span>
    D<span class="token punctuation">.</span>NAME Department<span class="token punctuation">,</span>
    E<span class="token punctuation">.</span>NAME Employee<span class="token punctuation">,</span>
    E<span class="token punctuation">.</span>Salary
<span class="token keyword">FROM</span>
    Employee E<span class="token punctuation">,</span>
    Department D<span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> DepartmentId<span class="token punctuation">,</span> <span class="token function">MAX</span><span class="token punctuation">(</span> Salary <span class="token punctuation">)</span> Salary 
     <span class="token keyword">FROM</span> Employee 
     <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> DepartmentId <span class="token punctuation">)</span> M
<span class="token keyword">WHERE</span>
    E<span class="token punctuation">.</span>DepartmentId <span class="token operator">=</span> D<span class="token punctuation">.</span>Id
    <span class="token operator">AND</span> E<span class="token punctuation">.</span>DepartmentId <span class="token operator">=</span> M<span class="token punctuation">.</span>DepartmentId
    <span class="token operator">AND</span> E<span class="token punctuation">.</span>Salary <span class="token operator">=</span> M<span class="token punctuation">.</span>Salary<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- SQL Schema</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> Employee<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Employee <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> Salary <span class="token keyword">INT</span><span class="token punctuation">,</span> DepartmentId <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> Department<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Department <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Employee <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> Salary<span class="token punctuation">,</span> DepartmentId <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Joe'</span><span class="token punctuation">,</span> <span class="token number">70000</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Henry'</span><span class="token punctuation">,</span> <span class="token number">80000</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Sam'</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'Max'</span><span class="token punctuation">,</span> <span class="token number">90000</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Department <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> NAME <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'IT'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Sales'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>Second Highest Salary(176)</p>
<ol>
<li><p>题述</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Salary</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>200</td>
</tr>
<tr>
<td>3</td>
<td>300</td>
</tr>
</tbody></table>
<p>查找工资第二高的员工</p>
<table>
<thead>
<tr>
<th>SecondHighestSalary</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
</tr>
</tbody></table>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 没有找到返回 null 而不是不返回数据</span>
<span class="token comment" spellcheck="true">-- 为了在没有查找到数据时返回 null，需要在查询结果外面再套一层 SELECT</span>
<span class="token keyword">SELECT</span>
    <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> Salary 
     <span class="token keyword">FROM</span> Employee 
     <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Salary <span class="token keyword">DESC</span> 
     <span class="token keyword">LIMIT</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span> SecondHighestSalary<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- SQL Schema</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span>
<span class="token keyword">IF</span>
    <span class="token keyword">EXISTS</span> Employee<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Employee <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> Salary <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Employee <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> Salary <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">200</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">300</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>Nth Highest Salary(177)</p>
<ol>
<li><p>题述</p>
<blockquote>
<p>查找工资第 N 高的员工</p>
</blockquote>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> getNthHighestSalary <span class="token punctuation">(</span> N <span class="token keyword">INT</span> <span class="token punctuation">)</span> <span class="token keyword">RETURNS</span> <span class="token keyword">INT</span> <span class="token keyword">BEGIN</span>

<span class="token keyword">SET</span> N <span class="token operator">=</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">RETURN</span> <span class="token punctuation">(</span> 
    <span class="token keyword">SELECT</span> <span class="token punctuation">(</span> 
        <span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> Salary 
        <span class="token keyword">FROM</span> Employee 
        <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Salary <span class="token keyword">DESC</span> 
        <span class="token keyword">LIMIT</span> N<span class="token punctuation">,</span> <span class="token number">1</span> 
    <span class="token punctuation">)</span> 
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">END</span></code></pre>
</li>
</ol>
</li>
<li><p>Rank Scores(178)</p>
<ol>
<li><p>题述</p>
<p>得分表</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>3.50</td>
</tr>
<tr>
<td>2</td>
<td>3.65</td>
</tr>
<tr>
<td>3</td>
<td>4.00</td>
</tr>
<tr>
<td>4</td>
<td>3.85</td>
</tr>
<tr>
<td>5</td>
<td>4.00</td>
</tr>
<tr>
<td>6</td>
<td>3.65</td>
</tr>
</tbody></table>
<p>将得分排序，并统计排名</p>
<table>
<thead>
<tr>
<th>Score</th>
<th>Rank</th>
</tr>
</thead>
<tbody><tr>
<td>4.00</td>
<td>1</td>
</tr>
<tr>
<td>4.00</td>
<td>1</td>
</tr>
<tr>
<td>3.85</td>
<td>2</td>
</tr>
<tr>
<td>3.65</td>
<td>3</td>
</tr>
<tr>
<td>3.65</td>
<td>3</td>
</tr>
<tr>
<td>3.50</td>
<td>4</td>
</tr>
</tbody></table>
<p>要统计某个 score 的排名，只要统计大于等于该 score 的 score 数量</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>score</th>
<th>大于等于该 score 的 score 数量</th>
<th>排名</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>4.1</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>4.2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>4.3</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 使用连接操作找到某个 score 对应的大于等于其值的记录</span>
<span class="token keyword">SELECT</span>
    <span class="token operator">*</span>
<span class="token keyword">FROM</span>
    Scores S1
    <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Scores S2
    <span class="token keyword">ON</span> S1<span class="token punctuation">.</span>score <span class="token operator">&lt;=</span> S2<span class="token punctuation">.</span>score
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>
    S1<span class="token punctuation">.</span>score <span class="token keyword">DESC</span><span class="token punctuation">,</span> S1<span class="token punctuation">.</span>Id<span class="token punctuation">;</span></code></pre>
<table>
<thead>
<tr>
<th>S1.Id</th>
<th>S1.score</th>
<th>S2.Id</th>
<th>S2.score</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>4.3</td>
<td>3</td>
<td>4.3</td>
</tr>
<tr>
<td>2</td>
<td>4.2</td>
<td>2</td>
<td>4.2</td>
</tr>
<tr>
<td>2</td>
<td>4.2</td>
<td>3</td>
<td>4.3</td>
</tr>
<tr>
<td>1</td>
<td>4.1</td>
<td>1</td>
<td>4.1</td>
</tr>
<tr>
<td>1</td>
<td>4.1</td>
<td>2</td>
<td>4.2</td>
</tr>
<tr>
<td>1</td>
<td>4.1</td>
<td>3</td>
<td>4.3</td>
</tr>
</tbody></table>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 可以看到每个 S1.score 都有对应好几条记录，我们再进行分组，并统计每个分组的数量作为 'Rank</span>
<span class="token keyword">SELECT</span>
    S1<span class="token punctuation">.</span>score <span class="token string">'Score'</span><span class="token punctuation">,</span>
    <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token string">'Rank'</span>
<span class="token keyword">FROM</span>
    Scores S1
    <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Scores S2
    <span class="token keyword">ON</span> S1<span class="token punctuation">.</span>score <span class="token operator">&lt;=</span> S2<span class="token punctuation">.</span>score
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>
    S1<span class="token punctuation">.</span>id<span class="token punctuation">,</span> S1<span class="token punctuation">.</span>score
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>
    S1<span class="token punctuation">.</span>score <span class="token keyword">DESC</span><span class="token punctuation">,</span> S1<span class="token punctuation">.</span>Id<span class="token punctuation">;</span></code></pre>
<table>
<thead>
<tr>
<th>score</th>
<th>Rank</th>
</tr>
</thead>
<tbody><tr>
<td>4.3</td>
<td>1</td>
</tr>
<tr>
<td>4.2</td>
<td>2</td>
</tr>
<tr>
<td>4.1</td>
<td>3</td>
</tr>
</tbody></table>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 我们想要的结果是，把分数相同的放在同一个排名，并且相同分数只占一个位置，例如上面的分数，Id=2 和 Id=3 的记录都有相同的分数，并且最高，他们并列第一。而 Id=1 的记录应该排第二名，而不是第三名。所以在进行 COUNT 计数统计时，我们需要使用 COUNT( DISTINCT S2.score ) 从而只统计一次相同的分数</span>
<span class="token keyword">SELECT</span>
    S1<span class="token punctuation">.</span>score <span class="token string">'Score'</span><span class="token punctuation">,</span>
    <span class="token function">COUNT</span><span class="token punctuation">(</span> <span class="token keyword">DISTINCT</span> S2<span class="token punctuation">.</span>score <span class="token punctuation">)</span> <span class="token string">'Rank'</span>
<span class="token keyword">FROM</span>
    Scores S1
    <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Scores S2
    <span class="token keyword">ON</span> S1<span class="token punctuation">.</span>score <span class="token operator">&lt;=</span> S2<span class="token punctuation">.</span>score
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>
    S1<span class="token punctuation">.</span>id<span class="token punctuation">,</span> S1<span class="token punctuation">.</span>score
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>
    S1<span class="token punctuation">.</span>score <span class="token keyword">DESC</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- SQL Schema</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span>
<span class="token keyword">IF</span>
    <span class="token keyword">EXISTS</span> Scores<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Scores <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> Score <span class="token keyword">DECIMAL</span> <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Scores <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> Score <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4.1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4.1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4.2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4.2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4.3</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4.3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>Consecutive Numbers(180)</p>
<ol>
<li><p>题述</p>
<p>数字表</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Num</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>2</td>
</tr>
</tbody></table>
<p>查找连续出现三次的数字</p>
<table>
<thead>
<tr>
<th>ConsecutiveNums</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
</tr>
</tbody></table>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>
    <span class="token keyword">DISTINCT</span> L1<span class="token punctuation">.</span>num ConsecutiveNums
<span class="token keyword">FROM</span>
    Logs L1<span class="token punctuation">,</span>
    Logs L2<span class="token punctuation">,</span>
    Logs L3
<span class="token keyword">WHERE</span> L1<span class="token punctuation">.</span>id <span class="token operator">=</span> l2<span class="token punctuation">.</span>id <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token operator">AND</span> L2<span class="token punctuation">.</span>id <span class="token operator">=</span> L3<span class="token punctuation">.</span>id <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token operator">AND</span> L1<span class="token punctuation">.</span>num <span class="token operator">=</span> L2<span class="token punctuation">.</span>num
    <span class="token operator">AND</span> l2<span class="token punctuation">.</span>num <span class="token operator">=</span> l3<span class="token punctuation">.</span>num<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">-- SQL Schema</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span>
<span class="token keyword">IF</span>
    <span class="token keyword">EXISTS</span> LOGS<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> LOGS <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> Num <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> LOGS <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> Num <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>Exchange Seats(626)</p>
<ol>
<li><p>题述</p>
<p>seat 表存储着座位对应的学生</p>
<table>
<thead>
<tr>
<th>id</th>
<th>student</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Abbot</td>
</tr>
<tr>
<td>2</td>
<td>Doris</td>
</tr>
<tr>
<td>3</td>
<td>Emerson</td>
</tr>
<tr>
<td>4</td>
<td>Green</td>
</tr>
<tr>
<td>5</td>
<td>Jeames</td>
</tr>
</tbody></table>
<p>要求交换相邻座位的两个学生，如果最后一个座位是奇数，那么不交换这个座位上的学生</p>
<table>
<thead>
<tr>
<th>id</th>
<th>student</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Doris</td>
</tr>
<tr>
<td>2</td>
<td>Abbot</td>
</tr>
<tr>
<td>3</td>
<td>Green</td>
</tr>
<tr>
<td>4</td>
<td>Emerson</td>
</tr>
<tr>
<td>5</td>
<td>Jeames</td>
</tr>
</tbody></table>
</li>
<li><p>实现</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 使用多个 union</span>
<span class="token comment" spellcheck="true">-- 处理偶数 id，让 id 减 1</span>
<span class="token comment" spellcheck="true">-- 例如 2,4,6,... 变成 1,3,5,...</span>
<span class="token keyword">SELECT</span>
    s1<span class="token punctuation">.</span>id <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">AS</span> id<span class="token punctuation">,</span>
    s1<span class="token punctuation">.</span>student
<span class="token keyword">FROM</span>
    seat s1
<span class="token keyword">WHERE</span>
    s1<span class="token punctuation">.</span>id MOD <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">UNION</span>
<span class="token comment" spellcheck="true">-- 处理奇数 id，让 id 加 1。但是如果最大的 id 为奇数，则不做处理</span>
<span class="token comment" spellcheck="true">-- 例如 1,3,5,... 变成 2,4,6,...</span>
<span class="token keyword">SELECT</span>
    s2<span class="token punctuation">.</span>id <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">AS</span> id<span class="token punctuation">,</span>
    s2<span class="token punctuation">.</span>student
<span class="token keyword">FROM</span>
    seat s2
<span class="token keyword">WHERE</span>
    s2<span class="token punctuation">.</span>id MOD <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token operator">AND</span> s2<span class="token punctuation">.</span>id <span class="token operator">!=</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token function">max</span><span class="token punctuation">(</span> s3<span class="token punctuation">.</span>id <span class="token punctuation">)</span> <span class="token keyword">FROM</span> seat s3 <span class="token punctuation">)</span> <span class="token keyword">UNION</span>
<span class="token comment" spellcheck="true">-- 如果最大的 id 为奇数，单独取出这个数</span>
<span class="token keyword">SELECT</span>
    s4<span class="token punctuation">.</span>id <span class="token keyword">AS</span> id<span class="token punctuation">,</span>
    s4<span class="token punctuation">.</span>student
<span class="token keyword">FROM</span>
    seat s4
<span class="token keyword">WHERE</span>
    s4<span class="token punctuation">.</span>id MOD <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token operator">AND</span> s4<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token function">max</span><span class="token punctuation">(</span> s5<span class="token punctuation">.</span>id <span class="token punctuation">)</span> <span class="token keyword">FROM</span> seat s5 <span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>
    id<span class="token punctuation">;</span>

<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span>
<span class="token keyword">IF</span>
    <span class="token keyword">EXISTS</span> seat<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> seat <span class="token punctuation">(</span> id <span class="token keyword">INT</span><span class="token punctuation">,</span> student <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> seat <span class="token punctuation">(</span> id<span class="token punctuation">,</span> student <span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
    <span class="token punctuation">(</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'Abbot'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'Doris'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'Emerson'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'Green'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'Jeames'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="2-4-MySQL"><a href="#2-4-MySQL" class="headerlink" title="2.4 MySQL"></a>2.4 MySQL</h3><h4 id="2-4-1-索引"><a href="#2-4-1-索引" class="headerlink" title="2.4.1 索引"></a>2.4.1 索引</h4><ol>
<li><p>B+ Tree 原理</p>
<ol>
<li><p>数据结构</p>
<blockquote>
<p>B Tree 指的是 Balance Tree，也就是平衡树</p>
<p>平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1</p>
</blockquote>
</li>
<li><p>操作</p>
<ul>
<li>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找</li>
<li>直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data</li>
<li>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</li>
</ul>
</li>
<li><p>与红黑树的比较</p>
<blockquote>
<p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能</p>
</blockquote>
<ul>
<li><p>B+ 树有更低的树高</p>
<blockquote>
<p>平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度</p>
<p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多</p>
</blockquote>
</li>
<li><p>磁盘访问原理</p>
<blockquote>
<p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据</p>
<p>数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p>
<p>如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间</p>
<p>B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p>
</blockquote>
</li>
<li><p>磁盘预读特性</p>
<blockquote>
<p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读</p>
<p>预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快</p>
<p>并且可以利用预读特性，相邻的节点也能够被预先载入</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li><p>MySQL 索引</p>
<blockquote>
<p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现</p>
</blockquote>
<ul>
<li><p>B+Tree 索引</p>
<blockquote>
<p>大多数 MySQL 存储引擎的默认索引类型</p>
<p>不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多</p>
<p>除了用于查找，还可以用于排序和分组，可以指定多个列作为索引列，多个索引列共同组成键</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找，如果不是按照索引列的顺序进行查找，则无法使用索引</p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引</p>
<p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引，因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引</p>
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找</p>
</blockquote>
</li>
<li><p>哈希索引</p>
<blockquote>
<p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性</p>
<p>无法用于排序与分组，只支持精确查找，无法用于部分查找和范围查找</p>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找</p>
</blockquote>
</li>
<li><p>全文索引</p>
<blockquote>
<p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等<br>查找条件使用 MATCH AGAINST，而不是普通的 WHERE<br>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射<br>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引</p>
</blockquote>
</li>
<li><p>空间数据索引</p>
<blockquote>
<p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储</p>
<p>空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询<br>必须使用 GIS 相关的函数来维护数据</p>
</blockquote>
</li>
</ul>
</li>
<li><p>索引优化</p>
<ol>
<li><p>独立的列</p>
<blockquote>
<p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 例如下面的查询不能使用 actor_id 列的索引</span>
<span class="token keyword">SELECT</span> actor_id <span class="token keyword">FROM</span> sakila<span class="token punctuation">.</span>actor <span class="token keyword">WHERE</span> actor_id <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>多列索引</p>
<blockquote>
<p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引</span>
<span class="token keyword">SELECT</span> film_id<span class="token punctuation">,</span> actor_ id <span class="token keyword">FROM</span> sakila<span class="token punctuation">.</span>film_actor
<span class="token keyword">WHERE</span> actor_id <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">AND</span> film_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>索引列的顺序</p>
<blockquote>
<p>让选择性最强的索引列放在前面</p>
<p>索引的选择性是指：不重复的索引值和记录总数的比值</p>
<p>最大值为 1，此时每个记录都有唯一的索引与其对应</p>
<p>选择性越高，每个记录的区分度越高，查询效率也越高</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面</span>
<span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> staff_id<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> staff_id_selectivity<span class="token punctuation">,</span>
<span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> customer_id<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> customer_id_selectivity<span class="token punctuation">,</span>
<span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
<span class="token keyword">FROM</span> payment<span class="token punctuation">;</span>

   staff_id_selectivity: <span class="token number">0.0001</span>
customer_id_selectivity: <span class="token number">0.0373</span>
               <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>: <span class="token number">16049</span></code></pre>
</li>
<li><p>前缀索引</p>
<blockquote>
<p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符</p>
<p>前缀长度的选取需要根据索引选择性来确定</p>
</blockquote>
</li>
<li><p>覆盖索引</p>
<blockquote>
<p>索引包含所有需要查询的字段的值</p>
</blockquote>
<p>优势</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引</li>
</ul>
</li>
</ol>
</li>
<li><p>索引的优点</p>
<ul>
<li>大大减少了服务器需要扫描的数据行数</li>
<li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）</li>
<li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）</li>
</ul>
</li>
<li><p>索引的使用条件</p>
<ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效</li>
<li>对于中到大型的表，索引就非常有效</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术</li>
</ul>
</li>
</ol>
<h4 id="2-4-2-查询性能优化"><a href="#2-4-2-查询性能优化" class="headerlink" title="2.4.2 查询性能优化"></a>2.4.2 查询性能优化</h4><ol>
<li><p>使用 Explain 进行分析</p>
<blockquote>
<p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句</p>
</blockquote>
<p>重要字段</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
</li>
<li><p>优化数据访问</p>
<ol>
<li><p>减少请求的数据量</p>
<ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
</li>
<li><p>减少服务器扫描的行数</p>
<blockquote>
<p>最有效的方式是使用索引来覆盖查询</p>
</blockquote>
</li>
</ol>
</li>
<li><p>重构查询方式</p>
<ol>
<li><p>切分大于查询</p>
<blockquote>
<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> messages <span class="token keyword">WHERE</span> <span class="token keyword">create</span> <span class="token operator">&lt;</span> DATE_SUB<span class="token punctuation">(</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> INTERVAL <span class="token number">3</span> MONTH<span class="token punctuation">)</span><span class="token punctuation">;</span>

rows_affected <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">do</span> {
    rows_affected <span class="token operator">=</span> do_query<span class="token punctuation">(</span>
    <span class="token string">"DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"</span><span class="token punctuation">)</span>
} <span class="token keyword">while</span> rows_affected <span class="token operator">></span> <span class="token number">0</span></code></pre>
</li>
<li><p>分解大于连接查询</p>
<blockquote>
<p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联</p>
</blockquote>
<p>优势</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询</li>
<li>减少锁竞争</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效</li>
</ul>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tag
<span class="token keyword">JOIN</span> tag_post <span class="token keyword">ON</span> tag_post<span class="token punctuation">.</span>tag_id<span class="token operator">=</span>tag<span class="token punctuation">.</span>id
<span class="token keyword">JOIN</span> post <span class="token keyword">ON</span> tag_post<span class="token punctuation">.</span>post_id<span class="token operator">=</span>post<span class="token punctuation">.</span>id
<span class="token keyword">WHERE</span> tag<span class="token punctuation">.</span>tag<span class="token operator">=</span><span class="token string">'mysql'</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tag <span class="token keyword">WHERE</span> tag<span class="token operator">=</span><span class="token string">'mysql'</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tag_post <span class="token keyword">WHERE</span> tag_id<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> post <span class="token keyword">WHERE</span> post<span class="token punctuation">.</span>id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span><span class="token number">456</span><span class="token punctuation">,</span><span class="token number">567</span><span class="token punctuation">,</span><span class="token number">9098</span><span class="token punctuation">,</span><span class="token number">8904</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="2-4-3-存储引擎"><a href="#2-4-3-存储引擎" class="headerlink" title="2.4.3 存储引擎"></a>2.4.3 存储引擎</h4><ol>
<li><p>InnoDB</p>
<blockquote>
<p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
</blockquote>
</li>
<li><p>MyISAM</p>
<blockquote>
<p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等</p>
<p>不支持事务</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的</p>
<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘</p>
<p>这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作</p>
</blockquote>
</li>
<li><p>比较</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>事务</td>
<td>InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句</td>
</tr>
<tr>
<td>并发</td>
<td>MyISAM 只支持表级锁，而 InnoDB 还支持行级锁</td>
</tr>
<tr>
<td>外键</td>
<td>InnoDB 支持外键</td>
</tr>
<tr>
<td>备份</td>
<td>InnoDB 支持在线热备份</td>
</tr>
<tr>
<td>崩溃恢复</td>
<td>MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢</td>
</tr>
<tr>
<td>其他</td>
<td>MyISAM 支持压缩表和空间数据索引</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="2-4-5-数据类型"><a href="#2-4-5-数据类型" class="headerlink" title="2.4.5 数据类型"></a>2.4.5 数据类型</h4><ol>
<li><p>整型</p>
<blockquote>
<p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p>
<p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
</blockquote>
</li>
<li><p>浮点数</p>
<blockquote>
<p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价</p>
<p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分</p>
</blockquote>
</li>
<li><p>字符串</p>
<blockquote>
<p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的</p>
<p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内</p>
<p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格</p>
</blockquote>
</li>
<li><p>时间和日期</p>
<blockquote>
<p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP</p>
</blockquote>
<ol>
<li><p>DATETIME</p>
<blockquote>
<p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间</p>
<p>它与时区无关</p>
</blockquote>
</li>
<li><p>TIMESTAMP</p>
<blockquote>
<p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的</p>
<p>尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h4 id="2-4-5-切分"><a href="#2-4-5-切分" class="headerlink" title="2.4.5 切分"></a>2.4.5 切分</h4><ol>
<li><p>水平切分</p>
<blockquote>
<p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中</p>
<p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力</p>
</blockquote>
</li>
<li><p>垂直切分</p>
<blockquote>
<p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等</p>
</blockquote>
</li>
<li><p>Sharding 策略</p>
<ul>
<li>哈希取模：hash(key) % N</li>
<li>范围：可以是 ID 范围也可以是时间范围</li>
<li>映射表：使用单独的一个数据库来存储映射关系</li>
</ul>
</li>
<li><p>Sharding 存在的问题</p>
<ul>
<li><p>事务问题</p>
<blockquote>
<p>使用分布式事务来解决，比如 XA 接口</p>
</blockquote>
</li>
<li><p>连接</p>
<blockquote>
<p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接</p>
</blockquote>
</li>
<li><p>ID唯一性</p>
<ul>
<li>使用全局唯一 ID（GUID）</li>
<li>为每个分片指定一个 ID 范围</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-4-6-复制"><a href="#2-4-6-复制" class="headerlink" title="2.4.6 复制"></a>2.4.6 复制</h4><ol>
<li><p>主从复制</p>
<blockquote>
<p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程</p>
</blockquote>
<ul>
<li>解释<ul>
<li>binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中</li>
<li>I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）</li>
<li>SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）</li>
</ul>
</li>
</ul>
</li>
<li><p>读写分离</p>
<blockquote>
<p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作</p>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器</p>
</blockquote>
<p>原因</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销</li>
<li>增加冗余，提高可用性</li>
</ul>
</li>
</ol>
<h3 id="2-5-Redis"><a href="#2-5-Redis" class="headerlink" title="2.5 Redis"></a>2.5 Redis</h3><h4 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1 概述"></a>2.5.1 概述</h4><blockquote>
<p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射</p>
<p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合</p>
<p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能</p>
</blockquote>
<h4 id="2-5-2-数据类型"><a href="#2-5-2-数据类型" class="headerlink" title="2.5.2 数据类型"></a>2.5.2 数据类型</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作<br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素 <br> 对单个或者多个元素进行修剪，<br> 只保留一个范围内的元素</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对<br> 获取所有键值对<br> 检查某个键是否存在</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素<br> 根据分值范围或者成员来获取元素<br> 计算一个键的排名</td>
</tr>
</tbody></table>
<ol>
<li><p>STRING</p>
<pre class=" language-sql"><code class="language-sql"><span class="token operator">></span> <span class="token keyword">set</span> hello world
OK
<span class="token operator">></span> get hello
<span class="token string">"world"</span>
<span class="token operator">></span> del hello
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token operator">></span> get hello
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span></code></pre>
</li>
<li><p>LIST</p>
<pre class=" language-sql"><code class="language-sql"><span class="token operator">></span> rpush list<span class="token operator">-</span><span class="token keyword">key</span> item
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token operator">></span> rpush list<span class="token operator">-</span><span class="token keyword">key</span> item2
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">2</span>
<span class="token operator">></span> rpush list<span class="token operator">-</span><span class="token keyword">key</span> item
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">3</span>

<span class="token operator">></span> lrange list<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token number">1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"item"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"item2"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"item"</span>

<span class="token operator">></span> lindex list<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">1</span>
<span class="token string">"item2"</span>

<span class="token operator">></span> lpop list<span class="token operator">-</span><span class="token keyword">key</span>
<span class="token string">"item"</span>

<span class="token operator">></span> lrange list<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token number">1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"item2"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"item"</span></code></pre>
</li>
<li><p>SET</p>
<pre class=" language-sql"><code class="language-sql"><span class="token operator">></span> sadd <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token operator">></span> sadd <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item2
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token operator">></span> sadd <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item3
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token operator">></span> sadd <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">0</span>

<span class="token operator">></span> smembers <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"item"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"item2"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"item3"</span>

<span class="token operator">></span> sismember <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item4
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token operator">></span> sismember <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>

<span class="token operator">></span> srem <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item2
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token operator">></span> srem <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item2
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">0</span>

<span class="token operator">></span> smembers <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"item"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"item3"</span></code></pre>
</li>
<li><p>HASH</p>
<pre class=" language-sql"><code class="language-sql"><span class="token operator">></span> hset <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span> sub<span class="token operator">-</span>key1 value1
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token operator">></span> hset <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span> sub<span class="token operator">-</span>key2 value2
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token operator">></span> hset <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span> sub<span class="token operator">-</span>key1 value1
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">0</span>

<span class="token operator">></span> hgetall <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"sub-key1"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"value1"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"sub-key2"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"value2"</span>

<span class="token operator">></span> hdel <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span> sub<span class="token operator">-</span>key2
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token operator">></span> hdel <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span> sub<span class="token operator">-</span>key2
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">0</span>

<span class="token operator">></span> hget <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span> sub<span class="token operator">-</span>key1
<span class="token string">"value1"</span>

<span class="token operator">></span> hgetall <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"sub-key1"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"value1"</span></code></pre>
</li>
<li><p>ZSET</p>
<pre class=" language-sql"><code class="language-sql"><span class="token operator">></span> zadd zset<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">728</span> member1
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token operator">></span> zadd zset<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">982</span> member0
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token operator">></span> zadd zset<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">982</span> member0
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">0</span>

<span class="token operator">></span> zrange zset<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token number">1</span> withscores
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"member1"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"728"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"member0"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"982"</span>

<span class="token operator">></span> zrangebyscore zset<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">0</span> <span class="token number">800</span> withscores
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"member1"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"728"</span>

<span class="token operator">></span> zrem zset<span class="token operator">-</span><span class="token keyword">key</span> member1
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token operator">></span> zrem zset<span class="token operator">-</span><span class="token keyword">key</span> member1
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">0</span>

<span class="token operator">></span> zrange zset<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token number">1</span> withscores
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"member0"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"982"</span></code></pre>
</li>
</ol>
<h4 id="2-5-3-数据结构"><a href="#2-5-3-数据结构" class="headerlink" title="2.5.3 数据结构"></a>2.5.3 数据结构</h4><ol>
<li><p>字典</p>
<blockquote>
<p>dictht 是一个散列表结构，使用拉链法解决哈希冲突</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */</span>
typedef struct dictht {
    dictEntry <span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">table</span><span class="token punctuation">;</span>
    unsigned long size<span class="token punctuation">;</span>
    unsigned long sizemask<span class="token punctuation">;</span>
    unsigned long used<span class="token punctuation">;</span>
} dictht<span class="token punctuation">;</span>

typedef struct dictEntry {
    void <span class="token operator">*</span><span class="token keyword">key</span><span class="token punctuation">;</span>
    <span class="token keyword">union</span> {
        void <span class="token operator">*</span>val<span class="token punctuation">;</span>
        uint64_t u64<span class="token punctuation">;</span>
        int64_t s64<span class="token punctuation">;</span>
        <span class="token keyword">double</span> <span class="token number">d</span><span class="token punctuation">;</span>
    } v<span class="token punctuation">;</span>
    struct dictEntry <span class="token operator">*</span><span class="token keyword">next</span><span class="token punctuation">;</span>
} dictEntry<span class="token punctuation">;</span></code></pre>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</span>
typedef struct dict {
    dictType <span class="token operator">*</span><span class="token keyword">type</span><span class="token punctuation">;</span>
    void <span class="token operator">*</span>privdata<span class="token punctuation">;</span>
    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    long rehashidx<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* rehashing not in progress if rehashidx == -1 */</span>
    unsigned long iterators<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* number of iterators currently running */</span>
} dict<span class="token punctuation">;</span></code></pre>
<p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</p>
<p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p>
<p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</p>
<p>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* Performs N steps of incremental rehashing. Returns 1 if there are still
 * keys to move from the old to the new hash table, otherwise 0 is returned.
 *
 * Note that a rehashing step consists in moving a bucket (that may have more
 * than one key as we use chaining) from the old to the new hash table, however
 * since part of the hash table may be composed of empty spaces, it is not
 * guaranteed that this function will rehash even a single bucket, since it
 * will visit at max N*10 empty buckets in total, otherwise the amount of
 * work it does would be unbound and the function may block for a long time. */</span>
<span class="token keyword">int</span> dictRehash<span class="token punctuation">(</span>dict <span class="token operator">*</span><span class="token number">d</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> {
    <span class="token keyword">int</span> empty_visits <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Max number of empty buckets to visit. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dictIsRehashing<span class="token punctuation">(</span><span class="token number">d</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token comment" spellcheck="true">-- &amp;&amp; d->ht[0].used != 0) {</span>
        dictEntry <span class="token operator">*</span><span class="token number">de</span><span class="token punctuation">,</span> <span class="token operator">*</span>nextde<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */</span>
        assert<span class="token punctuation">(</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">></span> <span class="token punctuation">(</span>unsigned long<span class="token punctuation">)</span> <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>rehashidx<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">table</span><span class="token punctuation">[</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>rehashidx<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">=</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span> {
            <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>rehashidx<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment" spellcheck="true">--empty_visits == 0) return 1;</span>
        }
        <span class="token number">de</span> <span class="token operator">=</span> <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">table</span><span class="token punctuation">[</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>rehashidx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/* Move all the keys in this bucket from the old to the new hash HT */</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">de</span><span class="token punctuation">)</span> {
            uint64_t h<span class="token punctuation">;</span>

            nextde <span class="token operator">=</span> <span class="token number">de</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">next</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">/* Get the index in the new hash table */</span>
            h <span class="token operator">=</span> dictHashKey<span class="token punctuation">(</span><span class="token number">d</span><span class="token punctuation">,</span> <span class="token number">de</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">key</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sizemask<span class="token punctuation">;</span>
            <span class="token number">de</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">next</span> <span class="token operator">=</span> <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">table</span><span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">table</span><span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">de</span><span class="token punctuation">;</span>
            <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used<span class="token comment" spellcheck="true">--;</span>
            <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>
            <span class="token number">de</span> <span class="token operator">=</span> nextde<span class="token punctuation">;</span>
        }
        <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">table</span><span class="token punctuation">[</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>rehashidx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>
        <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>rehashidx<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>
    }

    <span class="token comment" spellcheck="true">/* Check if we already rehashed the whole table... */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">=</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> {
        zfree<span class="token punctuation">(</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">table</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        _dictReset<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>rehashidx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    }

    <span class="token comment" spellcheck="true">/* More to rehash... */</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
}</code></pre>
</li>
<li><p>跳跃表</p>
<blockquote>
<p>是有序集合的底层实现之一。</p>
<p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。</p>
<p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。</p>
</blockquote>
<p>优势</p>
<ul>
<li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li>
<li>更容易实现；</li>
<li>支持无锁操作。</li>
</ul>
</li>
</ol>
<h4 id="2-5-4-使用场景"><a href="#2-5-4-使用场景" class="headerlink" title="2.5.4 使用场景"></a>2.5.4 使用场景</h4><ol>
<li><p>计数器</p>
<blockquote>
<p>可以对 String 进行自增自减运算，从而实现计数器功能。</p>
<p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
</blockquote>
</li>
<li><p>缓存</p>
<blockquote>
<p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率</p>
</blockquote>
</li>
<li><p>查找表</p>
<blockquote>
<p>例如 DNS 记录就很适合使用 Redis 进行存储</p>
<p>查找表和缓存类似，也是利用了 Redis 快速的查找特性</p>
<p>但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
</blockquote>
</li>
<li><p>消息队列</p>
<blockquote>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p>
<p>不过最好使用 Kafka、RabbitMQ 等消息中间件</p>
</blockquote>
</li>
<li><p>会话缓存</p>
<blockquote>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息</p>
<p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性</p>
</blockquote>
</li>
<li><p>分布式锁实现</p>
<blockquote>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步</p>
<p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现</p>
</blockquote>
</li>
<li><p>其它</p>
<blockquote>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能</p>
<p>ZSet 可以实现有序性操作，从而实现排行榜等功能</p>
</blockquote>
</li>
</ol>
<h4 id="2-5-5-Redis-与-Memcached"><a href="#2-5-5-Redis-与-Memcached" class="headerlink" title="2.5.5 Redis 与 Memcached"></a>2.5.5 Redis 与 Memcached</h4><ol>
<li><p>都是非关系型内存键值数据库</p>
</li>
<li><p>数据类型</p>
<blockquote>
<p>Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题</p>
</blockquote>
</li>
<li><p>数据持久化</p>
<blockquote>
<p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化</p>
</blockquote>
</li>
<li><p>分布式</p>
<blockquote>
<p>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点</p>
<p>Redis Cluster 实现了分布式的支持</p>
</blockquote>
</li>
<li><p>内存管理机制</p>
<ul>
<li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中</li>
<li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了</li>
</ul>
</li>
</ol>
<h4 id="2-5-6-键的过期时间"><a href="#2-5-6-键的过期时间" class="headerlink" title="2.5.6 键的过期时间"></a>2.5.6 键的过期时间</h4><blockquote>
<p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键</p>
<p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间</p>
</blockquote>
<h4 id="2-5-7-数据淘汰策略"><a href="#2-5-7-数据淘汰策略" class="headerlink" title="2.5.7 数据淘汰策略"></a>2.5.7 数据淘汰策略</h4><blockquote>
<p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略</p>
</blockquote>
<ul>
<li><p>6 种淘汰策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>volatile-lru</td>
<td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td>volatile-random</td>
<td>从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td>noeviction</td>
<td>禁止驱逐数据</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key</p>
<p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰</p>
<p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰</p>
</blockquote>
<h4 id="2-5-8-持久化"><a href="#2-5-8-持久化" class="headerlink" title="2.5.8 持久化"></a>2.5.8 持久化</h4><ol>
<li><p>概述</p>
<blockquote>
<p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上</p>
</blockquote>
</li>
<li><p>RDB 持久化</p>
<ul>
<li>将某个时间点的所有数据都存放到硬盘上</li>
<li>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本</li>
<li>如果系统发生故障，将会丢失最后一次创建快照之后的数据</li>
<li>如果数据量很大，保存快照的时间会很长。</li>
</ul>
</li>
<li><p>AOF 持久化</p>
<blockquote>
<p>将写命令添加到 AOF 文件（Append Only File）的末尾</p>
<p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘</p>
</blockquote>
<ul>
<li><p>同步选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>同步频率</th>
</tr>
</thead>
<tbody><tr>
<td>always</td>
<td>每个写命令都同步</td>
</tr>
<tr>
<td>everysec</td>
<td>每秒同步一次</td>
</tr>
<tr>
<td>no</td>
<td>让操作系统来决定何时同步</td>
</tr>
</tbody></table>
</li>
<li><p>解释</p>
<ul>
<li>always 选项会严重减低服务器的性能</li>
<li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响</li>
<li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-5-9-事务"><a href="#2-5-9-事务" class="headerlink" title="2.5.9 事务"></a>2.5.9 事务</h4><blockquote>
<p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求</p>
<p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能</p>
<p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来</p>
</blockquote>
<h4 id="2-5-10-事件"><a href="#2-5-10-事件" class="headerlink" title="2.5.10 事件"></a>2.5.10 事件</h4><ol>
<li><p>概述</p>
<blockquote>
<p>Redis 服务器是一个事件驱动程序</p>
</blockquote>
</li>
<li><p>文件事件</p>
<blockquote>
<p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象</p>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器</p>
</blockquote>
</li>
<li><p>时间事件</p>
<blockquote>
<p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象</p>
<p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器</p>
</blockquote>
<ul>
<li>分类<ul>
<li>定时事件：是让一段程序在指定的时间之内执行一次</li>
<li>周期性事件：是让一段程序每隔指定时间就执行一次</li>
</ul>
</li>
</ul>
</li>
<li><p>事件的调度与执行</p>
<blockquote>
<p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定</p>
</blockquote>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 事件调度与执行由 aeProcessEvents 函数负责，伪代码如下</span>
<span class="token number">def</span> aeProcessEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>:
    <span class="token comment" spellcheck="true">-- 获取到达时间离当前时间最接近的时间事件</span>
    time_event <span class="token operator">=</span> aeSearchNearestTimer<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">-- 计算最接近的时间事件距离到达还有多少毫秒</span>
    remaind_ms <span class="token operator">=</span> time_event<span class="token punctuation">.</span><span class="token keyword">when</span> <span class="token operator">-</span> unix_ts_now<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">-- 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span>
    <span class="token keyword">if</span> remaind_ms <span class="token operator">&lt;</span> <span class="token number">0</span>:
        remaind_ms <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment" spellcheck="true">-- 根据 remaind_ms 的值，创建 timeval</span>
    timeval <span class="token operator">=</span> create_timeval_with_ms<span class="token punctuation">(</span>remaind_ms<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">-- 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span>
    aeApiPoll<span class="token punctuation">(</span>timeval<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">-- 处理所有已产生的文件事件</span>
    procesFileEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">-- 处理所有已到达的时间事件</span>
    processTimeEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">-- 将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下</span>
<span class="token number">def</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span>:
    <span class="token comment" spellcheck="true">-- 初始化服务器</span>
    init_server<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">-- 一直处理事件，直到服务器关闭为止</span>
    <span class="token keyword">while</span> server_is_not_shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span>:
        aeProcessEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">-- 服务器关闭，执行清理操作</span>
    clean_server<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
</li>
</ol>
<h4 id="2-5-11-复制"><a href="#2-5-11-复制" class="headerlink" title="2.5.11 复制"></a>2.5.11 复制</h4><ol>
<li><p>概述</p>
<blockquote>
<p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器</p>
<p>一个从服务器只能有一个主服务器，并且不支持主主复制</p>
</blockquote>
</li>
<li><p>连接过程</p>
<ol>
<li>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li>
<li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li>
<li>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li>
</ol>
</li>
<li><p>主从链</p>
<blockquote>
<p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器</p>
</blockquote>
</li>
</ol>
<h4 id="2-5-12-Sentinel"><a href="#2-5-12-Sentinel" class="headerlink" title="2.5.12 Sentinel"></a>2.5.12 Sentinel</h4><blockquote>
<p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器</p>
</blockquote>
<h4 id="2-5-13-分片"><a href="#2-5-13-分片" class="headerlink" title="2.5.13 分片"></a>2.5.13 分片</h4><blockquote>
<p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升</p>
<p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中</p>
</blockquote>
<ul>
<li>最简单的方式是范围分片，例如用户 id 从 0<del>1000 的存储到实例 R0 中，用户 id 从 1001</del>2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li>
<li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li>
</ul>
<p>三种分片方式</p>
<ul>
<li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li>
<li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li>
<li>服务器分片：Redis Cluster。</li>
</ul>
<h4 id="2-5-14-一个简单的论坛系统分析"><a href="#2-5-14-一个简单的论坛系统分析" class="headerlink" title="2.5.14 一个简单的论坛系统分析"></a>2.5.14 一个简单的论坛系统分析</h4><ol>
<li><p>基础功能</p>
<ol>
<li>可以发布文章；</li>
<li>可以对文章进行点赞；</li>
<li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示。</li>
</ol>
</li>
<li><p>文章信息</p>
<blockquote>
<p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p>
<p>Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔</p>
</blockquote>
</li>
<li><p>点赞功能</p>
<blockquote>
<p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。</p>
<p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定</p>
</blockquote>
</li>
<li><p>对文章进行排序</p>
<blockquote>
<p>为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合</p>
</blockquote>
</li>
</ol>
<h3 id="2-6-Oracle"><a href="#2-6-Oracle" class="headerlink" title="2.6 Oracle"></a>2.6 Oracle</h3><h2 id="3-系统设计"><a href="#3-系统设计" class="headerlink" title="3. 系统设计"></a>3. 系统设计</h2><h3 id="3-1-基础"><a href="#3-1-基础" class="headerlink" title="3.1 基础"></a>3.1 基础</h3><ol>
<li><p>性能</p>
<ol>
<li><p>性能指标</p>
<ol>
<li><p>响应时间</p>
<blockquote>
<p>指某个请求从发出到接 收到响应消耗的时间。<br>在对响应时间进行测试时，通常采用重复请求的方式，然后计算平均响应时间。</p>
</blockquote>
</li>
<li><p>吞吐量</p>
<blockquote>
<p> 指系统在单位时间内可以处理的请求数量，通常使用每秒的请求数来衡量。</p>
</blockquote>
</li>
<li><p>并发用户数</p>
<blockquote>
<p>指系统能同时处理的并发用 户请求数量。<br>在没有并发存在的系统中，请求被顺序执行，此时响应时间为吞吐量的倒数。例如系统支持的吞吐量为 100 req/s，那么平均响应时间应该为 0.01s。<br>使用 IO 多路复用等方式，系统在等待一个 IO 操作完成的这段时间内不需要被阻塞，可以去处理其它请求。通过将这个等待时间利用起来，使得 CPU 利用率大大提高。<br>并发用户数不是越高越好，因为如果并发用户数太高，系统来不及处理这么多的请求，会使得过多的请求需要等待，那么响应时间就会大大提高。</p>
</blockquote>
<p>目前的大型系统都支持多线程来处理并发请求，多线程能够提高吞吐量以及缩短响应时间，主要有两个原因：</p>
<ul>
<li>多 CPU</li>
<li>IO 等待时间</li>
</ul>
</li>
</ol>
</li>
<li><p>性能优化</p>
<ol>
<li><p>集群</p>
<blockquote>
<p>将多台服务器组成集群，使用负载均衡将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低。</p>
</blockquote>
</li>
<li><p>缓存<br> 缓存能够提高性能的原因如下：</p>
<ul>
<li>缓存数据通常位于内存等介质中，这种介质对于读操作特别快</li>
<li>缓存数据可以位于靠近用户的地理位置上</li>
<li>可以将计算结果进行缓存，从而避免重复计算</li>
</ul>
</li>
<li><p>异步</p>
<blockquote>
<p>某些流程可以 将操作转换为消息，将消息发送到消息队列之后立即返回，之后这个操作会被异步处理。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
<li><p>伸缩性</p>
<blockquote>
<p>指不断向集群中添加服务器来缓解不断上升的用户并发访问压力和不断增长的数据存储需求</p>
</blockquote>
<ul>
<li><p>伸缩性与性能</p>
<blockquote>
<p>如果系统存在性能问题，那么单个用户的请求总是很慢的；<br>如果系统存在伸缩性问题，那么单个用户的请求可能会很快，但是在并发数很高的情况下系统会很慢。</p>
</blockquote>
</li>
<li><p>实现伸缩性</p>
<blockquote>
<p>应用服务器只要不具有状态 ，那么就可以很容易地通过负载均衡器向集群中添加新的服务器。<br>关系型数据库的伸缩性通过 Sharding 来实现，将数据按一定的规则分布到不同的节点上，从而解决单台存储服务器的存储空间限制。<br>对于非关系型数据库，它们天生就是为海量数据而诞生，对伸缩性的支持特别好。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>扩展性</p>
<blockquote>
<p>指的是添加新功能时对现有系统的其它应用无影响，这就要求不同应用具备低耦合的特点</p>
</blockquote>
<p>扩展方式</p>
<ul>
<li>使用消息队列进行解耦，应用之间通过消息传递进行通信；</li>
<li>使用分布式服务将业务和可复用的服务分离开来，业务使用分布式服务框架调用可复用的服务。新增的产品可以通过调用可复用的服务来实现业务逻辑，对其它产品没有影响。</li>
</ul>
</li>
<li><p>可用性</p>
<ol>
<li><p>冗余</p>
<blockquote>
<p>保证高可用的 主要手段是使用冗余，当某个服务器故障时就请求其它服务器。</p>
<p>应用服务器的冗余比较容易实现，只要保证应用服务器不具有状态，那么某个应用服务器故障时，负载均衡器将该应用服务器原先的用户请求转发到另一个应用服务器上，不会对用户有任何影响。</p>
<p>存储服务器的冗余需要使用主从复制来实现，当主服务器故障时，需要提升从服务器为主服务器，这个过程称为切换。</p>
</blockquote>
</li>
<li><p>监控</p>
<blockquote>
<p>对 CPU、内存、磁盘、网络等系统负载信息进行监控，当某个信息达到一定阈值时通知运维人员，从而在系统发生故障之前及时发现问题。</p>
</blockquote>
</li>
<li><p>服务降级</p>
<blockquote>
<p>服务降级是系统为了应 对大量的请求，主动关闭部分功能，从而保证核心功能可用。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>安全性</p>
<blockquote>
<p>要求系统在应对各种攻击手段时能够有可靠的应对措施</p>
</blockquote>
</li>
</ol>
<h3 id="3-2-分布式"><a href="#3-2-分布式" class="headerlink" title="3.2 分布式"></a>3.2 分布式</h3><h4 id="3-2-1-分布式锁"><a href="#3-2-1-分布式锁" class="headerlink" title="3.2.1 分布式锁"></a>3.2.1 分布式锁</h4><ol>
<li><p>概述</p>
<blockquote>
<p>在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁</p>
</blockquote>
<ul>
<li>阻塞锁通常使用互斥量来实现<ul>
<li>互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态</li>
<li>互斥量为 1 表示未锁定状态</li>
</ul>
</li>
</ul>
</li>
<li><p>数据库的唯一索引</p>
<blockquote>
<p>获得锁时向表中插入一条记录，释放锁时删除这条记录</p>
<p>唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态</p>
</blockquote>
<p>存在问题</p>
<ul>
<li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁；</li>
<li>只能是非阻塞锁，插入失败直接就报错了，无法重试；</li>
<li>不可重入，已经获得锁的进程也必须重新获取锁</li>
</ul>
</li>
<li><p>Redis 的 SETNX 指令</p>
<blockquote>
<p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p>
<p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p>
<p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p>
</blockquote>
</li>
<li><p>Redis 的 RedLock 算法</p>
<blockquote>
<p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用</p>
</blockquote>
<ul>
<li>尝试从 N 个互相独立 Redis 实例获取锁；</li>
<li>计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；</li>
<li>如果获取锁失败，就到每个实例上释放锁。</li>
</ul>
</li>
<li><p>Zookeeper 的有序节点</p>
<ol>
<li><p>Zookeeper抽象模型</p>
<blockquote>
<p>Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1</p>
</blockquote>
</li>
<li><p>节点模型</p>
<ul>
<li>永久节点：不会因为会话结束或者超时而消失；</li>
<li>临时节点：如果会话结束或者超时就会消失；</li>
<li>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推</li>
</ul>
</li>
<li><p>监听器</p>
<blockquote>
<p>为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息</p>
</blockquote>
</li>
<li><p>分布式锁实现</p>
<ul>
<li>创建一个锁目录 /lock；</li>
<li>当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；</li>
<li>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；</li>
<li>执行业务代码，完成后，删除对应的子节点</li>
</ul>
</li>
<li><p>会话超时</p>
<blockquote>
<p>如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题</p>
</blockquote>
</li>
<li><p>羊群效应</p>
<blockquote>
<p>一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应，一只羊动起来，其它羊也会一哄而上），而我们只希望它的后一个子节点收到通知</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h4 id="3-2-2-分布式事务"><a href="#3-2-2-分布式事务" class="headerlink" title="3.2.2 分布式事务"></a>3.2.2 分布式事务</h4><ol>
<li><p>概述</p>
<blockquote>
<p>指事务的操作位于不同的节点上，需要保证事务的 ACID 特性</p>
</blockquote>
<p>分布式锁和分布式事务区别</p>
<ul>
<li>锁问题的关键在于进程操作的互斥关系，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。</li>
<li>而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。</li>
</ul>
</li>
<li><p>2PC</p>
<blockquote>
<p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务</p>
</blockquote>
<ol>
<li><p>运行过程</p>
<ol>
<li><p>准备阶段</p>
<blockquote>
<p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行</p>
</blockquote>
</li>
<li><p>提交阶段</p>
<blockquote>
<p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p>
<p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>存在问题</p>
<ol>
<li><p>同步阻塞</p>
<blockquote>
<p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作</p>
</blockquote>
</li>
<li><p>单点问题</p>
<blockquote>
<p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完成其它操作</p>
</blockquote>
</li>
<li><p>数据不一致</p>
<blockquote>
<p>在提交阶段，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致</p>
</blockquote>
</li>
<li><p>太过保守</p>
<blockquote>
<p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
<li><p>本地消息表</p>
<blockquote>
<p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性</p>
</blockquote>
<ol>
<li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li>
<li>之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li>
<li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作.</li>
</ol>
</li>
</ol>
<h4 id="3-2-3-CAP"><a href="#3-2-3-CAP" class="headerlink" title="3.2.3 CAP"></a>3.2.3 CAP</h4><ol>
<li><p>概述</p>
<blockquote>
<p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项</p>
</blockquote>
</li>
<li><p>一致性</p>
<blockquote>
<p>一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p>
</blockquote>
</li>
<li><p>可用性</p>
<blockquote>
<p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
</blockquote>
</li>
<li><p>分区容忍性</p>
<blockquote>
<p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
</blockquote>
</li>
<li><p>权衡</p>
<blockquote>
<p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难使它们同时满足</p>
</blockquote>
<p>多个节点之间进行数据同步</p>
<ul>
<li>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性</li>
<li>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致</li>
</ul>
</li>
</ol>
<h4 id="3-2-4-BASE"><a href="#3-2-4-BASE" class="headerlink" title="3.2.4 BASE"></a>3.2.4 BASE</h4><ol>
<li><p>概述</p>
<blockquote>
<p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p>
<p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
</blockquote>
</li>
<li><p>基本可用</p>
<blockquote>
<p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p>
<p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面</p>
</blockquote>
</li>
<li><p>软状态</p>
<blockquote>
<p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。</p>
</blockquote>
</li>
<li><p>最终一致性</p>
<blockquote>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p>
<p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p>
</blockquote>
</li>
</ol>
<h4 id="3-2-5-Paxos"><a href="#3-2-5-Paxos" class="headerlink" title="3.2.5 Paxos"></a>3.2.5 Paxos</h4><ol>
<li><p>基础</p>
<blockquote>
<p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值</p>
</blockquote>
<p>主要有三类节点</p>
<ul>
<li>提议者（Proposer）：提议一个值；</li>
<li>接受者（Acceptor）：对每个提议进行投票；</li>
<li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li>
</ul>
</li>
<li><p>执行过程</p>
<blockquote>
<p>规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值</p>
</blockquote>
<ol>
<li><p>Prepare 阶段</p>
<blockquote>
<p>当 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n1, v1]，并且之前还未接收过 Prepare 请求，那么发送一个 Prepare 响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议</p>
<p>如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 &gt; n2，那么就丢弃该提议请求；否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议</p>
</blockquote>
</li>
<li><p>Accept 阶段</p>
<blockquote>
<p>当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时，就可以发送 Accept 请求</p>
</blockquote>
</li>
<li><p>Learn 阶段</p>
<blockquote>
<p>Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来</p>
</blockquote>
</li>
</ol>
</li>
<li><p>约束条件</p>
<ol>
<li><p>正确性</p>
<blockquote>
<p>指只有一个提议值会生效。</p>
<p>因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。</p>
</blockquote>
</li>
<li><p>可终止性</p>
<blockquote>
<p>指最后总会有一个提议生效。</p>
<p>Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h4 id="3-2-6-Raft"><a href="#3-2-6-Raft" class="headerlink" title="3.2.6 Raft"></a>3.2.6 Raft</h4><ol>
<li><p>概述</p>
<blockquote>
<p>Raft 也是分布式一致性协议，主要是用来竞选主节点</p>
</blockquote>
</li>
<li><p>单个 Candidate 的竞选</p>
<blockquote>
<p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段</p>
</blockquote>
</li>
<li><p>多个 Candidate 竞选</p>
<blockquote>
<p>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Node B 和 Node D 都获得两票，需要重新开始投票</p>
<p>由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低</p>
</blockquote>
</li>
<li><p>数据同步</p>
<blockquote>
<p>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中</p>
<p>Leader 会把修改复制到所有 Follower</p>
<p>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交</p>
<p>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致</p>
</blockquote>
</li>
</ol>
<h3 id="3-3-集群"><a href="#3-3-集群" class="headerlink" title="3.3 集群"></a>3.3 集群</h3><h4 id="3-3-1-负载均衡"><a href="#3-3-1-负载均衡" class="headerlink" title="3.3.1 负载均衡"></a>3.3.1 负载均衡</h4><ol>
<li><p>概述</p>
<blockquote>
<p>集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点</p>
<p>负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上</p>
</blockquote>
<p>负载均衡器可以用来实现高可用以及伸缩性</p>
<ul>
<li>高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用；</li>
<li>伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点</li>
</ul>
<p>负载均衡器运行过程</p>
<ol>
<li>根据负载均衡算法得到转发的节点；</li>
<li>进行转发。</li>
</ol>
</li>
<li><p>负载均衡算法</p>
<ol>
<li><p>轮询（Round Robin）</p>
<blockquote>
<p>轮询算法把每个请求轮流发送到每个服务器上</p>
<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载</p>
</blockquote>
</li>
<li><p>加权轮询（Weighted Round Robbin）</p>
<blockquote>
<p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值</p>
</blockquote>
</li>
<li><p>最少连接（least Connections）</p>
<blockquote>
<p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡</p>
<p>最少连接算法就是将请求发送给当前最少连接数的服务器上</p>
</blockquote>
</li>
<li><p>加权最少连接（Weighted Least Connection）</p>
<blockquote>
<p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数</p>
</blockquote>
</li>
<li><p>随机算法（Random）</p>
<blockquote>
<p>把请求随机发送到服务器上。</p>
<p>和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p>
</blockquote>
</li>
<li><p>源地址哈希法 (IP Hash)</p>
<blockquote>
<p>源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。</p>
<p>可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）</p>
</blockquote>
</li>
</ol>
</li>
<li><p>转发实现</p>
<ol>
<li><p>HTTP 重定向</p>
<blockquote>
<p>HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求</p>
<p>该负载均衡转发的缺点比较明显，实际场景中很少使用它</p>
</blockquote>
<ul>
<li>缺点<ul>
<li>需要两次请求，因此访问延迟比较高；</li>
<li>HTTP 负载均衡器处理能力有限，会限制集群的规模。</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS 域名解析</p>
<blockquote>
<p>在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址</p>
<p>大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址</p>
</blockquote>
<ul>
<li><p>优点</p>
<blockquote>
<p>DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址</p>
</blockquote>
</li>
<li><p>缺点</p>
<blockquote>
<p>由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效</p>
</blockquote>
</li>
</ul>
</li>
<li><p>反向代理服务器</p>
<blockquote>
<p>反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器</p>
<p>在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址</p>
</blockquote>
<p>优点：</p>
<ul>
<li>与其它功能集成在一起，部署简单。</li>
</ul>
<p>缺点：</p>
<ul>
<li>所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。</li>
</ul>
</li>
<li><p>网络层</p>
<blockquote>
<p>在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。</p>
<p>源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现</p>
</blockquote>
<p>优点：</p>
<ul>
<li>在内核进程中进行处理，性能比较高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。</li>
</ul>
</li>
<li><p>链路层</p>
<blockquote>
<p>在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。</p>
<p>通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。</p>
<p>这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。</p>
<p>这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h4 id="3-3-2-集群下的-Session-管理"><a href="#3-3-2-集群下的-Session-管理" class="headerlink" title="3.3.2 集群下的 Session 管理"></a>3.3.2 集群下的 Session 管理</h4><ol>
<li><p>概述</p>
<blockquote>
<p>一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作</p>
</blockquote>
</li>
<li><p>Sticky Session</p>
<blockquote>
<p>需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中</p>
</blockquote>
<p>缺点：</p>
<ul>
<li>当服务器宕机时，将丢失该服务器上的所有 Session。</li>
</ul>
</li>
<li><p>Session Replication</p>
<blockquote>
<p>在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求</p>
</blockquote>
<p>缺点：</p>
<ul>
<li>占用过多内存；</li>
<li>同步过程占用网络带宽以及服务器处理器时间。</li>
</ul>
</li>
<li><p>Session Server</p>
<blockquote>
<p>使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库</p>
</blockquote>
<p>优点：</p>
<ul>
<li>为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要去实现存取 Session 的代码。</li>
</ul>
</li>
</ol>
<h3 id="3-4-缓存"><a href="#3-4-缓存" class="headerlink" title="3.4 缓存"></a>3.4 缓存</h3><ol>
<li><p>缓存特征</p>
<ol>
<li><p>命中率</p>
<blockquote>
<p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。<br>缓存命中率越高，缓存的利用率也就越高。</p>
</blockquote>
</li>
<li><p>最大空间</p>
<blockquote>
<p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。<br>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p>
</blockquote>
</li>
<li><p>淘汰策略</p>
<ul>
<li>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</li>
<li>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</li>
<li>LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。</li>
</ul>
</li>
</ol>
</li>
<li><p>缓存位置</p>
<ol>
<li><p>浏览器</p>
<blockquote>
<p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p>
</blockquote>
</li>
<li><p>ISP</p>
<blockquote>
<p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p>
</blockquote>
</li>
<li><p>反向代理</p>
<blockquote>
<p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p>
</blockquote>
</li>
<li><p>本地缓存</p>
<blockquote>
<p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p>
</blockquote>
</li>
<li><p>分布式缓存</p>
<blockquote>
<p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。<br>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p>
</blockquote>
</li>
<li><p>数据库缓存</p>
<blockquote>
<p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p>
</blockquote>
</li>
<li><p>Java 内部的缓存</p>
<blockquote>
<p>Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。</p>
</blockquote>
</li>
<li><p>CPU 多级缓存</p>
<blockquote>
<p>CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>CDN</p>
<blockquote>
<p>内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户</p>
</blockquote>
<p>优点</p>
<ul>
<li>更快地将数据分发给用户；</li>
<li>通过部署多台服务器，从而提高系统整体的带宽性能；</li>
<li>多台服务器可以看成是一种冗余机制，从而具有高可用性。</li>
</ul>
</li>
<li><p>缓存问题</p>
<ol>
<li><p>缓存穿透</p>
<blockquote>
<p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p>
</blockquote>
<p>解决方案：</p>
<ul>
<li>对这些不存在的数据缓存一个空数据；</li>
<li>对这类请求进行过滤。</li>
</ul>
</li>
<li><p>缓存雪崩</p>
<blockquote>
<p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。<br>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p>
</blockquote>
<p>解决方案：</p>
<ul>
<li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li>
<li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li>
<li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li>
</ul>
</li>
<li><p>缓存一致性</p>
<blockquote>
<p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p>
<p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p>
</blockquote>
<p>解决方案：</p>
<ul>
<li>在数据更新的同时立即去更新缓存；</li>
<li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li>
</ul>
</li>
<li><p>缓存 “无底洞” 现象</p>
<blockquote>
<p>指的是为了满足业务要求添加了大量缓存节点，但是性 能不但没有好转反而下降了的现象。<br>产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。</p>
</blockquote>
<p>解决方案：</p>
<ul>
<li>优化批量数据操作命令；</li>
<li>减少网络通信次数；</li>
<li>降低接入成本，使用长连接 / 连接池，NIO 等。</li>
</ul>
</li>
</ol>
</li>
<li><p>数据分布</p>
<ol>
<li><p>哈希分布</p>
<blockquote>
<p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p>
<p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移</p>
</blockquote>
</li>
<li><p>顺序分布</p>
<blockquote>
<p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上</p>
</blockquote>
<p>顺序分布相比于哈希分布的主要优点</p>
<ul>
<li>能保持数据原有的顺序；</li>
<li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大</li>
</ul>
</li>
</ol>
</li>
<li><p>一致性哈希</p>
<blockquote>
<p>Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题</p>
</blockquote>
<ol>
<li><p>基本原理</p>
<blockquote>
<p>将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上</p>
<p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点</p>
</blockquote>
</li>
<li><p>虚拟节点</p>
<blockquote>
<p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。</p>
<p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。</p>
<p>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀</p>
</blockquote>
</li>
</ol>
</li>
<li><p>LRU</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：</span>

<span class="token comment" spellcheck="true">// 访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。</span>
<span class="token comment" spellcheck="true">// 为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRU</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Iterable</span><span class="token operator">&lt;</span>K<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> Node head<span class="token punctuation">;</span>
    <span class="token keyword">private</span> Node tail<span class="token punctuation">;</span>
    <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> Node<span class="token operator">></span> map<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> maxSize<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>

        Node pre<span class="token punctuation">;</span>
        Node next<span class="token punctuation">;</span>
        K k<span class="token punctuation">;</span>
        V v<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>K k<span class="token punctuation">,</span> V v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>k <span class="token operator">=</span> k<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>v <span class="token operator">=</span> v<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

</code></pre>
</li>
</ol>
<pre><code>   public LRU(int maxSize) &#123;

       this.maxSize = maxSize;
       this.map = new HashMap&lt;&gt;(maxSize * 4 / 3);

       head = new Node(null, null);
       tail = new Node(null, null);

       head.next = tail;
       tail.pre = head;
   &#125;


   public V get(K key) &#123;

       if (!map.containsKey(key)) &#123;
           return null;
       &#125;

       Node node = map.get(key);
       unlink(node);
       appendHead(node);

       return node.v;
   &#125;


   public void put(K key, V value) &#123;

       if (map.containsKey(key)) &#123;
           Node node = map.get(key);
           unlink(node);
       &#125;

       Node node = new Node(key, value);
       map.put(key, node);
       appendHead(node);

       if (map.size() &gt; maxSize) &#123;
           Node toRemove = removeTail();
           map.remove(toRemove.k);
       &#125;
   &#125;


   private void unlink(Node node) &#123;

       Node pre = node.pre;
       Node next = node.next;

       pre.next = next;
       next.pre = pre;

       node.pre = null;
       node.next = null;
   &#125;


   private void appendHead(Node node) &#123;
       Node next = head.next;
       node.next = next;
       next.pre = node;
       node.pre = head;
       head.next = node;
   &#125;


   private Node removeTail() &#123;

       Node node = tail.pre;

       Node pre = node.pre;
       tail.pre = pre;
       pre.next = tail;

       node.pre = null;
       node.next = null;

       return node;
   &#125;


   @Override
   public Iterator&lt;K&gt; iterator() &#123;

       return new Iterator&lt;K&gt;() &#123;
           private Node cur = head.next;

           @Override
           public boolean hasNext() &#123;
               return cur != tail;
           &#125;

           @Override
           public K next() &#123;
               Node node = cur;
               cur = cur.next;
               return node.k;
           &#125;
       &#125;;
   &#125;</code></pre>
<p>   }</p>
<pre><code>
### 3.5 消息队列

#### 3.5.1 消息模型

1. 点对点

&gt; 消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次

2. 发布/订阅

&gt; 消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费

3. 发布与订阅模式和观察者模式有以下不同

* 观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信
* 观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回

#### 3.5.2 使用场景

1. 异步处理

&gt; 发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理

2. 流量削锋

&gt; 在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。
&gt;
&gt; 可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。

3. 应用解耦

&gt; 如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。
&gt;
&gt; 通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用

#### 3.5.3 可靠性

1. 发送端的可靠性

&gt; 发送端完成操作后一定能将消息成功发送到消息队列中。
&gt;
&gt; 实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传

2. 接收端的可靠性

&gt; 接收端能够从消息队列成功消费一次消息

实现方式

* 保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。
* 保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。

### 3.6 攻击防御

1. 跨站脚本攻击

&gt; 跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript

危害

* 窃取用户的 Cookie
* 伪造虚假的输入表单骗取个人信息
* 显示伪造的文章或者图片

防御

* 设置 Cookie 为 HttpOnly

  &gt; 设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息

* 过滤特殊字符

  &gt; 例如将 `&lt;` 转义为 `&amp;lt;`，将 `&gt;` 转义为 `&amp;gt;`，从而避免 HTML 和 Jascript 代码的运行。
  &gt;
  &gt; 富文本编辑器允许用户输入 HTML 代码，就不能简单地将 `&lt;` 等字符进行过滤了，极大地提高了 XSS 攻击的可能性。
  &gt;
  &gt; 富文本编辑器通常采用 XSS filter 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。

2. 跨站请求伪造

&gt; 跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。
&gt;
&gt; XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任
&gt;
&gt; 攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作

防御

* 检查 Referer 首部字段

  &gt; Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。
  &gt;
  &gt; 这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能

* 添加校验 Token

  &gt; 在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数

* 输入验证码

  &gt; 因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作

3. SQL 注入攻击

&gt; 服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成

防御

* 使用参数化查询

  &gt; Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生

* 单引号转换

  &gt; 将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能

4. 拒绝服务攻击

&gt; 拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问
&gt;
&gt; 分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击

## 4. 工具

### 4.1 Git

1. 集中式与分布式

&gt; Git 属于分布式版本控制系统，而 SVN 属于集中式
&gt;
&gt; 集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑上就有一份完整的代码
&gt;
&gt; 集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了
&gt;
&gt; 集中式版本控制需要连网才能工作，如果网速过慢，那么提交一个文件会慢的无法让人忍受。而分布式版本控制不需要连网就能工作
&gt;
&gt; 分布式版本控制新建分支、合并分支操作速度非常快，而集中式版本控制新建一个分支相当于复制一份完整代码

2. 中心服务器

&gt; 中心服务器用来交换每个用户的修改，没有中心服务器也能工作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改
&gt;
&gt; Github 就是一个中心服务器

3. 工作流

&gt; 新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库
&gt;
&gt; Git 的版本库有一个称为 Stage 的暂存区以及最后的 History 版本库，History 存储所有分支信息，使用一个 HEAD 指针指向当前分支

操作

* git add files 把文件的修改添加到暂存区
* git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了
* git reset -- files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files
* git checkout -- files 使用暂存区的修改覆盖工作目录，用来撤销本地修改

可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中

* git commit -a 直接把所有文件的修改添加到暂存区然后执行提交
* git checkout HEAD -- files 取出最后一次修改，可以用来进行回滚操作

4. 分支实现

&gt; 使用指针将每个提交连接成一条时间线，HEAD 指针指向当前分支指针
&gt;
&gt; 新建分支是新建一个指针指向时间线的最后一个节点，并让 HEAD 指针指向新分支，表示新分支成为当前分支
&gt;
&gt; 每次提交只会让当前分支指针向前移动，而其它分支指针不会移动
&gt;
&gt; 合并分支也只需要改变指针即可

5. 冲突

&gt; 当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突
&gt;
&gt; Git 会使用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ，\=\=\===== ，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突

```shell
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Creating a new branch is quick &amp; simple.
=======
Creating a new branch is quick AND simple.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</code></pre>
<ol start="6">
<li><p>Fast forward</p>
<blockquote>
<p>“快进式合并”（fast-farward merge），会直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息</p>
<p>可以在合并时加上 –no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">$ git merge --no-ff -m "merge with no-ff" dev</code></pre>
</li>
<li><p>储藏（Stashing）</p>
<blockquote>
<p>在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也能看到新的修改。这是因为所有分支都共用一个工作区的缘故</p>
<p>可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的所有修改都会被存到栈中，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">$ git stash
Saved working directory and index state \ "WIP on master: 049d078 added the index file"
HEAD is now at 049d078 added the index file (To restore them type "git stash apply")</code></pre>
<blockquote>
<p>该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master 上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分支并切换到 bug 分支之前就需要使用 git stash 将 dev 分支的未提交修改储藏起来</p>
</blockquote>
</li>
<li><p>SSH 传输设置</p>
<blockquote>
<p>Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密</p>
<p>如果工作区下没有 .ssh 目录，或者该目录下没有 id_rsa 和 id_rsa.pub 这两个文件，可以通过以下命令来创建 SSH Key</p>
<p>然后把公钥 id_rsa.pub 的内容复制到 Github “Account settings” 的 SSH Keys 中</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">$ ssh-keygen -t rsa -C "youremail@example.com"</code></pre>
</li>
<li><p>.gitignore 文件</p>
<ul>
<li>操作系统自动生成的文件，比如缩略图；</li>
<li>编译生成的中间文件，比如 Java 编译产生的 .class 文件；</li>
<li>自己的敏感信息，比如存放口令的配置文件。</li>
</ul>
</li>
<li><p>Git 命令一览</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://camo.githubusercontent.com/c91a2b2afab81bacf79151369d88d29d6c71ee65641fcc452e51d8ad95af906e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37613239616363652d663234332d343931342d396630302d6632393838633532383431322e6a7067" alt="img"></p>
</li>
</ol>
<h3 id="4-2-Docker"><a href="#4-2-Docker" class="headerlink" title="4.2 Docker"></a>4.2 Docker</h3><ol>
<li><p>解决的问题</p>
<blockquote>
<p>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。</p>
<p>Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。</p>
</blockquote>
</li>
<li><p>与虚拟机的比较</p>
<blockquote>
<p>虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现</p>
</blockquote>
<p>启动速度</p>
<ul>
<li>启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢；</li>
<li>而启动 Docker 相当于启动宿主操作系统上的一个进程。</li>
</ul>
<p>占用资源</p>
<ul>
<li>虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU 资源，一台机器只能开启几十个的虚拟机。</li>
<li>而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。</li>
</ul>
</li>
<li><p>优势</p>
<blockquote>
<p>启动速度快以及占用资源少之外</p>
</blockquote>
<ul>
<li><p>更容易迁移</p>
<blockquote>
<p>提供一致性的运行环境。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行</p>
</blockquote>
</li>
<li><p>更容易维护</p>
<blockquote>
<p>使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易</p>
</blockquote>
</li>
<li><p>更容易扩展</p>
<blockquote>
<p>可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li><p>持续集成</p>
<blockquote>
<p>持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。<br>Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。</p>
</blockquote>
</li>
<li><p>提供可伸缩的云服务</p>
<blockquote>
<p>根据应用的负载情况，可以很容易地增加或者减少 Docker。</p>
</blockquote>
</li>
<li><p>搭建微服务架构</p>
<blockquote>
<p>Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>镜像与容器</p>
<blockquote>
<p>镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。</p>
<p>镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。</p>
<p>构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。</p>
</blockquote>
</li>
</ol>
<h3 id="4-3-构建工具"><a href="#4-3-构建工具" class="headerlink" title="4.3 构建工具"></a>4.3 构建工具</h3><ol>
<li><p>构建工具的作用</p>
<blockquote>
<p>构建一个项目通常包含了依赖管理、测试、编译、打包、发布等流程，构建工具可以自动化进行这些操作，从而为我们减少这些繁琐的工作。</p>
<p>其中构建工具提供的依赖管理能够可以自动处理依赖关系。例如一个项目需要用到依赖 A，A 又依赖于 B，那么构建工具就能帮我们导入 B，而不需要我们手动去寻找并导入。</p>
<p>在 Java 项目中，打包流程通常是将项目打包成 Jar 包。在没有构建工具的情况下，我们需要使用命令行工具或者 IDE 手动打包。而发布流程通常是将 Jar 包上传到服务器上</p>
</blockquote>
</li>
<li><p>Java 主流构建工具</p>
<ul>
<li>Ant 具有编译、测试和打包功能，其后出现的 Maven 在 Ant 的功能基础上又新增了依赖管理功能，而最新的 Gradle 又在 Maven 的功能基础上新增了对 Groovy 语言的支持</li>
<li>Gradle 和 Maven 的区别是，它使用 Groovy 这种特定领域语言（DSL）来管理构建脚本，而不再使用 XML 这种标记性语言。因为项目如果庞大的话，XML 很容易就变得臃肿</li>
</ul>
</li>
<li><p>Maven</p>
<blockquote>
<p>提供了项目对象模型（POM）文件来管理项目的构建</p>
</blockquote>
<ul>
<li><p>仓库</p>
<blockquote>
<p>仓库的搜索顺序为：本地仓库、中央仓库、远程仓库</p>
</blockquote>
<ul>
<li>本地仓库用来存储项目的依赖库；</li>
<li>中央仓库是下载依赖库的默认位置；</li>
<li>远程仓库，因为并非所有的依赖库都在中央仓库，或者中央仓库访问速度很慢，远程仓库是中央仓库的补充</li>
</ul>
</li>
<li><p>POM文件</p>
<blockquote>
<p>POM 代表项目对象模型，它是一个 XML 文件，保存在项目根目录的 pom.xml 文件中</p>
<p>[groupId, artifactId, version, packaging, classifier] 称为一个项目的坐标，其中 groupId、artifactId、version 必须定义，packaging 可选（默认为 Jar），classifier 不能直接定义的，需要结合插件使用</p>
</blockquote>
<ul>
<li>说明<ul>
<li>groupId：项目组 Id，必须全球唯一；</li>
<li>artifactId：项目 Id，即项目名；</li>
<li>version：项目版本；</li>
<li>packaging：项目打包方式。</li>
</ul>
</li>
</ul>
</li>
<li><p>依赖原则</p>
<ul>
<li><p>依赖路径最短优先原则</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 由于 X(2.0) 路径最短，所以使用 X(2.0)</span>
A <span class="token operator">-</span><span class="token operator">></span> B <span class="token operator">-</span><span class="token operator">></span> C <span class="token operator">-</span><span class="token operator">></span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span>
A <span class="token operator">-</span><span class="token operator">></span> D <span class="token operator">-</span><span class="token operator">></span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span></code></pre>
</li>
<li><p>声明顺序优先原则</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 在 POM 中最先声明的优先，上面的两个依赖如果先声明 B，那么最后使用 X(1.0)</span>
A <span class="token operator">-</span><span class="token operator">></span> B <span class="token operator">-</span><span class="token operator">></span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span>
A <span class="token operator">-</span><span class="token operator">></span> C <span class="token operator">-</span><span class="token operator">></span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span></code></pre>
</li>
<li><p>覆写优先原则</p>
<blockquote>
<p>子 POM 内声明的依赖优先于父 POM 中声明的依赖</p>
</blockquote>
</li>
</ul>
</li>
<li><p>解决依赖冲突</p>
<blockquote>
<p>找到 Maven 加载的 Jar 包版本，使用 <code>mvn dependency:tree</code> 查看依赖树，根据依赖原则来调整依赖在 POM 文件的声明顺序</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="4-4-正则"><a href="#4-4-正则" class="headerlink" title="4.4 正则"></a>4.4 正则</h3><ol>
<li><p>概述</p>
<blockquote>
<p>正则表达式用于文本内容的查找和替换。</p>
<p>正则表达式内置于其它语言或者软件产品中，它本身不是一种语言或者软件</p>
</blockquote>
</li>
<li><p>匹配单个字符</p>
<blockquote>
<p><strong>.</strong> 可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；</p>
<p><strong>.</strong> 是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。</p>
<p>正则表达式一般是区分大小写的，但也有些实现不区分。</p>
</blockquote>
</li>
<li><p>匹配一组字符</p>
<blockquote>
<p><strong>[ ]</strong> 定义一个字符集合；</p>
<p>0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。</p>
<p><strong>-</strong> 只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；</p>
<p><strong>^</strong> 在 [ ] 中是取非操作。</p>
</blockquote>
<ul>
<li><p>应用</p>
<blockquote>
<p>匹配以 abc 为开头，并且最后一个字母不为数字的字符串</p>
</blockquote>
</li>
<li><p>正则</p>
<pre><code>abc[^0-9]</code></pre>
</li>
</ul>
</li>
<li><p>使用元字符</p>
<ul>
<li><p>匹配空白字符</p>
<blockquote>
<p>\r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n。</p>
<p>\r\n\r\n 可以匹配 Windows 下的空白行，因为它匹配两个连续的行尾标签，而这正是两条记录之间的空白行</p>
</blockquote>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[\b]</td>
<td>回退（删除）一个字符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
</tbody></table>
</li>
<li><p>匹配特定的字符</p>
<ul>
<li><p>数字元字符</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>数字字符，等价于 [0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>非数字字符，等价于 [^0-9]</td>
</tr>
</tbody></table>
</li>
<li><p>字母数字元字符</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\w</td>
<td>大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>对 \w 取非</td>
</tr>
</tbody></table>
</li>
<li><p>空白字符元字符</p>
<blockquote>
<p>\x 匹配十六进制字符，\0 匹配八进制，例如 \xA 对应值为 10 的 ASCII 字符 ，即 \n</p>
</blockquote>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\s</td>
<td>任何一个空白字符，等价于 [\f\n\r\t\v]</td>
</tr>
<tr>
<td>\S</td>
<td>对 \s 取非</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>重复匹配</p>
<blockquote>
<p>和 + 都是贪婪型元字符，会匹配尽可能多的内容。在后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m,n}? </p>
<p>[\w.] 匹配的是字母数字或者 . ，在其后面加上 + ，表示匹配多次。在字符集合 [ ] 里，. 不是元字符；</p>
</blockquote>
<ul>
<li><strong>+</strong> 匹配 1 个或者多个字符</li>
<li>* 匹配 0 个或者多个字符</li>
<li><strong>?</strong> 匹配 0 个或者 1 个字符</li>
</ul>
<ul>
<li><p>应用</p>
<blockquote>
<p>匹配邮箱地址</p>
</blockquote>
</li>
<li><p>正则</p>
<pre><code>[\w.]+@\w+\.\w+</code></pre>
</li>
</ul>
</li>
<li><p>位置匹配</p>
<ol>
<li><p>单词边界</p>
<blockquote>
<p><strong>\b</strong> 可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；<strong>\B</strong> 匹配一个不是单词边界的位置。</p>
<p>\b 只匹配位置，不匹配字符，因此 \babc\b 匹配出来的结果为 3 个字符。</p>
</blockquote>
</li>
<li><p>字符串边界</p>
<blockquote>
<p><strong>^</strong> 匹配整个字符串的开头，**$** 匹配结尾。</p>
<p>^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。</p>
<p>分行匹配模式（multiline）下，换行被当做字符串的边界。</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>应用</p>
<blockquote>
<p>匹配代码中以 // 开始的注释行</p>
</blockquote>
</li>
<li><p>正则</p>
<pre><code>^\s*\/\/.*$</code></pre>
</li>
</ul>
</li>
<li><p>使用子表达式</p>
<blockquote>
<p>使用 <strong>( )</strong> 定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。</p>
<p>子表达式可以嵌套，但是嵌套层次过深会变得很难理解。</p>
</blockquote>
<ul>
<li><p>应用</p>
<blockquote>
<p>匹配 IP 地址</p>
</blockquote>
</li>
<li><p>正则</p>
<pre><code>((25[0-5]|(2[0-4]\d)|(1\d&#123;2&#125;)|([1-9]\d)|(\d))\.)&#123;3&#125;(25[0-5]|(2[0-4]\d)|(1\d&#123;2&#125;)|([1-9]\d)|(\d))</code></pre>
</li>
</ul>
</li>
<li><p>回溯引用</p>
<blockquote>
<p>回溯引用使用 <strong>\n</strong> 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc</p>
</blockquote>
<ul>
<li><p>应用</p>
<blockquote>
<p>匹配 HTML 中合法的标题元素</p>
</blockquote>
</li>
<li><p>正则</p>
<pre class=" language-html"><code class="language-html">\1 将回溯引用子表达式 (h[1-6]) 匹配的内容，也就是说必须和子表达式匹配的内容一
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>(h[1-6])</span><span class="token punctuation">></span></span>\w*?&lt;\/\1></code></pre>
</li>
</ul>
</li>
<li><p>替换</p>
<blockquote>
<p>需要用到两个正则表达式</p>
</blockquote>
<ul>
<li><p>应用</p>
<blockquote>
<p>修改电话号码格式</p>
</blockquote>
</li>
<li><p>正则</p>
<pre><code>(\d&#123;3&#125;)(-)(\d&#123;3&#125;)(-)(\d&#123;4&#125;)</code></pre>
</li>
<li><p>大小写转换</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\l</td>
<td>把下个字符转换为小写</td>
</tr>
<tr>
<td>\u</td>
<td>把下个字符转换为大写</td>
</tr>
<tr>
<td>\L</td>
<td>把\L 和\E 之间的字符全部转换为小写</td>
</tr>
<tr>
<td>\U</td>
<td>把\U 和\E 之间的字符全部转换为大写</td>
</tr>
<tr>
<td>\E</td>
<td>结束\L 或者\U</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>前后查找</p>
<blockquote>
<p>前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。</p>
<p>向前查找使用 <strong>?=</strong> 定义，它规定了尾部匹配的内容，这个匹配的内容在 ?= 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 ?&lt;= 定义（注: JavaScript 不支持向后匹配，Java 对其支持也不完善）</p>
</blockquote>
<ul>
<li><p>应用</p>
<blockquote>
<p>查找出邮件地址 @ 字符前面的部分</p>
</blockquote>
</li>
<li><p>正则</p>
<pre><code>\w+(?=@)</code></pre>
</li>
</ul>
</li>
<li><p>嵌入条件</p>
<blockquote>
<p>回溯引用条件：条件为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容</p>
<p>前后查找条件：条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中</p>
</blockquote>
<ul>
<li><p>应用</p>
<blockquote>
<p>回溯引用条件：子表达式 (() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 ) 匹配，也就是匹配右括号</p>
<p>前后查找条件：?(?=-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \d{5} ，才继续匹配 -\d{4}</p>
</blockquote>
</li>
<li><p>正则</p>
<pre><code>(\()?abc(?(1)\))
\d&#123;5&#125;(?(?=-)-\d&#123;4&#125;)</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="5-网络"><a href="#5-网络" class="headerlink" title="5. 网络"></a>5. 网络</h2><h3 id="5-1-基础"><a href="#5-1-基础" class="headerlink" title="5.1 基础"></a>5.1 基础</h3><h4 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1 概述"></a>5.1.1 概述</h4><ol>
<li><p>网络的网络</p>
<blockquote>
<p>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络</p>
<p>互联网（Internet）是全球范围的互连网</p>
</blockquote>
</li>
<li><p>ISP</p>
<blockquote>
<p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网</p>
<p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP</p>
<p>互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP</p>
</blockquote>
</li>
<li><p>主机之间的通信方式</p>
<ul>
<li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方</li>
<li>对等（P2P）：不区分客户和服务器</li>
</ul>
</li>
<li><p>电路交换与分组交换</p>
<ol>
<li><p>电路交换</p>
<blockquote>
<p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%</p>
</blockquote>
</li>
<li><p>分组交换</p>
<blockquote>
<p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路</p>
<p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程</p>
</blockquote>
</li>
</ol>
</li>
<li><p>时延</p>
<ol>
<li><p>概述</p>
<ul>
<li>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</li>
</ul>
</li>
<li><p>排队时延</p>
<blockquote>
<p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量</p>
</blockquote>
</li>
<li><p>处理时延</p>
<blockquote>
<p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等</p>
</blockquote>
</li>
<li><p>传输时延</p>
<blockquote>
<p>主机或路由器传输数据帧所需要的时间</p>
<p>其中 l 表示数据帧的长度，v 表示传输速率</p>
</blockquote>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/2018/07/13/0-javabase/githubblog\source_posts\notes\传输时延.png" alt="传输时延"></p>
</li>
<li><p>传播时延</p>
<blockquote>
<p>电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速</p>
<p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速度</p>
</blockquote>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/2018/07/13/0-javabase/githubblog\source_posts\notes\传播时延.png" alt="传播时延"></p>
</li>
</ol>
</li>
<li><p>计算机网络体系结构</p>
<ol>
<li><p>五层协议</p>
<ul>
<li>应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li>
<li>传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
<li>网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li>
<li>数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li>
<li>物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>
</ul>
</li>
<li><p>OSI</p>
<blockquote>
<p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理</p>
</blockquote>
<ul>
<li>表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li>
<li>会话层 ：建立及管理会话。</li>
</ul>
</li>
<li><p>TCP/IP</p>
<blockquote>
<p>只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层</p>
<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层</p>
</blockquote>
</li>
<li><p>数据在各层之间的传递过程</p>
<blockquote>
<p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部</p>
<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h4 id="5-1-2-物理层"><a href="#5-1-2-物理层" class="headerlink" title="5.1.2 物理层"></a>5.1.2 物理层</h4><ol>
<li><p>通信方式</p>
<ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
</li>
<li><p>带通调制</p>
<blockquote>
<p>模拟信号是连续的信号，数字信号是离散的信号</p>
<p>带通调制把数字信号转换为模拟信号</p>
</blockquote>
</li>
</ol>
<h4 id="5-1-3-链路层"><a href="#5-1-3-链路层" class="headerlink" title="5.1.3 链路层"></a>5.1.3 链路层</h4><ol>
<li><p>基本问题</p>
<ol>
<li><p>封装成帧</p>
<blockquote>
<p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束</p>
</blockquote>
</li>
<li><p>透明传输</p>
<blockquote>
<p>透明表示一个实际存在的事物看起来好像不存在一样</p>
<p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在</p>
</blockquote>
</li>
<li><p>差错检测</p>
<blockquote>
<p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错</p>
</blockquote>
</li>
</ol>
</li>
<li><p>信道分类</p>
<ol>
<li><p>广播信道</p>
<blockquote>
<p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p>
<p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p>
<p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议    </p>
</blockquote>
</li>
<li><p>点对点信道</p>
<blockquote>
<p>一对一通信。</p>
<p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制</p>
</blockquote>
</li>
</ol>
</li>
<li><p>信道复用技术</p>
<ol>
<li><p>频分复用</p>
<blockquote>
<p>频分复用的所有主机在相同的时间占用不同的频率带宽资源</p>
</blockquote>
</li>
<li><p>时分复用</p>
<blockquote>
<p>时分复用的所有主机在不同的时间占用相同的频率带宽资源</p>
<p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高</p>
</blockquote>
</li>
<li><p>统计时分复用</p>
<blockquote>
<p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送</p>
</blockquote>
</li>
<li><p>波分复用</p>
<blockquote>
<p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波</p>
</blockquote>
</li>
<li><p>码分复用</p>
<blockquote>
<p>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/cb19d7914e289404e5bd587c0aaec7d424c2d324e71496250e468043272e9a08/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f5c7665637b537d"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://camo.githubusercontent.com/cb19d7914e289404e5bd587c0aaec7d424c2d324e71496250e468043272e9a08/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f5c7665637b537d" alt="img"></a> 和 <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/6bb6f35a4d875ec06aaac352bc3d40e053dad7629c060df62cfd75d0fdd5499a/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f5c7665637b547d"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://camo.githubusercontent.com/6bb6f35a4d875ec06aaac352bc3d40e053dad7629c060df62cfd75d0fdd5499a/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f5c7665637b547d" alt="img"></a> 有</p>
<p>码分复用需要发送的数据量为原先的 m 倍</p>
</blockquote>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/2018/07/13/0-javabase/githubblog\source_posts\notes\码分复用.png" alt="码分复用"></p>
</li>
</ol>
</li>
<li><p>CSMA/CD 协议</p>
<blockquote>
<p>CSMA/CD 表示载波监听多点接入 / 碰撞检测</p>
<p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 <strong>争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 <strong>截断二进制指数退避算法</strong> 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间</p>
</blockquote>
<ul>
<li>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li>
<li>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>
<li>碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li>
</ul>
</li>
<li><p>PPP 协议</p>
<blockquote>
<p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议</p>
</blockquote>
<p>PPP 的帧格式：</p>
<ul>
<li>F 字段为帧的定界符</li>
<li>A 和 C 字段暂时没有意义</li>
<li>FCS 字段是使用 CRC 的检验序列</li>
<li>信息部分的长度不超过 1500</li>
</ul>
</li>
<li><p>MAC 地址</p>
<blockquote>
<p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p>
<p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p>
</blockquote>
</li>
<li><p>局域网</p>
<blockquote>
<p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p>
<p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p>
</blockquote>
</li>
<li><p>以太网</p>
<blockquote>
<p>以太网是一种星型拓扑结构局域网。</p>
<p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p>
<p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发</p>
</blockquote>
<p>以太网帧格式：</p>
<ul>
<li>类型 ：标记上层使用的协议；</li>
<li>数据 ：长度在 46-1500 之间，如果太小则需要填充；</li>
<li>FCS ：帧检验序列，使用的是 CRC 检验方法</li>
</ul>
</li>
<li><p>交换机</p>
<blockquote>
<p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p>
<p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p>
</blockquote>
</li>
<li><p>虚拟局域网</p>
<blockquote>
<p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息</p>
<p>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p>
</blockquote>
</li>
</ol>
<h4 id="5-1-4-网络层"><a href="#5-1-4-网络层" class="headerlink" title="5.1.4 网络层"></a>5.1.4 网络层</h4><ol>
<li><p>概述</p>
<blockquote>
<p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p>
<p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络</p>
</blockquote>
<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
</li>
<li><p>IP 数据报格式</p>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>版本</td>
<td>有 4（IPv4）和 6（IPv6）两个值</td>
</tr>
<tr>
<td>首部长度</td>
<td>占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充</td>
</tr>
<tr>
<td>区分服务</td>
<td>用来获得更好的服务，一般情况下不使用</td>
</tr>
<tr>
<td>总长度</td>
<td>包括首部长度和数据部分长度</td>
</tr>
<tr>
<td>生存时间</td>
<td>TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报</td>
</tr>
<tr>
<td>协议</td>
<td>指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等</td>
</tr>
<tr>
<td>首部检验和</td>
<td>因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量</td>
</tr>
<tr>
<td>标识</td>
<td>在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符</td>
</tr>
<tr>
<td>片偏移</td>
<td>和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节</td>
</tr>
</tbody></table>
</li>
<li><p>IP 地址编址方式</p>
<ol>
<li><p>分类</p>
<blockquote>
<p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的</p>
</blockquote>
<p><code>IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 主机号 &gt;&#125;</code></p>
</li>
<li><p>子网划分</p>
<blockquote>
<p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址</p>
<p>要使用子网，必须配置子网掩码</p>
<p>一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0</p>
<p>注意，外部网络看不到子网的存在</p>
</blockquote>
<p><code>IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;&#125;</code></p>
</li>
<li><p>无分类</p>
<blockquote>
<p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化</p>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀</p>
<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> </p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个</p>
</blockquote>
<p><code>IP 地址 ::= &#123;&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;&#125;</code></p>
</li>
</ol>
</li>
<li><p>地址解析协议 ARP</p>
<blockquote>
<p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变</p>
<p>ARP 实现由 IP 地址得到 MAC 地址</p>
<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表</p>
</blockquote>
</li>
<li><p>网际控制报文协议 ICMP</p>
<ol>
<li><p>概述</p>
<blockquote>
<p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议</p>
<p>ICMP 报文分为差错报告报文和询问报文</p>
</blockquote>
</li>
<li><p>Ping</p>
<blockquote>
<p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率</p>
</blockquote>
</li>
<li><p>Traceroute</p>
<blockquote>
<p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文</p>
</blockquote>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
</li>
</ol>
</li>
<li><p>虚拟专用网 VPN</p>
<blockquote>
<p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）</p>
<p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网</p>
</blockquote>
<p>三个专用地址块：</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
</li>
<li><p>网络地址转换 NAT</p>
<blockquote>
<p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP</p>
</blockquote>
</li>
<li><p>路由器的结构</p>
<blockquote>
<p>路由器从功能上可以划分为：路由选择和分组转发。</p>
<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口</p>
</blockquote>
</li>
<li><p>路由器分组转发流程</p>
<ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错</li>
</ul>
</li>
<li><p>路由选择协议</p>
<ol>
<li><p>概述</p>
<blockquote>
<p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议</p>
</blockquote>
<p>路由选择协议的两大类：</p>
<ul>
<li>自治系统内部的路由选择：RIP 和 OSPF</li>
<li>自治系统间的路由选择：BGP</li>
</ul>
</li>
<li><p>内部网关协议 RIP</p>
<blockquote>
<p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址</p>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
</blockquote>
<p>距离向量算法：</p>
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16</li>
</ul>
</li>
<li><p>内部网关协议 OSPF</p>
<blockquote>
<p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>
<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF</p>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快</p>
</blockquote>
<p>OSPF 的下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息</li>
</ul>
</li>
<li><p>外部网关协议 BGP</p>
<blockquote>
<p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>BGP 只能寻找一条比较好的路由，而不是最佳路由</p>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息</p>
</blockquote>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="5-1-5-传输层"><a href="#5-1-5-传输层" class="headerlink" title="5.1.5 传输层"></a>5.1.5 传输层</h4><ol>
<li><p>概述</p>
<blockquote>
<p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道</p>
</blockquote>
</li>
<li><p>UDP 和 TCP 的特点</p>
<ul>
<li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）</li>
</ul>
</li>
<li><p>UDP 首部格式</p>
<blockquote>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的</p>
</blockquote>
</li>
<li><p>TCP 首部格式</p>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>序号</td>
<td>用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401</td>
</tr>
<tr>
<td>确认号</td>
<td>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701</td>
</tr>
<tr>
<td>数据偏移</td>
<td>指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度</td>
</tr>
<tr>
<td>确认 ACK</td>
<td>当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1</td>
</tr>
<tr>
<td>同步 SYN</td>
<td>在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1</td>
</tr>
<tr>
<td>终止 FIN</td>
<td>用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接</td>
</tr>
<tr>
<td>窗口</td>
<td>窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的</td>
</tr>
</tbody></table>
</li>
<li><p>TCP 的三次握手</p>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立</li>
</ul>
<p><strong>三次握手的原因</strong></p>
<blockquote>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
</blockquote>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接</p>
</li>
<li><p>TCP 的四次挥手</p>
<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li>A 发送连接释放报文，FIN=1。</li>
<li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li>
<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<blockquote>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
</blockquote>
<p><strong>TIME_WAIT</strong></p>
<blockquote>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。</p>
</blockquote>
<p>这么做有两个理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文</li>
</ul>
</li>
<li><p>TCP 可靠传输</p>
<blockquote>
<p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段</p>
</blockquote>
<p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/2018/07/13/0-javabase/githubblog\source_posts\notes\TCP可靠传输往返时间RTT.png" alt="TCP可靠传输往返时间RTT"></p>
<p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p>
<p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/2018/07/13/0-javabase/githubblog\source_posts\notes\TCP使用的超时时间.png" alt="TCP使用的超时时间"></p>
<p>其中 RTTd 为偏差的加权平均值</p>
</li>
<li><p>TCP 滑动窗口</p>
<blockquote>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收</p>
</blockquote>
</li>
<li><p>TCP 流量控制</p>
<blockquote>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
</blockquote>
</li>
<li><p>TCP 拥塞控制</p>
<ol>
<li><p>概述</p>
<blockquote>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度</p>
<p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口</p>
</blockquote>
<p>假设：</p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段</li>
</ul>
<p>有</p>
<ul>
<li>慢开始与拥塞避免</li>
<li>快重传与快恢复</li>
</ul>
</li>
<li><p>慢开始与拥塞避免</p>
<ul>
<li>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</li>
<li>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</li>
<li>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始</li>
</ul>
</li>
<li><p>快重传与快恢复</p>
<ul>
<li>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2的确认。</li>
<li>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</li>
<li>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</li>
<li>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="5-1-6-应用层"><a href="#5-1-6-应用层" class="headerlink" title="5.1.6 应用层"></a>5.1.6 应用层</h4><ol>
<li><p>域名系统</p>
<blockquote>
<p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名</p>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性</p>
</blockquote>
<p>在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）</li>
</ul>
</li>
<li><p>文件传送协议</p>
<blockquote>
<p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p>
</blockquote>
<ul>
<li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li>
<li>数据连接：用来传送一个文件数据。</li>
</ul>
<blockquote>
<p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p>
<p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号</p>
</blockquote>
<ul>
<li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li>
<li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机</li>
</ul>
</li>
<li><p>动态主机配置协议</p>
<blockquote>
<p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址</p>
</blockquote>
<p>DHCP 工作过程：</p>
<ol>
<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息</li>
</ol>
</li>
<li><p>远程登录协议</p>
<blockquote>
<p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p>
<p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义</p>
</blockquote>
</li>
<li><p>电子邮件协议</p>
<ol>
<li><p>概述</p>
<blockquote>
<p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p>
<p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP</p>
</blockquote>
</li>
<li><p>SMTP</p>
<blockquote>
<p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则</p>
</blockquote>
</li>
<li><p>POP3</p>
<blockquote>
<p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件</p>
</blockquote>
</li>
<li><p>IMAP</p>
<blockquote>
<p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件</p>
</blockquote>
</li>
</ol>
</li>
<li><p>常用端口</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>应用</td>
<td>应用层协议</td>
<td>端口号</td>
<td>传输层协议</td>
<td>备注</td>
</tr>
<tr>
<td>域名解析</td>
<td>DNS</td>
<td>53</td>
<td>UDP/TCP</td>
<td>长度超过 512 字节时使用 TCP</td>
</tr>
<tr>
<td>动态主机配置协议</td>
<td>DHCP</td>
<td>67/68</td>
<td>UDP</td>
<td></td>
</tr>
<tr>
<td>简单网络管理协议</td>
<td>SNMP</td>
<td>161/162</td>
<td>UDP</td>
<td></td>
</tr>
<tr>
<td>文件传送协议</td>
<td>FTP</td>
<td>20/21</td>
<td>TCP</td>
<td>控制连接 21，数据连接 20</td>
</tr>
<tr>
<td>远程终端协议</td>
<td>TELNET</td>
<td>23</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>超文本传送协议</td>
<td>HTTP</td>
<td>80</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>简单邮件传送协议</td>
<td>SMTP</td>
<td>25</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>邮件读取协议</td>
<td>POP3</td>
<td>110</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>网际报文存取协议</td>
<td>IMAP</td>
<td>143</td>
<td>TCP</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>Web 页面请求过程</p>
<ol>
<li>DHCP 配置主机信息<ul>
<li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li>
<li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li>
<li>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</li>
<li>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF，将广播到与交换机连接的所有设备。</zero-width></zero-width></zero-width></zero-width></li>
<li>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li>
<li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li>
<li>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关</li>
</ul>
</li>
<li>ARP 解析 MAC 地址<ul>
<li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li>
<li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li>
<li>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</li>
<li>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li>
<li>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</li>
<li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</zero-width></zero-width></zero-width></zero-width></li>
<li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机</li>
</ul>
</li>
<li>DNS 解析域名<ul>
<li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li>
<li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li>
<li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li>
<li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li>
<li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机</li>
</ul>
</li>
<li>HTTP 请求页面<ul>
<li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li>
<li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li>
<li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li>
<li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li>
<li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li>
<li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="5-2-HTTP"><a href="#5-2-HTTP" class="headerlink" title="5.2 HTTP"></a>5.2 HTTP</h3><h4 id="5-2-1-基础概念"><a href="#5-2-1-基础概念" class="headerlink" title="5.2.1 基础概念"></a>5.2.1 基础概念</h4><ol>
<li><p>请求和响应报文</p>
<blockquote>
<p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端</p>
</blockquote>
<p>请求报文结构：</p>
<ul>
<li>第一行是包含了请求方法、URL、协议版本；</li>
<li>接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。</li>
<li>一个空行用来分隔首部和内容主体 Body</li>
<li>最后是请求的内容主体</li>
</ul>
<p>响应报文结构：</p>
<ul>
<li>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了</li>
<li>接下来多行也是首部内容</li>
<li>一个空行分隔首部和内容主体</li>
<li>最后是响应的内容主体</li>
</ul>
</li>
<li><p>URL</p>
<blockquote>
<p>HTTP 使用 URL（ <strong>U</strong> niform <strong>R</strong>esource <strong>L</strong>ocator，统一资源定位符）来定位资源，它是 URI（<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。URI 除了包含 URL，还包含 URN（Uniform Resource Name，统一资源名称），它只是用来定义一个资源的名称，并不具备定位该资源的能力</p>
</blockquote>
</li>
</ol>
<h4 id="5-2-2-方法"><a href="#5-2-2-方法" class="headerlink" title="5.2.2 方法"></a>5.2.2 方法</h4><ol>
<li><p>概述</p>
<blockquote>
<p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段</p>
</blockquote>
</li>
<li><p>GET</p>
<blockquote>
<p>获取资源</p>
<p>当前网络请求中，绝大部分使用的是 GET 方法</p>
</blockquote>
</li>
<li><p>HEAD</p>
<blockquote>
<p>获取报文首部</p>
<p>和 GET 方法类似，但是不返回报文实体主体部分</p>
<p>主要用于确认 URL 的有效性以及资源更新的日期时间等</p>
</blockquote>
</li>
<li><p>POST</p>
<blockquote>
<p>传输实体主体</p>
<p>POST 主要用来传输数据，而 GET 主要用来获取资源</p>
</blockquote>
</li>
<li><p>PUT</p>
<blockquote>
<p>上传文件</p>
<p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法</p>
</blockquote>
</li>
<li><p>PATCH</p>
<blockquote>
<p>对资源进行部分修改</p>
<p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改</p>
</blockquote>
</li>
<li><p>DELETE</p>
<blockquote>
<p>删除文件</p>
<p>与 PUT 功能相反，并且同样不带验证机制</p>
</blockquote>
</li>
<li><p>OPTIONS</p>
<blockquote>
<p>查询支持的方法</p>
<p>查询指定的 URL 能够支持的方法</p>
<p>会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容</p>
</blockquote>
</li>
<li><p>CONNECT</p>
<blockquote>
<p>要求在与代理服务器通信时建立隧道</p>
<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输</p>
</blockquote>
</li>
<li><p>TRACE</p>
<blockquote>
<p>追踪路径</p>
<p>服务器会将通信路径返回给客户端。</p>
<p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p>
<p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）</p>
</blockquote>
</li>
</ol>
<h4 id="5-2-3-HTTP-状态码"><a href="#5-2-3-HTTP-状态码" class="headerlink" title="5.2.3 HTTP 状态码"></a>5.2.3 HTTP 状态码</h4><ol>
<li><p>概述</p>
<blockquote>
<p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果</p>
</blockquote>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
</li>
<li><p>1XX 信息</p>
<blockquote>
<p>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</p>
</blockquote>
</li>
<li><p>2XX 成功</p>
<ul>
<li>200 OK</li>
<li>204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容</li>
</ul>
</li>
<li><p>3XX 重定向</p>
<ul>
<li>301 Moved Permanently ：永久性重定向</li>
<li>302 Found ：临时性重定向</li>
<li>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li>304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法</li>
</ul>
</li>
<li><p>4XX 客户端错误</p>
<ul>
<li>400 Bad Request ：请求报文中存在语法错误。</li>
<li>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li>403 Forbidden ：请求被拒绝。</li>
<li>404 Not Found</li>
</ul>
</li>
<li><p>5XX 服务器错误</p>
<ul>
<li>500 Internal Server Error ：服务器正在执行请求时发生错误。</li>
<li>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
</ul>
</li>
</ol>
<h4 id="5-2-4-HTTP-首部"><a href="#5-2-4-HTTP-首部" class="headerlink" title="5.2.4 HTTP 首部"></a>5.2.4 HTTP 首部</h4><blockquote>
<p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段</p>
</blockquote>
<ol>
<li><p>通用首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>控制不再转发给代理的首部字段、管理持久连接</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody></table>
</li>
<li><p>请求首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言（自然语言）</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web 认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与 If-Modified-Since 相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP 客户端程序的信息</td>
</tr>
</tbody></table>
</li>
<li><p>响应首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定 URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP 服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody></table>
</li>
<li><p>实体首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的 URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="5-2-5-具体应用"><a href="#5-2-5-具体应用" class="headerlink" title="5.2.5 具体应用"></a>5.2.5 具体应用</h4><ol>
<li><p>连接管理</p>
<ol>
<li><p>短连接与长连接</p>
<blockquote>
<p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p>
<p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信</p>
</blockquote>
<ul>
<li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li>
<li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code></li>
</ul>
</li>
<li><p>流水线</p>
<blockquote>
<p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p>
<p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟</p>
</blockquote>
</li>
</ol>
</li>
<li><p>Cookie</p>
<blockquote>
<p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB</p>
</blockquote>
<ul>
<li><p>用途</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</li>
<li><p>创建过程</p>
<blockquote>
<p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中</p>
<p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器</p>
</blockquote>
</li>
<li><p>分类</p>
<ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>
<li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）</li>
<li>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配</li>
</ul>
</li>
<li><p>JavaScript</p>
<blockquote>
<p>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie</p>
</blockquote>
</li>
<li><p>HttpOnly</p>
<blockquote>
<p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击</p>
</blockquote>
</li>
<li><p>Secure</p>
<blockquote>
<p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障</p>
</blockquote>
</li>
<li><p>Session</p>
<blockquote>
<p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高</p>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式</p>
</blockquote>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
</li>
<li><p>浏览器禁用 Cookie</p>
<blockquote>
<p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递</p>
</blockquote>
</li>
<li><p>Cookie 与 Session 选择</p>
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存</p>
<ul>
<li><p>优点</p>
<ul>
<li>缓解服务器压力；</li>
<li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存</li>
</ul>
</li>
<li><p>实现方法</p>
<ul>
<li>让代理服务器进行缓存；</li>
<li>让客户端浏览器进行缓存</li>
</ul>
</li>
<li><p>Cache-Control</p>
<blockquote>
<p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存</p>
</blockquote>
<ul>
<li><p>禁止进行缓存</p>
<blockquote>
<p>no-store 指令规定不能对请求或响应的任何一部分进行缓存</p>
</blockquote>
</li>
<li><p>强制确认缓存</p>
<blockquote>
<p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应</p>
</blockquote>
</li>
<li><p>私有缓存和公共缓存</p>
<blockquote>
<p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中</p>
<p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中</p>
</blockquote>
</li>
<li><p>缓存过期机制</p>
<blockquote>
<p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>
<p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间</p>
</blockquote>
<p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期</p>
<ul>
<li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li>
<li>在 HTTP/1.0 中，max-age 指令会被忽略掉</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存验证</p>
<blockquote>
<p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识</p>
<p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified</p>
<p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文</p>
</blockquote>
</li>
</ul>
</li>
<li><p>内容协商</p>
<blockquote>
<p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面</p>
</blockquote>
<ul>
<li><p>类型</p>
<ul>
<li><p>服务端驱动型</p>
<blockquote>
<p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源</p>
</blockquote>
<p>存在以下问题：</p>
<ul>
<li>服务器很难知道客户端浏览器的全部信息；</li>
<li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li>
<li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂</li>
</ul>
</li>
<li><p>代理驱动型</p>
<blockquote>
<p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Vary</p>
<blockquote>
<p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源</p>
</blockquote>
</li>
</ul>
</li>
<li><p>内容编码</p>
<blockquote>
<p>内容编码将实体主体进行压缩，从而减少传输的数据量。</p>
<p>常用的内容编码有：gzip、compress、deflate、identity。</p>
<p>浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding</p>
</blockquote>
</li>
<li><p>范围请求</p>
<blockquote>
<p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据</p>
</blockquote>
<ul>
<li><p>Range</p>
<blockquote>
<p>在请求报文中添加 Range 首部字段指定请求的范围</p>
<p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码</p>
</blockquote>
</li>
<li><p>Accept-Ranges</p>
<blockquote>
<p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none</p>
</blockquote>
</li>
<li><p>响应状态码</p>
<ul>
<li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li>
<li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li>
<li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li>
</ul>
</li>
</ul>
</li>
<li><p>分块传输编码</p>
<blockquote>
<p>Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面</p>
</blockquote>
</li>
<li><p>多部分对象集合</p>
<blockquote>
<p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段</p>
</blockquote>
</li>
<li><p>虚拟主机</p>
<blockquote>
<p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器</p>
</blockquote>
</li>
<li><p>通信数据转发</p>
<ul>
<li><p>代理</p>
<blockquote>
<p>代理服务器接受客户端的请求，并且转发给其它服务器</p>
</blockquote>
<p>目的</p>
<ul>
<li>缓存</li>
<li>负载均衡</li>
<li>网络访问控制</li>
<li>访问日志记录</li>
</ul>
<p>分类</p>
<ul>
<li><p>正向代理</p>
<blockquote>
<p>用户可察觉</p>
</blockquote>
</li>
<li><p>反向代理</p>
<blockquote>
<p>用户不可察觉</p>
</blockquote>
</li>
</ul>
</li>
<li><p>网关</p>
<blockquote>
<p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务</p>
</blockquote>
</li>
<li><p>隧道</p>
<blockquote>
<p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="5-2-6-HTTPS"><a href="#5-2-6-HTTPS" class="headerlink" title="5.2.6 HTTPS"></a>5.2.6 HTTPS</h4><ol>
<li><p>概述</p>
<blockquote>
<p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p>
<p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</p>
</blockquote>
<p>有以下安全性问题：</p>
<ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改</li>
</ul>
</li>
<li><p>加密</p>
<ul>
<li><p>对称密钥加密</p>
<blockquote>
<p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥</p>
</blockquote>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>
</li>
<li><p>非对称密钥加密</p>
<blockquote>
<p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确</p>
</blockquote>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度慢</li>
</ul>
</li>
<li><p>HTTPS 采用的加密方式</p>
<blockquote>
<p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案</p>
</blockquote>
<ul>
<li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;</li>
<li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。</li>
</ul>
</li>
</ul>
</li>
<li><p>认证</p>
<blockquote>
<p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了</p>
</blockquote>
</li>
<li><p>完整性保护</p>
<blockquote>
<p>SSL 提供报文摘要功能来进行完整性保护。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文</p>
</blockquote>
</li>
<li><p>HTTPS 的缺点</p>
<ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用</li>
</ul>
</li>
</ol>
<h4 id="5-2-7-HTTP-2-0"><a href="#5-2-7-HTTP-2-0" class="headerlink" title="5.2.7 HTTP/2.0"></a>5.2.7 HTTP/2.0</h4><ol>
<li><p>HTTP/1.x 缺陷</p>
<blockquote>
<p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p>
</blockquote>
<ul>
<li>客户端需要使用多个连接才能实现并发和缩短延迟；</li>
<li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li>
<li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下</li>
</ul>
</li>
<li><p>二进制分帧层</p>
<blockquote>
<p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的</p>
</blockquote>
<p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p>
<ul>
<li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li>
<li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li>
<li>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装</li>
</ul>
</li>
<li><p>服务端推送</p>
<blockquote>
<p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了</p>
</blockquote>
</li>
<li><p>首部压缩</p>
<blockquote>
<p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p>
<p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p>
<p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩</p>
</blockquote>
</li>
</ol>
<h4 id="5-2-8-HTTP-1-1-新特性"><a href="#5-2-8-HTTP-1-1-新特性" class="headerlink" title="5.2.8 HTTP/1.1 新特性"></a>5.2.8 HTTP/1.1 新特性</h4><ul>
<li>默认是长连接</li>
<li>支持流水线</li>
<li>支持同时打开多个 TCP 连接</li>
<li>支持虚拟主机</li>
<li>新增状态码 100</li>
<li>支持分块传输编码</li>
<li>新增缓存处理指令 max-age</li>
</ul>
<h4 id="5-2-9-GET-和-POST-比较"><a href="#5-2-9-GET-和-POST-比较" class="headerlink" title="5.2.9 GET 和 POST 比较"></a>5.2.9 GET 和 POST 比较</h4><ol>
<li><p>作用</p>
<blockquote>
<p>GET 用于获取资源，而 POST 用于传输实体主体</p>
</blockquote>
</li>
<li><p>参数</p>
<blockquote>
<p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p>
<p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集</p>
</blockquote>
</li>
<li><p>安全</p>
<ul>
<li>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的</li>
<li>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变</li>
<li>安全的方法除了 GET 之外还有：HEAD、OPTIONS</li>
<li>不安全的方法除了 POST 之外还有 PUT、DELETE</li>
</ul>
</li>
<li><p>幂等性</p>
<ul>
<li>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）</li>
<li>所有的安全方法也都是幂等的</li>
<li>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是</li>
<li>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的</li>
<li>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录</li>
<li>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样</li>
</ul>
</li>
<li><p>可缓存</p>
<blockquote>
<p>要对响应进行缓存，需要满足以下条件：</p>
</blockquote>
<ul>
<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>
<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存</li>
</ul>
</li>
<li><p>XMLHttpRequest</p>
<blockquote>
<p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用</p>
</blockquote>
<ul>
<li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会</li>
<li>而 GET 方法 Header 和 Data 会一起发送</li>
</ul>
</li>
</ol>
<h3 id="5-3-Socket"><a href="#5-3-Socket" class="headerlink" title="5.3 Socket"></a>5.3 Socket</h3><h4 id="5-3-1-I-O-模型"><a href="#5-3-1-I-O-模型" class="headerlink" title="5.3.1 I/O 模型"></a>5.3.1 I/O 模型</h4><ol>
<li><p>概述</p>
<blockquote>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区</p>
</blockquote>
<ul>
<li>一个输入操作通常包括两个阶段：<ul>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ul>
</li>
<li>Unix 有五种 I/O 模型：<ul>
<li>阻塞式 I/O</li>
<li>非阻塞式 I/O</li>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li>异步 I/O（AIO</li>
</ul>
</li>
</ul>
</li>
<li><p>阻塞式 I/O</p>
<blockquote>
<p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>
<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高</p>
</blockquote>
</li>
<li><p>非阻塞式 I/O</p>
<blockquote>
<p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低</p>
</blockquote>
</li>
<li><p>I/O 复用</p>
<blockquote>
<p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p>
<p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p>
<p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小</p>
</blockquote>
</li>
<li><p>信号驱动 I/O</p>
<blockquote>
<p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高</p>
</blockquote>
</li>
<li><p>异步 I/O</p>
<blockquote>
<p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>
<p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p>
</blockquote>
</li>
<li><p>五大 I/O 模型比较</p>
<blockquote>
<p>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。</p>
<p>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞</p>
</blockquote>
<ul>
<li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>
<li>异步 I/O：第二阶段应用进程不会阻塞。</li>
</ul>
</li>
</ol>
<h4 id="5-3-2-I-O-复用"><a href="#5-3-2-I-O-复用" class="headerlink" title="5.3.2 I/O 复用"></a>5.3.2 I/O 复用</h4><blockquote>
<p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll</p>
</blockquote>
<ol>
<li><p>select</p>
<blockquote>
<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作</p>
</blockquote>
<ul>
<li>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</li>
<li>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</li>
<li>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</li>
</ul>
</li>
<li><p>poll</p>
<ul>
<li>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态</li>
<li>poll 中的描述符是 pollfd 类型的数组</li>
</ul>
</li>
<li><p>比较</p>
<ul>
<li><p>功能</p>
<blockquote>
<p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同</p>
</blockquote>
<ul>
<li>select 会修改描述符，而 poll 不会；</li>
<li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>
<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定</li>
</ul>
</li>
<li><p>速度</p>
<blockquote>
<p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区</p>
</blockquote>
</li>
<li><p>可移植性</p>
<blockquote>
<p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll</p>
</blockquote>
</li>
</ul>
</li>
<li><p>epoll</p>
<ul>
<li>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符</li>
<li>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符</li>
<li>epoll 仅适用于 Linux OS</li>
<li>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制</li>
<li>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况</li>
</ul>
</li>
<li><p>工作模式</p>
<blockquote>
<p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）</p>
</blockquote>
<ul>
<li><p>LT模式</p>
<blockquote>
<p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking</p>
</blockquote>
</li>
<li><p>ET模式</p>
<blockquote>
<p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>
<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死</p>
</blockquote>
</li>
</ul>
</li>
<li><p>应用场景</p>
<blockquote>
<p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景</p>
</blockquote>
<ul>
<li><p>select 应用场景</p>
<blockquote>
<p>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制</p>
<p>select 可移植性更好，几乎被所有主流平台所支持</p>
</blockquote>
</li>
<li><p>poll 应用场景</p>
<blockquote>
<p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select</p>
</blockquote>
</li>
<li><p>epoll 应用场景</p>
<blockquote>
<p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接</p>
<p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势</p>
<p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="6-操作系统"><a href="#6-操作系统" class="headerlink" title="6. 操作系统"></a>6. 操作系统</h2><h3 id="6-1-基础"><a href="#6-1-基础" class="headerlink" title="6.1 基础"></a>6.1 基础</h3><ol>
<li><p>基本特征</p>
<ol>
<li><p>并发</p>
<blockquote>
<p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令</p>
</blockquote>
<ul>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统</li>
<li>操作系统通过引入进程和线程，使得程序能够并发运行。</li>
</ul>
</li>
<li><p>共享</p>
<blockquote>
<p>共享是指系统中的资源可以被多个并发进程共同使用</p>
</blockquote>
<ul>
<li>有两种共享方式：互斥共享和同时共享</li>
<li>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问</li>
</ul>
</li>
<li><p>虚拟</p>
<blockquote>
<p>虚拟技术把一个物理实体转换为多个逻辑实体</p>
</blockquote>
<ul>
<li>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术</li>
<li>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换</li>
<li>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li>
</ul>
</li>
<li><p>异步</p>
<blockquote>
<p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进</p>
</blockquote>
</li>
</ol>
</li>
<li><p>基本功能</p>
<ol>
<li><p>进程管理</p>
<blockquote>
<p>进程控制、进程同步、进程通信、死锁处理、处理机调度等</p>
</blockquote>
</li>
<li><p>内存管理</p>
<blockquote>
<p>内存分配、地址映射、内存保护与共享、虚拟内存等</p>
</blockquote>
</li>
<li><p>文件管理</p>
<blockquote>
<p>文件存储空间的管理、目录管理、文件读写管理和保护等</p>
</blockquote>
</li>
<li><p>设备管理</p>
<blockquote>
<p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率</p>
<p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等</p>
</blockquote>
</li>
</ol>
</li>
<li><p>系统调用</p>
<blockquote>
<p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成</p>
</blockquote>
<p>Linux 的系统调用主要有以下这些：</p>
<table>
<thead>
<tr>
<th>Task</th>
<th>Commands</th>
</tr>
</thead>
<tbody><tr>
<td>进程控制</td>
<td>fork(); exit(); wait();</td>
</tr>
<tr>
<td>进程通信</td>
<td>pipe(); shmget(); mmap();</td>
</tr>
<tr>
<td>文件操作</td>
<td>open(); read(); write();</td>
</tr>
<tr>
<td>设备操作</td>
<td>ioctl(); read(); write();</td>
</tr>
<tr>
<td>信息维护</td>
<td>getpid(); alarm(); sleep();</td>
</tr>
<tr>
<td>安全</td>
<td>chmod(); umask(); chown();</td>
</tr>
</tbody></table>
</li>
<li><p>宏内核和微内核</p>
<ol>
<li><p>宏内核</p>
<blockquote>
<p>宏内核是将操作系统功能作为一个紧密结合的整体放到内核。</p>
<p>由于各模块共享信息，因此有很高的性能。</p>
</blockquote>
</li>
<li><p>微内核</p>
<blockquote>
<p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p>
<p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p>
<p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失</p>
</blockquote>
</li>
</ol>
</li>
<li><p>中断分类</p>
<ol>
<li><p>外中断</p>
<blockquote>
<p>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等</p>
</blockquote>
</li>
<li><p>异常</p>
<blockquote>
<p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等</p>
</blockquote>
</li>
<li><p>陷入</p>
<blockquote>
<p>在用户程序中使用系统调用</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="6-2-进程管理"><a href="#6-2-进程管理" class="headerlink" title="6.2 进程管理"></a>6.2 进程管理</h3><ol>
<li><p>进程与线程</p>
<ol>
<li><p>进程</p>
<blockquote>
<p>进程是资源分配的基本单位</p>
<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作</p>
</blockquote>
</li>
<li><p>线程</p>
<blockquote>
<p>线程是独立调度的基本单位</p>
<p>一个进程中可以有多个线程，它们共享进程资源</p>
</blockquote>
</li>
<li><p>区别</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>拥有资源</td>
<td>资源分配的基本单位</td>
<td>不拥有资源，线程可以访问隶属进程的资源</td>
</tr>
<tr>
<td>调度</td>
<td>从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换</td>
<td>独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换</td>
</tr>
<tr>
<td>系统开销</td>
<td>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销</td>
<td>在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小</td>
</tr>
<tr>
<td>通信方面</td>
<td>进程通信需要借助 IPC</td>
<td>线程间可以通过直接读写同一进程中的数据进行通信</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>进程状态的切换</p>
<blockquote>
<p>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度</p>
<p>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态</p>
</blockquote>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
</li>
<li><p>进程调度算法</p>
<blockquote>
<p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法</p>
</blockquote>
<ol start="4">
<li><p>批处理系统</p>
<blockquote>
<p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）</p>
</blockquote>
<ul>
<li><p>先来先服务 first-come first-serverd（FCFS）</p>
<blockquote>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
</blockquote>
</li>
<li><p>短作业优先 shortest job first（SJF）</p>
<blockquote>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度</p>
</blockquote>
</li>
<li><p>最短剩余时间优先 shortest remaining time next（SRTN）</p>
<blockquote>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待</p>
</blockquote>
</li>
</ul>
</li>
<li><p>交互式系统</p>
<blockquote>
<p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应</p>
</blockquote>
<ul>
<li><p>时间片轮转</p>
<blockquote>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程</p>
</blockquote>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证</li>
</ul>
</li>
<li><p>优先级调度</p>
<blockquote>
<p>为每个进程分配一个优先级，按优先级进行调度</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级</p>
</blockquote>
</li>
<li><p>多级反馈队列</p>
<blockquote>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合</p>
</blockquote>
</li>
</ul>
</li>
<li><p>实时系统</p>
<blockquote>
<p>实时系统要求一个请求在一个确定时间内得到响应</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时</p>
</blockquote>
</li>
</ol>
</li>
<li><p>进程同步</p>
<ol>
<li><p>临界区</p>
<blockquote>
<p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查</p>
</blockquote>
</li>
<li><p>同步与互斥</p>
<ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
</li>
<li><p>信号量</p>
<blockquote>
<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作</p>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁</p>
</blockquote>
<ul>
<li><p>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</p>
</li>
<li><p>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> semaphore<span class="token punctuation">;</span>
semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 临界区</span>
    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 临界区</span>
    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>使用信号量实现生产者-消费者问题</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</span>

<span class="token comment" spellcheck="true">// 因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</span>

<span class="token comment" spellcheck="true">// 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</span>

<span class="token comment" spellcheck="true">// 注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去</span>

<span class="token macro property">#<span class="token directive keyword">define</span> N 100</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> semaphore<span class="token punctuation">;</span>
semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
semaphore empty <span class="token operator">=</span> N<span class="token punctuation">;</span>
semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> item <span class="token operator">=</span> <span class="token function">produce_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">insert_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> item <span class="token operator">=</span> <span class="token function">remove_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">consume_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ul>
</li>
<li><p>管程</p>
<blockquote>
<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易</p>
<p>在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程</p>
<p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程</p>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题</span>
monitor ProducerConsumer
    integer i<span class="token punctuation">;</span>
    condition c<span class="token punctuation">;</span>

    procedure <span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    begin
        <span class="token comment" spellcheck="true">// ...</span>
    end<span class="token punctuation">;</span>

    procedure <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    begin
        <span class="token comment" spellcheck="true">// ...</span>
    end<span class="token punctuation">;</span>
end monitor<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 使用管程实现生产者-消费者问题</span>
monitor ProducerConsumer
    condition full<span class="token punctuation">,</span> empty<span class="token punctuation">;</span>
    integer count <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    condition c<span class="token punctuation">;</span>

    procedure <span class="token function">insert</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> integer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    begin
        <span class="token keyword">if</span> count <span class="token operator">=</span> N then <span class="token function">wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">insert_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        count <span class="token punctuation">:</span><span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> count <span class="token operator">=</span> <span class="token number">1</span> then <span class="token function">signal</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
    end<span class="token punctuation">;</span>

    function remove<span class="token punctuation">:</span> integer<span class="token punctuation">;</span>
    begin
        <span class="token keyword">if</span> count <span class="token operator">=</span> <span class="token number">0</span> then <span class="token function">wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
        remove <span class="token operator">=</span> remove_item<span class="token punctuation">;</span>
        count <span class="token punctuation">:</span><span class="token operator">=</span> count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> count <span class="token operator">=</span> N <span class="token operator">-</span><span class="token number">1</span> then <span class="token function">signal</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
    end<span class="token punctuation">;</span>
end monitor<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 生产者客户端</span>
procedure producer
begin
    <span class="token keyword">while</span> true <span class="token keyword">do</span>
    begin
        item <span class="token operator">=</span> produce_item<span class="token punctuation">;</span>
        ProducerConsumer<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    end
end<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 消费者客户端</span>
procedure consumer
begin
    <span class="token keyword">while</span> true <span class="token keyword">do</span>
    begin
        item <span class="token operator">=</span> ProducerConsumer<span class="token punctuation">.</span>remove<span class="token punctuation">;</span>
        <span class="token function">consume_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    end
end<span class="token punctuation">;</span></code></pre>
</li>
</ol>
</li>
<li><p>经典同步问题</p>
<ol>
<li><p>哲学家进餐问题</p>
<blockquote>
<p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子</p>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁</span>
<span class="token macro property">#<span class="token directive keyword">define</span> N 5</span>

<span class="token keyword">void</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">think</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">take</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 拿起左边的筷子</span>
        <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 拿起右边的筷子</span>
        <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐</li>
</ul>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> N 5</span>
<span class="token macro property">#<span class="token directive keyword">define</span> LEFT (i + N - 1) % N </span><span class="token comment" spellcheck="true">// 左邻居</span>
<span class="token macro property">#<span class="token directive keyword">define</span> RIGHT (i + 1) % N    </span><span class="token comment" spellcheck="true">// 右邻居</span>
<span class="token macro property">#<span class="token directive keyword">define</span> THINKING 0</span>
<span class="token macro property">#<span class="token directive keyword">define</span> HUNGRY   1</span>
<span class="token macro property">#<span class="token directive keyword">define</span> EATING   2</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> semaphore<span class="token punctuation">;</span>
<span class="token keyword">int</span> state<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 跟踪每个哲学家的状态</span>
semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span>
semaphore s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 每个哲学家一个信号量</span>

<span class="token keyword">void</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">think</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">take_two</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">eat</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">put_two</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">take_two</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> HUNGRY<span class="token punctuation">;</span>
    <span class="token function">check</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只有收到通知之后才可以开始吃，否则会一直等下去</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">put_two</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> THINKING<span class="token punctuation">;</span>
    <span class="token function">check</span><span class="token punctuation">(</span>LEFT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span>
    <span class="token function">check</span><span class="token punctuation">(</span>RIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> EATING<span class="token punctuation">;</span>
    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span>
<span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>         
    <span class="token keyword">if</span><span class="token punctuation">(</span>state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> HUNGRY <span class="token operator">&amp;&amp;</span> state<span class="token punctuation">[</span>LEFT<span class="token punctuation">]</span> <span class="token operator">!=</span> EATING <span class="token operator">&amp;&amp;</span> state<span class="token punctuation">[</span>RIGHT<span class="token punctuation">]</span> <span class="token operator">!=</span>EATING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> EATING<span class="token punctuation">;</span>
        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>读者-写者问题</p>
<blockquote>
<p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁</p>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> semaphore<span class="token punctuation">;</span>
semaphore count_mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
semaphore data_mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 第一个读者需要对数据进行加锁，防止写进程访问</span>
        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ol>
</li>
<li><p>进程通信</p>
<ol>
<li><p>概述</p>
<blockquote>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息</p>
</blockquote>
<p>进程同步与进程通信的区别：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息</li>
</ul>
</li>
<li><p>管道</p>
<blockquote>
<p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写</p>
</blockquote>
<p>限制：</p>
<ul>
<li>只支持半双工通信（单向交替传输）；</li>
<li>只能在父子进程或者兄弟进程中使用</li>
</ul>
</li>
<li><p>FIFO</p>
<blockquote>
<p>也称为命名管道，去除了管道只能在父子进程中使用的限制</p>
<p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据</p>
</blockquote>
</li>
<li><p>消息队列</p>
<p>优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li>
</ul>
</li>
<li><p>信号量</p>
<blockquote>
<p>它是一个计数器，用于为多个进程提供对共享数据对象的访问</p>
</blockquote>
</li>
<li><p>共享存储</p>
<blockquote>
<p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p>
<p>需要使用信号量用来同步对共享存储的访问。</p>
<p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段</p>
</blockquote>
</li>
<li><p>套接字</p>
<blockquote>
<p>与其它通信机制不同的是，它可用于不同机器间的进程通信</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="6-3-内存管理"><a href="#6-3-内存管理" class="headerlink" title="6.3 内存管理"></a>6.3 内存管理</h3><ol>
<li><p>虚拟内存</p>
<blockquote>
<p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序</p>
</blockquote>
</li>
<li><p>分页系统地址映射</p>
<blockquote>
<p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量</p>
</blockquote>
</li>
<li><p>页面置换算法</p>
<blockquote>
<p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>
<p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>
<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）</p>
</blockquote>
<ol>
<li><p>最佳</p>
<blockquote>
<p>OPT, Optimal replacement algorithm</p>
<p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p>
<p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问</p>
</blockquote>
</li>
<li><p>最近最久未使用</p>
<blockquote>
<p>LRU, Least Recently Used</p>
<p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p>
<p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高</p>
</blockquote>
</li>
<li><p>最近未使用</p>
<blockquote>
<p>NRU, Not Recently Used</p>
<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零</p>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出</p>
<p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）</p>
</blockquote>
</li>
<li><p>先进先出</p>
<blockquote>
<p>FIFO, First In First Out</p>
<p>选择换出的页面是最先进入的页面</p>
<p>该算法会将那些经常被访问的页面换出，导致缺页率升高</p>
</blockquote>
</li>
<li><p>第二次机会算法</p>
<blockquote>
<p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p>
<p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索</p>
</blockquote>
</li>
<li><p>时钟</p>
<blockquote>
<p>Clock</p>
<p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面</p>
</blockquote>
</li>
</ol>
</li>
<li><p>分段</p>
<blockquote>
<p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射</p>
<p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长</p>
</blockquote>
</li>
<li><p>段页式</p>
<blockquote>
<p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能</p>
</blockquote>
</li>
<li><p>分页与分段的比较</p>
<ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的。</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li>
<li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
</li>
</ol>
<h3 id="6-4-死锁"><a href="#6-4-死锁" class="headerlink" title="6.4 死锁"></a>6.4 死锁</h3><ol>
<li><p>必要条件</p>
<ul>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
</li>
<li><p>处理方法</p>
<ul>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
</li>
<li><p>鸵鸟策略</p>
<blockquote>
<p>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它</p>
</blockquote>
</li>
<li><p>死锁检测与死锁恢复</p>
<blockquote>
<p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复</p>
</blockquote>
<ol>
<li><p>每种类型一个资源的死锁检测</p>
<blockquote>
<p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生</p>
</blockquote>
</li>
<li><p>每种类型多个资源的死锁检测</p>
<blockquote>
<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁</p>
</blockquote>
<p>算法总结：</p>
<blockquote>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
</blockquote>
<ol>
<li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止</li>
</ol>
</li>
<li><p>死锁恢复</p>
<ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
</li>
</ol>
</li>
<li><p>死锁预防</p>
<blockquote>
<p>在程序运行之前预防发生死锁</p>
</blockquote>
<ol>
<li><p>破坏互斥条件</p>
<blockquote>
<p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程</p>
</blockquote>
</li>
<li><p>破坏占有和等待条件</p>
<blockquote>
<p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源</p>
</blockquote>
</li>
<li><p>破坏不可抢占条件</p>
</li>
<li><p>破坏环路等待</p>
<blockquote>
<p>给资源统一编号，进程只能按编号顺序来请求资源</p>
</blockquote>
</li>
</ol>
</li>
<li><p>死锁避免</p>
<blockquote>
<p>在程序运行时避免发生死锁</p>
</blockquote>
<ol>
<li><p>安全状态</p>
<blockquote>
<p>如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的</p>
<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比</p>
</blockquote>
</li>
<li><p>单个资源的银行家算法</p>
<blockquote>
<p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配</p>
</blockquote>
</li>
<li><p>多个资源的银行家算法</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态</p>
</li>
</ol>
</li>
</ol>
<h3 id="6-5-设备管理"><a href="#6-5-设备管理" class="headerlink" title="6.5 设备管理"></a>6.5 设备管理</h3><ol>
<li><p>磁盘结构</p>
<ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动</li>
</ul>
</li>
<li><p>磁盘调度算法</p>
<ol>
<li><p>概述</p>
<p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短</p>
</li>
<li><p>先来先服务</p>
<blockquote>
<p>FCFS, First Come First Served</p>
<p>按照磁盘请求的顺序进行调度</p>
<p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长</p>
</blockquote>
</li>
<li><p>最短寻道时间优先</p>
<blockquote>
<p>SSTF, Shortest Seek Time First</p>
<p>优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象</p>
</blockquote>
</li>
<li><p>电梯算法</p>
<blockquote>
<p>SCAN</p>
<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="6-6-链接"><a href="#6-6-链接" class="headerlink" title="6.6 链接"></a>6.6 链接</h3><ol>
<li><p>编译系统</p>
<blockquote>
<p>在 Unix 系统上，由编译器把源文件转换为目标文件</p>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// hello.c 程序</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

gcc <span class="token operator">-</span>o hello hello<span class="token punctuation">.</span>c</code></pre>
<p>过程大致如下</p>
<ul>
<li>预处理阶段：处理以 # 开头的预处理命令；</li>
<li>编译阶段：翻译成汇编文件；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li>
<li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件</li>
</ul>
</li>
<li><p>静态链接</p>
<blockquote>
<p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出</p>
</blockquote>
<p>链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置</li>
</ul>
</li>
<li><p>目标文件</p>
<ul>
<li>可执行目标文件：可以直接在内存中执行；</li>
<li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li>
<li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接</li>
</ul>
</li>
<li><p>动态链接</p>
<p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享</li>
</ul>
</li>
</ol>
<h3 id="6-7-Linux"><a href="#6-7-Linux" class="headerlink" title="6.7 Linux"></a>6.7 Linux</h3><h4 id="6-7-1-常用操作以及概念"><a href="#6-7-1-常用操作以及概念" class="headerlink" title="6.7.1 常用操作以及概念"></a>6.7.1 常用操作以及概念</h4><ol>
<li><p>快捷键</p>
<ul>
<li>Tab：命令和文件名补全；</li>
<li>Ctrl+C：中断正在运行的程序；</li>
<li>Ctrl+D：结束键盘输入（End Of File，EOF）</li>
</ul>
</li>
<li><p>求助</p>
<ol>
<li><p>–help：指令的基本用法与选项介绍</p>
</li>
<li><p>man</p>
<blockquote>
<p>man 是 manual 的缩写，将指令的具体信息显示出来</p>
<p>当执行 <code>man date</code> 时，有 DATE(1) 出现，其中的数字代表指令的类型</p>
</blockquote>
<p>常用的数字及其类型</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>用户在 shell 环境中可以操作的指令或者可执行文件</td>
</tr>
<tr>
<td>5</td>
<td>配置文件</td>
</tr>
<tr>
<td>8</td>
<td>系统管理员可以使用的管理指令</td>
</tr>
</tbody></table>
</li>
<li><p>info</p>
<blockquote>
<p>info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转</p>
</blockquote>
</li>
<li><p>doc</p>
<blockquote>
<p>/usr/share/doc 存放着软件的一整套说明文件</p>
</blockquote>
</li>
</ol>
</li>
<li><p>关机</p>
<ol>
<li><p>who</p>
<blockquote>
<p>在关机前需要先使用 who 命令查看有没有其它用户在线</p>
</blockquote>
</li>
<li><p>sync</p>
<blockquote>
<p>为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作</p>
</blockquote>
</li>
<li><p>shutdown</p>
<pre class=" language-shell"><code class="language-shell">## shutdown [-krhc] 时间 [信息]
-k ： 不会关机，只是发送警告信息，通知所有在线的用户
-r ： 将系统的服务停掉后就重新启动
-h ： 将系统的服务停掉后就立即关机
-c ： 取消已经在进行的 shutdown</code></pre>
</li>
</ol>
</li>
<li><p>PATH</p>
<blockquote>
<p>可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔</p>
</blockquote>
<p><code>/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin</code></p>
</li>
<li><p>sudo</p>
<blockquote>
<p>sudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令</p>
</blockquote>
</li>
<li><p>包管理工具</p>
<p>RPM 和 DPKG 为最常见的两类软件包管理工具：</p>
<ul>
<li>RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为许多 Linux 系统的既定软件标准。YUM 基于 RPM，具有依赖管理和软件升级功能。</li>
<li>与 RPM 竞争的是基于 Debian 操作系统的 DEB 软件包管理工具 DPKG，全称为 Debian Package，功能方面与 RPM 相似</li>
</ul>
</li>
<li><p>发行版</p>
<blockquote>
<p>Linux 发行版是 Linux 内核及各种应用软件的集成版本。</p>
</blockquote>
<table>
<thead>
<tr>
<th>基于的包管理工具</th>
<th>商业发行版</th>
<th>社区发行版</th>
</tr>
</thead>
<tbody><tr>
<td>RPM</td>
<td>Red Hat</td>
<td>Fedora / CentOS</td>
</tr>
<tr>
<td>DPKG</td>
<td>Ubuntu</td>
<td>Debian</td>
</tr>
</tbody></table>
</li>
<li><p>VIM 三个模式</p>
<ul>
<li>一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；</li>
<li>编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑；</li>
<li>指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。</li>
</ul>
<p>在指令列模式下，有以下命令用于离开或者保存文件。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>写入磁盘</td>
</tr>
<tr>
<td>:w!</td>
<td>当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td>
</tr>
<tr>
<td>:q</td>
<td>离开</td>
</tr>
<tr>
<td>:q!</td>
<td>强制离开不保存</td>
</tr>
<tr>
<td>:wq</td>
<td>写入磁盘后离开</td>
</tr>
<tr>
<td>:wq!</td>
<td>强制写入磁盘后离开</td>
</tr>
</tbody></table>
</li>
<li><p>GNU</p>
<blockquote>
<p>GNU 计划，译为革奴计划，它的目标是创建一套完全自由的操作系统，称为 GNU，其内容软件完全以 GPL 方式发布。其中 GPL 全称为 GNU 通用公共许可协议（GNU General Public License）</p>
</blockquote>
<p>内容</p>
<ul>
<li>以任何目的运行此程序的自由；</li>
<li>再复制的自由；</li>
<li>改进此程序，并公开发布改进的自由</li>
</ul>
</li>
<li><p>开源协议</p>
</li>
</ol>
<h4 id="6-7-2-磁盘"><a href="#6-7-2-磁盘" class="headerlink" title="6.7.2 磁盘"></a>6.7.2 磁盘</h4><ol>
<li><p>磁盘接口</p>
<ol>
<li><p>IDE</p>
<blockquote>
<p>IDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代</p>
</blockquote>
</li>
<li><p>SATA</p>
<blockquote>
<p>SATA 全称 Serial ATA，也就是使用串口的 ATA 接口，抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能。SATA-II 的接口速度为 300MB/s，而 SATA-III 标准可达到 600MB/s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便</p>
</blockquote>
</li>
<li><p>SCSI</p>
<blockquote>
<p>SCSI 全称是 Small Computer System Interface（小型机系统接口），SCSI 硬盘广为工作站以及个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵</p>
</blockquote>
</li>
<li><p>SAS</p>
<blockquote>
<p>SAS（Serial Attached SCSI）是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。此外也通过缩小连接线改善系统内部空间等</p>
</blockquote>
</li>
</ol>
</li>
<li><p>磁盘的文件名</p>
<blockquote>
<p>Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名</p>
<p>其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关</p>
</blockquote>
<p>常见磁盘的文件名如下：</p>
<ul>
<li>IDE 磁盘：/dev/hd[a-d]</li>
<li>SATA/SCSI/SAS 磁盘：/dev/sd[a-p]</li>
</ul>
</li>
</ol>
<h4 id="6-7-3-分区"><a href="#6-7-3-分区" class="headerlink" title="6.7.3 分区"></a>6.7.3 分区</h4><ol>
<li><p>分区表</p>
<blockquote>
<p>磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表</p>
</blockquote>
<ul>
<li><p>MBR</p>
<blockquote>
<p>MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。</p>
<p>分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区来记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。</p>
<p>Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始</p>
</blockquote>
</li>
<li><p>GPT</p>
<blockquote>
<p>扇区是磁盘的最小存储单位，旧磁盘的扇区大小通常为 512 bytes，而最新的磁盘支持 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。</p>
<p>GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。</p>
<p>GPT 没有扩展分区概念，都是主分区，每个 LBA 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。</p>
<p>MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 233 TB = 8 ZB</p>
</blockquote>
</li>
</ul>
</li>
<li><p>开机检测程序</p>
<ul>
<li><p>BIOS</p>
<blockquote>
<p>BIOS（Basic Input/Output System，基本输入输出系统），它是一个固件（嵌入在硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中</p>
<p>BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。</p>
<p>主要开机记录（MBR）中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统</p>
<p>安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉主要开机记录（MBR），而 Linux 可以选择将开机管理程序安装在主要开机记录（MBR）或者其它分区的启动扇区，并且可以设置开机管理程序的选单</p>
</blockquote>
</li>
<li><p>UEFI</p>
<blockquote>
<p>BIOS 不可以读取 GPT 分区表，而 UEFI 可以</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="6-7-4-文件系统"><a href="#6-7-4-文件系统" class="headerlink" title="6.7.4 文件系统"></a>6.7.4 文件系统</h4><ol>
<li><p>分区与文件系统</p>
<blockquote>
<p>对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统</p>
</blockquote>
</li>
<li><p>组成</p>
<p>最主要的几个组成部分如下：</p>
<ul>
<li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li>
<li>block：记录文件的内容，文件太大时，会占用多个 block。</li>
</ul>
<p>除此之外还包括：</p>
<ul>
<li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li>
<li>block bitmap：记录 block 是否被使用的位图</li>
</ul>
</li>
<li><p>文件读取</p>
<blockquote>
<p>对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来</p>
<p>而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号</p>
</blockquote>
</li>
<li><p>磁盘碎片</p>
<blockquote>
<p>指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能</p>
</blockquote>
</li>
<li><p>block</p>
<blockquote>
<p>在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。</p>
<p>一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block</p>
</blockquote>
<table>
<thead>
<tr>
<th>大小</th>
<th>1KB</th>
<th>2KB</th>
<th>4KB</th>
</tr>
</thead>
<tbody><tr>
<td>最大单一文件</td>
<td>16GB</td>
<td>256GB</td>
<td>2TB</td>
</tr>
<tr>
<td>最大文件系统</td>
<td>2TB</td>
<td>8TB</td>
<td>16TB</td>
</tr>
</tbody></table>
</li>
<li><p>inode</p>
<blockquote>
<p>inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息</p>
</blockquote>
<p>inode 具体包含以下信息：</p>
<ul>
<li>权限 (read/write/excute)；</li>
<li>拥有者与群组 (owner/group)；</li>
<li>容量；</li>
<li>建立或状态改变的时间 (ctime)；</li>
<li>最近读取时间 (atime)；</li>
<li>最近修改时间 (mtime)；</li>
<li>定义文件特性的旗标 (flag)，如 SetUID…；</li>
<li>该文件真正内容的指向 (pointer)。</li>
</ul>
<p>inode 具有以下特点：</p>
<ul>
<li>每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；</li>
<li>每个文件都仅会占用一个 inode。</li>
</ul>
</li>
<li><p>目录</p>
<blockquote>
<p>建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。</p>
<p>可以看到文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关</p>
</blockquote>
</li>
<li><p>日志</p>
<blockquote>
<p>如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。</p>
<p>ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统</p>
</blockquote>
</li>
<li><p>挂载</p>
<blockquote>
<p>挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据</p>
</blockquote>
</li>
<li><p>目录配置</p>
<blockquote>
<p>为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构</p>
</blockquote>
<p>最基础的三个目录如下：</p>
<ul>
<li>/ (root, 根目录)</li>
<li>/usr (unix software resource)：所有系统默认软件都会安装到这个目录；</li>
<li>/var (variable)：存放系统或程序运行过程中的数据文件。</li>
</ul>
</li>
</ol>
<h4 id="6-7-5-文件"><a href="#6-7-5-文件" class="headerlink" title="6.7.5 文件"></a>6.7.5 文件</h4><ol>
<li><p>文件属性</p>
<blockquote>
<p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限</p>
</blockquote>
<p>使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p>
<ul>
<li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li>
<li>3：链接数</li>
<li>root：文件拥有者</li>
<li>root：所属群组</li>
<li>17：文件大小</li>
<li>May 6 00:14：文件最后被修改的时间</li>
<li>.config：文件名</li>
</ul>
<p>常见的文件类型及其含义有：</p>
<ul>
<li>d：目录</li>
<li>-：文件</li>
<li>l：链接文件</li>
</ul>
<p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p>
<p>文件时间有以下三种：</p>
<ul>
<li>modification time (mtime)：文件的内容更新就会更新；</li>
<li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li>
<li>access time (atime)：读取文件时就会更新。</li>
</ul>
</li>
<li><p>文件与目录的基本操作</p>
<ol>
<li><p>ls</p>
<pre class=" language-shell"><code class="language-shell"># 列出文件或者目录的信息，目录的信息就是其中包含的文件
## ls [-aAdfFhilnrRSt] file|dir
-a ：列出全部的文件
-d ：仅列出目录本身
-l ：以长数据串行列出，包含文件的属性与权限等等数据</code></pre>
</li>
<li><p>cd</p>
<pre class=" language-shell"><code class="language-shell"># 更换当前目录
cd [相对路径或绝对路径]</code></pre>
</li>
<li><p>mkdir</p>
<pre class=" language-shell"><code class="language-shell"># 创建目录
## mkdir [-mp] 目录名称
-m ：配置目录权限
-p ：递归创建目录</code></pre>
</li>
<li><p>rmdir</p>
<pre class=" language-shell"><code class="language-shell"># 删除目录，目录必须为空
rmdir [-p] 目录名称
-p ：递归删除目录</code></pre>
</li>
<li><p>touch</p>
<pre class=" language-shell"><code class="language-shell"># 更新文件时间或者建立新文件
## touch [-acdmt] filename
-a ： 更新 atime
-c ： 更新 ctime，若该文件不存在则不建立新文件
-m ： 更新 mtime
-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date="日期或时间"
-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]</code></pre>
</li>
<li><p>cp</p>
<pre class=" language-shell"><code class="language-shell"># 复制文件。如果源文件有两个以上，则目的文件一定要是目录才行
cp [-adfilprsu] source destination
-a ：相当于 -dr --preserve=all
-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身
-i ：若目标文件已经存在时，在覆盖前会先询问
-p ：连同文件的属性一起复制过去
-r ：递归复制
-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制
--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了</code></pre>
</li>
<li><p>rm</p>
<pre class=" language-shell"><code class="language-shell"># 删除文件
## rm [-fir] 文件或目录
-r ：递归删除</code></pre>
</li>
<li><p>mv</p>
<pre class=" language-shell"><code class="language-shell"># 移动文件
## mv [-fiu] source destination
## mv [options] source1 source2 source3 .... directory
-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</code></pre>
</li>
</ol>
</li>
<li><p>修改权限</p>
<blockquote>
<p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 也可以使用符号来设定权限
## chmod [ugoa]  [+-=] [rwx] dirname/filename
- u：拥有者
- g：所属群组
- o：其他人
- a：所有人
- +：添加权限
- -：移除权限
- =：设定权限</code></pre>
</li>
<li><p>默认权限</p>
<blockquote>
<p>可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r–</p>
</blockquote>
<ul>
<li>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</li>
<li>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</li>
</ul>
</li>
<li><p>目录的权限</p>
<blockquote>
<p>文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。</p>
<p>目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了</p>
</blockquote>
</li>
<li><p>链接</p>
<pre class=" language-shell"><code class="language-shell">## ln [-sf] source_filename dist_filename
-s ：默认是实体链接，加 -s 为符号链接
-f ：如果目标文件存在时，先删除目标文件</code></pre>
<ul>
<li><p>实体链接</p>
<blockquote>
<p>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。</p>
<p>删除任意一个条目，文件还是存在，只要引用数量不为 0</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 有以下限制：不能跨越文件系统、不能对目录进行链接
## ln /etc/crontab .
## ll -i /etc/crontab crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab</code></pre>
</li>
<li><p>符号链接</p>
<blockquote>
<p>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。</p>
<p>当源文件被删除了，链接文件就打不开了。</p>
<p>因为记录的是路径，所以可以为目录建立符号链接</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">## ll -i /etc/crontab /root/crontab2
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -> /etc/crontab</code></pre>
</li>
</ul>
</li>
<li><p>获取文件内容</p>
<ol>
<li><p>cat</p>
<blockquote>
<p>取得文件内容</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">## cat [-AbEnTv] filename
-n ：打印出行号，连同空白行也会有行号，-b 不会</code></pre>
</li>
<li><p>tac</p>
<blockquote>
<p>是 cat 的反向操作，从最后一行开始打印</p>
</blockquote>
</li>
<li><p>more</p>
<blockquote>
<p>和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看</p>
</blockquote>
</li>
<li><p>less</p>
<blockquote>
<p>和 more 类似，但是多了一个向前翻页的功能</p>
</blockquote>
</li>
<li><p>head</p>
<blockquote>
<p>取得文件前几行</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">## head [-n number] filename
-n ：后面接数字，代表显示几行的意思</code></pre>
</li>
<li><p>tai</p>
<blockquote>
<p>是 head 的反向操作，只是取得是后几行</p>
</blockquote>
</li>
<li><p>od</p>
<blockquote>
<p>以字符或者十六进制的形式显示二进制文件</p>
</blockquote>
</li>
</ol>
</li>
<li><p>指令与文件搜索</p>
<ol>
<li><p>which</p>
<blockquote>
<p>指令搜索</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">## which [-a] command
-a ：将所有指令列出，而不是只列第一个</code></pre>
</li>
<li><p>whereis</p>
<blockquote>
<p>文件搜索。速度比较快，因为它只搜索几个特定的目录</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">## whereis [-bmsu] dirname/filename</code></pre>
</li>
<li><p>locate</p>
<blockquote>
<p>文件搜索。可以用关键字或者正则表达式进行搜索。</p>
<p>locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">## locate [-ir] keyword
-r：正则表达式</code></pre>
</li>
<li><p>find</p>
<blockquote>
<p>文件搜索。可以使用文件的属性和权限进行搜索</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">## find [basedir] [option]
example: find . -name "shadow*"

# 与时间有关的选项
-mtime  n ：列出在 n 天前的那一天修改过内容的文件
-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件
-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件
-newer file ： 列出比 file 更新的文件

# 与文件拥有者和所属群组有关的选项
-uid n
-gid n
-user name
-group name
-nouser ：搜索拥有者不存在 /etc/passwd 的文件
-nogroup：搜索所属群组不存在于 /etc/group 的文件

# 与文件权限和名称有关的选项
-name filename
-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k
-type TYPE
-perm mode  ：搜索权限等于 mode 的文件
-perm -mode ：搜索权限包含 mode 的文件
-perm /mode ：搜索权限包含任一 mode 的文件</code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="6-7-6-压缩与打包"><a href="#6-7-6-压缩与打包" class="headerlink" title="6.7.6 压缩与打包"></a>6.7.6 压缩与打包</h4><ol>
<li><p>压缩文件名</p>
<p>Linux 底下有很多压缩文件名，常见的如下：</p>
<table>
<thead>
<tr>
<th>扩展名</th>
<th>压缩程序</th>
</tr>
</thead>
<tbody><tr>
<td>*.Z</td>
<td>compress</td>
</tr>
<tr>
<td>*.zip</td>
<td>zip</td>
</tr>
<tr>
<td>*.gz</td>
<td>gzip</td>
</tr>
<tr>
<td>*.bz2</td>
<td>bzip2</td>
</tr>
<tr>
<td>*.xz</td>
<td>xz</td>
</tr>
<tr>
<td>*.tar</td>
<td>tar 程序打包的数据，没有经过压缩</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td>tar 程序打包的文件，经过 gzip 的压缩</td>
</tr>
<tr>
<td>*.tar.bz2</td>
<td>tar 程序打包的文件，经过 bzip2 的压缩</td>
</tr>
<tr>
<td>*.tar.xz</td>
<td>tar 程序打包的文件，经过 xz 的压缩</td>
</tr>
</tbody></table>
</li>
<li><p>压缩指令</p>
<ol>
<li><p>gzip</p>
<blockquote>
<p>gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。</p>
<p>经过 gzip 压缩过，源文件就不存在了。</p>
<p>有 9 个不同的压缩等级可以使用。</p>
<p>可以使用 zcat、zmore、zless 来读取压缩文件的内容</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">$ gzip [-cdtv#] filename
-c ：将压缩的数据输出到屏幕上
-d ：解压缩
-t ：检验压缩文件是否出错
-v ：显示压缩比等信息
-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6</code></pre>
</li>
<li><p>bzip2</p>
<blockquote>
<p>提供比 gzip 更高的压缩比。</p>
<p>查看命令：bzcat、bzmore、bzless、bzgrep</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">$ bzip2 [-cdkzv#] filename
-k ：保留源文件</code></pre>
</li>
<li><p>xz</p>
<blockquote>
<p>提供比 bzip2 更佳的压缩比。</p>
<p>可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。</p>
<p>查看命令：xzcat、xzmore、xzless、xzgrep</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">$ xz [-dtlkc#] filename</code></pre>
</li>
</ol>
</li>
<li><p>打包</p>
<blockquote>
<p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩
$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看
$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩
-z ：使用 zip；
-j ：使用 bzip2；
-J ：使用 xz；
-c ：新建打包文件；
-t ：查看打包文件里面有哪些文件；
-x ：解打包或解压缩的功能；
-v ：在压缩/解压缩的过程中，显示正在处理的文件名；
-f : filename：要处理的文件；
-C 目录 ： 在特定目录解压缩。</code></pre>
<table>
<thead>
<tr>
<th>使用方式</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>打包压缩</td>
<td>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</td>
</tr>
<tr>
<td>查 看</td>
<td>tar -jtv -f filename.tar.bz2</td>
</tr>
<tr>
<td>解压缩</td>
<td>tar -jxv -f filename.tar.bz2 -C 要解压缩的目录</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="6-7-7-Bash"><a href="#6-7-7-Bash" class="headerlink" title="6.7.7 Bash"></a>6.7.7 Bash</h4><blockquote>
<p>可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种</p>
</blockquote>
<ol>
<li><p>特性</p>
<ul>
<li>命令历史：记录使用过的命令</li>
<li>命令与文件补全：快捷键：tab</li>
<li>命名别名：例如 ll 是 ls -al 的别名</li>
<li>shell scripts</li>
<li>通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件</li>
</ul>
</li>
<li><p>变量操作</p>
<blockquote>
<p>对一个变量赋值直接使用 =。</p>
<p>对变量取用需要在变量前加上 $ ，也可以用 ​${} 的形式；</p>
<p>输出变量使用 echo 命令</p>
<p>变量内容如果有空格，必须使用双引号或者单引号。</p>
<ul>
<li>双引号内的特殊字符可以保留原本特性，例如 x=”lang is $LANG”，则 x 的值为 lang is zh_TW.UTF-8；</li>
<li>单引号内的特殊字符就是特殊字符本身，例如 x=’lang is $LANG’，则 x 的值为 lang is ​$LANG。</li>
</ul>
<p>可以使用 <code>指令</code> 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。</p>
<p>可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。</p>
<p>Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">$ x=abc
$ echo $x
$ echo ${x}

# 变量的声明使用 declare 命令
$ declare [-aixr] variable
-a ： 定义为数组类型
-i ： 定义为整数类型
-x ： 定义为环境变量
-r ： 定义为 readonly 类型

# 使用 [ ] 来对数组进行索引操作
$ array[1]=a
$ array[2]=b
$ echo ${array[1]}</code></pre>
</li>
<li><p>指令搜索顺序</p>
<ul>
<li>以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；</li>
<li>由别名找到该指令来执行；</li>
<li>由 Bash 内置的指令来执行；</li>
<li>按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行</li>
</ul>
</li>
<li><p>数据流重定向</p>
<blockquote>
<p>重定向指的是使用文件代替标准输入、标准输出和标准错误输出</p>
<p>其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。</p>
<p>可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱</p>
</blockquote>
<table>
<thead>
<tr>
<th>1</th>
<th>代码</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>标准输入 (stdin)</td>
<td>0</td>
<td>&lt; 或 &lt;&lt;</td>
</tr>
<tr>
<td>标准输出 (stdout)</td>
<td>1</td>
<td>&gt; 或 &gt;&gt;</td>
</tr>
<tr>
<td>标准错误输出 (stderr)</td>
<td>2</td>
<td>2&gt; 或 2&gt;&gt;</td>
</tr>
</tbody></table>
<pre class=" language-shell"><code class="language-shell"># 如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2>&1 表示将标准错误输出转换为标准输出
$ find /home -name .bashrc > list 2>&1</code></pre>
</li>
</ol>
<h4 id="6-7-8-管道指令"><a href="#6-7-8-管道指令" class="headerlink" title="6.7.8 管道指令"></a>6.7.8 管道指令</h4><blockquote>
<p>管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 令之间使用 | 分隔各个管道命令。
$ ls -al /etc | less</code></pre>
<ol>
<li><p>提取指令</p>
<blockquote>
<p>cut 对数据进行切分，取出想要的部分。</p>
<p>切分过程一行一行地进行</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">$ cut
-d ：分隔符
-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间
-c ：以字符为单位取出区间</code></pre>
</li>
<li><p>排序指令</p>
<blockquote>
<p>sort 用于排序</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">$ sort [-fbMnrtuk] [file or stdin]
-f ：忽略大小写
-b ：忽略最前面的空格
-M ：以月份的名字来排序，例如 JAN，DEC
-n ：使用数字
-r ：反向排序
-u ：相当于 unique，重复的内容只出现一次
-t ：分隔符，默认为 tab
-k ：指定排序的区间

# uniq 可以将重复的数据只取一个
$ uniq [-ic]
-i ：忽略大小写
-c ：进行计数</code></pre>
</li>
<li><p>双向输出重定向</p>
<blockquote>
<p>输出重定向会将输出内容重定向到文件中，而 <strong>tee</strong> 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">$ tee [-a] file</code></pre>
</li>
<li><p>字符转换指令</p>
<blockquote>
<p>tr 用来删除一行中的字符，或者对字符进行替换</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">$ tr [-ds] SET1 ...
-d ： 删除行中 SET1 这个字符串

# col 将 tab 字符转为空格字符
$ col [-xb]
-x ： 将 tab 键转换成对等的空格键

# expand 将 tab 转换一定数量的空格，默认是 8 个
$ expand [-t] file
-t ：tab 转为空格的数量

# join 将有相同数据的那一行合并在一起
$ join [-ti12] file1 file2
-t ：分隔符，默认为空格
-i ：忽略大小写的差异
-1 ：第一个文件所用的比较字段
-2 ：第二个文件所用的比较字段

# paste 直接将两行粘贴在一起
$ paste [-d] file1 file2
-d ：分隔符，默认为 tab</code></pre>
</li>
<li><p>分区指令</p>
<blockquote>
<p>split 将一个文件划分成多个文件</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">$ split [-bl] file PREFIX
-b ：以大小来进行分区，可加单位，例如 b, k, m 等
-l ：以行数来进行分区。
- PREFIX ：分区文件的前导名称</code></pre>
</li>
</ol>
<h4 id="6-7-9-正则表达式"><a href="#6-7-9-正则表达式" class="headerlink" title="6.7.9 正则表达式"></a>6.7.9 正则表达式</h4><ol>
<li><p>grep</p>
<pre class=" language-shell"><code class="language-shell"># g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印
$ grep [-acinv] [--color=auto] 搜寻字符串 filename
-c ： 统计匹配到行的个数
-i ： 忽略大小写
-n ： 输出行号
-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行
--color=auto ：找到的关键字加颜色显示</code></pre>
</li>
<li><p>printf</p>
<pre class=" language-shell"><code class="language-shell"># 用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式
$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt)
    DmTsai    80    60    92    77.33
     VBird    75    55    80    70.00
       Ken    60    90    70    73.33</code></pre>
</li>
<li><p>awk</p>
<blockquote>
<p>是由 Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。</p>
<p>awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，​$0 表示一整行</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $1 和 $3 就能取出这两个字段，然后用 print 进行打印
$ last -n 5
dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in
dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)
dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)
dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)
dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)

$ last -n 5 | awk '{print $1 "\t" $3}'
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   Fri

# 可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据
$ awk '条件类型 1 {动作 1} 条件类型 2 {动作 2} ...' filename</code></pre>
<p>awk 变量：</p>
<table>
<thead>
<tr>
<th>变量名称</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>NF</td>
<td>每一行拥有的字段总数</td>
</tr>
<tr>
<td>NR</td>
<td>目前所处理的是第几行数据</td>
</tr>
<tr>
<td>FS</td>
<td>目前的分隔字符，默认是空格键</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="6-7-10-进程管理"><a href="#6-7-10-进程管理" class="headerlink" title="6.7.10 进程管理"></a>6.7.10 进程管理</h4><ol>
<li><p>查看进程</p>
<ol>
<li><p>ps</p>
<blockquote>
<p>查看某个时间点的进程信息</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 查看特定的进程
## ps aux | grep threadx</code></pre>
</li>
<li><p>pstree</p>
<blockquote>
<p>查看进程树</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 查看所有进程树
## pstree -A</code></pre>
</li>
<li><p>top</p>
<pre class=" language-shell"><code class="language-shell"># 实时显示进程信息
## top -d 2 两秒钟刷新一次</code></pre>
</li>
<li><p>netstat</p>
<blockquote>
<p>查看占用端口的进程</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell"># 查看特定端口的进程
## netstat -anp | grep port</code></pre>
</li>
</ol>
</li>
<li><p>进程状态</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中。</td>
</tr>
<tr>
<td>D</td>
<td>uninterruptible sleep (usually I/O) 不可中断阻塞，通常为 IO 阻塞。</td>
</tr>
<tr>
<td>S</td>
<td>interruptible sleep (waiting for an event to complete)  可中断阻塞，此时进程正在等待某个事件完成。</td>
</tr>
<tr>
<td>Z</td>
<td>zombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息。</td>
</tr>
<tr>
<td>T</td>
<td>stopped (either by a job control signal or because it is being traced)  结束，进程既可以被作业控制信号结束，也可能是正在被追踪。</td>
</tr>
</tbody></table>
</li>
<li><p>SIGCHLD</p>
<blockquote>
<p>其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等</p>
<p>在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息</p>
</blockquote>
<p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p>
<ul>
<li>得到 SIGCHLD 信号；</li>
<li>waitpid() 或者 wait() 调用会返回。</li>
</ul>
</li>
<li><p>wait()</p>
<blockquote>
<p>父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。</p>
<p>如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。</p>
<p>参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">pid_t wait(int *status)</code></pre>
</li>
<li><p>waitpid()</p>
<blockquote>
<p>作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。</p>
<p>pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。</p>
<p>options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">pid_t waitpid(pid_t pid, int *status, int options)</code></pre>
</li>
<li><p>孤儿进程</p>
<blockquote>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p>
<p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p>
<p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p>
</blockquote>
</li>
<li><p>僵尸进程</p>
<blockquote>
<p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
<p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p>
<p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程</p>
</blockquote>
</li>
</ol>
<h2 id="7-编码规范"><a href="#7-编码规范" class="headerlink" title="7. 编码规范"></a>7. 编码规范</h2><h3 id="7-1-泛化规范"><a href="#7-1-泛化规范" class="headerlink" title="7.1 泛化规范"></a>7.1 泛化规范</h3><h3 id="7-2-阿里特约"><a href="#7-2-阿里特约" class="headerlink" title="7.2 阿里特约"></a>7.2 阿里特约</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">mjh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://codeofmjh.github.com/2018/07/13/0-javabase/">https://codeofmjh.github.com/2018/07/13/0-javabase/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://codeOfMjh.github.com" target="_blank">No weal without woe!</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E9%9B%86%E5%90%88/">集合</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2019/11/01/hello-world/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hello World</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/07/25/5-algorithm/" title="5.Algorithm"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-25</div><div class="title">5.Algorithm</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mjh</div><div class="author-info__description">С����·��</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E7%90%86%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">Java理论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">1. Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1.1 数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.1.2 缓存池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.1.3 字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">1.1.4 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">1.1.5 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-6-%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">1.1.6 对象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.7.</span> <span class="toc-text">1.1.7 面向对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-8-%E5%8F%8D%E5%B0%84"><span class="toc-number">1.1.1.8.</span> <span class="toc-text">1.1.8 反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-9-%E5%85%B6%E4%BB%96"><span class="toc-number">1.1.1.9.</span> <span class="toc-text">1.1.9 其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2 设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">1.2.3 源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-IO"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1.3.1 基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">1.3.2 基础操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%B9%B6%E5%8F%91-amp-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 并发&amp;多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1.4.1 使用线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">1.4.2 基础线程机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E4%B8%AD%E6%96%AD"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">1.4.3 中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">1.4.4 互斥同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-5-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">1.4.5 线程之间的协作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-6-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.4.6.</span> <span class="toc-text">1.4.6 线程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-7-J-U-C-AQS"><span class="toc-number">1.1.4.7.</span> <span class="toc-text">1.4.7 J.U.C - AQS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-8-J-U-C-%E5%85%B6%E5%AE%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.1.4.8.</span> <span class="toc-text">1.4.8 J.U.C - 其它组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-9-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.4.9.</span> <span class="toc-text">1.4.9 线程不安全示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-10-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.4.10.</span> <span class="toc-text">1.4.10 Java 内存模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-11-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.1.4.11.</span> <span class="toc-text">1.4.11 线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-12-%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.4.12.</span> <span class="toc-text">1.4.12 锁优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-13-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.4.13.</span> <span class="toc-text">1.4.13 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1.5.1 运行时数据区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">1.5.2 垃圾收集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">1.5.3 内存分配与回收策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">1.5.4 类加载机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.2.</span> <span class="toc-text">2. 数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2 并发一致性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E5%B0%81%E9%94%81"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">2.1.3 封锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">2.1.4 隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">2.1.5 多版本并发控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-6-Next-Key-Locks"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">2.1.6 Next-Key Locks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-7-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">2.1.7 关系数据库设计理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-8-ER-%E5%9B%BE"><span class="toc-number">1.2.1.8.</span> <span class="toc-text">2.1.8 ER 图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E8%A1%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 表的基础操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E8%A1%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3 表的高级操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E5%85%B6%E4%BB%96"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.2.4 其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%BB%83%E4%B9%A0"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-MySQL"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">2.4.1 索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.4.2 查询性能优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">2.4.3 存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">2.4.5 数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5-%E5%88%87%E5%88%86"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">2.4.5 切分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-6-%E5%A4%8D%E5%88%B6"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">2.4.6 复制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Redis"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">2.5.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2.5.2 数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">2.5.3 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">2.5.4 使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-5-Redis-%E4%B8%8E-Memcached"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">2.5.5 Redis 与 Memcached</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-6-%E9%94%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">2.5.6 键的过期时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-7-%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.5.7.</span> <span class="toc-text">2.5.7 数据淘汰策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-8-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.2.5.8.</span> <span class="toc-text">2.5.8 持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-9-%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.2.5.9.</span> <span class="toc-text">2.5.9 事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-10-%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.2.5.10.</span> <span class="toc-text">2.5.10 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-11-%E5%A4%8D%E5%88%B6"><span class="toc-number">1.2.5.11.</span> <span class="toc-text">2.5.11 复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-12-Sentinel"><span class="toc-number">1.2.5.12.</span> <span class="toc-text">2.5.12 Sentinel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-13-%E5%88%86%E7%89%87"><span class="toc-number">1.2.5.13.</span> <span class="toc-text">2.5.13 分片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-14-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BA%E5%9D%9B%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90"><span class="toc-number">1.2.5.14.</span> <span class="toc-text">2.5.14 一个简单的论坛系统分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-Oracle"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6 Oracle</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.</span> <span class="toc-text">3. 系统设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 分布式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">3.2.1 分布式锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">3.2.2 分布式事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-CAP"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3.2.3 CAP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-BASE"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">3.2.4 BASE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-Paxos"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">3.2.5 Paxos</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-6-Raft"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">3.2.6 Raft</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%9B%86%E7%BE%A4"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.3.1 负载均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%9A%84-Session-%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.3.2 集群下的 Session 管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%BC%93%E5%AD%98"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Docker"><span class="toc-number">1.3.5.</span> <span class="toc-text">4.2 Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7"><span class="toc-number">1.3.6.</span> <span class="toc-text">4.3 构建工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%AD%A3%E5%88%99"><span class="toc-number">1.3.7.</span> <span class="toc-text">4.4 正则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BD%91%E7%BB%9C"><span class="toc-number">1.4.</span> <span class="toc-text">5. 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.4.1.</span> <span class="toc-text">5.1 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">5.1.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">5.1.2 物理层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">5.1.3 链路层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-4-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">5.1.4 网络层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-5-%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">5.1.5 传输层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-6-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">5.1.6 应用层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-HTTP"><span class="toc-number">1.4.2.</span> <span class="toc-text">5.2 HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">5.2.1 基础概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">5.2.2 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">5.2.3 HTTP 状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-HTTP-%E9%A6%96%E9%83%A8"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">5.2.4 HTTP 首部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-5-%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">5.2.5 具体应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-6-HTTPS"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">5.2.6 HTTPS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-7-HTTP-2-0"><span class="toc-number">1.4.2.7.</span> <span class="toc-text">5.2.7 HTTP&#x2F;2.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-8-HTTP-1-1-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.2.8.</span> <span class="toc-text">5.2.8 HTTP&#x2F;1.1 新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-9-GET-%E5%92%8C-POST-%E6%AF%94%E8%BE%83"><span class="toc-number">1.4.2.9.</span> <span class="toc-text">5.2.9 GET 和 POST 比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Socket"><span class="toc-number">1.4.3.</span> <span class="toc-text">5.3 Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-I-O-%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">5.3.1 I&#x2F;O 模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-I-O-%E5%A4%8D%E7%94%A8"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">5.3.2 I&#x2F;O 复用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.</span> <span class="toc-text">6. 操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.5.1.</span> <span class="toc-text">6.1 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.2.</span> <span class="toc-text">6.2 进程管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.3.</span> <span class="toc-text">6.3 内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%AD%BB%E9%94%81"><span class="toc-number">1.5.4.</span> <span class="toc-text">6.4 死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.5.</span> <span class="toc-text">6.5 设备管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E9%93%BE%E6%8E%A5"><span class="toc-number">1.5.6.</span> <span class="toc-text">6.6 链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-Linux"><span class="toc-number">1.5.7.</span> <span class="toc-text">6.7 Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-1-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">6.7.1 常用操作以及概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-%E7%A3%81%E7%9B%98"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">6.7.2 磁盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-%E5%88%86%E5%8C%BA"><span class="toc-number">1.5.7.3.</span> <span class="toc-text">6.7.3 分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.7.4.</span> <span class="toc-text">6.7.4 文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-5-%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.7.5.</span> <span class="toc-text">6.7.5 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-6-%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85"><span class="toc-number">1.5.7.6.</span> <span class="toc-text">6.7.6 压缩与打包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-7-Bash"><span class="toc-number">1.5.7.7.</span> <span class="toc-text">6.7.7 Bash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-8-%E7%AE%A1%E9%81%93%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.7.8.</span> <span class="toc-text">6.7.8 管道指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-9-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.5.7.9.</span> <span class="toc-text">6.7.9 正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-10-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.7.10.</span> <span class="toc-text">6.7.10 进程管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-number">1.6.</span> <span class="toc-text">7. 编码规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%B3%9B%E5%8C%96%E8%A7%84%E8%8C%83"><span class="toc-number">1.6.1.</span> <span class="toc-text">7.1 泛化规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E9%98%BF%E9%87%8C%E7%89%B9%E7%BA%A6"><span class="toc-number">1.6.2.</span> <span class="toc-text">7.2 阿里特约</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/09/1-mkjavaprojectnotes-five/" title="容器化—docker&amp;K8S"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="容器化—docker&amp;K8S"/></a><div class="content"><a class="title" href="/2022/01/09/1-mkjavaprojectnotes-five/" title="容器化—docker&amp;K8S">容器化—docker&amp;K8S</a><time datetime="2022-01-09T03:24:37.000Z" title="发表于 2022-01-09 11:24:37">2022-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/09/1-mkjavaprojectnotes-four/" title="基于SpringCloud改造微服务"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于SpringCloud改造微服务"/></a><div class="content"><a class="title" href="/2022/01/09/1-mkjavaprojectnotes-four/" title="基于SpringCloud改造微服务">基于SpringCloud改造微服务</a><time datetime="2022-01-09T03:24:37.000Z" title="发表于 2022-01-09 11:24:37">2022-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/09/1-mkjavaprojectnotes-six/" title="网络通信和性能调优"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络通信和性能调优"/></a><div class="content"><a class="title" href="/2022/01/09/1-mkjavaprojectnotes-six/" title="网络通信和性能调优">网络通信和性能调优</a><time datetime="2022-01-09T03:24:37.000Z" title="发表于 2022-01-09 11:24:37">2022-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/09/1-mkjavaprojectnotes-three/" title="分布式技术要点"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式技术要点"/></a><div class="content"><a class="title" href="/2022/01/09/1-mkjavaprojectnotes-three/" title="分布式技术要点">分布式技术要点</a><time datetime="2022-01-09T03:24:37.000Z" title="发表于 2022-01-09 11:24:37">2022-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/09/1-mkjavaprojectnotes-two/" title="集群式高可用"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="集群式高可用"/></a><div class="content"><a class="title" href="/2022/01/09/1-mkjavaprojectnotes-two/" title="集群式高可用">集群式高可用</a><time datetime="2022-01-09T03:24:37.000Z" title="发表于 2022-01-09 11:24:37">2022-01-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By mjh</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=i;var e=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}i(),n.addEventListener("scroll",function(){var t,e;t=i,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>