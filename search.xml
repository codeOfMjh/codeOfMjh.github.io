<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>5.DataStructureAndAlgorithm</title>
      <link href="2020/12/20/5-datastructureandalgorithm/"/>
      <url>2020/12/20/5-datastructureandalgorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><div style="display:none;">1. 方式   1. 三分理解，七分练习   2. 思考本质，大道至简(太极)   3. 刻意练习，坚持不懈2. 评价   1. 找重复，简算法   2. 优秀的算法介于10-20-30行左右3. 明确核心竞争力—刻意练习后形成的条件反射能力   1. 阶段性总结   2. 注重内功(算法)心法(设计模式)   3. 明确短板(算法，数据结构，设计模式，英语)4. 工作目标(核心竞争力)   1. 业务能力(逐日积累)   2. 技术能力(借外力更快)   3. 管理能力5. 做事和工作   1. 一定要==多问自己为什么==6. 领域学习   1. 将知识分块学习精确控制   2. 知识点辅以练习   3. 定期反馈知识点掌握程度   4. 循环已掌握和未掌握知识点练习和学习新知并行   5. 做到每次复习越来越多，学习越来越少   6. 任务量控制在可执行范围   7. 练习次数和薄弱项7. 反馈   1. 主动反馈      1. 高手代码-github，leetcode，etc      2. 第一视角直播   2. 被动式反馈      1. code review      2. 高手点评8. 系统化思考题目   1. 正确的理解题意   2. 想所有可能的解法择最优   3. 编写代码   4. 列举测试样例9. 刷题   1. 一刷      1. 10-15分不能解直接看答案      2. 背诵，默写好的解法   2. 二刷      1. 立刻自己写      2. 找到最优解，领先80%-90%   3. 三刷      1. 第二天重复做之前的题目      2. 明确不同解法的熟练度      3. 对于不熟悉的解法进行刻意练习   4. 四刷      1. 一周之后在进行重复练习      2. 对于不熟悉的解法进行刻意练习   5. 面试前再次刷题(五刷)10. 职业练习    1. 拆分知识点，刻意练习，反馈11. 解题    1. 和面试官交流充分理解题意    2. 思考解法，选择一种最优的解法    3. 开始编码    4. 测试代码</div><h3 id="1-2-时间复杂度"><a href="#1-2-时间复杂度" class="headerlink" title="1.2 时间复杂度"></a>1.2 时间复杂度</h3><ol><li><p>算法分类</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/01.%E7%AE%97%E6%B3%95.png" alt="算法"></p></li><li><p>数据结构</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="数据结构"></p></li><li><p>环境设置与准备</p><ol><li><p>win：<code>https://github.com/microsoft/terminal</code></p></li><li><p>vscode搭建</p></li><li><p>做题以中文站为主：<code>https://leetcode-cn.com/</code></p></li><li><p>学习进步以外站为主：<code>https://leetcode.com/</code>-most votes</p></li><li><p>注意编码规范</p></li><li><p>操作</p><ol><li><code>home</code>，<code>end</code></li><li>选单词，选整行</li></ol></li><li><p>自顶向下的编程方式</p><blockquote><p>先高层次(主干)逻辑为主；其次辅以附加(次要)逻辑</p></blockquote></li></ol></li><li><p>时空复杂度</p><ol><li><p>时间复杂度</p><ol><li><p>常见的时间复杂度</p><table><thead><tr><th>时间复杂度</th><th>类型</th></tr></thead><tbody><tr><td><code>O(1)</code></td><td>常数阶</td></tr><tr><td><code>O(log n)</code></td><td>对数阶</td></tr><tr><td><code>O(n)</code></td><td>线性阶</td></tr><tr><td><code>O(n^2)</code></td><td>平方阶</td></tr><tr><td><code>O(n^3)</code></td><td>立方阶</td></tr><tr><td><code>O(2^n)</code></td><td>指数阶</td></tr><tr><td><code>O(n!)</code></td><td>阶乘</td></tr></tbody></table></li><li><p>只看最高(最坏的情况)时间复杂度，不考虑常数系数(图像伸缩变化，不影响斜率)的影响</p></li><li><p>图形表示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/03.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="时间复杂度"></p></li><li><p>非线性时间复杂度</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/04.%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="非线性时间复杂度"></p></li><li><p>二叉树的三种遍历方式的时间复杂度都是<code>O(n)</code>；每个节点有且仅访问一次，所以时间复杂度线性于二叉树的节点总数；n是二叉树的节点总数</p></li><li><p>图的遍历时间复杂度也是<code>O(n)</code>；因为每个节点有且仅访问一次；n是图的节点总数</p></li><li><p><code>DFS</code>(深度优先)和<code>BFS</code>(广度优先)的时间复杂度；同样的每个节点仅访问一次，所以时间复杂度是<code>O(n)</code></p></li><li><p>二分查找的时间复杂度是<code>log n</code></p></li></ol></li><li><p>空间复杂度</p></li></ol></li></ol><h2 id="2-线性结构"><a href="#2-线性结构" class="headerlink" title="2. 线性结构"></a>2. 线性结构</h2><h3 id="2-1-数组和链表"><a href="#2-1-数组和链表" class="headerlink" title="2.1 数组和链表"></a>2.1 数组和链表</h3><ol><li><p>高级数据语言</p><ol><li>对于数组的元素不做类型限制，称之为泛型</li></ol></li><li><p>内存管理器</p><blockquote><p>为创建的数组元素分配对应的地址值</p></blockquote></li><li><p>数组</p><blockquote><p>元素依靠索引相互关联</p></blockquote><ol><li>查询快<code>O(1)</code></li><li>增删慢<code>O(n)</code></li></ol></li><li><p>单链表</p><blockquote><p>仅有一个前驱指针指向下一个元素</p></blockquote></li><li><p>循环链表</p><blockquote><p>将单链表的最后一个指针指向头结点</p></blockquote></li><li><p>双向链表(Java中的链表)</p><blockquote><p>每一个元素都有前驱指针和后驱指针来指向相邻元素</p></blockquote><ol><li>查询慢<code>O(n)</code></li><li>增删快<code>O(1)</code></li><li>应用于LRU Cache(最近最少使用)</li></ol></li><li><p>小结数组链表的时间复杂度</p><table><thead><tr><th>类型</th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>前追加</td><td><code>O(n)</code>–&gt;<code>O(1)</code></td><td><code>O(1)</code></td></tr><tr><td>后追加</td><td><code>O(1)</code></td><td><code>O(1)</code></td></tr><tr><td>随机访问</td><td><code>O(1)</code></td><td><code>O(n)</code></td></tr><tr><td>添加</td><td><code>O(n)</code></td><td><code>O(1)</code></td></tr><tr><td>删除</td><td><code>O(n)</code></td><td><code>O(1)</code></td></tr></tbody></table></li></ol><h3 id="2-2-跳表-skip-list"><a href="#2-2-跳表-skip-list" class="headerlink" title="2.2 跳表(skip list)"></a>2.2 跳表(skip list)</h3><ol><li><p>主要应用于redis</p></li><li><p>链表到跳表的改进</p><blockquote><p>主要思想就是进行维度升级(即就是空间换时间)</p></blockquote><ol><li>方式：增加多级索引<ol><li>增加索引的级数：log 2n；n为链表长度 </li></ol></li></ol></li><li><p>时间复杂度</p><ol><li><code>log n</code>（增删查一致）</li></ol></li><li><p>空间复杂度</p><ol><li>O(n)</li></ol></li></ol><h3 id="2-3-数组，链表和跳表应用"><a href="#2-3-数组，链表和跳表应用" class="headerlink" title="2.3 数组，链表和跳表应用"></a>2.3 数组，链表和跳表应用</h3><ol><li><p>数组(移动零)</p><p>题述：给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre><p>说明：</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 1. 移除零元素</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非零元素的索引</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums<span class="token punctuation">[</span>count<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 2. 添加零元素</span><span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    nums<span class="token punctuation">[</span>count<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>数组(装水最多的容器)</p><p>题述：给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</code></pre><p>提示：</p><pre class=" language-text"><code class="language-text">n = height.length2 <= n <= 3 * 1040 <= height[i] <= 3 * 104</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 枚举：left bar l &amp; right bar r ：(r-l)*height_diff(这里的diff是差分)，时间复杂度是O(n^2)</span><span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化最大面积值</span><span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化当前面积值</span><span class="token comment" spellcheck="true">// 外层循环遍历左边界，内循环遍历右边界</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 选取左右边界的最小高作为当前矩形高，并计算左右边界差作为当前矩形长</span>        <span class="token comment" spellcheck="true">// 由此计算当前矩形面积</span>        area <span class="token operator">=</span> <span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">*</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 始终将最大的面积值存放在max变量</span>        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span>area<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 返回最大面积</span><span class="token keyword">return</span> max<span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Description // 双向交叉计算矩形面积取最大值 **/</span><span class="token comment" spellcheck="true">// 初始最大面积值</span><span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化右边界</span><span class="token keyword">int</span> right <span class="token operator">=</span> height<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化左边界</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化当前面积</span><span class="token keyword">int</span> area<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">!=</span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果右边界的高度值大于左边界</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 则当前面积为左边界的高*左右边界之差</span>        area <span class="token operator">=</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 左边界向前走</span>        left <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 否则当前面积为右边界的高*左右边界之差</span>        area <span class="token operator">=</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 右边界向后走(以数组索引递增为正方向)</span>        right <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回最大值的面积值</span>    max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> area<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 返回最大面积</span><span class="token keyword">return</span> max<span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用三元运算符简化最优解</span><span class="token comment" spellcheck="true">// 初始最大面积值</span><span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化右边界</span><span class="token keyword">int</span> right <span class="token operator">=</span> height<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化左边界</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化当前面积</span><span class="token keyword">int</span> area<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">!=</span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计算最小高度，注意这里返回的是left+1和right-1处的高度值</span>    <span class="token keyword">int</span> minHeight <span class="token operator">=</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">?</span> height<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> height<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里+1是补加left和left+1间的矩形面积，同样也是补加right和right-1之间的面积值(谁小补谁)</span>    area <span class="token operator">=</span> minHeight <span class="token operator">*</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> area<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 返回最大面积</span><span class="token keyword">return</span> max<span class="token punctuation">;</span></code></pre></li><li><p>数组(爬楼梯)-70题</p><p>题述：假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1.  1 阶 + 1 阶2.  2 阶</code></pre><pre class=" language-text"><code class="language-text">输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1.  1 阶 + 1 阶 + 1 阶2.  1 阶 + 2 阶3.  2 阶 + 1 阶</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 没思路，先考虑简单情况 --> 泛化(数学归纳法)找到递推公式(找重复)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 1个台阶的方法数</span><span class="token keyword">int</span> one_step_before <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 2个台阶的方法数</span><span class="token keyword">int</span> two_steps_before <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当前台阶总方法数</span><span class="token keyword">int</span> all_ways <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 更新方法数</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    all_ways <span class="token operator">=</span> one_step_before <span class="token operator">+</span> two_steps_before<span class="token punctuation">;</span>    one_step_before <span class="token operator">=</span> two_steps_before<span class="token punctuation">;</span>    two_steps_before <span class="token operator">=</span> all_ways<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 返回指定数字的方法数</span><span class="token keyword">return</span> all_ways<span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        a <span class="token operator">=</span> <span class="token punctuation">(</span>b <span class="token operator">+=</span> a<span class="token punctuation">)</span> <span class="token operator">-</span> a<span class="token punctuation">;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>数组(三数之和)—高频老题</p><p>题述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意</strong>：答案中不可以包含重复的三元组。</p><p>示例：</p><pre class=" language-text"><code class="language-text">给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[  [-1, 0, 1],  [-1, -1, 2]]</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 暴力解法，依次枚举三个数求和，和为0则添加至结果集，有重复则跳出本次循环</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">threeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> sum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历寻找第1个数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 遍历寻找第2个数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 遍历寻找第3个数</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果三个数的和相加等于0；则将三数添加至sum数组</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 如果结果集已有该和为零的序列，则结束本次循环；继续下一次</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>sum<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 为结果集合添加符合要求的数组</span>                    sum<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回最终的结果集</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 双指针解法</span><span class="token comment" spellcheck="true">// 对原始数组进行排序</span>Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化结果集</span>List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 枚举所有的变量</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果当前变量是第一个元素或者相邻两数和不为0，则开始双端遍历</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 左端遍历起点</span>        <span class="token keyword">int</span> lo <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 右端遍历起点</span>        <span class="token keyword">int</span> hi <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化目标值</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果左端序列比右端序列小则一直进行查找</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>lo <span class="token operator">&lt;</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果在左右端找出和为sum的值即将目标值，左端值，右端值添加到结果集合</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">==</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 将符合条件的目标值，左端值和右端值添加至结果集</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>hi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果左端序列小于右端序列；且；左端值等于左端序列之前的值就跳过该序列</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>lo <span class="token operator">&lt;</span> hi <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>lo <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    lo<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 如果左端序列小于右端序列；且；右端值等于右端序列之后的值就跳过该序列</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>lo <span class="token operator">&lt;</span> hi <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>hi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    hi<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 左端序列递增</span>                lo<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 右端序列递减</span>                hi<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">&lt;</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 如果三数和小于0，则继续向前找左端值</span>                lo<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 如果三数和大于0，则继续向后找右端值</span>                hi<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 返回最终的结果集</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span></code></pre></li><li><p>链表</p><ol><li>暴力解法</li><li>快慢指针</li></ol></li><li><p>链表(反转链表)</p><p>题述：反转一个单链表</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: 1->2->3->4->5->NULL输出: 5->4->3->2->1->NULL</code></pre><p>附加：你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化前驱节点</span>    ListNode prevHead <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果头结点不为null</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 记录头结点的指针</span>        ListNode recordNext <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将头结点的指针指向前驱节点</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> prevHead<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将头结点和前驱节点值交换</span>        prevHead <span class="token operator">=</span> head<span class="token punctuation">;</span>        head <span class="token operator">=</span> recordNext<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回最新链表</span>    <span class="token keyword">return</span> prevHead<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法一</span><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">reverseListInt</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> ListNode <span class="token function">reverseListInt</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> ListNode newHead<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果头结点的指针指向null说明链表翻转完成，则返回反转后的链表</span>        <span class="token keyword">return</span> newHead<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 交换头结点和前驱节点的值</span>    ListNode next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> newHead<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将交换后的指针和头结点再次进行交换；直到头结点的指针指向null后返回最新链表</span>    <span class="token keyword">return</span> <span class="token function">reverseListInt</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法二</span><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果头结点的指针指向null说明链表翻转完成，则返回反转后的链表</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 交换头结点和递归交换前驱节点的值</span>    ListNode nextNode <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    ListNode newHead <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将前驱节点的指针指向头结点</span>    nextNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将头结点的指针指向null</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回最新的链表</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>链表(两两交换链表中的节点)</p><p>题述：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/05.%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9.jpg" alt="交换链表节点"></p><pre class=" language-text"><code class="language-text">输入：head = [1,2,3,4]输出：[2,1,4,3]输入：head = []输出：[]输入：head = [1]输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span><span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 记录头结点指针的位置</span>    ListNode prevHead <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 递归将头节点的指针指向头结点指针的指针</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将前驱元素的指针指向头结点</span>    prevHead<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回最新链表</span>    <span class="token keyword">return</span> prevHead<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">algorithm</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将链表的指针指向头结点</span>    dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 记录当前链表</span>    ListNode current <span class="token operator">=</span> dummy<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果当前链表的指针不为null且者前驱元素的指针不为null</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 记录头结点的指针</span>        ListNode first <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 记录头结点前驱元素的指针</span>        ListNode second <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将头结点前驱元素的指针指向头结点前驱的前驱的指针</span>        first<span class="token punctuation">.</span>next <span class="token operator">=</span> second<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将头结点的指针指向头结点前驱元素的指针</span>        current<span class="token punctuation">.</span>next <span class="token operator">=</span> second<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将头结点前去元素的指针指向头结点的指针</span>        current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将当前链表指向头结点前去元素的指针</span>        current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回头结点前驱元素的指针</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>链表(环形链表)</p><p>题述：给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>附加：</p><p>你能用 *O(1)*（即，常量）内存解决此问题吗？</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/06.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A81.png" alt="环形链表1"></p><pre class=" language-text"><code class="language-text">输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/07.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82.png" alt="环形链表2"></p><pre class=" language-text"><code class="language-text">输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/08.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A83.png" alt="环形链表3"></p><pre class=" language-text"><code class="language-text">输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><p>题解：</p><ol><li>使用两个指针，一个快指针，一个慢指针</li><li>慢指针一次走一步，快指针一次走两步</li><li>当快慢指针指向同一个元素说明有环存在，否则无环存在</li></ol><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 快慢指针解法</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化慢指针</span>    ListNode walker <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化快指针</span>    ListNode runner <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果快指针不指向null且快指针的前驱指针不为null</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>runner<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> runner<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将慢指针指向他的前驱指针</span>        walker <span class="token operator">=</span> walker<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将快指针指向他的前驱指针</span>        runner <span class="token operator">=</span> runner<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果快慢指针指向同一个元素说明有环存在</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>walker <span class="token operator">==</span> runner<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 快慢指针指向不是同一个元素</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre></li><li><p>链表(环形链表 II)</p><p>题述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以使用 O(1) 空间解决此题？</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/06.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A81.png" alt="环形链表1"></p><pre class=" language-text"><code class="language-text">输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/07.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82.png" alt="环形链表2"></p><pre class=" language-text"><code class="language-text">输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/08.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A83.png" alt="环形链表3"></p><pre class=" language-text"><code class="language-text">输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化慢指针</span>    ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化快指针</span>    ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果快指针不指向null且快指针的前驱指针不为null</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将慢指针指向其前驱的指针</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将快指针指向前驱的前驱</span>        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果快慢指针相遇，则说明链表有环</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果慢指针没有指向头结点</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 就一直往前走</span>                slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 将头结点指向自身</span>                head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 返回头结点</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>链表(K 个一组翻转链表)</p><p>题述：给你一个链表，<strong>每 k 个节点一组进行翻转</strong>，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/12.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A81.jpg" alt="翻转链表1"></p><pre class=" language-text"><code class="language-text">输入: head = [1,2,3,4,5], k = 2输出: [2,1,4,3,5]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/13.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A82.jpg" alt="翻转链表2"></p><pre class=" language-text"><code class="language-text">输入: head = [1,2,3,4,5], k = 3输出: [3,2,1,4,5]输入: head = [1,2,3,4,5], k = 1输出: [1,2,3,4,5]输入: head = [1], k = 1输出: [1]</code></pre><p><strong>说明：</strong></p><ul><li>你的算法只能使用常数的额外空间。</li><li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li></ul><p><strong>提示</strong>：</p><ol><li>列表中节点的范围是<code>sz</code>.</li><li><code>1 &lt;= sz &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= sz</code></li></ol><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span><span class="token keyword">public</span> ListNode <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> count <span class="token operator">!=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// find the k+1 node</span>        curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// if k+1 node is found</span>        curr <span class="token operator">=</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// reverse list with k+1 node as head</span>        <span class="token comment" spellcheck="true">// head - head-pointer to direct part, </span>        <span class="token comment" spellcheck="true">// curr - head-pointer to reversed part;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// reverse current k-group:</span>            ListNode tmp <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// tmp - next head in direct part</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> curr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// preappending "direct" head to the reversed list</span>            curr <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// move head of reversed part to a new node</span>            head <span class="token operator">=</span> tmp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// move "direct" head to the next node in direct part</span>        <span class="token punctuation">}</span>        head <span class="token operator">=</span> curr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">public</span> ListNode <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ListNode i <span class="token operator">=</span> head<span class="token punctuation">;</span> i <span class="token operator">!=</span> null<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">,</span> i <span class="token operator">=</span> i<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode dmy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dmy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>ListNode prev <span class="token operator">=</span> dmy<span class="token punctuation">,</span> tail <span class="token operator">=</span> head<span class="token punctuation">;</span> n <span class="token operator">>=</span> k<span class="token punctuation">;</span> n <span class="token operator">-=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode next <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            tail<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            tail<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        prev <span class="token operator">=</span> tail<span class="token punctuation">;</span>        tail <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dmy<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 推荐解法</span><span class="token keyword">public</span> ListNode <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化开始节点</span>    ListNode begin<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果头结点的值或头结点的前驱元素不为null或者一个元素为一组反转</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">==</span>null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span>null <span class="token operator">||</span> k<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接返回当前链表</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化头结点的后驱元素</span>    ListNode dummyhead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将头结点后驱元素的指针指向头结点</span>    dummyhead<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将头结点的后驱元素赋给开始节点</span>    begin <span class="token operator">=</span> dummyhead<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化计数器</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果头节点不为null</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 计数器递增</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将计数器值对分组值取余，刚好除尽就进行反转操作</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">%</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将头结点元素和头结点的后驱元素进行位置调换</span>            begin <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将当前链表指向头结点元素</span>            head <span class="token operator">=</span> begin<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将当前链表指向头结点元素</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回开始节点的指针</span>    <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 反转链表</span><span class="token keyword">public</span> ListNode <span class="token function">reverse</span><span class="token punctuation">(</span>ListNode begin<span class="token punctuation">,</span> ListNode end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将开始元素的指针记录</span>    ListNode curr <span class="token operator">=</span> begin<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义两个链表</span>    ListNode next<span class="token punctuation">,</span> first<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将开始元素赋记录</span>    ListNode prev <span class="token operator">=</span> begin<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将开始元素的指针指向反转后的链表</span>    first <span class="token operator">=</span> curr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果反转链表的值和原始链表的结束值不一致，就一直进行交换操作</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token operator">!=</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将反转链表的指针指向原始链表</span>        next <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将反转链表的指针指向开始元素的值</span>        curr<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用反转链表替换原始元素</span>        prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用原始链表替换反转链表</span>        curr <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将开始元素的指针指向最终的元素</span>    begin<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将反转链表的指针指向开始元素的值</span>    first<span class="token punctuation">.</span>next <span class="token operator">=</span> curr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回最终的反转链表</span>    <span class="token keyword">return</span> first<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="2-4-练习"><a href="#2-4-练习" class="headerlink" title="2.4 练习"></a>2.4 练习</h3><ol><li><p>删除排序数组中的重复项</p><p>题述：给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例：</p><pre class=" language-text"><code class="language-text">给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><pre class=" language-text"><code class="language-text">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i < len; i++) {    print(nums[i]);}</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 简单解法</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化重复数字的计数器</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取数组的长度</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历数组拿出每一个元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果当前元素和上一个元素一致，则计数器值+1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 否则将当前元素赋给去重后的最新索引位置的值</span>            nums<span class="token punctuation">[</span>i <span class="token operator">-</span> count<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回最新的数组长度</span>    <span class="token keyword">return</span> len <span class="token operator">-</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Time O(n), Space O(1)</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取数组长度</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果长度小于2直接返回当前数组的长度</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> len<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化非重数组长度计数器</span>    <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历拿出数组中的每一个元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果当前元素和上一个元素相等就将当前元素记录在非重复数组中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>id<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回非重复元素数组的长度</span>    <span class="token keyword">return</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代器遍历最简形式</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化非重数组的长度</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历数组</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 如果当前元素和上一个元素不相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">></span> nums<span class="token punctuation">[</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 就将非重数组索引递增来存储当前元素</span>            nums<span class="token punctuation">[</span>length<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回非重数组的长度</span>    <span class="token keyword">return</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>旋转数组</p><p>题述：给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]</code></pre><p><strong>说明:</strong></p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的<strong>原地</strong>算法。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取k的索引值</span>    k <span class="token operator">%=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 执行旋转</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 旋转数组</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 记录开始位置的值</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将结束位置的值赋给开始位置</span>        nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将开始位置的值赋给结束位置</span>        nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 开始序列递增</span>        start<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 结束序列递减</span>        end<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>合并两个有序链表</p><p>题述：将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/14.%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.jpg" alt="合并有序链表"></p><pre class=" language-text"><code class="language-text">输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]输入：l1 = [], l2 = []输出：[]输入：l1 = [], l2 = [0]输出：[0]</code></pre><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span><span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果链表1为null就返回链表2,如果链表2为null就返回链表1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null <span class="token operator">||</span> l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> l2 <span class="token operator">==</span> null <span class="token operator">?</span> l1 <span class="token operator">:</span> l2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果链表1的值小于链表2的值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将链表1的指针指向链表2</span>        l1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 返回链表1</span>        <span class="token keyword">return</span> l1<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 否则将链表2的指针指向链表1</span>        l2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 返回链表2</span>        <span class="token keyword">return</span> l2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果链表1为null就返回链表2,如果链表2为null就返回链表1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> l2<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> l1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化开始节点</span>    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将开始节点存入当前链表</span>    ListNode curr <span class="token operator">=</span> dummy<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果两个链表都不为null，就对链表的值进行判断</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果链表1的值小于链表2的值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 就将当前链表的指针指向链表1</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将链表1的指针指向链表1</span>            l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 否则将当前链表的指针指向链表2</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将链表2的指针指向链表2</span>            l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将当前链表的指针指向当前链表</span>        curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果当前链表的指针指向链表1且为null就指向链表2，否则指向链表1</span>    curr<span class="token punctuation">.</span>next <span class="token operator">=</span> l1 <span class="token operator">==</span> null <span class="token operator">?</span> l2 <span class="token operator">:</span> l1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回开始元素指针指向的链表</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>合并两个有序数组</p><p>题述：给你两个有序整数数组 <em>nums1</em> 和 <em>nums2</em>，请你将 <em>nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使 <em>nums1</em> 成为一个有序数组。</p><p>示例：</p><pre class=" language-java"><code class="language-java">输入：nums1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token number">3</span>nums2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       n <span class="token operator">=</span> <span class="token number">3</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>输入：nums1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>             m <span class="token operator">=</span> <span class="token number">1</span>nums2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            n <span class="token operator">=</span> <span class="token number">0</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre><p>说明：</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p><p>提示：</p><p><code>0 &lt;= m, n &lt;= 200</code><br><code>1 &lt;= m + n &lt;= 200</code><br><code>nums1.length == m + n</code><br><code>nums2.length == n</code><br><code>-109 &lt;= nums1[i], nums2[i] &lt;= 109</code></p><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// AC解法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 记录数组1的末尾元素索引</span>    <span class="token keyword">int</span> endOne <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 记录数组2的末尾元素索引</span>    <span class="token keyword">int</span> endTwo <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 记录数组1和数组2衔接处的索引</span>    <span class="token keyword">int</span> midpoint <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果两个数组的起始索引都大于零</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>endOne <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> endTwo <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果数组1的末尾元素比数组2的大</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>endOne<span class="token punctuation">]</span> <span class="token operator">></span> nums2<span class="token punctuation">[</span>endTwo<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 说明数组1的最大值是整个数组的最大值，所以将相邻之前的元素赋值给衔接处之前的位置</span>            nums1<span class="token punctuation">[</span>midpoint<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>endOne<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 否则将数组2之前的元素赋给衔接处之前的位置</span>            nums1<span class="token punctuation">[</span>midpoint<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>endTwo<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果数组2的末尾索引一直大于0</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>endTwo <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 就依次将该所引之前的元素赋给数组1</span>        nums1<span class="token punctuation">[</span>midpoint<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>endTwo<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 简单解法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> nums2<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">:</span> nums1<span class="token punctuation">[</span>i<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 最佳解法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化三个节点的索引，数组1的末尾索引，数组1和数组2衔接处索引，数组2的末尾索引</span>    <span class="token keyword">int</span> tail1 <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> tail2 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> finished <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果数组1和数组2的末端索引值一直大于等于0</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>tail1 <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tail2 <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果数组1末端值大于数组2末端值，则将数组1的末端值赋值给数组衔接处，否则将数组2的末端值赋值给衔接处，总是保证最后一个元素最大</span>        nums1<span class="token punctuation">[</span>finished<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>tail1<span class="token punctuation">]</span> <span class="token operator">></span> nums2<span class="token punctuation">[</span>tail2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span>            nums1<span class="token punctuation">[</span>tail1<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">:</span> nums2<span class="token punctuation">[</span>tail2<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 单独处理数组2，将数组2拼接到后面</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>tail2 <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//only need to combine with remaining nums2</span>        nums1<span class="token punctuation">[</span>finished<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>tail2<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>两数之和</p><p>题述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>你可以按任意顺序返回答案。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。输入：nums = [3,2,4], target = 6输出：[1,2]输入：nums = [3,3], target = 6输出：[0,1]</code></pre><p>提示：</p><p><code>2 &lt;= nums.length &lt;= 103</code><br><code>-109 &lt;= nums[i] &lt;= 109</code><br><code>-109 &lt;= target &lt;= 109</code><br>只会存在一个有效答案</p><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 一般方法</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化索引数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用于记录数组元素和其索引的映射关系</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历数组拿出每一个元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果集合的键是目标值减去当前元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将当前元素的索引赋给索引数组的第二个位置</span>            result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 根据该键获取集合元素的值赋给索引数组的第一个位置</span>            result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 返回最新的索引数组</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 否则就将当前元素和其索引添加到集合进行映射---主要操作</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回最新的索引数组</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 集合解法// hash解法</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 用于记录数组元素和其索引的映射关系</span>    HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历数组拿出每一个元素</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果集合的键是目标值减去当前元素</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 就根据该键获取集合元素的值和当前元素的索引</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 否则将当前元素作为键其索引做为值添加到集合中</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回最新的索引数组</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>加一</p><p>题述：给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例：</p><pre class=" language-java"><code class="language-java">输入：digits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>解释：输入数组表示数字 <span class="token number">123</span>。输入：digits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>解释：输入数组表示数字 <span class="token number">4321</span>输入：digits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 分情况讨论，+1后需要进位的和+1后不需要进位的</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">plusOne</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取数组长度</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> digits<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从后往前遍历数组，看数组元素是否都等于9</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将数组中所有小于9的元素递增后并返回新数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> digits<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将数组中所有等于9的元素置为0</span>        digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果数组所有元素都等于9，表示+1后需要进行进位，长度比原来大1</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将新数组的0元素置为1</span>    newNumber<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> newNumber<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 一般解法</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">plusOne</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化要加的数字</span>    <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从后往前遍历数组，进行+1</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> digits<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将数组的末尾元素进行+1</span>        digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> carry<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果这个+1后比9小</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// early return</span>            <span class="token comment" spellcheck="true">// 直接返回当前数组</span>            <span class="token keyword">return</span> digits<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 否则将末尾元素置为0</span>        digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 创建新数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>digits<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将新数组的第一个元素置为1</span>    ret<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回最新的数组</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">plusOne</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>digits<span class="token punctuation">,</span>digits<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> digits<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>digits<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        digits<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> digits<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            digits<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>digits<span class="token punctuation">,</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>digits<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">plusOne</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> digits<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> digits<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        i<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>digits<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="2-5-栈"><a href="#2-5-栈" class="headerlink" title="2.5 栈"></a>2.5 栈</h3><ol><li><p>描述</p><blockquote><p>先进后出</p></blockquote></li><li><p>时间复杂度</p><blockquote><p>添加删除都是常数阶；查询是O(n)</p></blockquote></li><li><p>示例操作</p><pre class=" language-java"><code class="language-java">Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 3, 4]</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer topElement <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>topElement<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3的位置："</span> <span class="token operator">+</span> stack<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3的位置：-1</span></code></pre></li></ol><h3 id="2-6-队列"><a href="#2-6-队列" class="headerlink" title="2.6 队列"></a>2.6 队列</h3><ol><li><p>描述</p><blockquote><p>先进先出</p></blockquote></li><li><p>时间复杂度</p><blockquote><p>添加删除都是常数阶；查询是O(n)</p></blockquote></li><li><p>示例代码</p><pre class=" language-java"><code class="language-java">Queue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [one, two, three, four]</span>String polledElement <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>polledElement<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// one</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [two, three, four]</span>String peekedElement <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>peekedElement<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// two</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [two, three, four]</span><span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第一次循环 two</span>    <span class="token comment" spellcheck="true">// 第二次循环 three</span>    <span class="token comment" spellcheck="true">// 第三次循环 four</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2-6-1-优先队列"><a href="#2-6-1-优先队列" class="headerlink" title="2.6.1 优先队列"></a>2.6.1 优先队列</h4><ol><li><p>描述</p><blockquote><p>该数据结构存储元素有优先级别；底层具体实现的数据结构较为多样复杂，如：heap，bst，treap</p></blockquote></li><li><p>时间复杂度</p><blockquote><p>插入是常数阶，查询是Log(n)—按照元素的优先级取出</p></blockquote></li></ol><h4 id="2-6-2-双端队列"><a href="#2-6-2-双端队列" class="headerlink" title="2.6.2 双端队列"></a>2.6.2 双端队列</h4><ol><li><p>描述</p><blockquote><p>栈和队列的结合(queue和stack的结合)</p></blockquote></li><li><p>时间复杂度</p><blockquote><p>添加删除都是常数阶；查询是O(n)</p></blockquote></li><li><p>示例代码</p><pre class=" language-java"><code class="language-java">Deque<span class="token operator">&lt;</span>String<span class="token operator">></span> deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>deque<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>deque<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>deque<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [c, b, a]</span>String peek <span class="token operator">=</span> deque<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>peek<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// c</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [c, b, a]</span><span class="token keyword">while</span> <span class="token punctuation">(</span>deque<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>deque<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第一次循环 c</span>    <span class="token comment" spellcheck="true">// 第二次循环 b</span>    <span class="token comment" spellcheck="true">// 第三次循环 a</span><span class="token punctuation">}</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// []</span></code></pre></li></ol><h3 id="2-7-栈-amp-队列练习"><a href="#2-7-栈-amp-队列练习" class="headerlink" title="2.7 栈&amp;队列练习"></a>2.7 栈&amp;队列练习</h3><h4 id="2-7-1-栈"><a href="#2-7-1-栈" class="headerlink" title="2.7.1 栈"></a>2.7.1 栈</h4><ol><li><p>一个问题有最近相关性就考虑用栈来解决</p></li><li><p>栈(stack)—有效的括号1</p><p>题述：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: "()"输出: true输入: "()[]{}"输出: true输入: "(]"输出: false输入: "([)]"输出: false输入: "{[]}"输出: true</code></pre><p>题解：</p><ol><li>如果是左括号就入栈</li><li>如果是右括号就和栈顶元素进行匹配</li><li>匹配上就将栈顶元素移除栈</li><li>一直这么操作下去直到栈为空或者站内元素不匹配字符串任意字符</li></ol><p>实现：</p><pre class=" language-java"><code class="language-java">Stack<span class="token operator">&lt;</span>Character<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Character<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果字符是左括号就像栈里存入右括号</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'{'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果字符是左中括号就像栈里存入右中括号</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'['</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果字符是左大括号就像栈里存入大右括号</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果栈顶元素和字符串字符不相等就说明不匹配返回false，这里需要对栈进行非空校验</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果栈为空说明全部匹配上</span></code></pre></li><li><p>栈(最小栈)2</p><p>题述：设计一个支持<code>push</code> ，<code>pop</code> ，<code>top</code>操作，并能在常数时间内检索到最小元素的栈。</p><p><code>push(x)</code>—— 将元素 x 推入栈中。<br><code>pop()</code> —— 删除栈顶的元素。<br><code>top()</code> —— 获取栈顶元素。<br><code>getMin()</code> —— 检索栈中的最小元素。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：["MinStack","push","push","push","getMin","pop","top","getMin"][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --> 返回 -3.minStack.pop();minStack.top();      --> 返回 0.minStack.getMin();   --> 返回 -2.</code></pre><p><strong>提示：</strong></p><ul><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** initialize your data structure here. */</span><span class="token keyword">public</span> <span class="token function">MinStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 初始化最小值为0x7fffffff</span><span class="token keyword">int</span> min <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化栈</span>Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// </span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>min<span class="token punctuation">)</span><span class="token punctuation">;</span>        min <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> min<span class="token punctuation">)</span> min <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> min<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>栈(柱状图中最大的矩形)3</p><p>题述：给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/09.%E6%9D%A1%E5%BD%A2%E5%9B%BE%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.png" alt="条形图最大面积"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/10.%E6%9D%A1%E5%BD%A2%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E5%9B%BE.png" alt="条形最大面积图"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><p>示例图1：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/15.%E6%9D%A1%E5%BD%A2%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E5%9B%BE1.jpg" alt="条形最大面积图"></p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [2,1,5,6,2,3]输出: 10输入: heights = [2,4]输出: 4</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;= 105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><p>实现：</p><pre class=" language-text"><code class="language-text">// 暴力解法// 依次遍历左右边界，算出面积值，并轮换比较，求得最大值for i-->(0,n-2)    for j-->(i+1,n-1)        min(i,j),area        update max-->area// 暴力法优化for i-->i(0,n-1)    // 找到i的左右边界，即是左边最近最小的矩形，右边最近最小的矩形    area = height[i] * (rightBar - leftBar)    update max-->area// 栈解法(优化算法的核心——减少重复步骤的产生)// 维护一个有序栈，里面的元素从小到大排列/*    这个题的核心是要保持一个单调递增的stack，每次遇到比栈顶小的元素，pop掉最高的元素    此时最高的元素是局部最小的height，这里就需要利用当前i的index减去栈顶前一个元素的坐标    这样可以得到这个局部的width是多少。这样height*width就是局部最小的面积。    如果当前的i仍然大于栈顶元素，继续进行pop，这样得到下一个局部最小值    最后stack剩下的height index，就是全局下最小的index，因为比他们大的，都被pop掉了    所以直接pop stack，width就是总的len 减去他的index即可    */</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 暴力解法二</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果bar的高度数组长度为0直接返回；健壮性判断</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>heights <span class="token operator">==</span> null <span class="token operator">||</span> heights<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 左边界bar的最小高度</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lessFromLeft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>heights<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右边界bar的最小高度</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lessFromRight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>heights<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右边界bar的边界值</span>    lessFromRight<span class="token punctuation">[</span>heights<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左边界bar的边界值</span>    lessFromLeft<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历每一个bar</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 记录每个bar和左边界bar的距离</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当左边界bar距离大于0且该位置对应的高比当前的元素高</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> heights<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">>=</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将p记录为最高bar</span>            p <span class="token operator">=</span> lessFromLeft<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将最高bar值记录为当前元素</span>        lessFromLeft<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 再次遍历数组，寻找最小bar</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> heights<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 当前元素的之前元素索引</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&lt;</span> heights<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> heights<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">>=</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> lessFromRight<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        lessFromRight<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> maxArea <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        maxArea <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxArea<span class="token punctuation">,</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>lessFromRight<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> lessFromLeft<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> maxArea<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 单调栈解法</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> maxArea <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> len <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> h <span class="token operator">>=</span> heights<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> tp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            maxArea <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxArea<span class="token punctuation">,</span> heights<span class="token punctuation">[</span>tp<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> i <span class="token operator">:</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> s<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> maxArea<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>栈(接雨水)6</p><p>题述：给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/11.%E6%8E%A5%E9%9B%A8%E6%B0%B4.png" alt="接雨水"></p><pre class=" language-text"><code class="language-text">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 输入：height = [4,2,0,3,2,5]输出：9</code></pre><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>0 &lt;= n &lt;= 3 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 指针解法</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化数组长度</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化左端索引</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化右端索引</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化结果值</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化左右高度</span>    <span class="token keyword">int</span> maxleft <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> maxright <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果左端索引小于右端索引</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果左边高度小于右边高度</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在看左端的索引是不是比左边最大的高度大</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">>=</span> maxleft<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 是就把左边索引的高度对应值赋给左边最大的bar</span>                maxleft <span class="token operator">=</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 将左端最高bar减去左端高算出容积并返回</span>                res <span class="token operator">+=</span> maxleft <span class="token operator">-</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 左端索引递增</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在看右端的索引是不是比右边最大的高度大</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> maxright<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 是就把右边索引的高度对应值赋给右边最大的bar</span>                maxright <span class="token operator">=</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 右端最高bar减去右端高算出容积并返回</span>                res <span class="token operator">+=</span> maxright <span class="token operator">-</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 右端索引递增</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回最终的容积数</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2-7-2-队列"><a href="#2-7-2-队列" class="headerlink" title="2.7.2 队列"></a>2.7.2 队列</h4><ol><li><p>讲究先来后到的顺序(公平性)</p></li><li><p>队列(滑动窗口最大值)4</p><p>题述：给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7输入：nums = [1], k = 1输出：[1]输入：nums = [1,-1], k = 1输出：[1,-1]输入：nums = [9,11], k = 2输出：[11]输入：nums = [4,-2], k = 2输出：[4]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 暴力解法O(n*k)</span><span class="token comment" spellcheck="true">// 确定窗口的起点位置和终点位置；从起点位置一直找k个元素求出最大值输出(解不出来，超出时间限制)</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 优化的暴力解法</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> max_left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> max_right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    max_left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    max_right<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        max_left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max_left<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        max_right<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">%</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max_right<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sliding_max <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">+</span> k <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sliding_max<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max_right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> max_left<span class="token punctuation">[</span>i <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sliding_max<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 单调解法(队列)</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ri <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// store index</span>    Deque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// remove numbers out of range k</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// remove smaller numbers in k range as they are useless</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            q<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// q contains index... r contains content</span>        q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            r<span class="token punctuation">[</span>ri<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>队列(设计循环双端队列)5</p><p>题述：设计实现双端队列。<br>你的实现需要支持以下操作：</p><p>MyCircularDeque(k)：构造函数,双端队列的大小为k。<br>insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。<br>insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。<br>deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。<br>deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。<br>getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。<br>getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。<br>isEmpty()：检查双端队列是否为空。<br>isFull()：检查双端队列是否满了。</p><p>示例：</p><pre class=" language-text"><code class="language-text">MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3circularDeque.insertLast(1);                    // 返回 truecircularDeque.insertLast(2);                    // 返回 truecircularDeque.insertFront(3);                    // 返回 truecircularDeque.insertFront(4);                    // 已经满了，返回 falsecircularDeque.getRear();                  // 返回 2circularDeque.isFull();                        // 返回 truecircularDeque.deleteLast();                    // 返回 truecircularDeque.insertFront(4);                    // 返回 truecircularDeque.getFront();                // 返回 4</code></pre><p><strong>提示：</strong></p><ul><li>所有值的范围为 [1, 1000]</li><li>操作次数的范围为 [1, 1000]</li><li>请不要使用内置的双端队列库。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyCircularDeque</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> q<span class="token punctuation">;</span>    <span class="token keyword">int</span> head<span class="token punctuation">,</span> tail<span class="token punctuation">,</span> size<span class="token punctuation">,</span> count<span class="token punctuation">,</span> cap<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Initialize your data structure here. Set the size of the deque to be k. */</span>    <span class="token keyword">public</span> <span class="token function">MyCircularDeque</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cap <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">insertFront</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>q<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">insertLast</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>q<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">deleteFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">deleteLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Get the front item from the deque. */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>q<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Get the last item from the deque. */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getRear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>q<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Checks whether the circular deque is empty or not. */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Checks whether the circular deque is full or not. */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cap<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="2-8-哈希表-amp-映射-amp-集合"><a href="#2-8-哈希表-amp-映射-amp-集合" class="headerlink" title="2.8 哈希表&amp;映射&amp;集合"></a>2.8 哈希表&amp;映射&amp;集合</h3><ol><li><p>应用</p><ol><li>map<ol><li>使用hash码实现</li><li>部分使用二叉树实现</li></ol></li><li>set<ol><li>使用hash码实现</li><li>部分使用二叉树实现</li></ol></li></ol></li><li><p>概述</p><ol><li><p>描述</p><blockquote><p>哈希表(hash table) ，也称为散列表，是根据关键码值(key value)而直接进行访问的数据结构</p></blockquote></li><li><p>特点</p><ol><li>通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度</li><li>这种映射关系称为散列函数(hash function)，存放记录的数组称为hash表(或散列表)</li></ol></li><li><p>应用</p><ol><li>用户信息表</li><li>缓存(LRU Cache)</li><li>键值对存储(Redis)</li></ol></li><li><p>hash table原理图</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/16.hash%E8%A1%A8%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="hash表原理图"></p></li><li><p>hash碰撞</p><blockquote><p>对于一个存储元素，由hash函数计算所得到的整数值，有可能两个不同元素的hashcode值是一样的，不过概率很小</p></blockquote></li><li><p>解决hash碰撞</p><ol><li>升级维度(由原来的数组结构升级为数组+链表形式)—拉链式解决冲突的方法</li></ol></li><li><p>增删改查的时间复杂度都是<code>O(1)</code></p></li><li><p>实现</p><ol><li>HashMap/TreeMap—<code>key-value</code>对，key不重复<ol><li>主要掌握put和get原理流程</li></ol></li><li>HashSet/TreeSet—不重复的元素集合<ol><li>主要依赖<code>HashMap/TreeMap</code>来实现</li></ol></li></ol></li></ol></li></ol><h4 id="2-8-1-练习"><a href="#2-8-1-练习" class="headerlink" title="2.8.1 练习"></a>2.8.1 练习</h4><ol><li><p>hash(有效的字母异位词)</p><p>题述：给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: s = "anagram", t = "nagaram"输出: true输入: s = "rat", t = "car"输出: false</code></pre><p><strong>说明:</strong><br>你可以假设字符串只包含小写字母。</p><p><strong>进阶:</strong><br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 一般方法</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> alphabet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        alphabet<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        alphabet<span class="token punctuation">[</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> alphabet<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 时间复杂度较低解法</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> anagram<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> anagramlength <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        anagram<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>index <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>anagram<span class="token punctuation">[</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            anagramlength<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> anagramlength <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>hash(字母异位词分组)</p><p>题述：给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: ["eat", "tea", "tan", "ate", "nat", "bat"]输出:[  ["ate","eat","tea"],  ["nat","tan"],  ["bat"]]Input: strs = [""]Output: [[""]]Input: strs = ["a"]Output: [["a"]]</code></pre><p><strong>说明：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li>所有输入均为小写字母</li><li>不考虑答案输出的顺序。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 排序解法</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>strs <span class="token operator">==</span> null <span class="token operator">||</span> strs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">>></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String s <span class="token operator">:</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ca <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>ca<span class="token punctuation">)</span><span class="token punctuation">;</span>        String keyStr <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ca<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>keyStr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>keyStr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>keyStr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 固定字节数组</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>strs <span class="token operator">==</span> null <span class="token operator">||</span> strs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">>></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String s <span class="token operator">:</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ca<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String keyStr <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ca<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>keyStr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>keyStr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>keyStr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>hash(两数之和)</p><p>题述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>你可以按任意顺序返回答案。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。输入：nums = [3,2,4], target = 6输出：[1,2]输入：nums = [3,3], target = 6输出：[0,1]</code></pre><p>提示：</p><p><code>2 &lt;= nums.length &lt;= 103</code><br><code>-109 &lt;= nums[i] &lt;= 109</code><br><code>-109 &lt;= target &lt;= 109</code><br>只会存在一个有效答案</p><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 集合解法</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建两数集合</span>    HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历两数集合</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果集合中包含目标值减去集合中任意元素的值</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 则返回一个新数组，里面包含上面差值对应的索引，和当前元素的索引</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 否则向集合中添加当前元素</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回新的数组</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="3-树形结构"><a href="#3-树形结构" class="headerlink" title="3. 树形结构"></a>3. 树形结构</h2><h3 id="3-1-一般树"><a href="#3-1-一般树" class="headerlink" title="3.1 一般树"></a>3.1 一般树</h3><ol><li><p>概述</p><blockquote><p>Linked list 是简化的Tree；Tree是简化的Graph</p></blockquote><ol><li>Tree相比Linked list有两个next指针</li><li>没有环的Graph就是Tree</li></ol></li><li><p>遍历时间复杂度O(n)</p></li></ol><h3 id="3-2-二叉树"><a href="#3-2-二叉树" class="headerlink" title="3.2 二叉树"></a>3.2 二叉树</h3><ol><li>树的遍历<ol><li>前序遍历<code>根-左-右</code></li><li>中序遍历<code>左-根-右</code></li><li>后序遍历<code>左-右-根</code></li></ol></li><li>遍历时间复杂度O(n)；因为无序</li></ol><h3 id="3-3-二叉搜索树"><a href="#3-3-二叉搜索树" class="headerlink" title="3.3 二叉搜索树"></a>3.3 二叉搜索树</h3><ol><li><p>概述</p><blockquote><p>二叉搜索树也称二叉搜索排序树，有序二叉树，排序二叉树；是指一颗空树或者具有下列性质的二叉树</p></blockquote><ol><li>左子树上==所有节点==的值均小于根节点的值</li><li>右子树上==所有节点==的值均大于根节点的值</li><li>以此类推：左，右子树也分别为二叉查找树(这就是重复性)</li></ol></li><li><p>特点</p><blockquote><p>中序遍历是升序遍历</p></blockquote></li><li><p>遍历时间复杂度<code>O(logn)</code></p></li><li><p>常见操作</p><ol><li>查询</li><li>插入新增</li><li>删除</li></ol></li><li><p>极端情况</p><blockquote><p>树退化成单链表，即全部数字升序排列，此时查询时间复杂度是O(n)</p></blockquote></li></ol><h3 id="3-4-练习"><a href="#3-4-练习" class="headerlink" title="3.4 练习"></a>3.4 练习</h3><ol><li><p>Tree(二叉树的中序遍历)</p><p>题述：给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/17.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE1.jpg" alt="二叉树遍历方式图1"></p><pre class=" language-text"><code class="language-text">输入：root = [1,null,2,3]输出：[1,3,2]输入：root = []输出：[]输入：root = [1]输出：[1]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/18.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE2.jpg" alt="二叉树遍历方式图2"></p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：root = [1,2]输出：[2,1]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/19.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE3.jpg" alt="二叉树遍历方式图3"></p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：root = [1,null,2]输出：[1,2]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代方式</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>              stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>            root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                                          list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归实现</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>Tree(二叉树的前序遍历)</p><p>题述：给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/17.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE1.jpg" alt="二叉树遍历方式图1"></p><pre class=" language-text"><code class="language-text">输入：root = [1,null,2,3]输出：[1,2,3]输入：root = []输出：[]输入：root = [1]输出：[1]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/18.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE2.jpg" alt="二叉树遍历方式图2"></p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：root = [1,2]输出：[1,2]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/19.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE3.jpg" alt="二叉树遍历方式图3"></p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：root = [1,null,2]输出：[1,2]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> rights <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            rights<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>rights<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            root <span class="token operator">=</span> rights<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> pre <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    pre<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    pre<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pre<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pre<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>Tree(N叉树的后序遍历)—590题</p><p>题述：给定一个 N 叉树，返回其节点值的<em>后序遍历</em>。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/20.N%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE1.png" alt="N叉树遍历方式图1"></p><pre class=" language-text"><code class="language-text">输入: root = [1,null,3,2,4,null,5,6]输出: [5,6,3,2,4,1]</code></pre><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/21.N%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE2.png" alt="N叉树遍历方式图2"></p><pre class=" language-text"><code class="language-text">输入: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]</code></pre><p><strong>提示：</strong></p><ul><li>树的高度不会超过 <code>1000</code></li><li>树的节点总数在 <code>[0, 10^4]</code> 之间</li></ul><p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Stack<span class="token operator">&lt;</span>Node<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span> root<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>           <span class="token punctuation">}</span>    Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span> root<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">postorder</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>Tree(N叉树的前序遍历)</p><p>题述：给定一个 N 叉树，返回其节点值的<em>前序遍历</em>。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/20.N%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE1.png" alt="N叉树遍历方式图1"></p><pre class=" language-text"><code class="language-text">输入: root = [1,null,3,2,4,null,5,6]输出: [1,3,5,6,2,4]</code></pre><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/21.N%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE2.png" alt="N叉树遍历方式图2"></p><pre class=" language-text"><code class="language-text">输入: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]</code></pre><p><strong>提示：</strong></p><ul><li>树的高度不会超过 <code>1000</code></li><li>树的节点总数在 <code>[0, 10^4]</code> 之间</li></ul><p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>Tree(N叉树的层序遍历)</p><p>题述：给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/20.N%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE1.png" alt="N叉树遍历方式图1"></p><pre class=" language-text"><code class="language-text">输入：root = [1,null,3,2,4,null,5,6]输出：[[1],[3,2,4],[5,6]]</code></pre><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/21.N%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE2.png" alt="N叉树遍历方式图2"></p><pre class=" language-text"><code class="language-text">输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</code></pre><p><strong>提示：</strong></p><ul><li>树的高度不会超过 <code>1000</code></li><li>树的节点总数在 <code>[0, 10^4]</code> 之间</li></ul><p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h3 id="3-5-泛型递归"><a href="#3-5-泛型递归" class="headerlink" title="3.5 泛型递归"></a>3.5 泛型递归</h3><ol><li><p>适用场景</p><ol><li>节点的定义</li><li>重复性(自相似性)</li></ol></li><li><p>本质</p><blockquote><p>通过函数体来进行循环</p></blockquote></li><li><p>代码模板</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// java递归模板</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> param<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// terminator</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>level <span class="token operator">></span> MAX_LEVEL<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// process result</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// process current logic</span>    <span class="token function">process</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// drill down</span>    <span class="token function">recur</span><span class="token punctuation">(</span>level<span class="token operator">:</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> newParam<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// retore current status</span><span class="token punctuation">}</span></code></pre></li><li><p>思维要点</p><ol><li>不要进行人肉递归(手写递归树)</li><li>找到最近最简方法，将其拆解成可重复解决的问题(重复子问题)</li><li>数学归纳法思维</li></ol></li></ol><h3 id="3-6-练习"><a href="#3-6-练习" class="headerlink" title="3.6 练习"></a>3.6 练习</h3><ol><li><p>递归(括号生成)-22题</p><p>题述：数字n代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且<strong>有效的</strong>括号组合。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：n = 3输出：["((()))","(()())","(())()","()(())","()()()"]输入：n = 1输出：["()"]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token punctuation">,</span> String str<span class="token punctuation">,</span> <span class="token keyword">int</span> open<span class="token punctuation">,</span> <span class="token keyword">int</span> close<span class="token punctuation">,</span> <span class="token keyword">int</span> max<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> max<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>open <span class="token operator">&lt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> str<span class="token operator">+</span><span class="token string">"("</span><span class="token punctuation">,</span> open<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> close<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>close <span class="token operator">&lt;</span> open<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> str<span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">,</span> open<span class="token punctuation">,</span> close<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre></li><li><p>二叉树(翻转二叉树)—226题</p><p>题述：翻转一棵二叉树。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：     4   /   \  2     7 / \   / \1   3 6   9输出：     4   /   \  7     2 / \   / \9   6 3   1</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>二叉树(验证二叉搜索树)—98题</p><p>题述：给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/22.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE1.jpg" alt="二叉树图1"></p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/23.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE2.jpg" alt="二叉树图2"></p><pre class=" language-text"><code class="language-text">输入: root = [2,1,3]输出: true输入: root = [5,1,4,null,null,3,6]输出: false解释: 输入为: [5,1,4,null,null,3,6]。     根节点的值为 5 ，但是其右子节点值为 4 。</code></pre><p><strong>提示：</strong></p><ul><li>二叉树节点的取值范围<code>[1, 104]</code>.</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>二叉树(二叉树的最大深度)—104题</p><p>题述：给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/24.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE3.jpg" alt="二叉树图3"></p><pre class=" language-text"><code class="language-text">输入: root = [3,9,20,null,null,15,7]输出: 3输入: root = [1,null,2]输出: 2输入: root = []输出: 0</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>二叉树(二叉树的最小深度)—111题</p><p>题述：给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/24.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE3.jpg" alt="二叉树图3"></p><pre class=" language-text"><code class="language-text">输入：root = [3,9,20,null,null,15,7]输出：2输入：root = [2,null,3,null,4,null,5,null,6]输出：5</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <code>[0, 105]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>二叉树(二叉树的序列化与反序列化)—297题</p><p>题述：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示:</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/25.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE4.jpg" alt="二叉树图4"></p><pre class=" language-text"><code class="language-text">输入：root = [1,2,3,null,null,4,5]输出：[1,2,3,null,null,4,5]输入：root = []输出：[]输入：root = [1]输出：[1]输入：root = [1,2]输出：[1,2]</code></pre><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 104]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>二叉树(二叉树的最近公共祖先)—236题</p><p>题述：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>示例：给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/26.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE5.png" alt="二叉树图5"></p><pre class=" language-text"><code class="language-text">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>二叉树(从前序与中序遍历序列构造二叉树)—105题</p><p>题述：根据一棵树的前序遍历与中序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>示例：例如，给出</p><pre class=" language-text"><code class="language-text">前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：    3   / \  9  20    /  \   15   7</code></pre></li><li><p>递归(组合)—77题</p><p>题述：给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: n = 4, k = 2输出:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]输入: n = 1, k = 1输出: [[1]]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>递归(全排列)—46题</p><p>题述：给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]输入: nums = [0,1]输出: [[0,1],[1,0]]输入: nums = [1]输出: [[1]]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>All the integers of <code>nums</code> are <strong>unique</strong>.</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>递归(全排列2)—47题</p><p>题述：给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [1,1,2]输出：[[1,1,2], [1,2,1], [2,1,1]]输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h3 id="3-7-字典树和并查集"><a href="#3-7-字典树和并查集" class="headerlink" title="3.7 字典树和并查集"></a>3.7 字典树和并查集</h3><h3 id="3-8-红黑树和AL树"><a href="#3-8-红黑树和AL树" class="headerlink" title="3.8 红黑树和AL树"></a>3.8 红黑树和AL树</h3><h2 id="4-算法"><a href="#4-算法" class="headerlink" title="4. 算法"></a>4. 算法</h2><h3 id="4-1-分治和回溯"><a href="#4-1-分治和回溯" class="headerlink" title="4.1 分治和回溯"></a>4.1 分治和回溯</h3><ol><li><p>本质</p><blockquote><p>是一种递归，递归的一个细化类；是一种特殊的递归。</p></blockquote></li><li><p>重复性分类</p><ol><li>最近的重复性<ol><li>重复性构造—回溯</li><li>重复性分解—分治</li></ol></li><li>最优的重复性—动态规划</li></ol></li><li><p>分治代码</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 代码模板</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">divideConquer</span><span class="token punctuation">(</span>problem<span class="token punctuation">,</span> param1<span class="token punctuation">,</span> param2<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// recursion terminator</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>problem <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// prepare data</span>    data <span class="token operator">=</span> <span class="token function">prepare_data</span><span class="token punctuation">(</span>problem<span class="token punctuation">)</span><span class="token punctuation">;</span>    subproblems <span class="token operator">=</span> <span class="token function">split_problem</span><span class="token punctuation">(</span>problem<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// conquer subproblems</span>    subresult1 <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">divide_conquer</span><span class="token punctuation">(</span>subproblem<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p1<span class="token punctuation">,</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    subresult2 <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">divide_conquer</span><span class="token punctuation">(</span>subproblem<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p1<span class="token punctuation">,</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    subresult3 <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">divide_conquer</span><span class="token punctuation">(</span>subproblem<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p1<span class="token punctuation">,</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// peocess and generate the final result</span>    result <span class="token operator">=</span> <span class="token function">process_result</span><span class="token punctuation">(</span>subresult1<span class="token punctuation">,</span> subresult2<span class="token punctuation">,</span> subresult3<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// revert the current level status    </span><span class="token punctuation">}</span></code></pre></li><li><p>回溯</p><blockquote><p>采用试错的思想，尝试分步的去解决一个问题；在分步解决问题的过程中，当通过尝试发现现有的分步答案不能得到有效(正确)的解答的时候，它将取消上一步甚至是上几步的计算，再通过其他的可能的分步解答再次尝试寻找问题的答案。</p></blockquote><ol><li><p>通常使用最简单的递归方法来实现，在反复重复上述的步骤可能出现的两种情况</p><ol><li>找了一个可能存在的正确答案</li><li>在尝试了所有可能的分步方法后宣告该问题没有答案</li></ol></li><li><p>时间复杂度</p><blockquote><p>在最坏情况下，回溯算法会导致一次复杂度为指数的时间计算</p></blockquote></li></ol></li></ol><h3 id="4-2-练习"><a href="#4-2-练习" class="headerlink" title="4.2 练习"></a>4.2 练习</h3><ol><li><p>分治和回溯(Pow(x, n))—50题</p><p>题述：实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：x = 2.00000, n = 10输出：1024.00000输入：x = 2.10000, n = 3输出：9.26100输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25</code></pre><p><strong>提示：</strong></p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li><code>-231 &lt;= n &lt;= 231-1</code></li><li><code>-104 &lt;= xn &lt;= 104</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 分治解法</span><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">myPow</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">/</span>x <span class="token operator">*</span> <span class="token function">myPow</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span>x<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">myPow</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token punctuation">,</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">:</span> x<span class="token operator">*</span><span class="token function">myPow</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token punctuation">,</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对数迭代法</span><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">myPow</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> absN <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>absN <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>absN <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ans <span class="token operator">*=</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        absN <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>        x <span class="token operator">*=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> n <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">/</span> ans <span class="token operator">:</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>分治和回溯(子集)—78题</p><p>题述：给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]输入：nums = [0]输出：[[],[0]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 浅拷贝：把容器中的每一个元素的指针(引用)拷贝了一次</span></code></pre></li><li><p>牛顿迭代法</p><blockquote><p>牛顿迭代法快速寻找平方根</p></blockquote><p>下面这种方法可以很有效地求出根号<code>a</code>的近似值：首先随便猜一个近似值<code>x</code>，然后不断令<code>x</code>等于<code>x</code>和<code>a/x</code>的平均数，迭代个六七次后<code>x</code>的值就已经相当精确了。</p><pre><code>例如，我想求根号2等于多少。假如我猜测的结果为4，虽然错的离谱，但你可以看到使用牛顿迭代法后这个值很快就趋近于根号2了：</code></pre><pre class=" language-text"><code class="language-text">(       4  + 2/   4     ) / 2 = 2.25(    2.25  + 2/   2.25  ) / 2 = 1.56944..( 1.56944..+ 2/1.56944..) / 2 = 1.42189..( 1.42189..+ 2/1.42189..) / 2 = 1.41423......</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/27.%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95.gif" alt="牛顿迭代法"></p><p>这种算法的原理很简单，我们仅仅是不断用<code>(x,f(x))</code>的切线来逼近方程<code>x^2-a=0</code>的根。根号<code>a</code>实际上就是<code>x^2-a=0</code>的一个正实根，这个函数的导数是<code>2x</code>。也就是说，函数上任一点<code>(x,f(x))</code>处的切线斜率是<code>2x</code>。那么，<code>x-f(x)/(2x)</code>就是一个比<code>x</code>更接近的近似值。代入<code>f(x)=x^2-a</code>得到<code>x-(x^2-a)/(2x)</code>，也就是<code>(x+a/x)/2</code>。</p><pre><code>同样的方法可以用在其它的近似值计算中。[Quake III的源码](http://www.matrix67.com/blog/article.asp?id=411)中有一段非常牛B的开方取倒函数。</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mysqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> tmpx <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> k <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> k0 <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>k0<span class="token operator">-</span>k<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        k0 <span class="token operator">=</span> k<span class="token punctuation">;</span>        k <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">+</span> tmpx<span class="token operator">/</span>k<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>k<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Quake-III</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mysqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">float</span> tmpx <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span>    <span class="token keyword">float</span> xhalf <span class="token operator">=</span> <span class="token number">0.5f</span><span class="token operator">*</span>tmpx<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>tmpx<span class="token punctuation">;</span>    i <span class="token operator">=</span> <span class="token number">0x5f375a86</span> <span class="token operator">-</span> <span class="token punctuation">(</span>i <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tmpx <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> i<span class="token punctuation">;</span>    tmpx <span class="token operator">=</span> tmpx <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1.5f</span> <span class="token operator">-</span> xhalf<span class="token operator">*</span>tmpx<span class="token operator">*</span>tmpx<span class="token punctuation">)</span><span class="token punctuation">;</span>    tmpx <span class="token operator">=</span> tmpx <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1.5f</span> <span class="token operator">-</span> xhalf<span class="token operator">*</span>tmpx<span class="token operator">*</span>tmpx<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><pre><code>   int res = (int)(1.0/tmpx);   if((res+1) * (res + 1) &lt;= x)       res += 1;   return res;</code></pre><p>   }</p><pre><code>4. 分治和回溯(多数元素)—169题题述：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。示例：```text输入：[3,2,3]输出：3输入：[2,2,1,1,1,2,2]输出：2</code></pre><p>   <strong>进阶：</strong></p><ul><li><p>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。</p><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 数组解法 </span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> major <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          count<span class="token operator">++</span><span class="token punctuation">;</span>          major <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>major <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>          count<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> major<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//assume the first element is the answer</span>  <span class="token keyword">int</span> ans <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>ans <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           count<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//if meet different value,count--</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//if meet the same value, count++ </span>          count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">//if the current best ans is no longer the majority</span>      <span class="token comment" spellcheck="true">// i.e. it's count is not larger than i / 2</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          ans <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Moore voting algorithm</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">majorityElement3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          ret <span class="token operator">=</span> num<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>num<span class="token operator">!=</span>ret<span class="token punctuation">)</span> <span class="token punctuation">{</span>          count<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><ol start="5"><li><p>分治和回溯(电话号码的字母组合)—17题</p><p>题述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/28.%E7%94%B5%E8%AF%9D%E6%8B%A8%E5%8F%B7%E9%94%AE%E7%9B%98.png" alt="电话拨号键盘"></p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：digits = "23"输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]输入：digits = ""输出：[]输入：digits = "2"输出：["a","b","c"]</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>分治和回溯(N皇后)—51题</p><p>题述：n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/29.N%E7%9A%87%E5%90%8E.jpg" alt="N皇后"></p><pre class=" language-text"><code class="language-text">输入：n = 4输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]解释：如上图所示，4 皇后问题存在两个不同的解法。输入：n = 1输出：[["Q"]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h3 id="4-3-深度优先搜索—DFS"><a href="#4-3-深度优先搜索—DFS" class="headerlink" title="4.3 深度优先搜索—DFS"></a>4.3 深度优先搜索—DFS</h3><ol><li><p>概述</p><blockquote><p>绝大多数情况下处理的都是暴力搜索，即大部分情况把所有节点全部遍历一次</p></blockquote></li><li><p>搜索</p><ol><li>每个节点有且仅有只能访问一次，以优化时间复杂度</li></ol></li><li><p>对于树中节点访问顺序的不同可分为</p><ol><li>深度优先搜索</li><li>广度优先搜索</li><li>其他优先搜索(加权优先搜索)—又称为启发式搜索</li></ol></li><li><p>代码模板</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 深度优先搜索</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> allResults <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> allResults<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// process current node</span>    <span class="token comment" spellcheck="true">// logic here</span>    <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>allResults<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// already visited</span>    <span class="token keyword">return</span> allResults<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">travel</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span><span class="token keyword">int</span> level<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> results<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>results<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>level<span class="token punctuation">)</span><span class="token punctuation">{</span>        results<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    results<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 非递归写法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    Stack stack <span class="token operator">=</span> <span class="token punctuation">[</span>tree<span class="token punctuation">.</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        nodes <span class="token operator">=</span> <span class="token function">gentate_related_nodes</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// other processing work</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="4-4-广度优先搜索—BFS"><a href="#4-4-广度优先搜索—BFS" class="headerlink" title="4.4 广度优先搜索—BFS"></a>4.4 广度优先搜索—BFS</h3><ol><li><p>代码模板</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 广度优先搜索</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> allResults <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> allResults<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// process current node here</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>nodes<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> nodes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> results <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            TreeNode node <span class="token operator">=</span> nodes<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            results<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        allResults<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> allResults<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 非递归写法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        nodes <span class="token operator">=</span> <span class="token function">gentate_related_nodes</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// other processing work</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="4-5-练习"><a href="#4-5-练习" class="headerlink" title="4.5 练习"></a>4.5 练习</h3><ol><li><p>二叉树的层序遍历—102题(面试前三热点题)</p><p>题述：给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>示例：二叉树：<code>[3,9,20,null,null,15,7]</code></p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/30.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%861.jpg" alt="二叉树的层序遍历1"></p><pre class=" language-text"><code class="language-text">输入: root = [3,9,20,null,null,15,7]输出: [[3],[9,20],[15,7]]输入: root = [1]输出: [[1]]输入: root = []输出: []</code></pre><p><strong>提示：</strong></p><ul><li>树的节点的取值范围是 <code>[0, 2000]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 队列解法</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> wrapList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> wrapList<span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> levelNum <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> subList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>levelNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            subList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        wrapList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>subList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> wrapList<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>最小基因变化—433题</p><p>题述：一条基因序列由一个带有8个字符的字符串表示，其中每个字符都属于 “A”, “C”, “G”, “T”中的任意一个。</p><p>假设我们要调查一个基因序列的变化。一次基因变化意味着这个基因序列中的一个字符发生了变化。</p><p>例如，基因序列由”AACCGGTT” 变化至 “AACCGGTA” 即发生了一次基因变化。</p><p>与此同时，每一次基因变化的结果，都需要是一个合法的基因串，即该结果属于一个基因库。</p><p>现在给定3个参数 — start, end, bank，分别代表起始基因序列，目标基因序列及基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数。如果无法实现目标变化，请返回 -1。</p><p><strong>注意：</strong></p><ol><li>起始基因序列默认是合法的，但是它并不一定会出现在基因库中。</li><li>如果一个起始基因序列需要多次变化，那么它每一次变化之后的基因序列都必须是合法的。</li><li>假定起始基因序列与目标基因序列是不一样的。</li></ol><p>示例：</p><pre class=" language-text"><code class="language-text">start: "AACCGGTT"end:   "AACCGGTA"bank: ["AACCGGTA"]返回值: 1start: "AACCGGTT"end:   "AAACGGTA"bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]返回值: 2start: "AAAAACCC"end:   "AACCCCCC"bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]返回值: 3</code></pre><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minMutation</span><span class="token punctuation">(</span>String start<span class="token punctuation">,</span> String end<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> bank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Set<span class="token operator">&lt;</span>String<span class="token operator">></span> bankSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>String b<span class="token operator">:</span> bank<span class="token punctuation">)</span> <span class="token punctuation">{</span>        bankSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> charSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'G'</span><span class="token punctuation">,</span> <span class="token string">'T'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>String<span class="token operator">></span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>    visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>size<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String curr <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> level<span class="token punctuation">;</span>            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> currArray <span class="token operator">=</span> curr<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currArray<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">char</span> old <span class="token operator">=</span> currArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">:</span> charSet<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    currArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>                    String next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>currArray<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> bankSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>                        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                currArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> old<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        level<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minMutation</span><span class="token punctuation">(</span>String start<span class="token punctuation">,</span> String end<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> bank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">recurse</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> bank<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> count <span class="token operator">==</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> count <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">recurse</span><span class="token punctuation">(</span>String start<span class="token punctuation">,</span> String end<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> bank<span class="token punctuation">,</span> <span class="token keyword">int</span> soFar<span class="token punctuation">,</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> visited<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> end<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        count <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> soFar<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>String e <span class="token operator">:</span> bank<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> diff <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> e<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                diff<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>diff <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>diff <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">recurse</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> end<span class="token punctuation">,</span> bank<span class="token punctuation">,</span> soFar<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>            visited<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>在每个树行中找最大值—515题</p><p>题述：您需要在二叉树的每一行中找到最大的值。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/31.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%862.jpg" alt="二叉树的层序遍历2"></p><pre class=" language-text"><code class="language-text">输入: root = [1,3,2,5,3,null,9]输出: [1,3,9]输入: root = [1,2,3]输出: [1,3]输入: root = [1]输出: [1]输入: root = [1,null,2]输出: [1,2]输入: root = []输出: []</code></pre><p><strong>提示：</strong></p><ul><li>The number of nodes in the tree will be in the range <code>[0, 104]</code>.</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">largestValues</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">helper</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//expand list size</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>d <span class="token operator">==</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//or set value</span>        res<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">,</span> d<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">,</span> d<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>单词接龙—127题</p><p>题述：字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p><ul><li>序列中第一个单词是 beginWord 。</li><li>序列中最后一个单词是 endWord 。</li><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典 wordList 中的单词。</li></ul><p>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p><p>示例：</p><pre class=" language-java"><code class="language-java">输入：beginWord <span class="token operator">=</span> <span class="token string">"hit"</span><span class="token punctuation">,</span> endWord <span class="token operator">=</span> <span class="token string">"cog"</span><span class="token punctuation">,</span> wordList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hot"</span><span class="token punctuation">,</span><span class="token string">"dot"</span><span class="token punctuation">,</span><span class="token string">"dog"</span><span class="token punctuation">,</span><span class="token string">"lot"</span><span class="token punctuation">,</span><span class="token string">"log"</span><span class="token punctuation">,</span><span class="token string">"cog"</span><span class="token punctuation">]</span>输出：<span class="token number">5</span>解释：一个最短转换序列是 <span class="token string">"hit"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"hot"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"dot"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"dog"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"cog"</span><span class="token punctuation">,</span> 返回它的长度 <span class="token number">5</span>。输入：beginWord <span class="token operator">=</span> <span class="token string">"hit"</span><span class="token punctuation">,</span> endWord <span class="token operator">=</span> <span class="token string">"cog"</span><span class="token punctuation">,</span> wordList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hot"</span><span class="token punctuation">,</span><span class="token string">"dot"</span><span class="token punctuation">,</span><span class="token string">"dog"</span><span class="token punctuation">,</span><span class="token string">"lot"</span><span class="token punctuation">,</span><span class="token string">"log"</span><span class="token punctuation">]</span>输出：<span class="token number">0</span>解释：endWord <span class="token string">"cog"</span> 不在字典中，所以无法进行转换。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= beginWord.length &lt;= 10</code></li><li><code>endWord.length == beginWord.length</code></li><li><code>1 &lt;= wordList.length &lt;= 5000</code></li><li><code>wordList[i].length == beginWord.length</code></li><li><code>beginWord、endWord 和 wordList[i] 由小写英文字母组成</code></li><li><code>beginWord != endWord</code></li><li><code>wordList 中的所有字符串 互不相同</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">ladderLength</span><span class="token punctuation">(</span>String beginWord<span class="token punctuation">,</span> String endWord<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordList<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Set<span class="token operator">&lt;</span>String<span class="token operator">></span> dict <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>wordList<span class="token punctuation">)</span><span class="token punctuation">,</span> qs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> qe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    qs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dict<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>endWord<span class="token punctuation">)</span><span class="token punctuation">)</span> qe<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>endWord<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all transformed words must be in dict (including endWord)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">!</span>qs<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> nq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String w <span class="token operator">:</span> qs<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> w<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ch <span class="token operator">=</span> w<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token string">'z'</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> w<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// beginWord and endWord not the same, so bypass itself</span>                    ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>                    String nb <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>qe<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// meet from two ends</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>dict<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nb<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> vis<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nb<span class="token punctuation">)</span><span class="token punctuation">)</span> nq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// not meet yet, vis is safe to use</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        qs <span class="token operator">=</span> <span class="token punctuation">(</span>nq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> qe<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> nq <span class="token operator">:</span> qe<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// switch to small one to traverse from other end</span>        qe <span class="token operator">=</span> <span class="token punctuation">(</span>qs <span class="token operator">==</span> nq<span class="token punctuation">)</span> <span class="token operator">?</span> qe <span class="token operator">:</span> nq<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>单词接龙 II—126题</p><p>题述：给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换后得到的单词必须是字典中的单词。</li></ol><p><strong>说明：</strong></p><ul><li>如果不存在这样的转换序列，返回一个空列表。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li></ul><p>示例：</p><pre class=" language-java"><code class="language-java">输入<span class="token operator">:</span>beginWord <span class="token operator">=</span> <span class="token string">"hit"</span><span class="token punctuation">,</span>endWord <span class="token operator">=</span> <span class="token string">"cog"</span><span class="token punctuation">,</span>wordList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hot"</span><span class="token punctuation">,</span><span class="token string">"dot"</span><span class="token punctuation">,</span><span class="token string">"dog"</span><span class="token punctuation">,</span><span class="token string">"lot"</span><span class="token punctuation">,</span><span class="token string">"log"</span><span class="token punctuation">,</span><span class="token string">"cog"</span><span class="token punctuation">]</span>输出<span class="token operator">:</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token string">"hit"</span><span class="token punctuation">,</span><span class="token string">"hot"</span><span class="token punctuation">,</span><span class="token string">"dot"</span><span class="token punctuation">,</span><span class="token string">"dog"</span><span class="token punctuation">,</span><span class="token string">"cog"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"hit"</span><span class="token punctuation">,</span><span class="token string">"hot"</span><span class="token punctuation">,</span><span class="token string">"lot"</span><span class="token punctuation">,</span><span class="token string">"log"</span><span class="token punctuation">,</span><span class="token string">"cog"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>输入<span class="token operator">:</span>beginWord <span class="token operator">=</span> <span class="token string">"hit"</span>endWord <span class="token operator">=</span> <span class="token string">"cog"</span>wordList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hot"</span><span class="token punctuation">,</span><span class="token string">"dot"</span><span class="token punctuation">,</span><span class="token string">"dog"</span><span class="token punctuation">,</span><span class="token string">"lot"</span><span class="token punctuation">,</span><span class="token string">"log"</span><span class="token punctuation">]</span>输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>解释<span class="token operator">:</span> endWord <span class="token string">"cog"</span> 不在字典中，所以不存在符合要求的转换序列。</code></pre><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>岛屿数量—200题</p><p>题述：给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：grid = [  ["1","1","1","1","0"],  ["1","1","0","1","0"],  ["1","1","0","0","0"],  ["0","0","0","0","0"]]输出：1输入：grid = [  ["1","1","0","0","0"],  ["1","1","0","0","0"],  ["0","0","1","0","0"],  ["0","0","0","1","1"]]输出：3</code></pre><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>扫雷游戏—529题</p><p>题述：让我们一起来玩扫雷游戏！</p><p>给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。</p><p>现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p><p>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。<br>如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的未挖出方块都应该被递归地揭露。<br>如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。<br>如果在此次点击中，若无更多方块可被揭露，则返回面板。</p><p>示例1：</p><pre class=" language-java"><code class="language-java">输入<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'M'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>Click <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'M'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/32.%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F1.png" alt="扫雷游戏1"></p><p>示例2：</p><pre class=" language-text"><code class="language-text">输入: [['B', '1', 'E', '1', 'B'], ['B', '1', 'M', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B']]Click : [1,2]输出: [['B', '1', 'E', '1', 'B'], ['B', '1', 'X', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B']]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/33.%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F2.png" alt="扫雷游戏2"></p><p><strong>注意：</strong></p><ol><li>输入矩阵的宽和高的范围为 [1,50]。</li><li>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。</li><li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li><li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。</li></ol><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h3 id="4-6-贪心算法"><a href="#4-6-贪心算法" class="headerlink" title="4.6 贪心算法"></a>4.6 贪心算法</h3><h4 id="4-6-1-简介"><a href="#4-6-1-简介" class="headerlink" title="4.6.1 简介"></a>4.6.1 简介</h4><h4 id="4-6-2-练习"><a href="#4-6-2-练习" class="headerlink" title="4.6.2 练习"></a>4.6.2 练习</h4><ol><li><p>零钱兑换—322题</p><p>题述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1输入：coins = [2], amount = 3输出：-1输入：coins = [1], amount = 0输出：0输入：coins = [1], amount = 1输出：1输入：coins = [1], amount = 2输出：2</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>amount<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">++</span>sum <span class="token operator">&lt;=</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">>=</span> coin <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>sum<span class="token operator">-</span>coin<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> dp<span class="token punctuation">[</span>sum<span class="token operator">-</span>coin<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                min <span class="token operator">=</span> min<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">?</span> temp <span class="token operator">:</span> <span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> min <span class="token operator">?</span> temp <span class="token operator">:</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        dp<span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>柠檬水找零—860题</p><p>题述：在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：[5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。输入：[5,5,10]输出：true输入：[10,10]输出：false输入：[5,5,10,10,20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= bills.length &lt;= 10000</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>买卖股票的最佳时机 II—122题</p><p>题述：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li><li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>分发饼干—455题</p><p>题述：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: g = [1,2,3], s = [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。输入: g = [1,2], s = [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</code></pre><p><strong>提示：</strong></p><p><code>1 &lt;= g.length &lt;= 3 * 10^4</code><br><code>0 &lt;= s.length &lt;= 3 * 10^4</code><br><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></p><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>模拟行走机器人—874题</p><p>题述：机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ：</p><p>-2 ：向左转 90 度<br>-1 ：向右转 90 度<br>1 &lt;= x &lt;= 9 ：向前移动 x 个单位长度<br>在网格上有一些格子被视为障碍物 obstacles 。第 i 个障碍物位于网格点  obstacles[i] = (xi, yi) 。</p><p>机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。</p><p>返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 5 ，则返回 25 ）</p><p><strong>注意：</strong></p><ul><li>北表示 <code>+Y</code> 方向。</li><li>东表示 <code>+X</code> 方向。</li><li>南表示 <code>-Y</code> 方向。</li><li>西表示 <code>-X</code> 方向。</li></ul><p>示例：</p><pre class=" language-text"><code class="language-text">输入：commands = [4,-1,3], obstacles = []输出：25解释：机器人开始位于 (0, 0)：1. 向北移动 4 个单位，到达 (0, 4)2. 右转3. 向东移动 3 个单位，到达 (3, 4)距离原点最远的是 (3, 4) ，距离为 32 + 42 = 25输入：commands = [4,-1,4,-2,4], obstacles = [[2,4]]输出：65解释：机器人开始位于 (0, 0)：1. 向北移动 4 个单位，到达 (0, 4)2. 右转3. 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4)4. 左转5. 向北走 4 个单位，到达 (1, 8)距离原点最远的是 (1, 8) ，距离为 12 + 82 = 65</code></pre><p><strong>提示：</strong></p><p><code>1 &lt;= commands.length &lt;= 10^4</code><br><code>commands[i] is one of the values in the list [-2,-1,1,2,3,4,5,6,7,8,9].</code><br><code>0 &lt;= obstacles.length &lt;= 10^4</code><br><code>-3 * 10^4 &lt;= xi, yi &lt;= 3 * 10^4</code><br>答案保证小于 231</p><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>跳跃游戏—55题</p><p>题述：给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>跳跃游戏 II—45题</p><p>题述：给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。输入: nums = [2,3,0,1,4]输出: 2     </code></pre><p><strong>说明:</strong></p><p>假设你总是可以到达数组的最后一个位置。</p><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h3 id="4-7-二分查找"><a href="#4-7-二分查找" class="headerlink" title="4.7 二分查找"></a>4.7 二分查找</h3><h3 id="4-8-动态规划"><a href="#4-8-动态规划" class="headerlink" title="4.8 动态规划"></a>4.8 动态规划</h3><h3 id="4-9-高级搜索"><a href="#4-9-高级搜索" class="headerlink" title="4.9 高级搜索"></a>4.9 高级搜索</h3><h3 id="4-10-位运算"><a href="#4-10-位运算" class="headerlink" title="4.10 位运算"></a>4.10 位运算</h3><h3 id="4-11-布隆过滤器和LRU缓存"><a href="#4-11-布隆过滤器和LRU缓存" class="headerlink" title="4.11 布隆过滤器和LRU缓存"></a>4.11 布隆过滤器和LRU缓存</h3><h2 id="5-重要算法"><a href="#5-重要算法" class="headerlink" title="5. 重要算法"></a>5. 重要算法</h2><h3 id="5-1-排序算法"><a href="#5-1-排序算法" class="headerlink" title="5.1 排序算法"></a>5.1 排序算法</h3><h3 id="5-2-高阶动态规划"><a href="#5-2-高阶动态规划" class="headerlink" title="5.2 高阶动态规划"></a>5.2 高阶动态规划</h3><h3 id="5-3-字符串算法"><a href="#5-3-字符串算法" class="headerlink" title="5.3 字符串算法"></a>5.3 字符串算法</h3>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.linux</title>
      <link href="2020/11/21/6-linux/"/>
      <url>2020/11/21/6-linux/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.Git</title>
      <link href="2020/11/21/6-git/"/>
      <url>2020/11/21/6-git/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.leetcode</title>
      <link href="2020/11/21/5-leetcode/"/>
      <url>2020/11/21/5-leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><h2 id="1-算法基础"><a href="#1-算法基础" class="headerlink" title="1. 算法基础"></a>1. 算法基础</h2><h2 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2. 线性表"></a>2. 线性表</h2><h3 id="2-1-类型"><a href="#2-1-类型" class="headerlink" title="2.1 类型"></a>2.1 类型</h3><h3 id="2-2-顺序表示实现"><a href="#2-2-顺序表示实现" class="headerlink" title="2.2 顺序表示实现"></a>2.2 顺序表示实现</h3><h3 id="2-3-链式表示实现"><a href="#2-3-链式表示实现" class="headerlink" title="2.3 链式表示实现"></a>2.3 链式表示实现</h3><h2 id="3-栈与队列"><a href="#3-栈与队列" class="headerlink" title="3. 栈与队列"></a>3. 栈与队列</h2><h3 id="3-1-类型"><a href="#3-1-类型" class="headerlink" title="3.1 类型"></a>3.1 类型</h3><h3 id="3-2-栈的实现"><a href="#3-2-栈的实现" class="headerlink" title="3.2 栈的实现"></a>3.2 栈的实现</h3><h3 id="3-3-队列的实现"><a href="#3-3-队列的实现" class="headerlink" title="3.3 队列的实现"></a>3.3 队列的实现</h3><h4 id="3-3-1-链式表示实现"><a href="#3-3-1-链式表示实现" class="headerlink" title="3.3.1 链式表示实现"></a>3.3.1 链式表示实现</h4><h4 id="3-3-2-顺序表示实现"><a href="#3-3-2-顺序表示实现" class="headerlink" title="3.3.2 顺序表示实现"></a>3.3.2 顺序表示实现</h4><h2 id="4-串"><a href="#4-串" class="headerlink" title="4. 串"></a>4. 串</h2><h3 id="4-1-类型"><a href="#4-1-类型" class="headerlink" title="4.1 类型"></a>4.1 类型</h3><h3 id="4-2-顺序表示实现"><a href="#4-2-顺序表示实现" class="headerlink" title="4.2 顺序表示实现"></a>4.2 顺序表示实现</h3><h3 id="4-3-链式表现实现"><a href="#4-3-链式表现实现" class="headerlink" title="4.3 链式表现实现"></a>4.3 链式表现实现</h3><h2 id="5-数组和广义表"><a href="#5-数组和广义表" class="headerlink" title="5. 数组和广义表"></a>5. 数组和广义表</h2><h3 id="5-1-数组"><a href="#5-1-数组" class="headerlink" title="5.1 数组"></a>5.1 数组</h3><h3 id="5-2-广义表-散列表"><a href="#5-2-广义表-散列表" class="headerlink" title="5.2 广义表(散列表)"></a>5.2 广义表(散列表)</h3><h3 id="5-3-空间表"><a href="#5-3-空间表" class="headerlink" title="5.3 空间表"></a>5.3 空间表</h3><h4 id="5-3-1-分配法之边界标识"><a href="#5-3-1-分配法之边界标识" class="headerlink" title="5.3.1 分配法之边界标识"></a>5.3.1 分配法之边界标识</h4><h4 id="5-3-2-分配法之伙伴系统"><a href="#5-3-2-分配法之伙伴系统" class="headerlink" title="5.3.2 分配法之伙伴系统"></a>5.3.2 分配法之伙伴系统</h4><h2 id="6-树"><a href="#6-树" class="headerlink" title="6. 树"></a>6. 树</h2><h3 id="6-1-基础"><a href="#6-1-基础" class="headerlink" title="6.1 基础"></a>6.1 基础</h3><h3 id="6-2-二叉树"><a href="#6-2-二叉树" class="headerlink" title="6.2 二叉树"></a>6.2 二叉树</h3><h3 id="6-3-其他"><a href="#6-3-其他" class="headerlink" title="6.3 其他"></a>6.3 其他</h3><h2 id="7-图"><a href="#7-图" class="headerlink" title="7. 图"></a>7. 图</h2><h3 id="7-1-基础"><a href="#7-1-基础" class="headerlink" title="7.1 基础"></a>7.1 基础</h3><h3 id="7-2-存储结构"><a href="#7-2-存储结构" class="headerlink" title="7.2 存储结构"></a>7.2 存储结构</h3><h3 id="7-3-遍历方式"><a href="#7-3-遍历方式" class="headerlink" title="7.3 遍历方式"></a>7.3 遍历方式</h3><h3 id="7-4-其他-广度优先搜索"><a href="#7-4-其他-广度优先搜索" class="headerlink" title="7.4 其他(广度优先搜索)"></a>7.4 其他(广度优先搜索)</h3><h2 id="8-查找"><a href="#8-查找" class="headerlink" title="8. 查找"></a>8. 查找</h2><h3 id="8-1-静态查找"><a href="#8-1-静态查找" class="headerlink" title="8.1 静态查找"></a>8.1 静态查找</h3><h3 id="8-2-动态查找"><a href="#8-2-动态查找" class="headerlink" title="8.2 动态查找"></a>8.2 动态查找</h3><h2 id="9-排序"><a href="#9-排序" class="headerlink" title="9. 排序"></a>9. 排序</h2><h3 id="9-1-内部排序"><a href="#9-1-内部排序" class="headerlink" title="9.1 内部排序"></a>9.1 内部排序</h3><h4 id="9-1-1-选择排序"><a href="#9-1-1-选择排序" class="headerlink" title="9.1.1 选择排序"></a>9.1.1 选择排序</h4><h4 id="9-1-2-快速排序"><a href="#9-1-2-快速排序" class="headerlink" title="9.1.2 快速排序"></a>9.1.2 快速排序</h4><h3 id="9-2-外部排序"><a href="#9-2-外部排序" class="headerlink" title="9.2 外部排序"></a>9.2 外部排序</h3><h2 id="10-重要算法"><a href="#10-重要算法" class="headerlink" title="10. 重要算法"></a>10. 重要算法</h2><h3 id="10-1-迪克斯特拉算法"><a href="#10-1-迪克斯特拉算法" class="headerlink" title="10.1 迪克斯特拉算法"></a>10.1 迪克斯特拉算法</h3><h3 id="10-2-贪婪算法"><a href="#10-2-贪婪算法" class="headerlink" title="10.2 贪婪算法"></a>10.2 贪婪算法</h3><h3 id="10-3-动态规划"><a href="#10-3-动态规划" class="headerlink" title="10.3 动态规划"></a>10.3 动态规划</h3><h3 id="10-4-K最近邻算法"><a href="#10-4-K最近邻算法" class="headerlink" title="10.4 K最近邻算法"></a>10.4 K最近邻算法</h3>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.JavaInterview</title>
      <link href="2020/11/21/5-javainterview/"/>
      <url>2020/11/21/5-javainterview/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面试"><a href="#Java面试" class="headerlink" title="Java面试"></a>Java面试</h1><h2 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1. Java基础"></a>1. Java基础</h2><ol><li>抽象类和接口的区别<ol><li>抽象类只能单继承，而接口可以多实现</li><li>接口的方法都是<code>public</code>修饰，而抽象类允许私有方法</li><li><code>jdk8</code>以前接口只能有抽象方法，而抽象类可以有普通和静态方法</li></ol></li><li><code>==</code>和<code>equals</code>的区别<ol><li><code>==</code>是值比较</li><li><code>equals</code>是比较对象内容是否相同</li><li>在比较自定义类是否相同需要重写<code>equals</code>方法，不然是值比较</li></ol></li><li><code>String</code><ol><li>由<code>final</code>修饰的不可改变的量</li><li><code>StingBuffer</code>：多线程环境下拼接效率高，有同步锁，所以线程安全</li><li><code>StringBuilder</code>：单线程环境下拼接效率高，没有同步锁，所以效率最高</li><li><code>new</code>字符串时首先会在常量池中找，没有就创建两个对象，一个在堆中，一个在常量池中；有就只在堆中创建一个对象</li></ol></li><li><code>final/finaly/finalize</code>区别<ol><li><code>final</code>修饰的量不可改变，修饰的方法不能重写，修饰的类不能被继承</li><li><code>finaly</code>是异常捕获用于兜底的操作，一般用于释放资源</li><li><code>finalize</code>是垃圾回收时，被回收对象调用执行的方法</li></ol></li><li><code>Servlet</code>生命周期<ol><li>初始化阶段，调用<code>init</code>方法</li><li>响应请求阶段，处理请求</li><li>终止销毁</li></ol></li><li><code>IO</code><ol><li><code>Block-IO</code><ol><li>字节流<ol><li><code>InputStream</code></li><li><code>OutputStream</code></li></ol></li><li>字符流<ol><li><code>Reader</code></li><li><code>Writer</code></li></ol></li><li>交互方式：同步阻塞式</li></ol></li><li><code>MonBlock-IO</code><ol><li>多路复用式的同步非阻塞式<code>IO</code></li><li>组成<ol><li><code>Channels</code><ol><li><code>FileChannel</code></li><li><code>DatagramChannel</code></li><li><code>SocketChannel</code></li><li><code>ServerSocketChannel</code></li></ol></li><li><code>Buffers</code><ol><li><code>ByteBuffer</code></li></ol></li><li><code>Selectors</code></li></ol></li><li><code>select</code>，<code>poll</code>，<code>epoll</code></li></ol></li><li><code>Asynchronous IO</code><ol><li>基于事件和回调机制的<code>IO</code></li><li>基于回调：实现<code>CompletionHandler</code>接口，调用时触发回调函数</li><li>返回<code>Future</code>：通过<code>isDone</code>方法检查是否准备好，通过<code>get</code>方法等待返回数据</li></ol></li><li>Netty</li></ol></li><li>异常<ol><li><code>Error</code>：程序无法处理的系统错误，编译器不做检查</li><li><code>Exception</code>：程序可以处理的异常，捕获后可能恢复<ol><li><code>!RuntimeException</code>：编译期异常，在编译时必须处理的异常</li><li><code>RuntimeException</code>：运行时异常</li></ol></li><li>抛出异常：创建异常对象交给运行时系统处理</li><li>捕获异常：寻找合适的异常处理器处理异常，否则终止运行</li><li><code>finally</code>优于<code>catch</code>块中的<code>return</code>执行，如果<code>finally</code>和<code>catch</code>都有<code>return</code>，则<code>catch</code>中的<code>return</code>会覆盖掉<code>finally</code>中的<code>return</code>值</li><li>异常处理规则<ol><li>具体明确：抛出的异常应能通过异常类名和<code>message</code>准说明异常的类型和异常产生的原因</li><li>提早抛出：尽可能早的发现并抛出异常，便于精确定位问题</li><li>延迟捕获：异常的捕获和处理尽可能的延迟，让掌握更多信息的作用域来处理异常</li></ol></li><li>异常梳理设计原则<ol><li>创建一个异常类继承自<code>RuntimeException</code>异常来统一处理</li><li>其余异常统一转为<code>AppException</code></li><li>在<code>catch</code>后，抛出自定义异常的子类，并提供足以定位的信息</li><li>由前端接收<code>AppException</code>做统一处理</li></ol></li><li>异常处理消耗性能的地方<ol><li><code>try-catch</code>块影响<code>JVM</code>优化</li><li>异常对象实例需要保存栈快照等信息，开销较大</li></ol></li></ol></li></ol><h2 id="2-Java集合-容器"><a href="#2-Java集合-容器" class="headerlink" title="2. Java集合(容器)"></a>2. Java集合(容器)</h2><ol><li><code>List</code>:<ol><li>特点<ol><li>有序可重复</li><li>可以通过索引值来操作元素</li></ol></li><li>实现类<ol><li><code>ArrayList</code><ol><li>底层是数组，利用数组的下标进行元素访问</li><li>初始大小为10 ，扩容为原来的0.5倍，扩容是基于数组的复制，比较耗费内存</li><li>查询快，增删慢</li></ol></li><li><code>LinkedList</code><ol><li>底层是双向链表，链表存储指向前后节点的引用和元素</li><li>增删快，查询慢</li></ol></li></ol></li></ol></li><li><code>Map</code><ol><li>特点<br>1. </li><li>实现类<ol><li><code>HashMap</code><ol><li>底层原理<ol><li>1.8之前底层是数组+链表，1.8之后是数组+链表+红黑树</li><li>链表的出现就是解决Hash值相同，由HashCode值决定存放的位置</li><li>链表转为红黑树—当数组长度大于64且链表长度大于8时会将链表转为红黑树</li><li>初始值为16，当负载因子达到0.75时，就会扩容为原来的2倍</li><li>一般用于单线程环境</li></ol></li><li><code>put</code>流程<ol><li>如果HashMap未被初始化，则先进行初始化</li><li>对key求hash值，然后通过hashcode方法计算下标值</li><li>如果没有hash碰撞，直接放入桶中</li><li>如果有hash碰撞，以链表的方式链接到后面</li><li>如果链表的长度超过8时，就把链表转为红黑树</li><li>如果链表的长度小于6时，就把红黑树转为链表</li><li>如果节点满了，则进行扩容，扩容为原来的2倍后进行重排</li></ol></li><li>减少hash碰撞<ol><li>扰动函数：使元素分布均匀，减少碰撞几率</li><li>使用final对象，这些对象已经重写equals和hashcode方法</li></ol></li><li>扩容<ol><li>基础容量为16，负载因子达到0.75时扩容为原来的2倍</li><li>多线程环境下，调整大小会存在条件竞争，容易造成死锁</li><li>rehashing是比较耗时的过程</li></ol></li><li>解决线程不安全<ol><li>调用Collections的synchronizedMap为HashMap实例对象加锁</li><li>synchronizedMap方法为hashMap实例对象加synchronized锁，锁是mutex互斥锁</li></ol></li></ol></li><li>LinkedHashMap</li><li>TreeMap</li><li>HashTable：线程安全，有同步锁</li></ol></li></ol></li><li>Queue</li><li>Set<ol><li>特点<ol><li>无序，不可重复，但TreeSet有序</li></ol></li><li>实现类<ol><li>HashSet：底层是HashMap，由Hashcode和equals方法保证元素唯一性</li><li>TreeSet：底层是TreeMap，元素有序<ol><li>自然排序：让所属对象的方法实现comparable接口的无参构造</li><li>比较器排序：comparator带参构造</li></ol></li><li>LinkedHashSet</li></ol></li></ol></li><li>JUC<ol><li>CAS是JUC的基础</li><li>AQS是JUC的locks包的基础</li><li>包的分类<ol><li>线程执行器executor</li><li>锁locks</li><li>原子变量atomic</li><li>并发工具类tools<ol><li>闭锁CountDownLatch：让主线程等待一组事件发生后继续执行</li><li>栅栏CyclicBarrier：阻塞当前线程，等待其他线程</li><li>信号量Semaphore：控制某个资源可被同时访问的线程个数</li><li>交换器Exchanger：两个线程达到同步点后，相互交换数据</li></ol></li><li>并发集合Collections<ol><li>BlockingQueue：提供可阻塞的入队和出队操作(都是线程安全的)<ol><li>主要用于生产者-消费者模式：将任务的生产和消费进行隔离</li><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：一个由链表结构组成的有/无界阻塞队列</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li><li>DealyQueue：一个使用优先级队列实现的无界阻塞队列</li><li>SynchronousQueue：一个不存储元素的阻塞队列</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li><li>ConcurrentHashMap<ol><li>JDK8以前：使用更细粒度的锁，由一个Segment数组和多个HashEntry组成，实现了锁分离，即每个元素的锁是不一样的</li><li>JDK8之后：使用CAS++synchronized使锁更细化</li><li>存在于JUC包下，不允许存储null键值</li><li>put逻辑<ol><li>判断Node[]数组是否初始化，没有就先初始化</li><li>通过hash定位数组的索引坐标，是否有node节点，如果没有则使用CAS进行添加(链表的头结点)，添加失败则进入下次循环</li><li>检查内部正在扩容，就帮助它一块扩容</li><li>如果f!=null，则使用synchronized锁住元素(锁是链表/红黑树的头元素)<ol><li>如果Node(链表结构)则执行链表的添加操作</li><li>如果Node(树结构)则执行树的添加操作</li></ol></li><li>判断链表的长度是否达到临界值8(可修改的默认值)，达到8就将链表转为红黑树</li></ol></li><li>锁<ol><li>首先使用无锁操作CAS插入头节点，失败就循环重试</li><li>若已有头节点，则尝试获取头节点的同步锁，再进行操作</li></ol></li><li>Size方法和MappingCount方法异同</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol><h2 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3. 多线程"></a>3. 多线程</h2><ol><li>进程和线程<ol><li>进程<ol><li>是资源分配时的最小单元(独占一块内存，相互之间互不干扰)</li><li>可以看做是独立应用，线程只是进程的不同执行路径</li></ol></li><li>线程<ol><li>是CPU调度的最小单元(共享进程的内存资源，可以更细粒度的控制任务)</li></ol></li><li>进程和线程的关系<ol><li>运行一个程序会产生一个进程，进程至少包含一个线程</li><li>每个进程对应一个JVM实例，多线程共享JVM里的堆</li><li>Java采用单线程编程模型，程序会自动创建主线程</li><li>主线程可以创建子线程，在子线程之后完成执行</li></ol></li></ol></li><li>start和run方法<ol><li>start用于启动线程，而run用于运行线程</li><li>start方法会创建子线程并启动，而run方法是线程的一个普通方法调用</li></ol></li><li>实现线程<ol><li>继承Thread类，而Thread类底层也是实现了Runnable接口</li><li>直接实现Runnable接口，重写run方法</li><li>实现Callable接口，重写call方法</li><li>处理线程的返回值<ol><li>主线程等待法</li><li>使用线程的join方法用以阻塞等待子线程处理完毕</li><li>实现Callable接口，获取call方法的返回值</li><li>通过线程池来获取返回值</li></ol></li></ol></li><li>线程状态<ol><li>新建：创建后还没有启动的线程</li><li>运行：包含正在运行和等待运行的线程</li><li>无限等待：不会被分配CPU执行，需要显示被唤醒</li><li>限期等待：在一定时间后会由系统自动唤醒</li><li>阻塞：等待获取排他锁</li><li>结束：已终止线程的状态，执行结束</li></ol></li><li>等待线程和唤醒线程<ol><li>等待线程<ol><li>wait<ol><li>是Object类中的方法</li><li>只能在synchronized方法或synchronized块中使用</li><li>不仅释放CPU，而且会释放已经占有的同步资源锁</li></ol></li><li>sleep<ol><li>是线程类特有的方法</li><li>可以在任何地方调用</li><li>只会让出cpu，不会导致锁行为的改变</li></ol></li></ol></li><li>唤醒线程<ol><li>池<ol><li>锁池EntryList：等待获取锁的池</li><li>等待池WaitSet：等待线程的池</li></ol></li><li>notify<ol><li>只会随机选取一个处于等待池中的线程进入锁池中去竞争获取锁</li></ol></li><li>notifyAll<ol><li>会让所有处于等待池中的线程全部进入锁池去竞争获取锁</li></ol></li></ol></li><li>函数<ol><li>yield<ol><li>告知线程调度器当前(调用者)线程愿意让出CPU的暗示，但是线程调度器会忽略这个暗示</li><li>不会影响锁的行为(不会使当前线程让出已经占用的锁)</li></ol></li><li>interrupt<ol><li>停止线程：stop方法，suspend方法，resume方法</li><li>调用interrupt如果线程处于阻塞状态，那么线程立即退出阻塞状态，抛出InterruptedException异常</li><li>调用interrupt如果线程处于正常运行，那么会将其中断标志位设置为true，被中断标识的线程仍可以正常运行</li><li>需要被调用interrupt的线程配合中断</li></ol></li></ol></li><li>锁—解决多线程操作共享数据带来的数据不安全<ol><li>互斥锁<ol><li>互斥性：在同一时刻只允许一个线程持有某个对象锁</li><li>可见性：确保在锁被释放前，对共享变量的修改是对后面线程是可见的</li></ol></li><li>同步锁<ol><li>获取对象锁<ol><li>同步代码块，锁 是this</li><li>同步非静态方法，锁是当前对象的实例对象</li></ol></li><li>获取类锁<ol><li>同步代码块，锁是类的字节码文件</li><li>同步静态方法，锁是当前对象的类对象</li></ol></li><li>原理<ol><li>基于Java对象头和Monitor实现</li><li>对象在内存中的布局<ol><li>对象头：Mark Word和Class Metadata Address组成<ol><li>Mark Word：存储对象的运行时数据，默认存储对象的HashCode，分代年龄，锁类型，锁标志位等</li><li>Class Metadata Address：是指针，指向对象的类元数据</li></ol></li><li>Monitor<ol><li>每个Java对象自身存在的内部锁—java对象可以作为锁的原因</li><li>重入：一个线程试图获取自己持有对象锁的临界资源时</li><li>阻塞：一个线程试图获取由其他线程持有的对象锁的临界资源时</li></ol></li><li>实例数据</li><li>对齐填充</li></ol></li><li>早期的synchronized锁<ol><li>属于重量级锁，依赖于Mutex Lock实现</li><li>线程之间的切换需要从用户态转到核心态，开销大</li></ol></li><li>自旋锁：通过让线程忙于循环等待锁的释放，不让出CPU的执行权；若锁被其他线程长时间占用，则会带来许多性能上的开销</li><li>自适应自旋锁：自旋的次数由前一次在同一个锁上自旋的时间以及锁的拥有者状态来决定</li><li>锁消除：JIT在编译时，对运行上下文进行扫描，消除不可能存在竞争的锁</li><li>状态<ol><li>无锁</li><li>偏向锁：减少同一线程获取锁的代价，不适用于锁竞争比较激烈的情况</li><li>轻量级锁</li><li>重量级锁</li><li>锁升级：无锁—偏向锁—轻量级锁—重量级锁</li></ol></li></ol></li></ol></li><li>ReentranLock(重入锁)<ol><li>位于Java.util.concurrent.locks包下</li><li>和CountDownLatch，FutureTask，Semaphore一样基于AQS实现<ol><li>AQS：AbstractQueueSynchronizer</li></ol></li><li>实现比synchronized更细粒度的控制，如fairness(公平锁)<ol><li>公平锁：获取锁的顺序按先后调用lock方法的顺序</li><li>非公平锁：抢占机制，优先度高的抢到的几率大</li></ol></li><li>调用lock方法后，必须调用unlock释放锁</li><li>区分synchronized锁<ol><li>synchronized是关键字，而ReentranLock是类</li><li>ReentranLock可以对锁的等待时间进行设置，避免死锁</li><li>ReentranLock可以获取各种锁的信息，可以灵活的实现多路通知</li><li>synchronized操作的是Mark Word，lock锁操作的是Unsafe类的park方法</li></ol></li></ol></li><li>JMM—Java Memory Model<ol><li>主内存<ol><li>存储Java实例对象</li><li>包括成员变量，类信息，常量，静态变量等</li><li>属于数据共享区域，多线程并发操作时会引发线程安全问题</li></ol></li><li>工作内存<ol><li>存储的是当前方法的所有本地变量信息，本地变量对其他线程不可见</li><li>字节码行号指示器，Native方法信息</li><li>属于线程私有数据区域，不存在线程安全问题</li></ol></li><li>区分Java内存划分<ol><li>JMM描述的是一组规则，围绕原子性，有序性，可见性展开</li><li>同Java内存相似，都存在共享区和私有区</li><li>方法里的基本数据类型和本地变量直接存储在工作内存的栈帧结构中</li><li>引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中</li><li>成员变量：static变量，类信息均会存储在主内存中</li></ol></li><li>指令重排序<ol><li>在单线程情况下不能改变程序运行的结果</li><li>存在数据依赖关系的不允许重排序</li><li>无法通过Happens-before原则推导出来的，才能进行指令重排序<ol><li>A操作的结果需要对B操作可见，则A和B存在happens-before关系</li><li>happens-before的原则<ol><li>程序次序规则：一个线程内，按照代码顺序，先写的代码先执行</li><li>锁定规则：一个unLock操作优先后面对同一个锁的lock操作</li><li>Volatile变量规则：一个变量的写操作优先于后面对这个变量的读操作</li><li>传递规则：如果A操作优于B操作，B操作优于C操作，那么A操作优于C操作</li><li>线程启动规则：Thread对象的start方法优先执行在该线程的每一个动作之前</li><li>线程中断规则：对线程interrupt方法的调用优于被中断线程的代码检测到中断事件前发生</li><li>线程终结规则：线程中所有的操作都优于线程终止检测事件</li><li>对象终结规则：一个对象的初始化完成优于其finalize方法执行</li></ol></li></ol></li></ol></li><li>Volatile<ol><li>JVM提供轻量级同步机制</li><li>由Volatile修饰的共享变量对所有线程总是可见的</li><li>禁止指令的重排序优化<ol><li>内存屏障<ol><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性</li></ol></li><li>通过插入内存屏障指令来禁止在内存屏障前后的指令执行重排序优化</li><li>强制刷出CPU的缓存数据，因此在cpu上的任何线程都能读取到这些数据的最新版本</li></ol></li><li>可见性分析<ol><li>定义一个Volatile变量时，JMM会把该线程对应的工作内存中的共享变量刷新到主内存中</li><li>读取一个Volatile变量时，JMM会把该线程对应的工作内存置为无效</li></ol></li></ol></li><li>Volatile和synchronized的区别<ol><li>Volatile本质是告知JVM当前变量在寄存器(工作内存)中的值不确定需要从主内存中读取，synchronized只是锁定当前变量</li><li>Volatile仅用于变量级别，synchronized可以用在变量，方法，类上</li><li>Volatile不会造成线程阻塞，synchronized会造成线程阻塞</li><li>Volatile标记的变量不会被编译器优化，synchronized标记的变量会被编译器优化</li></ol></li></ol></li><li>CAS(乐观所锁)—一种高效实现线程安全性的方法<ol><li>支持原子更新操作，适用于计数器，序列发生器等场景</li><li>属于乐观锁机制，号称lock-free</li><li>CAS操作失败 后开发者决定是否继续尝试，还是执行别的操作</li><li>包含三个操作数：内存位置，预期原值和新值</li><li>缺点<ol><li>若循环时间长，则开销大</li><li>只能保证一个共享变量的原子操作</li><li>ABA问题—一个变量A改变到B未被检测出来，导致两次读取的值都是A—通过AtomicStampedReference类改变</li></ol></li></ol></li></ol></li><li>线程池<ol><li>Executor接口<ol><li>Executor：运行新任务的简单接口，将任务提交和任务执行细节解耦</li><li>ExecutorService：具备管理执行器和任务生命周期的方法，提交任务 机制更完善</li><li>SchduledExecutorService：支持Future和定时任务</li></ol></li><li>5种不同场景的线程池创建<ol><li>newFixedThreadPool(int nThread)：指定工作线程数量的线程池</li><li>newCachedThreadPool()：短时间处理大量工作任务的线程池</li><li>newSingleThreadExecutor()：创建唯一的工作线程来执行任务，如果该线程一结束，会有另一个线程取代它</li><li>newSingleThreadScheduledExecutor()和newScheduledThreadExecutor(int corePoolSize)：定时或者周期性的工作调度线程池，两个的区别在于单一工作线程还是多线程</li><li>newWorkStealingPool()：内部构建ForkJoinPool，利用working-stealing算法，并行的执行任务，不保证处理顺序<ol><li>Fork/Join框架<ol><li>把大任务分割为有限的小任务执行，把每个小 任务的执行结果汇总得到大任务结果的框架</li></ol></li><li>work-stealing算法：某个线程从其他队列里窃取任务来执行</li></ol></li><li>确定线程池的大小<ol><li>CPU密集型：线程数=核数+1</li><li>IO密集型：线程数=核数*（1+平均等待时间/平均工作时间）</li></ol></li></ol></li><li>优势<ol><li>降低资源的消耗</li><li>提高线程的可管理性</li></ol></li><li>ThreadPoolExecutor构造函数<ol><li>corePoolSize：核心线程数量</li><li>maximunPoolSize：线程不够用时，最多可创建的线程数</li><li>workQueue：任务等待队列</li><li>keepAliveTime：抢占顺序不一定</li><li>ThreadFactory：创建新线程</li><li>Handler：线程池的饱和策略<ol><li>AbortPolicy：直接抛出异常，默认策略</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务，并执行当前任务</li><li>DiscardOldPolicy：丢弃队列中最靠前的任务，并执行当前任务</li><li>DiscardPolicy：直接丢弃任务</li><li>通过实现RejectedExecutorHandler接口来自定义Handler</li></ol></li></ol></li><li>executor流程<ol><li>如果线程数少于corePoolSize，则直接创建新线程来执行任务，即使线程池中其他线程是空闲的</li><li>如果线程池中的线程数量大于等于corePoolSize而小于maximumPoolSize，只有当workQueue满时才去创建新线程处理任务</li><li>如果corePoolSize和maximumPoolSize值相同，则创建的线程池大小固定的，这是如果有新任务，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取出任务并执行</li><li>如果运行的线程数大于等于maximumPoolSize，这时如果workQueue已满，则通过Handler所指定的策略来处理任务</li></ol></li><li>线程池的状态<ol><li>Runing：能够接受新任务提交，也可以处理阻塞队列中的任务</li><li>Shutdown：不在接受新提交的任务，但可以处理存量任务</li><li>Stop：不在接受新提交的任务，也不处理存量任务</li><li>Tidying：所有任务都已终止</li><li>Terminated：terminated方法执行后进入该状态(仅作标识)</li></ol></li></ol></li></ol></li></ol><h2 id="4-JVM"><a href="#4-JVM" class="headerlink" title="4. JVM"></a>4. JVM</h2><ol><li><p>Java跨平台原理</p><ul><li>基于不同平台的JVM实现，即在不同平台安装对应的JDK就能运行Java程序</li></ul></li><li><p>Java反射</p><ul><li>动态获取任意类，对象的属性和方法</li><li>这种在运行状态中动态获取信息以及调用对象方法的特性称为Java的反射机制</li><li>API：getDeclaredMethod(getMethod)：接收方法名，方法名对应的字节码对象</li><li>本质：把Java类中的方法和属性映射为Java对象</li></ul></li><li><p>类加载机制</p><ul><li>虚拟机将class文件加载进内存的行为</li><li>加载流程<ul><li>通过ClassLoader加载class字节码文件，生成class对象</li><li>检查class的正确性和安全性</li><li>为变量分配内存空间和设置初始值</li><li>JVM常量池中的符号引用转为直接引用</li><li>执行类变量赋值和静态代码块</li></ul></li><li>双亲委派机制<ul><li>一个类收到类加载请求时，会将请求委派给父类，如果父类不能加载才由子类去完成加载</li><li>避免同样的字节码文件被加载多次</li></ul></li><li>四种类加载器<ul><li>启动类加载器：用于加载Java的核心类库</li><li>扩展类加载器：用于加载Java的扩展库</li><li>系统类加载器：根据Java的类路径来加载Java类</li><li>用户自定义类加载器：通过继承Classloader类的方式实现</li></ul></li><li>LoaderClass和forName<ul><li>在运行时都能知道该类的属性和方法</li></ul></li></ul></li><li><p>内存结构 </p><ol><li>线程私有<ol><li>虚拟机栈，本地方法栈，程序计数器<ol><li>虚拟机栈<ol><li>Java方法执行的基础</li><li>包含多个栈帧(栈帧用于存储局部变量表，操作数栈，动态链接，方法出口)</li></ol></li><li>本地方法栈<ol><li>和虚拟机栈类似，主要用于标注native方法</li></ol></li><li>程序计数器<ol><li>当前线程所执行的字节码行号指示器(逻辑指示器)</li><li>改变计数器的值来选取下一条所需执行的字节码指令</li><li>和线程是一对一关系(即线程有)</li><li>对Java方法计数，如果是native方法则计数器值undefined</li></ol></li></ol></li></ol></li><li>线程共享<ol><li>堆<ol><li>对象实例的分配区域</li><li>GC管理的主要区域</li><li>JDK7以后常量池存在于堆中，方便GC(之前存在于永久代中，浪费内存)</li></ol></li><li>元空间(MetaSpace)和永久代(PermGen)—是方法区的实现<ol><li>都是用来存储class的相关信息</li><li>元空间使用的本地内存，而永久代使用的是JVM内存，所以元空间替代了永久代</li><li>字符串常量池存在于永久代中，容易出现性能问题和内存溢出</li><li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li><li>永久代为GC带来不必要的复杂性</li></ol></li><li>堆和栈的区别<ol><li>联系：引用对象，数组时，栈里定义变量保存在堆中的地址</li><li>管理方式：栈可以自动释放，堆需要GC</li><li>空间：栈比堆小</li><li>碎片：栈内存产生的碎片远小于堆</li><li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li><li>效率：栈的效率比堆高</li></ol></li></ol></li></ol></li><li><p>GC机制</p><ol><li>没有被其他对象引用时，就判定为垃圾</li><li>垃圾判定算法<ol><li>引用计数法<ol><li>通过判断对象的引用数量来决定对象是否可以被回收</li><li>为每个对象创建一个引用计数器，被引用的计数器值+1，完成引用后计数器值-1</li><li>当引用计数器值为0时，就认定该对象为垃圾</li><li>优点：执行效率高，程序执行受影响小</li><li>缺点：无法检测出循环引用的情况，导致内存泄漏(子类和父类之间循环引用，计数器值就没有为0的情况)</li></ol></li><li>可达性分析算法—基于图论<ol><li>判断对象的引用链是否可达，不可达就认定为垃圾</li><li>GC Root对象<ol><li>虚拟机栈中引用的对象(栈帧中的本地变量表)</li><li>方法区中常量引用的对象</li><li>方法区中静态属性引用的对象</li><li>本地方法栈中JNI(native方法)引用的对象</li><li>活跃线程引用的对象</li></ol></li></ol></li></ol></li><li>垃圾回收算法<ol><li>标记-清除算法<ol><li>标记：从跟集合进行扫描，对存活的对象进行标记</li><li>清除：对堆内存从到尾进行线程遍历，回收不可达的对象</li><li>缺点：产生碎片块多</li></ol></li><li>复制算法<ol><li>分为对象面和空闲面</li><li>对象在对象面上创建</li><li>将存活的对象从对象面复制到空闲面</li><li>将对象面的所有对象从内存中清除</li><li>优点<ol><li>解决碎片化问题</li><li>顺序分配内存，简单高效</li><li>适用于对象存活率低的场景(如年轻代)</li></ol></li></ol></li><li>标记-整理算法<ol><li>标记：从跟集合进行扫描，对存活的对象进行标记</li><li>整理：移动所有存活的对象，且按照内存地址依次排序，然后将末端内存地址以后的内存全部回收</li></ol></li><li>分代收集算法<ol><li>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法，提高了JVM的回收效率</li><li>JDK8以前分为年轻代，老年代，永久代；JDK8开始取消永久代</li><li>Minor GC发生在年轻代中的收集动作，采用的是复制算法<ol><li>尽可能快速的收集哪些生命周期短的对象</li><li>主要分为Eden区和两个Survivor区(包含一个from区和to区)[Eden:from:to=8:1:1]</li><li>每次触发GC后存活的对象年龄值+1，默认是15岁后进入老年代</li></ol></li><li>Full GC<ol><li>经历一定次数(默认是15次)的Minor GC后依然存活的对象开始进入老年代</li><li>Survivor区存放不下的大对象直接进入老年代</li><li>发生在老年代的收集动作，存放生命周期较长的对象；采用标记-清除算法和标记-整理算法</li><li>触发Full GC<ol><li>老年代和永久代空间不足</li><li>CMS GC时出现promotion failed，concurrent mode failure</li><li>Minor GC升级老年代的平均大小大于老年代的剩余空间</li><li>调用System.gc()方法—只是提醒虚拟机需要在这里进行回收，具体的回收操作由虚拟机自己决定</li><li>通过RMI来进行RPC或管理JDK引用，默认每1小时进行一次Full GC</li></ol></li></ol></li></ol></li><li>调优参数<ol><li>-XX:SurvivorRatio：设置Eden和Survivor的比值，默认是8:1</li><li>-XX:NewRatio：设置老年代和年轻代内存大小的比例</li><li>-XX:MaxTenuringThreshold：对象从年轻代升级为老年代需要出发Minor GC的次数</li></ol></li><li>Stop_the_World<ol><li>JVM由于要执行GC而停止了应用程序的执行</li><li>任何一种GC都会发生</li><li>通过避免减少Stop_the_World的发生时间来提高程序性能</li></ol></li><li>Safepoint(安全点)<ol><li>触发GC的快照点</li><li>分析过程中对象引用关系不会产生变化的点</li><li>Safepoint可能点：方法调用，循环跳转，异常跳转等</li><li>要确保安全点数量适中</li></ol></li></ol></li><li>垃圾收集器<ol><li>新生代垃圾收集器<ol><li>Serial收集器<ol><li>单线程收集，进行垃圾收集时，必须暂停所有的工作线程</li><li>简单高效，Client模式下默认的年轻代收集器</li></ol></li><li>ParNew收集器<ol><li>多线程收集器，其余和Serial相同</li><li>单线程执行效率不如Serial，在多核环境下才有优势</li></ol></li><li>Parallel Scavenge收集器<ol><li>更关注系统的吞吐量</li><li>在多核执行才有优势，Server模式下默认的年轻代收集器</li></ol></li></ol></li><li>老年代垃圾收集器<ol><li>Serial Old收集器<ol><li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li><li>简单高效，Client模式下默认的老年代收集器</li></ol></li><li>Parallel Old收集器<ol><li>多线程，吞吐量优先</li></ol></li><li>CMS收集器<ol><li>初始标记：Stop_the_World</li><li>并发标记：并发追溯标记，程序不会停顿</li><li>并发预清理：查找执行文件并发标记阶段从年轻代晋升老年代的对象</li><li>重新标记：暂停虚拟机，扫描CMS堆中的剩余对象</li><li>并发清理：清理垃圾对象，程序不会停顿</li><li>并发重置：重置CMS收集器的数据结构</li></ol></li><li>Garbage First收集器<ol><li>并发和并行</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li><li>将Java堆内存划分为多个大小相等的Region</li></ol></li><li>finalize方法</li><li>Java中的强引用，软引用，弱引用，虚引用<ol><li>强引用<ol><li>最普遍的引用，抛出OutMemoryError终止程序也不会回收具有强引用的对象</li><li>通过将对象置为null来弱化其引用，使其被回收</li></ol></li><li>软引用<ol><li>对象处于有用但非必须的状态</li><li>只有当空间不足时，GC会回收该引用对象的内存</li><li>用来实现高速缓存</li></ol></li><li>弱引用<ol><li>非必须引用对象，比软引用更弱一些</li><li>GC触发时会被回收</li><li>被回收的几率不大，因为GC线程的优先级比较低</li><li>适用于偶尔使用的对象</li></ol></li><li>虚引用<ol><li>不会决定对象的生命周期</li><li>任何时候都可能会被GC</li><li>用于跟踪垃圾回收器的回收活动，起到哨兵作用</li><li>必须和引用队列联合使用</li></ol></li><li>引用队列<ol><li>没有实际的存储结构，存储逻辑依赖于内部节点之间的关系来表达</li><li>存储关联被GC的软引用，弱引用，以及虚引用</li></ol></li><li>JVM调优<ol><li>调优参数含义<ol><li>-Xss：表示每个虚拟机栈(堆栈)的大小</li><li>-Xms：堆的初始值</li><li>-Xmx：堆能达到的最大值(一般情况下将-Xms和-Xmx值设置相同，避免扩容时的内存抖动而影响程序运行时的稳定性)</li></ol></li><li>内存分配策略<ol><li>静态存储：编译时确定每个数据目标在运行时的存储空间</li><li>栈式存储：数据区在编译时未知，运行时模块入口前确定</li><li>堆式存储：编译时或运行时模块入口都无法确定，动态分配</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li><li><p>内存溢出</p><blockquote><p>程序在申请内存的时候，没有足够的内存供其使用</p></blockquote><ul><li>死循环</li><li>递归</li><li>大对象太多，Java中的大对象是可以直接进入老年代的</li></ul></li><li></li></ol><h2 id="5-MySQL"><a href="#5-MySQL" class="headerlink" title="5. MySQL"></a>5. MySQL</h2><ol><li>关系型数据库<ul><li>数据库模块<ul><li>存储模块—OS文件系统(将数据持久化存储到硬盘，磁盘中)</li><li>程序实例—用逻辑结构来映射物理结构<ul><li>存储管理</li><li>缓存机制</li><li>sql解析模块</li><li>日志管理</li><li>权限划分</li><li>容灾机制</li><li>索引管理</li><li>锁管理</li></ul></li></ul></li></ul></li><li>索引<ul><li>作用：提高查询效率</li><li>实例：主键，唯一键(id)，让数据具备一定区分性的字段等可以作为索引</li><li>数据结构<ul><li>生成索引建立二叉树进行二分查找</li><li>生成索引建立B树结构进行查找</li><li>生成索引建立B+树结构进行查找</li><li>生成索引，建立hash结构进行查找</li></ul></li></ul></li><li>树结构介绍<ul><li>二叉查找树<ul><li>查询效率：O(logn)</li><li>左子树：左子树节点值均小于根节点值</li><li>右子树：右子树节点值均大于根节点值</li><li>注意：二叉树在有限次增删改之后会变成线性结构，此时查询效率为O(n)</li><li>解决：利用树的旋转特性，将二叉树转为平衡二叉树，这样查询效率会维持在O(logn)</li><li>平衡二叉树：大数据量情况下，由于每个节点只能有两个叶子节点，大大增加了树的层级和存储空间；会浪费大量的磁盘IO</li></ul></li><li>B树<ul><li>一种多路平衡查找树，每个节点最多有M个子节点，称为M阶B树，但至少有两个子节点</li><li>查询效率O(logn)</li></ul></li><li>B+树<ul><li>每个叶子节点的指针数和关键字数相同，同阶的B+树比B树能存储更多的关键字</li><li>优势<ul><li>磁盘读写代价更低</li><li>查询效率更为稳定</li><li>更有利于数据库的扫描(B+树只需遍历所有的叶子节点就能对全部的关键字进行扫描)</li></ul></li></ul></li><li>Hash索引<ul><li>根据Hash函数计算一次便能找到所需元素</li><li>仅仅满足=，in等等值查询，不能使用范围查询</li><li>不能进行排序操作，因为经过Hash运算后的值和运算前的键值对应，而查找是Hash索引对应的值，不能匹配到</li><li>不能避免全表 扫描</li></ul></li><li>BitMap<ul><li>仅Oracle支持</li><li>锁的粒度较大，新增和修改操作时，在同一位图的数据操作都会被阻塞</li></ul></li></ul></li><li>密集索引和稀疏索引<ul><li>密集索引：每个搜索码值都对应一个索引值</li><li>稀疏索引：只为索引码的某些值建立索引项</li></ul></li><li>InnoDB<ul><li>若一个主键被定义，则该主键则作为密集索引</li><li>若无主键定义，则该表第一个唯一非空索引值作为密集索引</li><li>若无以上，innodb内部会生成一个隐藏主键(密集索引)</li><li>数据和索引是存储在一起的，MyIsAM数据和索引是分开的</li></ul></li><li>优化步骤<ol><li>根据慢查询日志定位慢查询sql<ol><li>变量<ol><li>慢查询日志：slow_query_log</li><li>慢查询文件路径：slow_query_log_file</li><li>慢查询时间：long_query_time</li><li>开启慢查询日志：set global slow_query_log = on;</li></ol></li><li>状态<ol><li>slow_queries：慢查询数量</li></ol></li></ol></li><li>使用explain等工具分析 sql<ol><li>type：查找数据行的方式，index(索引)&gt;all(全表扫描)</li><li>extra：Using filesort和Using temporary意味着不走索引，应该进行优化</li></ol></li><li>修改sql或者尽量让sql走索引<ol><li>修改sql走索引</li><li>为查询字段添加索引</li></ol></li></ol></li><li>原则<ul><li>最左前缀匹配原则，mysql会一直向右匹配，直到范围限定，如果范围之间有索引，则只有第一个条件会走索引，其他不会走索引</li><li>=和in查询无需考虑索引顺序</li></ul></li></ol><p>索引相当于目录在书中的地位，内容远远多于目录时才适合建立。</p><ol><li><p>锁</p><ul><li><p>MyIsAM和InnoDB锁的区别</p><ul><li>MyIsAM默认使用表级锁，不支持行级锁</li><li>InnoDB默认使用行级锁，也支持表级锁</li></ul></li><li><p>排他锁和共享锁的区别</p><table><thead><tr><th></th><th>排他锁</th><th>共享锁</th></tr></thead><tbody><tr><td>排他锁</td><td>冲突</td><td>冲突</td></tr><tr><td>共享锁</td><td>冲突</td><td>兼容</td></tr></tbody></table></li><li><p>乐观锁和悲观锁</p></li><li><p>MyIsAM和InnoDB使用场景</p><ul><li>MyIsAM<ul><li>频繁的执行全表count语句</li><li>对数据进行增删频率不高，查询频率非常高</li><li>没有事务</li></ul></li><li>InnoDB<ul><li>数据增删改查的频率都非常频繁</li><li>可靠性要求比较高，要求支持事务</li></ul></li></ul></li><li><p>当前读和快照读</p></li><li><p>RC，RR级别下的InnoDB非阻塞读实现</p><ul><li>RR避免幻读，加行锁+Gap锁(gap锁用于非唯一索引和不走索引时)</li></ul></li></ul></li><li><p>事务的四大特性</p><ul><li>ACID</li><li>原子性，一致性，隔离性，持久性</li><li>隔离级别<ul><li>读已提交(RC)—解决脏读：一个事物读到另一个事务未提交的数据</li><li>可重复读(RR)—解决不重复读：一个数据前后两次读到的数据不一致</li><li>串行化—解决幻读：一个事物读到自己未提交的事务</li></ul></li></ul></li><li><p>锁的分类</p><ol><li>读锁又称为共享锁</li><li>写锁又称为排他锁</li><li>共享锁和排他锁，只有两个事务都是共享锁时不冲突</li><li>排他锁：增删改操作</li><li>共享锁：查询操作</li><li>悲观锁：在数据处理过程中将数据锁定，排他锁就是悲观锁的体现；为数据处理的安全性提供保证，同时也增加了产生死锁的机会</li><li>乐观锁：认为一般不会发生冲突，只有在更新数据时才会进行检测，如果冲突就返回错误信息(时间戳或数据版本)</li></ol></li><li><p>RC</p><ol><li>Oracle默认的提交方式</li><li>实现快照读(非阻塞读)<ol><li>数据行必须有DB_TRX_ID，DB_ROLL_PTR，DB_ROW_ID字段</li><li>undo日志</li><li>read view</li></ol></li></ol></li><li><p>RR</p><ol><li>MySQL默认的提交方式</li><li>行锁+gap锁</li><li>gap锁<ol><li>精确查找的时候，所有记录都有对应不会加gap锁</li><li>where条件部分命中，会加gap锁</li><li>用于非唯一索引或不走索引的当前读中</li></ol></li></ol></li><li><p>关键语法</p><ul><li>Group by<ul><li>Select语句中的列名必须为分组用到的列或列函数</li><li>只能是针对同一张表的字段进行分组</li></ul></li><li>having<ul><li>通常和Group By一起使用，where过滤行，having过滤组</li><li>如果省略了where，having的作用和where相同</li></ul></li></ul></li></ol><h2 id="6-Redis"><a href="#6-Redis" class="headerlink" title="6. Redis"></a>6. Redis</h2><ul><li>缓存中间件<ul><li>Memcache：代码层次类似于Hash<ul><li>支持简单的数据类型</li><li>不支持数据持久化存储和主从复制，以及分片</li></ul></li><li>Redis<ul><li>数据类型丰富</li><li>支持数据磁盘持久化和主从复制，以及分片</li><li>每秒100000+QPS，QPS即每秒内查询次数</li></ul></li></ul></li><li>为什么Redis速度快<ul><li>完全基于内存，没有磁盘IO操作，执行效率高</li><li>数据结构简单，对数据操作也简单</li><li>采用单线程也能处理高并发，多核也可以启动多实例</li><li>使用多了IO复用模型，即非阻塞式IO，采用多路复用函数</li></ul></li></ul><ol><li>数据类型<ul><li>String：基本数据类型，二进制安全</li><li>Hash：String组成的字典，适合存储对象</li><li>List：列表，按照String元素插入顺序排序</li><li>Set：String元素组成的无序集合，通过Hash表现，不允许重复</li><li>Sorted Set：通过分数类为集合中的成员进行从小到大的排序</li><li>HyperLogLog：用于支持存储地理位置信息</li></ul></li><li>大数据查询固定前缀的key<ul><li>使用scan count match key*</li></ul></li><li>分布式锁<ul><li>面临问题<ul><li>互斥性</li><li>安全性</li><li>死锁</li><li>容错</li></ul></li><li>解决<ul><li>使用set方法设置键的过期时间并给键添加一个随机字符，避免键集中过期时造成的卡顿</li></ul></li></ul></li><li>异步队列<ul><li>使用List做为队列，RPush产生消息，LPop消费消息<ul><li>缺点：没有等待队列有值就进行消费</li><li>解决<ol><li>通过应用层引入Sleep机制调用LPop重新消费</li><li>阻塞直到队列有消息或者超时；缺点：只能提供一个消费者消费</li><li>主题订阅模式；缺点：无法保证消息可达性</li></ol></li></ul></li></ul></li><li>持久化方式<ul><li>RDB<ul><li>保存某个时间点的全部数据快照方式，文件小，恢复快，数据丢失风险大</li><li>触发<ul><li>redis.conf文件配置的save m n定时触发</li><li>主从复制，主节点自动触发</li><li>执行Debug Reload时</li><li>执行Shutdown时</li></ul></li></ul></li><li>AOF<ul><li>保存到写状态，文件可读，适合保存增量数据；数据丢失风险小，但文件呢体积较大，恢复时间较长</li></ul></li><li>解决：混合模式—RDB做镜像的全量持久化，而AOF做增量的持久化</li></ul></li><li>主从同步<ul><li>Pipeline：批量执行Redis指令，节省多次IO往返的时间</li><li>同步原理 <ul><li>从节点发送同步命令到主节点</li><li>主节点启动一个后台进程，将Redis中的数据快照保存到文件中</li><li>主节点将保存数据快照期间接收到的写命令缓存起来</li><li>主节点完成文件操作后，将该文件发送给从节点</li><li>使用新的AOF文件替换旧的AOF文件</li><li>主节点将这期间收集的增量命令发送给从节点</li></ul></li></ul></li><li>集群<ul><li>哨兵<ul><li>主从复制的基石，由哨兵们监控集群状态，主节点宕机后根据定义规则选举新的主节点，保证系统的运行</li></ul></li><li>流言协议：在杂乱无章中寻求一致；用于主从切换<ul><li>消息节点向其他节点随机发送消息，最终消息会趋于一致性</li></ul></li><li>原理<ul><li>分片：按照一定规则划分数据，分散存储在多个节点上</li><li>获取：一致性哈希算法，对2^32取模，将hash值空间组成虚拟环</li></ul></li></ul></li></ol><h2 id="7-MongoDB"><a href="#7-MongoDB" class="headerlink" title="7. MongoDB"></a>7. MongoDB</h2><h2 id="8-Mybatis"><a href="#8-Mybatis" class="headerlink" title="8. Mybatis"></a>8. Mybatis</h2><h2 id="9-Spring"><a href="#9-Spring" class="headerlink" title="9. Spring"></a>9. Spring</h2><ol><li>IOC<ol><li>控制反转IOC：Spring最核心的部分，主要是用来创建对象</li><li>依赖注入DI：把第层类作为参数传递给上层类，实现上层对下层的”控制”<ol><li>是IOC的一种特殊实现</li><li>Setter</li><li>Interface</li><li>Constructor</li><li>Annotation</li></ol></li><li>依赖查找DL：IOC的另一种实现</li><li>优势<ol><li>避免在各处使用new来创建类，并且可以做到统一维护</li><li>创建实例的时候不需要了解其中的细节</li></ol></li><li>功能<ol><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调方法</li></ol></li><li>核心接口<ol><li>BeanDefinition：主要用来描述Bean的定义</li><li>BeanDefinitionRegistry：提供向IOC容器注册BeanDefinition对象的方法</li><li>BeanFactory：Spring最核心的接口<ol><li>提供IOC的配置机制</li><li>包含Bean的各种定义，便于实例化Bean</li><li>建立Bean之间的依赖关系</li><li>Bean生命周期的控制</li></ol></li><li>ApplicationContext<ol><li>继承BeanFactory接口，能够管理和装配Bean</li></ol></li></ol></li></ol></li><li>AOP</li></ol><h2 id="10-SpringMVC"><a href="#10-SpringMVC" class="headerlink" title="10. SpringMVC"></a>10. SpringMVC</h2><h2 id="11-Dubbo-zookeeper"><a href="#11-Dubbo-zookeeper" class="headerlink" title="11. Dubbo+zookeeper"></a>11. Dubbo+zookeeper</h2><h2 id="12-SpringCloud"><a href="#12-SpringCloud" class="headerlink" title="12. SpringCloud"></a>12. SpringCloud</h2><h2 id="13-网络基础"><a href="#13-网络基础" class="headerlink" title="13. 网络基础"></a>13. 网络基础</h2><ol><li><p>OSI网络基础</p><ul><li><p>七层模型</p><ul><li>物理层：电子接口通信信道上的原始比特流传输</li><li>数据链路层：将原始比特流转为逻辑传输线路</li><li>网络层：控制子网的运行，分组传输，路由选择</li><li>传输层：保证会话层的数据段有效的到达网络层</li><li>会话层：建立和管理应用层的会话</li><li>表示层：</li></ul></li><li><p>TCP</p><ul><li><p>流程</p><ul><li>面向连接的，可靠的，基于字节流的传输层通信协议</li><li>将应用层的数据流分割为报文段并发送给目标节点的TCP层</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和来检验数据在传输过程中是否有误</li></ul></li><li><p>标识</p><ul><li>URG：紧急指针标志</li><li>ACK：确认序号标志</li><li>PSH：push标志</li><li>PST：重置连接标志</li><li>SYN：同步序号，用于建立连接过程</li><li>FIN：finish标志，用于释放连接</li></ul></li><li><p>三次握手</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%8A%B6%E6%80%81.png"></p><ul><li>说明<ul><li>建立连接时，客户端发送syn包到服务器，并进入syn_send状态，等待服务器确认。</li><li>服务器收到syn包，必须确认客户的syn包为接收值+1，同时自己也发送一个syn包，即syn+ack包，此时服务器进入syn_recv状态</li><li>客户端受到服务器的syn+ack包，向服务器发送确认包ack为接收服务的值+1，此时包发送完毕，客户端和服务器端进入restablished状态完成三次握手</li></ul></li></ul></li><li><p>四次挥手</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p><ul><li>说明<ul><li>客户端发送fin字段来请求关闭连接到服务器，客户端进入fin_wait_1状态</li><li>服务器端接收到fin字段后，发送ack给客户端，确认序号为收到的序号+1，此时服务器进入close_wait状态</li><li>服务器发送fin字段，用来关闭服务器到客户端的数据传送，服务器进入last_ack状态</li><li>客户端收到fin后，进入time_wait状态，向服务器发送ack确认序号为收到序号+1，服务器进入closed状态，完成四次挥手</li></ul></li><li>服务器出现close_wait状态的原因<ul><li>服务器端未进行释放资源的操作</li><li>处理请求的线程配置不合理</li></ul></li></ul></li></ul></li><li><p>UDP</p><ul><li>特点<ul><li>面向非连接，不维护连接状态，支持同时向多个客户端传输相同的消息</li><li>数据包报头只有8个字节，额外开销小</li><li>吞吐量只受限于数据生成的速率，传输速率以及机器性能</li><li>尽最大努力交付，不保证交付的可靠性，不需要维持复杂的连接状态</li><li>面向报文，不对应用程序提交报文信息进行拆分合并</li></ul></li></ul></li><li><p>TCP和UDP对比</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>TCP</td><td>1. 面向连接<br>2. 传输可靠<br>3. 传输有序</td><td>1. 传输速度慢<br>2. 重量级传输协议</td></tr><tr><td>UDP</td><td>1. 传输速度高<br>2. 轻量级传输协议</td><td>1. 面向无连接<br>2. 不保证可靠性<br>3. 不保证有序性</td></tr></tbody></table></li><li><p>TCP的滑动窗口</p><blockquote><p>TCP使用滑动窗口做流量控制与乱序重排</p></blockquote><ul><li>保证TCP的可靠性</li><li>保证TCP的流控特性</li></ul></li></ul></li><li><p>HTTP</p><ul><li><p>特点</p><ul><li>支持客户和服务器模式</li><li>简单快速灵活</li><li>无连接，无状态</li></ul></li><li><p>步骤</p><ul><li>根据DNS解析的域名地址访问服务器</li><li>和服务器之间建立TCP连接(三次握手)</li><li>客户端发送HTTP请求到web服务器</li><li>服务器接收请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>浏览器释放连接(四次挥手)</li></ul></li><li><p>状态码</p><ul><li>200：请求成功</li><li>401：未授权</li><li>403：服务被拒绝</li><li>404：未找到资源</li><li>500：服务器端错误，代码异常</li><li>503：服务器当前不能处理请求，需要等待，常见于服务启动尚未被注册中心发现。</li></ul></li><li><p>get和post的区别</p><table><thead><tr><th></th><th>get</th><th>post</th></tr></thead><tbody><tr><td>HTTP报文</td><td>将请求信息放在URL地址栏中</td><td>放在报文主体中</td></tr><tr><td>数据库</td><td>符合幂等性和安全性</td><td>不符合</td></tr><tr><td>其他</td><td>可以被缓存，被存储</td><td>不可以被缓存存储</td></tr></tbody></table></li><li><p>cookie和session的区别</p><ul><li>cookie保存在客户端浏览器相对不安全，大小为4k限制 </li><li>session保存在服务器端相对安全，借助于cookie实现，无大小限制</li></ul></li></ul></li><li><p>HTTPS</p><ul><li>加密<ul><li>对称加密：加密和解密都使用同一个密钥</li><li>非对称加密：加密使用的密钥和解密使用的密钥不同</li><li>哈希算法：将任意长度值的信息转换为固定长度的汉字，算法不可逆，常见的是MD5</li><li>数字签名：证明某个消息或者文件是某人发出/认同的</li></ul></li><li>HTTPS流程<ul><li>浏览器将支持的加密算法信息发送给服务器</li><li>服务器选择一套浏览器支持的加密算法，以证书的形式发送给浏览器</li><li>浏览器验证证书的合法性，并结合证书公钥加密信息发送给服务器</li><li>服务器使用私钥解密信息，验证哈希，加密响应消息发送给浏览器</li><li>浏览器解密响应消息，并对消息验证真假，之后进行加密交互数据</li></ul></li></ul></li><li><p>HTTP和HTTPS区别</p><table><thead><tr><th></th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>证书</td><td>不需要CA证书</td><td>需要到CA申请证书</td></tr><tr><td>传输</td><td>明文传输</td><td>密文传输<br>使用HTTP+加密+认证+完整性保护</td></tr><tr><td>端口</td><td>使用80端口</td><td>使用443端口</td></tr></tbody></table></li><li><p>socket</p><blockquote><p>是TCP/IP协议的抽象，是操作系统对外开放的接口</p></blockquote></li><li><p>Linux</p><ol><li>查找指定文件：find path [options] params</li><li>查找符合条件的文本：grep [options] pattern file</li><li>对文件内容进行统计：awk [options] cmd file</li><li>批量替换文档内容：sed [options] ‘sed command’ filename</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.nginx</title>
      <link href="2020/11/21/4-nginx/"/>
      <url>2020/11/21/4-nginx/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 服务器与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.network</title>
      <link href="2020/11/21/4-network/"/>
      <url>2020/11/21/4-network/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 服务器与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.zookeeper</title>
      <link href="2020/11/21/3-zookeeper/"/>
      <url>2020/11/21/3-zookeeper/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.SpringCloud</title>
      <link href="2020/11/21/3-springcloud/"/>
      <url>2020/11/21/3-springcloud/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.Redis</title>
      <link href="2020/11/21/3-redis/"/>
      <url>2020/11/21/3-redis/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.MongoDB</title>
      <link href="2020/11/21/3-mongodb/"/>
      <url>2020/11/21/3-mongodb/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.Dubbo</title>
      <link href="2020/11/21/3-dubbo/"/>
      <url>2020/11/21/3-dubbo/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.SpringMVC</title>
      <link href="2020/11/21/2-springmvc/"/>
      <url>2020/11/21/2-springmvc/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SSM框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.SpringBoot</title>
      <link href="2020/11/21/2-springboot/"/>
      <url>2020/11/21/2-springboot/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SSM框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.Spring</title>
      <link href="2020/11/21/2-spring/"/>
      <url>2020/11/21/2-spring/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SSM框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.Mybatis</title>
      <link href="2020/11/21/2-mybatis/"/>
      <url>2020/11/21/2-mybatis/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SSM框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.Oracle</title>
      <link href="2020/11/21/1-oracle/"/>
      <url>2020/11/21/1-oracle/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.MySQL</title>
      <link href="2020/11/21/1-mysql/"/>
      <url>2020/11/21/1-mysql/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.MyCat</title>
      <link href="2020/11/21/1-mycat/"/>
      <url>2020/11/21/1-mycat/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0.multithreading</title>
      <link href="2020/11/21/0-multithreading/"/>
      <url>2020/11/21/0-multithreading/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0.JVM</title>
      <link href="2020/11/21/0-jvm/"/>
      <url>2020/11/21/0-jvm/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0.JavaSenior</title>
      <link href="2020/11/21/0-javasenior/"/>
      <url>2020/11/21/0-javasenior/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0.JavaBase</title>
      <link href="2020/11/21/0-javabase/"/>
      <url>2020/11/21/0-javabase/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a>1. 基本数据类型</h2><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2019/11/01/hello-world/"/>
      <url>2019/11/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
