<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>5.Algorithm</title>
      <link href="2021/07/25/5-algorithm/"/>
      <url>2021/07/25/5-algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><h2 id="1-算法基础"><a href="#1-算法基础" class="headerlink" title="1. 算法基础"></a>1. 算法基础</h2><h3 id="1-1-算法分析"><a href="#1-1-算法分析" class="headerlink" title="1.1 算法分析"></a>1.1 算法分析</h3><h4 id="1-1-1-数学模型"><a href="#1-1-1-数学模型" class="headerlink" title="1.1.1 数学模型"></a>1.1.1 数学模型</h4><ol><li><p>近似</p><blockquote><p>使用高阶函数复杂度代替函数复杂度的方式</p><p>使用~f(N)来表示所有随着N的增大除以f(N)的结果趋近于1的函数</p></blockquote></li><li><p>示例</p><ul><li><code>f(N)</code>=N^3^/6-N^2^/2+N/3</li><li><code>~f(N)</code>=N^3^/6</li><li>使用<code>~f(N)</code>近似代替<code>f(N)</code>的方式</li></ul></li><li><p>增长数量级</p><blockquote><p>N^3^ /6-N^2^/2+N/3 的增长数量级为 O(N^3^)。增长数量级将算法与它的具体实现隔离开来，一个算法的增长数量级为 O(N^3^) 与它是否用 Java 实现，是否运行于特定计算机上无关</p></blockquote></li><li><p>内循环</p><blockquote><p>执行最频繁的指令决定了程序执行的总时间，把这些指令称为程序的内循环</p></blockquote></li><li><p>成本模型</p><blockquote><p>使用成本模型来评估算法，例如数组的访问次数就是一种成本模型</p></blockquote></li><li><p>稳定性</p><blockquote><p>假设在数列中存在a[i] = a[j]，若在排序之前，a[i] 在 a[j]前面；并且排序之后，a[i] 仍然在 a[j]前面，则这个排序算法是稳定的</p></blockquote></li></ol><h4 id="1-1-2-注意事项"><a href="#1-1-2-注意事项" class="headerlink" title="1.1.2 注意事项"></a>1.1.2 注意事项</h4><ol><li><p>大常数</p><blockquote><p>在求近似时，如果低级项的常数系数很大，那么近似的结果是错误的</p></blockquote></li><li><p>缓存</p><blockquote><p>计算机系统会使用缓存技术来组织内存，<b>访问数组相邻的元素会比访问不相邻的元素快很多</b></p></blockquote></li><li><p>最坏情况下的性能保证</p><blockquote><p>在核反应堆、心脏起搏器或者刹车控制器中的软件，最坏情况下的性能是十分重要的</p></blockquote></li><li><p>随机化算法</p><blockquote><p>通过打乱输入，去除算法对输入的依赖</p></blockquote></li><li><p>均摊分析</p><blockquote><p>将所有操作的总成本除于操作总数来将成本均摊</p></blockquote></li></ol><h4 id="1-1-3-倍率计算"><a href="#1-1-3-倍率计算" class="headerlink" title="1.1.3 倍率计算"></a>1.1.3 倍率计算</h4><ol><li><p>假设T(N) ~ aN^b^log2^N^，那么T(2N)/T(N) ~ 2^b^</p></li><li><p>例如对于暴力的ThreeSum算法，近似时间为~N^3^/6；进行如下实验，多次运行该算法，每次取的N值为前一次的两倍，统计每次执行的时间，并统计本次运行时间与前一次运行时间的比值，得到如下结果</p><table><thead><tr><th align="center">N</th><th align="center">Time(ms)</th><th align="center">Ratio</th></tr></thead><tbody><tr><td align="center">500</td><td align="center">48</td><td align="center">/</td></tr><tr><td align="center">1000</td><td align="center">320</td><td align="center">6.7</td></tr><tr><td align="center">2000</td><td align="center">555</td><td align="center">1.7</td></tr><tr><td align="center">4000</td><td align="center">4105</td><td align="center">7.4</td></tr><tr><td align="center">8000</td><td align="center">33575</td><td align="center">8.2</td></tr><tr><td align="center">16000</td><td align="center">268909</td><td align="center">8.0</td></tr></tbody></table><p>可以看到，T(2N)/T(N) ~ 2^3^，因此可以确定 T(N) ~ aN^3^logN</p></li></ol><h3 id="1-2-案例"><a href="#1-2-案例" class="headerlink" title="1.2 案例"></a>1.2 案例</h3><h4 id="1-2-1-64选4"><a href="#1-2-1-64选4" class="headerlink" title="1.2.1 64选4"></a>1.2.1 64选4</h4><ol><li><p>背景</p><blockquote><p>64匹马,8个赛道,找出跑得最快的4匹马</p></blockquote></li><li><p>常规分析</p><ol><li><p>将马分为8组，每组各跑一次，然后淘汰掉每组的后四名</p><p><img src="/2021/07/25/5-algorithm/githubblog\source_posts\algorithm\001.64匹马问题1.png" alt="64匹马问题"></p></li><li><p>对上面8组的第一名进行一次单独跑，淘汰掉本轮后四名所在的组，并淘汰掉D2，D3，D4，C3，C4，B4；此时还剩下10匹马，A1是最快的，所以剩下9匹马</p><p><img src="/2021/07/25/5-algorithm/githubblog\source_posts\algorithm\002.64匹马问题2.png" alt="64匹马问题"></p></li><li><p>余下的马再跑一次选出前三并和A2在跑一次</p></li></ol></li><li><p>极限分析</p><ol><li>先跑一组选第一</li><li>将上次第一递归与下组7匹跑直到选出前四</li></ol></li></ol><h4 id="1-2-2-三数和"><a href="#1-2-2-三数和" class="headerlink" title="1.2.2 三数和"></a>1.2.2 三数和</h4><blockquote><p>用于统计一个数组中和为0的三元组数量</p></blockquote><ol><li><p>一般解法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">threeNumSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取数组长度</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化计数器</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拿出第一个数字</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 拿出第二个数字</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 拿出第三个数字</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 计算三个数字的和</span>                <span class="token keyword">int</span> sum <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> array<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果三数和为0，则计数器自增</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>双指针解法—适用于有序数组</p><blockquote><p>先对数组进行升序排序，在使用双指针进行遍历查找，时间复杂度为O(N^2)</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">threeNumSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对数组进行排序，升序</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取数组长度</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化计数器</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历数组，拿到每一个值索引，当左指针值小于右指针值时就一直查找</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化左指针索引</span>        <span class="token keyword">int</span> leftpointer <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化右指针索引</span>        <span class="token keyword">int</span> rightpointer <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化目标值</span>        <span class="token keyword">int</span> target <span class="token operator">=</span> <span class="token operator">-</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>leftpointer <span class="token operator">&lt;</span> rightpointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 计算左右指针值的和</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> array<span class="token punctuation">[</span>leftpointer<span class="token punctuation">]</span> <span class="token operator">+</span> array<span class="token punctuation">[</span>rightpointer<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果目标值等于左右指针值的和，计数器自增，左指针前移，右指针后移</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>                leftpointer<span class="token operator">++</span><span class="token punctuation">;</span>                rightpointer<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果左右指针值的和小于目标值，则只对左指针进行前移</span>                leftpointer<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果左右指针值的和大于目标值，则只对右指针进行后移</span>                rightpointer<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="1-2-3-汉诺塔"><a href="#1-2-3-汉诺塔" class="headerlink" title="1.2.3 汉诺塔"></a>1.2.3 汉诺塔</h4><ol><li><p>概述</p><blockquote><p>有三个柱子，分别为 from、buffer、to。需要将 from 上的圆盘全部移动到 to 上，并且要保证小圆盘始终在大圆盘上</p><p>经典的递归问题</p><p>an = 2 * an-1 + 1，显然 an = 2n - 1，n 个圆盘需要移动 2n - 1 次</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hanoi</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> String from<span class="token punctuation">,</span> String buffer<span class="token punctuation">,</span> String to<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"from "</span> <span class="token operator">+</span> from <span class="token operator">+</span> <span class="token string">" to "</span> <span class="token operator">+</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将 n-1 个圆盘从 from -> buffer</span>        <span class="token function">move</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将 1 个圆盘从 from -> to</span>        <span class="token function">move</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> from<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将 n-1 个圆盘从 buffer -> to</span>        <span class="token function">move</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Hanoi<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"H1"</span><span class="token punctuation">,</span> <span class="token string">"H2"</span><span class="token punctuation">,</span> <span class="token string">"H3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="2-比较排序"><a href="#2-比较排序" class="headerlink" title="2. 比较排序"></a>2. 比较排序</h2><ol><li><p>概述</p><blockquote><p>Java主要排序方法为java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序</p><p>假定排序元素需要实现 Java 的 Comparable 接口，该接口有 compareTo() 方法，可以用与判断两个元素的大小关系。</p><p>使用辅助函数 less() 和 swap() 来进行比较和交换的操作，使得代码的可读性和可移植性。</p><p>排序算法的成本模型是比较和交换的次数。</p></blockquote></li><li><p>接口定义</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 值比较</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span>T before<span class="token punctuation">,</span> T after<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> before<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>after<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 值交换</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> atarget<span class="token punctuation">,</span> <span class="token keyword">int</span> before<span class="token punctuation">,</span> <span class="token keyword">int</span> after<span class="token punctuation">)</span> <span class="token punctuation">{</span>        T temp <span class="token operator">=</span> atarget<span class="token punctuation">[</span>before<span class="token punctuation">]</span><span class="token punctuation">;</span>        atarget<span class="token punctuation">[</span>before<span class="token punctuation">]</span> <span class="token operator">=</span> atarget<span class="token punctuation">[</span>after<span class="token punctuation">]</span><span class="token punctuation">;</span>        atarget<span class="token punctuation">[</span>after<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="2-1-选择排序"><a href="#2-1-选择排序" class="headerlink" title="2.1 选择排序"></a>2.1 选择排序</h3><ol><li><p>概述</p><blockquote><p>选择数组中最小元素，将它与数组的第一个元素交换位置</p><p>再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置</p><p>重复操作，直至整个数组有序</p></blockquote></li><li><p>时间复杂度分析</p><blockquote><p>选择排序需要 ~N^2^/2 次比较和 ~N 次交换，它的运行时间与输入无关</p></blockquote></li><li><p>接口实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Selection</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对指定数组进行排序</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取数组长度，避免频繁访问数组</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    min <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>普通实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取数组长度，避免频繁访问数组</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化临时变量，用于值交换</span>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化最小索引</span>    <span class="token keyword">int</span> minIndex<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 假定当前值最小</span>        minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 在剩下的元素中找是否有比当前值还小的元素，找出其索引</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 值交换，保证nums[i]始终是最小值</span>        temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="2-2-冒泡排序"><a href="#2-2-冒泡排序" class="headerlink" title="2.2 冒泡排序"></a>2.2 冒泡排序</h3><ol><li><p>概述</p><blockquote><p>从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧</p></blockquote></li><li><p>时间复杂度分析</p><blockquote><p>最差情况下需要交换(n-1)!次</p></blockquote></li><li><p>接口实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bubble</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> isSorted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isSorted<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            isSorted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    isSorted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>普通实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取数组长度，避免频繁访问数组</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化临时变量，用于值交换</span>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果相邻两数之间前者比后者大就交换两数位置</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="2-3-插入排序"><a href="#2-3-插入排序" class="headerlink" title="2.3 插入排序"></a>2.3 插入排序</h3><ol><li><p>概述</p><blockquote><p>每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序</p><p>插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量</p></blockquote></li><li><p>时间复杂度分析</p><blockquote><p>平均情况下插入排序需要 ~N^2^/4 比较以及 ~N^2^/4 次交换；<br>最坏的情况下需要 ~N^2^/2 比较以及 ~N^2^/2 次交换，最坏的情况是数组是倒序的；<br>最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。</p></blockquote></li><li><p>接口实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Insertion</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>普通实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取数组长度，避免频繁访问数组</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化临时变量，用于值交换</span>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="2-4-希尔排序"><a href="#2-4-希尔排序" class="headerlink" title="2.4 希尔排序"></a>2.4 希尔排序</h3><ol><li><p>概述</p><blockquote><p>希尔排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的</p></blockquote></li><li><p>时间复杂度分析</p><blockquote><p>N 的若干倍乘于递增序列的长度</p></blockquote></li><li><p>接口实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Shell</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> gap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&lt;</span> length <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            gap <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> gap <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 4, 13, 40, ...</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> gap <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> gap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            gap <span class="token operator">=</span> gap <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>普通实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取数组长度，避免频繁访问数组</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> gap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 确定初始增量</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&lt;</span> length <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        gap <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> gap <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 4, 13, 40, ...</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 增量小于等于1就一直进行值交换，等于1为冒泡排序</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> gap<span class="token punctuation">;</span> j <span class="token operator">-=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 比较增量序列大小，按升序排列</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>                    nums<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 缩小增量</span>        gap <span class="token operator">=</span> gap <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="2-5-归并排序"><a href="#2-5-归并排序" class="headerlink" title="2.5 归并排序"></a>2.5 归并排序</h3><h4 id="2-5-1-归并方法"><a href="#2-5-1-归并方法" class="headerlink" title="2.5.1 归并方法"></a>2.5.1 归并方法</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> leftPosition<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> rightPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 在合并前先创建一个长度等于排序数组的备份数组，避免递归中频繁开辟空间</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> aux <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 左序列指针</span>        <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> leftPosition<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 右序列指针</span>        <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将数据复制到辅助数组</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> leftPosition<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> rightPosition<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            aux<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> leftPosition<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> rightPosition<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果左指针大于左序列值，左序列排序完成，将右序列值添加到数组中</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">></span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>rightPointer<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果右指针大于右序列值，右序列排序完成，将左序列值添加到数组中</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rightPointer <span class="token operator">></span> rightPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>leftPointer<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 先进行这一步，保证稳定性；左序列值小于右序列值，从左序列中读值向数组中添加，并左指针前移</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>aux<span class="token punctuation">[</span>leftPointer<span class="token punctuation">]</span> <span class="token operator">&lt;</span> aux<span class="token punctuation">[</span>rightPointer<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>leftPointer<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 左序列值大于右序列值，从右序列中读值向数组中添加，并右指针前移</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>rightPointer<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><p>时间复杂度分析</p><blockquote><p>NlogN</p></blockquote></li></ul><h4 id="2-5-2-自定向下归并排序"><a href="#2-5-2-自定向下归并排序" class="headerlink" title="2.5.2 自定向下归并排序"></a>2.5.2 自定向下归并排序</h4><ol><li><p>接口实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Up2DownMergeSort</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">MergeSort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> leftPosition<span class="token punctuation">,</span> <span class="token keyword">int</span> rightPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 递归退出条件，右序列的当前索引小于左序列的当前索引</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rightPosition <span class="token operator">&lt;=</span> leftPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计算左序列长度</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>rightPosition <span class="token operator">+</span> leftPosition<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 归并排序左序列，分割出有序左子序</span>    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> leftPosition<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 归并排序右序列，分割出有序右子序</span>    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将两个有序子序列合并</span>    <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> leftPosition<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> rightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>普通实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> leftPosition<span class="token punctuation">,</span> <span class="token keyword">int</span> rightPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 递归退出条件，右序列的当前索引小于左序列的当前索引</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rightPosition <span class="token operator">&lt;=</span> leftPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计算左序列长度</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>rightPosition <span class="token operator">+</span> leftPosition<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 归并排序左序列，分割出有序左子序</span>    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> leftPosition<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 归并排序右序列，分割出有序右子序</span>    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将两个有序子序列合并</span>    <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> leftPosition<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> rightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2-5-3-自定向上归并排序"><a href="#2-5-3-自定向上归并排序" class="headerlink" title="2.5.3 自定向上归并排序"></a>2.5.3 自定向上归并排序</h4><ol><li><p>接口实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Down2UpMergeSort</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">MergeSort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> childLength <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> childLength <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> childLength <span class="token operator">+=</span> childLength<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// childLength为子数组大小</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> childIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> childIndex <span class="token operator">&lt;</span> length <span class="token operator">-</span> childLength<span class="token punctuation">;</span> childIndex <span class="token operator">+=</span> childLength <span class="token operator">+</span> childLength<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// childIndex为子数组索引</span>                <span class="token keyword">int</span> min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>childIndex <span class="token operator">+</span> childLength <span class="token operator">+</span> childLength <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> childIndex<span class="token punctuation">,</span> childIndex <span class="token operator">+</span> childLength <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>普通实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> childLength <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> childLength <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> childLength <span class="token operator">+=</span> childLength<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// childLength为子数组大小</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> childIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> childIndex <span class="token operator">&lt;</span> length <span class="token operator">-</span> childLength<span class="token punctuation">;</span> childIndex <span class="token operator">+=</span> childLength <span class="token operator">+</span> childLength<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// childIndex为子数组索引</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>childIndex <span class="token operator">+</span> childLength <span class="token operator">+</span> childLength <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> childIndex<span class="token punctuation">,</span> childIndex <span class="token operator">+</span> childLength <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="2-6-快速排序"><a href="#2-6-快速排序" class="headerlink" title="2.6 快速排序"></a>2.6 快速排序</h3><ol><li><p>概述</p><blockquote><p>归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；<br>快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了</p></blockquote></li></ol><h4 id="2-6-1-基本算法"><a href="#2-6-1-基本算法" class="headerlink" title="2.6.1 基本算法"></a>2.6.1 基本算法</h4><ol><li><p>接口实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> leftPosition<span class="token punctuation">,</span> <span class="token keyword">int</span> rightPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rightPosition <span class="token operator">&lt;=</span> leftPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 找寻基准数据索引</span>        <span class="token keyword">int</span> baseIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> leftPosition<span class="token punctuation">,</span> rightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使baseIndex左序列有序</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> leftPosition<span class="token punctuation">,</span> baseIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使baseIndex右序列有序</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> baseIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2-6-2-切分"><a href="#2-6-2-切分" class="headerlink" title="2.6.2 切分"></a>2.6.2 切分</h4><ol><li><p>根据基准索引，将数组不断分割</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> leftPosition<span class="token punctuation">,</span> <span class="token keyword">int</span> rightPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 左序列指针</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> leftPosition<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右序列指针</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> rightPosition<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 基准数据</span>    <span class="token keyword">int</span> basicData <span class="token operator">=</span> nums<span class="token punctuation">[</span>leftPosition<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;</span> rightPointer <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>rightPosition<span class="token punctuation">]</span> <span class="token operator">>=</span> basicData<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 当队尾元素大于等于基准数据时，右指针前移</span>            rightPointer<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 使右序列有序</span>            nums<span class="token punctuation">[</span>leftPointer<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>rightPointer<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;</span> rightPointer <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>leftPosition<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> basicData<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 当队首元素小于等于基准数据时，左指针后移</span>            leftPointer<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 使左序列有序</span>            nums<span class="token punctuation">[</span>rightPointer<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>leftPointer<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    nums<span class="token punctuation">[</span>leftPointer<span class="token punctuation">]</span> <span class="token operator">=</span> basicData<span class="token punctuation">;</span>    <span class="token keyword">return</span> leftPointer<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2-6-3-性能分析"><a href="#2-6-3-性能分析" class="headerlink" title="2.6.3 性能分析"></a>2.6.3 性能分析</h4><ol><li><p>概述</p><blockquote><p>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈</p><p>快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)</p></blockquote></li></ol><h4 id="2-6-4-算法改进"><a href="#2-6-4-算法改进" class="headerlink" title="2.6.4 算法改进"></a>2.6.4 算法改进</h4><ol><li><p>切换到插入排序</p><blockquote><p>因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序</p></blockquote></li><li><p>三数取中</p><blockquote><p>最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素</p></blockquote></li><li><p>三向切分</p><blockquote><p>对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素</p><p>三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序</p></blockquote></li><li><p>三向切分实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> leftPosition<span class="token punctuation">,</span> <span class="token keyword">int</span> rightPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 递归退出条件，划分得每个子数组只有一个元素，即不可分割了。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rightPosition <span class="token operator">&lt;=</span> leftPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 左序列指针</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> leftPosition<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 中序列指针</span>    <span class="token keyword">int</span> midPointer <span class="token operator">=</span> leftPointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右序列指针</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> rightPosition<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 基准数据</span>    <span class="token keyword">int</span> basicData <span class="token operator">=</span> nums<span class="token punctuation">[</span>leftPosition<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 临时变量，用于值交换</span>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>midPointer <span class="token operator">&lt;=</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 中序列值小于基准数据，就从左序列中取值交换，左指针后移，中序列指针后移</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>midPointer<span class="token punctuation">]</span> <span class="token operator">&lt;</span> basicData<span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>leftPointer<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>leftPointer<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>midPointer<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>midPointer<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            leftPointer<span class="token operator">++</span><span class="token punctuation">;</span>            midPointer<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>midPointer<span class="token punctuation">]</span> <span class="token operator">></span> basicData<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 中序列值大于基准数据，就从右序列中取值交换，右指针前移</span>            temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>midPointer<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>midPointer<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>rightPointer<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>rightPointer<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            rightPointer<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 中序列值就是基准数据，中序列指针后移</span>            midPointer<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使左序列有序</span>    <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> leftPosition<span class="token punctuation">,</span> leftPointer <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使右序列有序</span>    <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> rightPointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2-6-5-基于切分的快速选择算法"><a href="#2-6-5-基于切分的快速选择算法" class="headerlink" title="2.6.5 基于切分的快速选择算法"></a>2.6.5 基于切分的快速选择算法</h4><ol><li><p>概述</p><blockquote><p>快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素</p><p>可以利用这个特性找出数组的第 k 个元素</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> targetindex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 左序列指针</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右序列指针</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>rightPointer <span class="token operator">></span> leftPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取基准数据索引</span>        <span class="token keyword">int</span> basicIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> leftPointer<span class="token punctuation">,</span> rightPointer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果基准数据索引恰好等于查找索引，直接返回该元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>basicIndex <span class="token operator">==</span> targetindex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span>targetindex<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>basicIndex <span class="token operator">></span> targetindex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果基准索引大于查找索引，基准数据索引前移作为新的右指针</span>            rightPointer <span class="token operator">=</span> basicIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果基准索引小于查找索引，基准数据索引前移作为新的左指针</span>            leftPointer <span class="token operator">=</span> basicIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 利用左右夹逼的办法，找到目标索引对应的元素</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>targetindex<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="2-7-堆排序"><a href="#2-7-堆排序" class="headerlink" title="2.7 堆排序"></a>2.7 堆排序</h3><h4 id="2-7-1-堆"><a href="#2-7-1-堆" class="headerlink" title="2.7.1 堆"></a>2.7.1 堆</h4><ol><li><p>概述</p><blockquote><p>堆中某个节点的值总是大于等于或小于等于其子节点的值，并且堆是一颗完全二叉树</p><p>堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Heap</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> heap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Heap</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxN<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>heap <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>maxN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        T t <span class="token operator">=</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2-7-2-上浮和下沉"><a href="#2-7-2-上浮和下沉" class="headerlink" title="2.7.2 上浮和下沉"></a>2.7.2 上浮和下沉</h4><ol><li><p>上浮</p><blockquote><p>在堆中，当一个节点比父节点大，那么需要交换这个两个节点</p><p>交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swim</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>下沉</p><blockquote><p>当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉</p><p>一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">less</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2-7-3-插入元素"><a href="#2-7-3-插入元素" class="headerlink" title="2.7.3 插入元素"></a>2.7.3 插入元素</h4><ol><li><p>概述</p><blockquote><p>将新元素放到数组末尾，然后上浮到合适的位置</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Comparable v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    heap<span class="token punctuation">[</span><span class="token operator">++</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>    <span class="token function">swim</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2-7-4-删除最大元素"><a href="#2-7-4-删除最大元素" class="headerlink" title="2.7.4 删除最大元素"></a>2.7.4 删除最大元素</h4><ol><li><p>概述</p><blockquote><p>从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">delMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    T max <span class="token operator">=</span> heap<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> N<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    heap<span class="token punctuation">[</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token function">sink</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2-7-5-堆排序"><a href="#2-7-5-堆排序" class="headerlink" title="2.7.5 堆排序"></a>2.7.5 堆排序</h4><ol><li><p>概述</p><blockquote><p>把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序</p></blockquote></li><li><p>构建堆</p><blockquote><p>无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作</p><p>一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序</p><p>叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可</p></blockquote></li><li><p>交换堆顶元素与最后一个元素</p><blockquote><p>交换之后需要进行下沉操作维持堆的有序状态</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp<span class="token punctuation">;</span>        <span class="token keyword">int</span> Node <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1. 构建大顶堆</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span>  midNodePointer <span class="token operator">=</span> Node <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> midNodePointer <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> midNodePointer<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 从第一个非叶子节点从下至上，从右至左调整结构</span>            <span class="token function">sink</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> midNodePointer<span class="token punctuation">,</span> Node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 2. 调整堆结构+交换堆顶元素与末尾元素</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>Node <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将堆顶元素与末尾元素进行交换</span>            temp <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>Node<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>Node<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            Node<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 重新对堆进行调整</span>            <span class="token function">sink</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 调整大堆顶，下沉</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> midNode<span class="token punctuation">,</span> <span class="token keyword">int</span> Node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从minNode节点的左子节点开始，也就是2*midNode处开始</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> midNode <span class="token operator">&lt;=</span> Node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> midNodePointer <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> midNode<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果左子节点小于右子节点，midNodePointer指向右子节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>midNodePointer <span class="token operator">&lt;</span> Node <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>midNodePointer<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>midNodePointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                midNodePointer<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>midNode<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>midNodePointer<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 如果子节点大于父节点，需要不断的向下进行比较和交换操作</span>            temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>midNode<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>midNode<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>midNodePointer<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>midNodePointer<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            midNode <span class="token operator">=</span> midNodePointer<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2-7-6-分析"><a href="#2-7-6-分析" class="headerlink" title="2.7.6 分析"></a>2.7.6 分析</h4><ol><li><p>概述</p><blockquote><p>一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。</p><p>对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。</p><p>堆排序是一种原地排序，没有利用额外的空间。</p><p>现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换</p></blockquote></li></ol><h3 id="2-8-小结"><a href="#2-8-小结" class="headerlink" title="2.8 小结"></a>2.8 小结</h3><ol><li><p>排序算法比较</p><table><thead><tr><th>算法</th><th>稳定性</th><th>时间复杂度</th><th>空间复杂度</th><th>备注</th></tr></thead><tbody><tr><td>选择排序</td><td>×</td><td>N2</td><td>1</td><td></td></tr><tr><td>冒泡排序</td><td>√</td><td>N2</td><td>1</td><td></td></tr><tr><td>插入排序</td><td>√</td><td>N ~ N2</td><td>1</td><td>时间复杂度和初始顺序有关</td></tr><tr><td>希尔排序</td><td>×</td><td>N 的若干倍乘于递增序列的长度</td><td>1</td><td>改进版插入排序</td></tr><tr><td>快速排序</td><td>×</td><td>NlogN</td><td>logN</td><td></td></tr><tr><td>三向切分快速排序</td><td>×</td><td>N ~ NlogN</td><td>logN</td><td>适用于有大量重复主键</td></tr><tr><td>归并排序</td><td>√</td><td>NlogN</td><td>N</td><td></td></tr><tr><td>堆排序</td><td>×</td><td>NlogN</td><td>1</td><td>无法利用局部性原理</td></tr></tbody></table><p>快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。</p><p>使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间</p></li><li><p>java中的排序算法实现</p><p>Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序</p></li></ol><h2 id="3-桶排序"><a href="#3-桶排序" class="headerlink" title="3. 桶排序"></a>3. 桶排序</h2><ol><li><p>概述</p><blockquote><p>获取最值以确定桶大小</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取最大值</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getArrayMax</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取最小值</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getArrayMin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> min <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">></span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            min <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> min<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取最大值的位数</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getNumLength</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> lenght <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> temp <span class="token operator">=</span> max<span class="token punctuation">;</span> temp <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> temp <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lenght<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> lenght<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 自动扩容，并保存数据</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">arrayAppend</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="3-1-计数排序"><a href="#3-1-计数排序" class="headerlink" title="3.1 计数排序"></a>3.1 计数排序</h3><ol><li><p>概述</p><blockquote><p>将输入的数据值转化为键存储在额外开辟的数组空间中，每个桶只存储单一键值</p></blockquote></li><li><p>时间复杂度分析</p><blockquote><p>一种线性时间复杂度的排序，技术排序要求输入的数据必须是有确定范围的整数</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">countingSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取最大值</span>    <span class="token keyword">int</span> arrayMax <span class="token operator">=</span> <span class="token function">getArrayMax</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取最小值</span>    <span class="token keyword">int</span> arrayMin <span class="token operator">=</span> <span class="token function">getArrayMin</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算最大值和最小值的差</span>    <span class="token keyword">int</span> diff <span class="token operator">=</span> arrayMax <span class="token operator">-</span> arrayMin<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建辅助数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> aux <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>diff <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 原数组索引</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 统计元素个数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        aux<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> arrayMin<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 辅助数组读值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> aux<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>aux<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> arrayMin<span class="token punctuation">;</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>            aux<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="3-2-桶排序"><a href="#3-2-桶排序" class="headerlink" title="3.2 桶排序"></a>3.2 桶排序</h3><ol><li><p>概述</p><blockquote><p>把数据放到一个定量的桶数组中，对非空桶数组进行排序，将桶数组合并，每个桶存储一定范围的数值</p></blockquote></li><li><p>时间复杂度分析</p><blockquote><p>一种线性时间复杂度的排序</p></blockquote></li><li><p>集合实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取最大值</span>    <span class="token keyword">int</span> arrayMax <span class="token operator">=</span> <span class="token function">getArrayMax</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取最小值</span>    <span class="token keyword">int</span> arrayMin <span class="token operator">=</span> <span class="token function">getArrayMin</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算最大值和最小值的差</span>    <span class="token keyword">int</span> diff <span class="token operator">=</span> arrayMax <span class="token operator">-</span> arrayMin<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算桶大小</span>    <span class="token keyword">int</span> bucketSize <span class="token operator">=</span> diff <span class="token operator">/</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶索引</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建桶，数量和原始数组长度一致</span>    ArrayList<span class="token operator">&lt;</span>LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> bucketList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        bucketList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将数据放到对应桶，最后一个桶永远只会存在一个元素，就是最大值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> bucketIndex <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> arrayMin<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">;</span>        bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>bucketIndex<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将每个桶内部排序，Collection.sort()底层是归并排序</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 遍历桶，所有元素已经从小到大排序好，输出元素即可</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> bucket <span class="token operator">:</span> bucketList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer element <span class="token operator">:</span> bucket<span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>二维数组实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取最大值</span>    <span class="token keyword">int</span> arrayMax <span class="token operator">=</span> <span class="token function">getArrayMax</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取最小值</span>    <span class="token keyword">int</span> arrayMin <span class="token operator">=</span> <span class="token function">getArrayMin</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算最大值和最小值的差</span>    <span class="token keyword">int</span> diff <span class="token operator">=</span> arrayMax <span class="token operator">-</span> arrayMin<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算桶大小</span>    <span class="token keyword">int</span> bucketSize <span class="token operator">=</span> diff <span class="token operator">/</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶索引</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建桶，数量和原始数组长度一致</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将数据放到对应桶，最后一个桶永远只会存在一个元素，就是最大值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> bucketIndex <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> arrayMin<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">;</span>        buckets<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">arrayAppend</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 遍历桶，并对桶内元素进行排序，再有序的添加到原数组中</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">:</span> buckets<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对桶内元素进行排序</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将有序桶元素依次添加到原数组中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer element <span class="token operator">:</span> bucket<span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="3-3-基数排序"><a href="#3-3-基数排序" class="headerlink" title="3.3 基数排序"></a>3.3 基数排序</h3><ol><li><p>概述</p><blockquote><p>将整数按位数切割成不同的数字，然后按每个位数分别比较，根据键值的每位数字来分配桶</p></blockquote></li><li><p>时间复杂度分析</p><blockquote><p>一种线性时间复杂度的排序</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取数组最大值</span>    <span class="token keyword">int</span> arrayMax <span class="token operator">=</span> <span class="token function">getArrayMax</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 对数组当中的数字按照每一个有效位进行一趟计数排序</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> exp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> arrayMax <span class="token operator">/</span> exp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> exp <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">countSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">countSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 辅助数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> aux <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 统计数组中元素第exp位的数目</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 对count[]数组进行转换</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        bucket<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+=</span> bucket<span class="token punctuation">[</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 进行计数排序</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> index <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> index<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        aux<span class="token punctuation">[</span>bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 输出到数组arr[]中</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>基于二维数组排序</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取数组最大值</span>    <span class="token keyword">int</span> arrayMax <span class="token operator">=</span> <span class="token function">getArrayMax</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// maxLen表示最大值的长度</span>    <span class="token keyword">int</span> maxLen <span class="token operator">=</span> <span class="token function">getNumLength</span><span class="token punctuation">(</span>arrayMax<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// LSD最低位优先排序  MSD最高位优先排序    l从0开始 循环三次</span>    <span class="token keyword">int</span> recordIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 基数</span>    <span class="token keyword">int</span> basicData <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶，0-9，长度为10，只能对正数进行排序</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 表示桶的每一行也就是每一位存放的个数</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> records <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 临时值，记录数组索引</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> maxLen<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> basicData<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">[</span>records<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            records<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将桶中的数值保存会原来的数组中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> records<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>records<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>recordIndex<span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    recordIndex<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 拷贝完成清除记录的个数，设为0</span>            records<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// basicData乘以10 取十位  百位的数值</span>        basicData <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// recordIndex值记录拷贝数据到原有数组中的位置，拷贝完成恢复0</span>        recordIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="4-数据结构"><a href="#4-数据结构" class="headerlink" title="4. 数据结构"></a>4. 数据结构</h2><h3 id="4-1-并查集"><a href="#4-1-并查集" class="headerlink" title="4.1 并查集"></a>4.1 并查集</h3><ol><li><p>概述</p><blockquote><p>用于解决动态连通性问题，能动态连接两个点，并且判断两个点是否连通</p></blockquote></li><li><p>API</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>UF(int N)</td><td>构造一个大小为 N 的并查集</td></tr><tr><td>void union(int p, int q)</td><td>连接 p 和 q 节点</td></tr><tr><td>int find(int p)</td><td>查找 p 所在的连通分量编号</td></tr><tr><td>boolean connected(int p, int q)</td><td>判断 p 和 q 节点是否连通</td></tr></tbody></table></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">UF</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> id<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">UF</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            id<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="4-1-1-quick-find"><a href="#4-1-1-quick-find" class="headerlink" title="4.1.1 quick find"></a>4.1.1 quick find</h4><ol><li><p>概述</p><blockquote><p>可以快速进行 find 操作，也就是可以快速判断两个节点是否连通</p><p>需要保证同一连通分量的所有节点的 id 值相等，就可以通过判断两个节点的 id 值是否相等从而判断其连通性</p><p>但是 union 操作代价却很高，需要将其中一个连通分量中的所有节点 id 值都修改为另一个节点的 id 值</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickFindUF</span> <span class="token keyword">extends</span> <span class="token class-name">UF</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">QuickFindUF</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pID <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> qID <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pID <span class="token operator">==</span> qID<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> id<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>id<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pID<span class="token punctuation">)</span> <span class="token punctuation">{</span>                id<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> qID<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="4-1-2-quick-union"><a href="#4-1-2-quick-union" class="headerlink" title="4.1.2 quick union"></a>4.1.2 quick union</h4><ol><li><p>概述</p><blockquote><p>可以快速进行 union 操作，只需要修改一个节点的 id 值即可</p><p>但是 find 操作开销很大，因为同一个连通分量的节点 id 值不同，id 值只是用来指向另一个节点。因此需要一直向上查找操作，直到找到最上层的节点</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这种方法可以快速进行 union 操作，但是 find 操作和树高成正比，最坏的情况下树的高度为节点的数目</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickUnionUF</span> <span class="token keyword">extends</span> <span class="token class-name">UF</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">QuickUnionUF</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> id<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> id<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> qRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pRoot <span class="token operator">!=</span> qRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>            id<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span> <span class="token operator">=</span> qRoot<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="4-1-3-加权quick-union"><a href="#4-1-3-加权quick-union" class="headerlink" title="4.1.3 加权quick union"></a>4.1.3 加权quick union</h4><ol><li><p>概述</p><blockquote><p>解决 quick-union 的树通常会很高的问题，加权 quick-union 在 union 操作时会让较小的树连接较大的树上面</p><p>理论研究证明，加权 quick-union 算法构造的树深度最多不超过 logN</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeightedQuickUnionUF</span> <span class="token keyword">extends</span> <span class="token class-name">UF</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 保存节点的数量信息</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sz<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">WeightedQuickUnionUF</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>sz <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>sz<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> id<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> id<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sz<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> sz<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            id<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>            sz<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> sz<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            id<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            sz<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> sz<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="4-1-4-路径压缩的加权-Quick-Union"><a href="#4-1-4-路径压缩的加权-Quick-Union" class="headerlink" title="4.1.4 路径压缩的加权 Quick Union"></a>4.1.4 路径压缩的加权 Quick Union</h4><ol><li><p>概述</p><blockquote><p>在检查节点的同时将它们直接链接到根节点，只需要在 find 中添加一个循环即可</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h4 id="4-1-5-小结"><a href="#4-1-5-小结" class="headerlink" title="4.1.5 小结"></a>4.1.5 小结</h4><table><thead><tr><th>算法</th><th>union</th><th>find</th></tr></thead><tbody><tr><td>Quick Find</td><td>N</td><td>1</td></tr><tr><td>Quick Union</td><td>树高</td><td>树高</td></tr><tr><td>加权 Quick Union</td><td>logN</td><td>logN</td></tr><tr><td>路径压缩的加权 Quick Union</td><td>非常接近 1</td><td>非常接近 1</td></tr></tbody></table><h3 id="4-2-栈和队列"><a href="#4-2-栈和队列" class="headerlink" title="4.2 栈和队列"></a>4.2 栈和队列</h3><h4 id="4-2-1-栈"><a href="#4-2-1-栈" class="headerlink" title="4.2.1 栈"></a>4.2.1 栈</h4><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MyStack</span><span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Iterable</span><span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token punctuation">{</span>    MyStack<span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token function">push</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">;</span>    Item <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="4-2-1-1-数组实现"><a href="#4-2-1-1-数组实现" class="headerlink" title="4.2.1.1 数组实现"></a>4.2.1.1 数组实现</h4><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayStack</span><span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">MyStack</span><span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 栈元素数组，只能通过转型来创建泛型数组</span>    <span class="token keyword">private</span> Item<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>Item<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 元素数量</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> MyStack<span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token function">push</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>N<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Item <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"stack is empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Item item <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token operator">--</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 避免对象游离</span>        a<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">>=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> a<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> N <span class="token operator">&lt;=</span> a<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resize</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 调整数组大小，使得栈具有伸缩性     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Item<span class="token punctuation">[</span><span class="token punctuation">]</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span>Item<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        a <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 返回逆序遍历的迭代器</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>Item<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> N<span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Item <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token operator">--</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="4-2-1-2-链表实现"><a href="#4-2-1-2-链表实现" class="headerlink" title="4.2.1.2 链表实现"></a>4.2.1.2 链表实现</h4><ol><li><p>概述</p><blockquote><p>需要使用链表的头插法来实现，因为头插法中最后压入栈的元素在链表的开头，它的 next 指针指向前一个压入栈的元素</p><p>在弹出元素时就可以通过 next 指针遍历到前一个压入栈的元素从而让这个元素成为新的栈顶元素</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListStack</span><span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">MyStack</span><span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Node top <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        Item item<span class="token punctuation">;</span>        Node next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> MyStack<span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token function">push</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node newTop <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newTop<span class="token punctuation">.</span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>        newTop<span class="token punctuation">.</span>next <span class="token operator">=</span> top<span class="token punctuation">;</span>        top <span class="token operator">=</span> newTop<span class="token punctuation">;</span>        N<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Item <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"stack is empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Item item <span class="token operator">=</span> top<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        top <span class="token operator">=</span> top<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        N<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>Item<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">private</span> Node cur <span class="token operator">=</span> top<span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> cur <span class="token operator">!=</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Item <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Item item <span class="token operator">=</span> cur<span class="token punctuation">.</span>item<span class="token punctuation">;</span>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">return</span> item<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="4-2-2-队列"><a href="#4-2-2-队列" class="headerlink" title="4.2.2 队列"></a>4.2.2 队列</h4><ol><li><p>概述</p><blockquote><p>队列的链表实现，需要维护 first 和 last 节点指针，分别指向队首和队尾</p><p>需要考虑 first 和 last 指针哪个作为链表的开头</p><p>因为出队列操作需要让队首元素的下一个元素成为队首，所以需要容易获取下一个元素，而链表的头部节点的 next 指针指向下一个元素，因此可以让 first 指针链表的开头</p></blockquote></li><li><p>实现接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MyQueue</span><span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Iterable</span><span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MyQueue<span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token function">add</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">;</span>    Item <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>具体实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListQueue</span><span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">MyQueue</span><span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Node first<span class="token punctuation">;</span>    <span class="token keyword">private</span> Node last<span class="token punctuation">;</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        Item item<span class="token punctuation">;</span>        Node next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> MyQueue<span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token function">add</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newNode<span class="token punctuation">.</span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>        newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            last<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        N<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Item <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"queue is empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Node node <span class="token operator">=</span> first<span class="token punctuation">;</span>        first <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        N<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> node<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>Item<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node cur <span class="token operator">=</span> first<span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> cur <span class="token operator">!=</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Item <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Item item <span class="token operator">=</span> cur<span class="token punctuation">.</span>item<span class="token punctuation">;</span>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">return</span> item<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="4-3-符号表"><a href="#4-3-符号表" class="headerlink" title="4.3 符号表"></a>4.3 符号表</h3><ol><li><p>概述</p><blockquote><p>符号表（Symbol Table）是一种存储键值对的数据结构，可以支持快速查找操作</p><p>符号表分为有序和无序两种，有序符号表主要指支持 min()、max() 等根据键的大小关系来实现的操作</p><p>有序符号表的键需要实现 Comparable 接口</p></blockquote></li><li><p>无序符号表实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UnorderedST</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Value <span class="token function">get</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>有序符号表实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">OrderedST</span><span class="token operator">&lt;</span>Key <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Key<span class="token operator">></span><span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span><span class="token punctuation">;</span>    Value <span class="token function">get</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span><span class="token punctuation">;</span>    Key <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Key <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">rank</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Key<span class="token operator">></span> <span class="token function">keys</span><span class="token punctuation">(</span>Key l<span class="token punctuation">,</span> Key h<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="4-3-1-链表实现无序符号表"><a href="#4-3-1-链表实现无序符号表" class="headerlink" title="4.3.1 链表实现无序符号表"></a>4.3.1 链表实现无序符号表</h4><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListUnorderedST</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">UnorderedST</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Node first<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        Key key<span class="token punctuation">;</span>        Value value<span class="token punctuation">;</span>        Node next<span class="token punctuation">;</span>        <span class="token function">Node</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">,</span> Node next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        Node cur <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cnt<span class="token operator">++</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node cur <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果在链表中找到节点的键等于 key 就更新这个节点的值为 value</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 否则使用头插法插入一个新节点</span>        first <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>            first <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        Node pre <span class="token operator">=</span> first<span class="token punctuation">,</span> cur <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Value <span class="token function">get</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node cur <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> cur<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="4-3-2-二分查找实现有序符号表"><a href="#4-3-2-二分查找实现有序符号表" class="headerlink" title="4.3.2 二分查找实现有序符号表"></a>4.3.2 二分查找实现有序符号表</h4><ol><li><p>概述</p><blockquote><p>使用一对平行数组，一个存储键一个存储值</p><p>二分查找的 rank() 方法至关重要，当键在表中时，它能够知道该键的位置；当键不在表中时，它也能知道在何处插入新键</p><p>二分查找最多需要 logN+1 次比较，使用二分查找实现的符号表的查找操作所需要的时间最多是对数级别的</p><p>但是插入操作需要移动数组元素，是线性级别的</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinarySearchOrderedST</span><span class="token operator">&lt;</span>Key <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Key<span class="token operator">></span><span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">OrderedST</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Key<span class="token punctuation">[</span><span class="token punctuation">]</span> keys<span class="token punctuation">;</span>    <span class="token keyword">private</span> Value<span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BinarySearchOrderedST</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        keys <span class="token operator">=</span> <span class="token punctuation">(</span>Key<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        values <span class="token operator">=</span> <span class="token punctuation">(</span>Value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rank</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> h <span class="token operator">=</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>h <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>keys<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> m<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                h <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Key<span class="token operator">></span> <span class="token function">keys</span><span class="token punctuation">(</span>Key l<span class="token punctuation">,</span> Key h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">rank</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Key<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>keys<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>keys<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">rank</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果找到已经存在的节点键为 key，就更新这个节点的值为 value</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> keys<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            values<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 否则在数组中插入新的节点，需要先将插入位置之后的元素都向后移动一个位置</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> N<span class="token punctuation">;</span> j <span class="token operator">></span> index<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            keys<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> keys<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            values<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> values<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        keys<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>        values<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        N<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Value <span class="token function">get</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">rank</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> keys<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> values<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Key <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> keys<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Key <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> keys<span class="token punctuation">[</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="4-3-3-散列表"><a href="#4-3-3-散列表" class="headerlink" title="4.3.3 散列表"></a>4.3.3 散列表</h4><ol><li><p>概述</p><blockquote><p>散列表类似于数组，可以把散列表的散列值看成数组的索引值</p><p>访问散列表和访问数组元素一样快速，它可以在常数时间内实现查找和插入操作</p><p>由于无法通过散列值知道键的大小关系，因此散列表无法实现有序性操作</p></blockquote></li><li><p>散列函数</p><blockquote><p>对于一个大小为 M 的散列表，散列函数能够把任意键转换为 [0, M-1] 内的正整数，该正整数即为 hash 值</p><p>散列表存在冲突，也就是两个不同的键可能有相同的 hash 值</p></blockquote></li><li><p>散列函数应该满足以下三个条件：</p><ul><li>一致性：相等的键应当有相等的 hash 值，两个键相等表示调用 equals() 返回的值相等</li><li>高效性：计算应当简便，有必要的话可以把 hash 值缓存起来，在调用 hash 函数时直接返回</li><li>均匀性：所有键的 hash 值应当均匀地分布到 [0, M-1] 之间，如果不能满足这个条件，有可能产生很多冲突，从而导致散列表的性能下降</li></ul></li><li><p>除留余数法</p><blockquote><p>除留余数法可以将整数散列到 [0, M-1] 之间，例如一个正整数 k，计算 k%M 既可得到一个 [0, M-1] 之间的 hash 值</p><p>注意 M 最好是一个素数，否则无法利用键包含的所有信息。例如 M 为 10k，那么只能利用键的后 k 位</p></blockquote></li><li><p>字符串散列函数</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    hash <span class="token operator">=</span> <span class="token punctuation">(</span>R <span class="token operator">*</span> hash <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">;</span></code></pre></li><li><p>多成员的自定义的散列函数</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// R 通常取 31</span><span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>day <span class="token operator">*</span> R <span class="token operator">+</span> month<span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">)</span> <span class="token operator">*</span> R <span class="token operator">+</span> year<span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">;</span></code></pre></li><li><p>java的HashCode方法</p><blockquote><p>Java 中的 hashCode() 实现了哈希函数，但是默认使用对象的内存地址值。在使用 hashCode() 时，应当结合除留余数法来使用。因为内存地址是 32 位整数，我们只需要 31 位的非负整数，因此应当屏蔽符号位之后再使用除留余数法</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7fffffff</span><span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">;</span></code></pre></li><li><p>java自定义类型实现的HashCode方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Transaction</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> String who<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Date when<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">double</span> amount<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Transaction</span><span class="token punctuation">(</span>String who<span class="token punctuation">,</span> Date when<span class="token punctuation">,</span> <span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>who <span class="token operator">=</span> who<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>when <span class="token operator">=</span> when<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>amount <span class="token operator">=</span> amount<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> R <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>        hash <span class="token operator">=</span> R <span class="token operator">*</span> hash <span class="token operator">+</span> who<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash <span class="token operator">=</span> R <span class="token operator">*</span> hash <span class="token operator">+</span> when<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hash <span class="token operator">=</span> R <span class="token operator">*</span> hash <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Double<span class="token punctuation">)</span> amount<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> hash<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>拉链法</p><blockquote><p>使用链表来存储 hash 值相同的键，从而解决冲突</p><p>查找需要分两步，首先查找 Key 所在的链表，然后在链表中顺序查找</p><p>对于 N 个键，M 条链表 (N&gt;M)，如果哈希函数能够满足均匀性的条件，每条链表的大小趋向于 N/M，因此未命中的查找和插入操作所需要的比较次数为 ~N/M</p></blockquote></li><li><p>线性探测法</p><ol><li><p>概述</p><blockquote><p>使用空位来解决冲突，当冲突发生时，向前探测一个空位来存储冲突的键</p><p>使用线性探测法，数组的大小 M 应当大于键的个数 N（M&gt;N)</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinearProbingHashST</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">UnorderedST</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Key<span class="token punctuation">[</span><span class="token punctuation">]</span> keys<span class="token punctuation">;</span>    <span class="token keyword">private</span> Value<span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">LinearProbingHashST</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">LinearProbingHashST</span><span class="token punctuation">(</span><span class="token keyword">int</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>M <span class="token operator">=</span> M<span class="token punctuation">;</span>        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        keys <span class="token operator">=</span> <span class="token punctuation">(</span>Key<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>        values <span class="token operator">=</span> <span class="token punctuation">(</span>Value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7fffffff</span><span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>查找</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Value <span class="token function">get</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>插入</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">putInternal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">putInternal</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>    values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>    N<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>删除</p><ol><li><p>概述</p><blockquote><p>删除操作应当将右侧所有相邻的键值对重新插入散列表中</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 不存在，直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>    values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将之后相连的键值对重新插入</span>    i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Key keyToRedo <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        Value valToRedo <span class="token operator">=</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        N<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token function">putInternal</span><span class="token punctuation">(</span>keyToRedo<span class="token punctuation">,</span> valToRedo<span class="token punctuation">)</span><span class="token punctuation">;</span>        i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    N<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>调整数组大小</p><ol><li><p>概述</p><blockquote><p>线性探测法的成本取决于连续条目的长度，连续条目也叫聚簇</p><p>当聚簇很长时，在查找和插入时也需要进行很多次探测</p><p>α = N/M，把 α 称为使用率。理论证明，当 α 小于 1/2 时探测的预计次数只在 1.5 到 2.5 之间。为了保证散列表的性能，应当调整数组的大小，使得 α 在 [1/4, 1/2] 之间</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">>=</span> M <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> M<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;=</span> M <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span>M <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LinearProbingHashST<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinearProbingHashST</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span><span class="token punctuation">(</span>cap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>            t<span class="token punctuation">.</span><span class="token function">putInternal</span><span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    keys <span class="token operator">=</span> t<span class="token punctuation">.</span>keys<span class="token punctuation">;</span>    values <span class="token operator">=</span> t<span class="token punctuation">.</span>values<span class="token punctuation">;</span>    M <span class="token operator">=</span> t<span class="token punctuation">.</span>M<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol></li></ol><h4 id="4-3-4-小结"><a href="#4-3-4-小结" class="headerlink" title="4.3.4 小结"></a>4.3.4 小结</h4><ol><li><p>符号表算法比较</p><table><thead><tr><th>算法</th><th>插入</th><th>查找</th><th>是否有序</th></tr></thead><tbody><tr><td>链表实现的无序符号表</td><td>N</td><td>N</td><td>yes</td></tr><tr><td>二分查找实现的有序符号表</td><td>N</td><td>logN</td><td>yes</td></tr><tr><td>二叉查找树</td><td>logN</td><td>logN</td><td>yes</td></tr><tr><td>2-3 查找树</td><td>logN</td><td>logN</td><td>yes</td></tr><tr><td>拉链法实现的散列表</td><td>N/M</td><td>N/M</td><td>no</td></tr><tr><td>线性探测法实现的散列表</td><td>1</td><td>1</td><td>no</td></tr></tbody></table><p>应当优先考虑散列表，当需要有序性操作时使用红黑树</p></li><li><p>java的符号表实现</p><ul><li>java.util.TreeMap：红黑树</li><li>java.util.HashMap：拉链法的散列表</li></ul></li><li><p>稀疏向量乘法</p><ol><li><p>概述</p><blockquote><p>当向量为稀疏向量时，可以使用符号表来存储向量中的非 0 索引和值，使得乘法运算只需要对那些非 0 元素进行即可</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SparseVector</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Double<span class="token operator">></span> hashMap<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SparseVector</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> vector<span class="token punctuation">)</span> <span class="token punctuation">{</span>        hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>vector<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>                hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> vector<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> hashMap<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">dot</span><span class="token punctuation">(</span>SparseVector other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> hashMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            sum <span class="token operator">+=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">*</span> other<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h3 id="4-4-树"><a href="#4-4-树" class="headerlink" title="4.4 树"></a>4.4 树</h3><h4 id="4-4-1-二叉查找树"><a href="#4-4-1-二叉查找树" class="headerlink" title="4.4.1 二叉查找树"></a>4.4.1 二叉查找树</h4><ol><li><p>概述</p><blockquote><p>是一颗二叉树，并且每个节点的值都大于等于其左子树中的所有节点的值而小于等于右子树的所有节点的值</p><p>BST 有一个重要性质，就是它的中序遍历结果递增排序</p><p>二叉树 是一个空链接，或者是一个有左右两个链接的节点，每个链接都指向一颗子二叉树</p><p>二叉查找树所有操作在最坏的情况下所需要的时间和树的高度成正比</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BST</span><span class="token operator">&lt;</span>Key <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Key<span class="token operator">></span><span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">OrderedST</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> Node root<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        Key key<span class="token punctuation">;</span>        Value val<span class="token punctuation">;</span>        Node left<span class="token punctuation">;</span>        Node right<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 以该节点为根的子树节点总数</span>        <span class="token keyword">int</span> N<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 红黑树中使用</span>        <span class="token keyword">boolean</span> color<span class="token punctuation">;</span>        <span class="token function">Node</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value val<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>N <span class="token operator">=</span> N<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span>Node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">recalculateSize</span><span class="token punctuation">(</span>Node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        x<span class="token punctuation">.</span>N <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">size</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>get</p><ol><li><p>概述</p><blockquote><p>如果树是空的，则查找未命中</p><p>如果被查找的键和根节点的键相等，查找命中</p><p>否则递归地在子树中查找：如果被查找的键较小就在左子树中查找，较大就在右子树中查找</p><p>二叉查找树的算法运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序</p><p>最好的情况下树是完全平衡的，每条空链接和根节点的距离都为 logN</p><p>在最坏的情况下，树的高度为 N</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Value <span class="token function">get</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> Value <span class="token function">get</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>put</p><ol><li><p>概述</p><blockquote><p>当插入的键不存在于树中，需要创建一个新节点，并且更新上层节点的链接指向该节点，使得该节点正确地链接到树中</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    root <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> Node <span class="token function">put</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        x<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        x<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        x<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">recalculateSize</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>floor</p><ol><li><p>概述</p><blockquote><p>floor(key)：小于等于键的最大键</p><p>如果键小于根节点的键，那么 floor(key) 一定在左子树中</p><p>如果键大于根节点的键，需要先判断右子树中是否存在 floor(key)，如果存在就返回，否则根节点就是 floor(key)</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Key <span class="token function">floor</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node x <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">.</span>key<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> Node <span class="token function">floor</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">floor</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    Node t <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t <span class="token operator">!=</span> null <span class="token operator">?</span> t <span class="token operator">:</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>rank</p><ol><li><p>概述</p><blockquote><p>rank(key) 返回 key 的排名</p><p>如果键和根节点的键相等，返回左子树的节点数</p><p>如果小于，递归计算在左子树中的排名</p><p>如果大于，递归计算在右子树中的排名，加上左子树的节点数，再加上 1（根节点）</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rank</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">rank</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">rank</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">rank</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">size</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">rank</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> x<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>main</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Key <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> Node <span class="token function">min</span><span class="token punctuation">(</span>Node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>deleteMin</p><ol><li><p>概述</p><blockquote><p>令指向最小节点的链接指向最小节点的右子树</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    root <span class="token operator">=</span> <span class="token function">deleteMin</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> Node <span class="token function">deleteMin</span><span class="token punctuation">(</span>Node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    x<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">deleteMin</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">recalculateSize</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>delete</p><ol><li><p>概述</p><blockquote><p>如果待删除的节点只有一个子树， 那么只需要让指向待删除节点的链接指向唯一的子树即可</p><p>否则，让右子树的最小节点替换该节点</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    root <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> Node <span class="token function">delete</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        x<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        x<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        Node t <span class="token operator">=</span> x<span class="token punctuation">;</span>        x <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        x<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">deleteMin</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        x<span class="token punctuation">.</span>left <span class="token operator">=</span> t<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">recalculateSize</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>keys</p><ol><li><p>概述</p><blockquote><p>利用二叉查找树中序遍历的结果为递增的特点</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Key<span class="token operator">></span> <span class="token function">keys</span><span class="token punctuation">(</span>Key l<span class="token punctuation">,</span> Key h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">keys</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> l<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> List<span class="token operator">&lt;</span>Key<span class="token operator">></span> <span class="token function">keys</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Key l<span class="token punctuation">,</span> Key h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Key<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token keyword">int</span> cmpL <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cmpH <span class="token operator">=</span> h<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmpL <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        list<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token function">keys</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> l<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmpL <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cmpH <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmpH <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        list<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token function">keys</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> l<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="4-4-2-查找树"><a href="#4-4-2-查找树" class="headerlink" title="4.4.2 查找树"></a>4.4.2 查找树</h4><ol><li><p>概述</p><blockquote><p>2-3 查找树引入了 2- 节点和 3- 节点，目的是为了让树平衡</p><p>一颗完美平衡的 2-3 查找树的所有空链接到根节点的距离应该是相同的</p></blockquote></li><li><p>插入</p><ol><li><p>概述</p><blockquote><p>插入操作和 BST 的插入操作有很大区别，BST 的插入操作是先进行一次未命中的查找，然后再将节点插入到对应的空链接上</p><p>2-3 查找树是将新节点插入到叶子节点上</p></blockquote></li><li><p>根据叶子节点的类型不同，有不同的处理方式</p><ul><li>如果插入到 2- 节点上，那么直接将新节点和原来的节点组成 3- 节点即可</li><li>如果是插入到 3- 节点上，就会产生一个临时 4- 节点时，需要将 4- 节点分裂成 3 个 2- 节点，并将中间的 2- 节点移到上层节点中</li><li>如果上移操作继续产生临时 4- 节点则一直进行分裂上移，直到不存在临时 4- 节点</li></ul></li></ol></li><li><p>性质</p><blockquote><p>2-3 查找树插入操作的变换都是局部的，除了相关的节点和链接之外不必修改或者检查树的其它部分，而这些局部变换不会影响树的全局有序性和平衡性</p><p>2-3 查找树的查找和插入操作复杂度和插入顺序无关，在最坏的情况下查找和插入操作访问的节点必然不超过 logN 个</p><p>10 亿个节点的 2-3 查找树最多只需要访问 30 个节点就能进行任意的查找和插入操作</p></blockquote></li></ol><h4 id="4-4-3-红黑树"><a href="#4-4-3-红黑树" class="headerlink" title="4.4.3 红黑树"></a>4.4.3 红黑树</h4><ol><li><p>概述</p><blockquote><p>红黑树是 2-3 查找树，但它不需要分别定义 2- 节点和 3- 节点，而是在普通的二叉查找树之上，为节点添加颜色</p><p>指向一个节点的链接颜色如果为红色，那么这个节点和上层节点表示的是一个 3- 节点，而黑色则是普通链接</p></blockquote></li><li><p>性质</p><blockquote><p>红链接都为左链接</p><p>完美黑色平衡，即任意空链接到根节点的路径上的黑链接数量相同</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedBlackBST</span><span class="token operator">&lt;</span>Key <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Key<span class="token operator">></span><span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">BST</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> RED <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> BLACK <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isRed</span><span class="token punctuation">(</span>Node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>color <span class="token operator">==</span> RED<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>左旋转</p><ol><li><p>概述</p><blockquote><p>合法的红链接都为左链接，如果出现右链接为红链接，那么就需要进行左旋转操作</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Node <span class="token function">rotateLeft</span><span class="token punctuation">(</span>Node h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node x <span class="token operator">=</span> h<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    h<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    x<span class="token punctuation">.</span>left <span class="token operator">=</span> h<span class="token punctuation">;</span>    x<span class="token punctuation">.</span>color <span class="token operator">=</span> h<span class="token punctuation">.</span>color<span class="token punctuation">;</span>    h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>    x<span class="token punctuation">.</span>N <span class="token operator">=</span> h<span class="token punctuation">.</span>N<span class="token punctuation">;</span>    <span class="token function">recalculateSize</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>右旋转</p><ol><li><p>概述</p><blockquote><p>进行右旋转是为了转换两个连续的左红链接</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Node <span class="token function">rotateRight</span><span class="token punctuation">(</span>Node h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node x <span class="token operator">=</span> h<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    h<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    x<span class="token punctuation">.</span>right <span class="token operator">=</span> h<span class="token punctuation">;</span>    x<span class="token punctuation">.</span>color <span class="token operator">=</span> h<span class="token punctuation">.</span>color<span class="token punctuation">;</span>    h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>    x<span class="token punctuation">.</span>N <span class="token operator">=</span> h<span class="token punctuation">.</span>N<span class="token punctuation">;</span>    <span class="token function">recalculateSize</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>颜色转换</p><ol><li><p>概述</p><blockquote><p>一个 4- 节点在红黑树中表现为一个节点的左右子节点都是红色的</p><p>分裂 4- 节点除了需要将子节点的颜色由红变黑之外，同时需要将父节点的颜色由黑变红，从 2-3 树的角度看就是将中间节点移到上层节点</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">flipColors</span><span class="token punctuation">(</span>Node h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>    h<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>    h<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>插入</p><ol><li><p>概述</p><blockquote><p>先将一个节点按二叉查找树的方法插入到正确位置，然后再进行如下颜色操作</p><ul><li>如果右子节点是红色的而左子节点是黑色的，进行左旋转</li><li>如果左子节点是红色的，而且左子节点的左子节点也是红色的，进行右旋转</li><li>如果左右子节点均为红色的，进行颜色转换</li></ul></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    root <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> Node <span class="token function">put</span><span class="token punctuation">(</span>Node x<span class="token punctuation">,</span> Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        node<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        x<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        x<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        x<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isRed</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>        x <span class="token operator">=</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>        x <span class="token operator">=</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">flipColors</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">recalculateSize</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 根节点一定为黑色，因为根节点没有上层节点，也就没有上层节点的左链接指向根节点</span><span class="token comment" spellcheck="true">// flipColors() 有可能会使得根节点的颜色变为红色，每当根节点由红色变成黑色时树的黑链接高度加 1</span></code></pre></li></ol></li><li><p>小结</p><blockquote><p>一颗大小为 N 的红黑树的高度不会超过 2logN</p><p>最坏的情况下是它所对应的 2-3 树，构成最左边的路径节点全部都是 3- 节点而其余都是 2- 节点</p><p>红黑树大多数的操作所需要的时间都是对数级别的</p></blockquote></li></ol><h4 id="4-4-4-哈夫曼编码"><a href="#4-4-4-哈夫曼编码" class="headerlink" title="4.4.4 哈夫曼编码"></a>4.4.4 哈夫曼编码</h4><ol><li><p>概述</p><blockquote><p>根据数据出现的频率对数据进行编码，从而压缩原始数据</p><p>哈夫曼编码采用了贪心策略，使出现频率最高的字符的编码最短，从而保证整体的编码长度最短</p><p>首先生成一颗哈夫曼树，每次生成过程中选取频率最少的两个节点，生成一个新节点作为它们的父节点，并且新节点的频率为两个节点的和</p><p>选取频率最少的原因是，生成过程使得先选取的节点位于树的更低层，那么需要的编码长度更长，频率更少可以使得总编码长度更少</p><p>生成编码时，从根节点出发，向左遍历则添加二进制位 0，向右则添加二进制位 1，直到遍历到叶子节点，叶子节点代表的字符的编码就是这个路径编码</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Huffman</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Node<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> ch<span class="token punctuation">;</span>        <span class="token keyword">int</span> freq<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> isLeaf<span class="token punctuation">;</span>        Node left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">char</span> ch<span class="token punctuation">,</span> <span class="token keyword">int</span> freq<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>ch <span class="token operator">=</span> ch<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>freq <span class="token operator">=</span> freq<span class="token punctuation">;</span>            isLeaf <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>Node left<span class="token punctuation">,</span> Node right<span class="token punctuation">,</span> <span class="token keyword">int</span> freq<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>freq <span class="token operator">=</span> freq<span class="token punctuation">;</span>            isLeaf <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Node o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>freq <span class="token operator">-</span> o<span class="token punctuation">.</span>freq<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> String<span class="token operator">></span> <span class="token function">encode</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Integer<span class="token operator">></span> frequencyForChar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        PriorityQueue<span class="token operator">&lt;</span>Node<span class="token operator">></span> priorityQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Character c <span class="token operator">:</span> frequencyForChar<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            priorityQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> frequencyForChar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>priorityQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node node1 <span class="token operator">=</span> priorityQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Node node2 <span class="token operator">=</span> priorityQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            priorityQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>node1<span class="token punctuation">,</span> node2<span class="token punctuation">,</span> node1<span class="token punctuation">.</span>freq <span class="token operator">+</span> node2<span class="token punctuation">.</span>freq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">encode</span><span class="token punctuation">(</span>priorityQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> String<span class="token operator">></span> <span class="token function">encode</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> String<span class="token operator">></span> encodingForChar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">encode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> encodingForChar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> encodingForChar<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">encode</span><span class="token punctuation">(</span>Node node<span class="token punctuation">,</span> String encoding<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> String<span class="token operator">></span> encodingForChar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>isLeaf<span class="token punctuation">)</span> <span class="token punctuation">{</span>            encodingForChar<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>ch<span class="token punctuation">,</span> encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">encode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> encoding <span class="token operator">+</span> <span class="token string">'0'</span><span class="token punctuation">,</span> encodingForChar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">encode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> encoding <span class="token operator">+</span> <span class="token string">'1'</span><span class="token punctuation">,</span> encodingForChar<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="5-Leetcode习题集"><a href="#5-Leetcode习题集" class="headerlink" title="5. Leetcode习题集"></a>5. Leetcode习题集</h2><h3 id="5-1-算法思想"><a href="#5-1-算法思想" class="headerlink" title="5.1 算法思想"></a>5.1 算法思想</h3><h4 id="5-1-1-数学"><a href="#5-1-1-数学" class="headerlink" title="5.1.1 数学"></a>5.1.1 数学</h4><h5 id="5-1-1-1-基础"><a href="#5-1-1-1-基础" class="headerlink" title="5.1.1.1 基础"></a>5.1.1.1 基础</h5><ol><li><p>素数分解</p><blockquote><p>每一个数都可以分解成素数的乘积</p></blockquote></li><li><p>整除</p><blockquote><p>令 x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * …</p><p>令 y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * …</p><p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p></blockquote></li><li><p>最大公约数&amp;&amp;最小公倍数</p><ol><li><p>概述</p><blockquote><p>x 和 y 的最大公约数为：gcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * …</p><p>x 和 y 的最小公倍数为：lcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * …</p></blockquote></li><li><p>最大公约数</p><p>对于 a 和 b 的最大公约数 f(a, b)，有：</p><ul><li>如果 a 和 b 均为偶数，f(a, b) = 2*f(a/2, b/2);</li><li>如果 a 是偶数 b 是奇数，f(a, b) = f(a/2, b);</li><li>如果 b 是偶数 a 是奇数，f(a, b) = f(a, b/2);</li><li>如果 a 和 b 均为奇数，f(a, b) = f(b, a-b);</li></ul></li><li><p>最小公倍数</p><blockquote><p>最小公倍数为两数的乘积除以最大公约数</p></blockquote></li></ol></li><li><p>进制</p><blockquote><p>几进制有几个数，即逢几进几</p></blockquote><ol><li><p>Java 中 static String toString(int num, int radix) 可以将一个整数转换为 radix 进制表示的字符串</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">convertToBase7</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h5 id="5-1-1-2-习题"><a href="#5-1-1-2-习题" class="headerlink" title="5.1.1.2 习题"></a>5.1.1.2 习题</h5><ol><li><p>统计素数</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 统计素数</span><span class="token comment" spellcheck="true">// 埃拉托斯特尼筛法在每次找到一个素数时，将能被素数整除的数排除掉</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countPrimes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> notPrimes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> primes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 不是素数的跳过count统计</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>notPrimes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 统计素数个数</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 添加素数元素</span>        primes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从 i * i 开始，因为如果 k &lt; i，那么 k * i 在之前就已经被去除过了</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> j <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">*</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 不是素数的置为true</span>            notPrimes<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>最大公约数&amp;&amp;最小公倍数</p><ol><li><p>概述</p><blockquote><p>乘 2 和除 2 都可以转换为移位操作</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 最大公约数</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 最小公倍数</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">lcm</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">*</span> b <span class="token operator">/</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 位运算求最大公约数</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> isAEven <span class="token operator">=</span> <span class="token function">isEven</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> isBEven <span class="token operator">=</span> <span class="token function">isEven</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isAEven <span class="token operator">&amp;&amp;</span> isBEven<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isAEven <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isBEven<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isAEven <span class="token operator">&amp;&amp;</span> isBEven<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 校验奇偶性</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isEven</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> num <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span>；<span class="token punctuation">}</span></code></pre></li></ol></li><li><p>7进制</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">convertToBase7</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"0"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> isNegative <span class="token operator">=</span> num <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isNegative<span class="token punctuation">)</span> <span class="token punctuation">{</span>        num <span class="token operator">=</span> <span class="token operator">-</span>num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        num <span class="token operator">/=</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    String ret <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> isNegative <span class="token operator">?</span> <span class="token string">"-"</span> <span class="token operator">+</span> ret <span class="token operator">:</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>16进制</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">toHex</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">"0"</span><span class="token punctuation">;</span>    StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>num <span class="token operator">&amp;</span> <span class="token number">0b1111</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        num <span class="token operator">>>>=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 因为考虑的是补码形式，因此符号位就不能有特殊的意义，需要使用无符号右移，左边填 0</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>26进制</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">convertToTitle</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    n<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">convertToTitle</span><span class="token punctuation">(</span>n <span class="token operator">/</span> <span class="token number">26</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">26</span> <span class="token operator">+</span> <span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>统计阶乘尾部有多少个0</p><ol><li><p>概述</p><blockquote><p>尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可</p><p>对于一个数 N，它所包含 5 的个数为：N/5 + N/52 + N/53 + …，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/52 表示不大于 N 的数中 52 的倍数再贡献一个 5 …</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trailingZeroes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> n <span class="token operator">/</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token function">trailingZeroes</span><span class="token punctuation">(</span>n <span class="token operator">/</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>二进制加法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">addBinary</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    StringBuilder str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>carry <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            carry<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            carry<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>carry <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        carry <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>字符串加法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">addStrings</span><span class="token punctuation">(</span>String num1<span class="token punctuation">,</span> String num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StringBuilder str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> num1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> num2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>carry <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> num1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> y <span class="token operator">=</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> num2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>        str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> carry<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        carry <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> carry<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>改变数组元素使所有的数组元素都相等</p><ol><li><p>概述</p><blockquote><p>每次可以对一个数组元素加一或者减一，求最小的改变次数</p><p>典型的相遇问题，移动距离最小的方式是所有元素都移动到中位数</p><p>设 m 为中位数。a 和 b 是 m 两边的两个元素，且 b &gt; a。要使 a 和 b 相等，它们总共移动的次数为 b - a，这个值等于 (b - m) + (m - a)，也就是把这两个数移动到中位数的移动次数</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 先排序</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minMoves2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> move <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> h <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        move <span class="token operator">+=</span> nums<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>        l<span class="token operator">++</span><span class="token punctuation">;</span>        h<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> move<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用快速选择找到中位数</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minMoves2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> move <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> median <span class="token operator">=</span> <span class="token function">findKthSmallest</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        move <span class="token operator">+=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>num <span class="token operator">-</span> median<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> move<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findKthSmallest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> h <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            l <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            h <span class="token operator">=</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> h<span class="token punctuation">)</span> <span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token operator">--</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">></span> l<span class="token punctuation">)</span> <span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>数组中出现次数多余n/2的元素</p><ol><li><p>概述</p><blockquote><ol><li>使用count来统计一个元素出现的次数</li><li>当遍历到的元素和统计元素不相等时，会count–</li><li>如果前面查找了i元素，且count == 0，说明前i个元素没有majority，或者有majority，但是出现次数少于1/2</li><li>剩下的n-i个元素中，majority的数目依然多余(n-i)/2，因此继续查找就能找出majority</li></ol></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Boyer-Moore Majority Vote Algorithm</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> el <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                el <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 出现次数少于1/2</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> el<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 出现一次count++</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                count<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 后买呢不出现就count--</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> el<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> majority <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        majority <span class="token operator">=</span> <span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> num <span class="token operator">:</span> majority<span class="token punctuation">;</span>        cnt <span class="token operator">=</span> <span class="token punctuation">(</span>majority <span class="token operator">==</span> num<span class="token punctuation">)</span> <span class="token operator">?</span> cnt <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> majority<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>平方数</p><ol><li><p>概述</p><blockquote><p>间隔为等差数列，使用这个特性可以得到从 1 开始的平方序列</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPerfectSquare</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> subNum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        num <span class="token operator">-=</span> subNum<span class="token punctuation">;</span>        subNum <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>3的n次方</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPowerOfThree</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token number">1162261467</span> <span class="token operator">%</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>乘积数组</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">productExceptSelf</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> products <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>products<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        left <span class="token operator">*=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        products<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*=</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        right <span class="token operator">*=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        products<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*=</span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> products<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>找出数组中的乘积最大的三个数</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">maximumProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="5-1-2-双指针"><a href="#5-1-2-双指针" class="headerlink" title="5.1.2 双指针"></a>5.1.2 双指针</h4><h5 id="5-1-2-1-基础"><a href="#5-1-2-1-基础" class="headerlink" title="5.1.2.1 基础"></a>5.1.2.1 基础</h5><ol><li><p>概述</p><blockquote><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务</p></blockquote></li></ol><h5 id="5-1-2-2-习题"><a href="#5-1-2-2-习题" class="headerlink" title="5.1.2.2 习题"></a>5.1.2.2 习题</h5><ol><li><p>有序数组的 Two Sum</p><ol><li><p>概述</p><blockquote><p>使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素</p><p>指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历</p></blockquote></li><li><p>步骤</p><ul><li>如果两个指针指向元素的和 sum == target，那么得到要求的结果</li><li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些</li><li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些</li></ul></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 健壮性校验</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化左指针</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化右指针</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> numbers<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果左右指针不相等就读取左右指针值求和是否等于目标值，相等就将指针索引存入数组返回</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 求取指针对应值的和</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">[</span>leftPointer<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>rightPointer<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果等于目标值，指针索引存入数组返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>leftPointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rightPointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果小于目标值，左指针前移，换一个大值</span>            leftPointer<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果小于目标值，右指针后移，换一个小值</span>            rightPointer<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>两数平方和</p><ol><li><p>概述</p><blockquote><p>在元素为 0~target 的有序数组中查找两个数，使得这两个数的平方和为 target</p><p>如果能找到，则返回 true，表示 target 是两个整数的平方和</p><p>使用双指针得到两个数，使其平方和为 target</p><p>关键是右指针的初始化，实现剪枝，从而降低时间复杂度；设右指针为 x，左指针固定为 0，为了使 02 + x2 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">judgeSquareSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;=</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> powSum <span class="token operator">=</span> leftPointer <span class="token operator">*</span> leftPointer <span class="token operator">+</span> rightPointer <span class="token operator">*</span> rightPointer<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>powSum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>powSum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            rightPointer<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            leftPointer<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>反转字符串中的元音字符</p><ol><li><p>概述</p><blockquote><p>使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">reverseVowels</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 健壮性校验</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化左指针</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化右指针</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化元音字符数组</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左右指针不相等就遍历</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;=</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取左指针字符</span>        <span class="token keyword">char</span> leftChar <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>leftPointer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取右指针字符</span>        <span class="token keyword">char</span> rightChar <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>rightPointer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vowels<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>leftChar<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 存储左指针字符</span>            result<span class="token punctuation">[</span>leftPointer<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftChar<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vowels<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>rightChar<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 存储右指针字符</span>            result<span class="token punctuation">[</span>rightPointer<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> rightChar<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            result<span class="token punctuation">[</span>leftPointer<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> rightChar<span class="token punctuation">;</span>            result<span class="token punctuation">[</span>rightPointer<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftChar<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>回文字符串</p><ol><li><p>概述</p><blockquote><p>一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">validPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rightPointer <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> leftPointer <span class="token operator">&lt;</span> rightPointer<span class="token punctuation">;</span> leftPointer<span class="token operator">++</span><span class="token punctuation">,</span> rightPointer<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>leftPointer<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>rightPointer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> leftPointer<span class="token punctuation">,</span> rightPointer <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> leftPointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rightPointer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> <span class="token keyword">int</span> leftPointer<span class="token punctuation">,</span> <span class="token keyword">int</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>leftPointer<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>rightPointer<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>判断链表是否存在环</p><ol><li><p>概述</p><blockquote><p>使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 健壮性校验</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 前驱指针</span>    ListNode predecessor <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 后驱指针</span>    ListNode successor <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>predecessor <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> successor <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> successor<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 前后指针相遇，表明有环，返回true</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>predecessor <span class="token operator">==</span> successor<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 前驱指针前移</span>        predecessor <span class="token operator">=</span> predecessor<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 后驱指针后移</span>        successor <span class="token operator">=</span> successor<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>最长子序列</p><ol><li><p>概述</p><blockquote><p>使用双指针来判断一个字符串是否为另一个字符串的子序列</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">findLongestWord</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化最长子序列</span>    String longestWord <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历目标字符串</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String target <span class="token operator">:</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化左指针</span>        <span class="token keyword">int</span> l1 <span class="token operator">=</span> longestWord<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化右指针</span>        <span class="token keyword">int</span> l2 <span class="token operator">=</span> target<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">></span> l2 <span class="token operator">||</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> l2 <span class="token operator">&amp;&amp;</span> longestWord<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 判断目标字符串和指定字符的差异性</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSubstr</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            longestWord <span class="token operator">=</span> target<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> longestWord<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isSubstr</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化左指针</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化右指针</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> rightPointer <span class="token operator">&lt;</span> target<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>leftPointer<span class="token punctuation">)</span> <span class="token operator">==</span> target<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>rightPointer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            rightPointer<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        leftPointer<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> rightPointer <span class="token operator">==</span> target<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="5-1-3-二分"><a href="#5-1-3-二分" class="headerlink" title="5.1.3 二分"></a>5.1.3 二分</h4><h5 id="5-1-3-1-基础"><a href="#5-1-3-1-基础" class="headerlink" title="5.1.3.1 基础"></a>5.1.3.1 基础</h5><ol><li><p>概述</p><blockquote><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 左指针</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右指针</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历查找</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;=</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 二分索引</span>        <span class="token keyword">int</span> midPointer <span class="token operator">=</span> leftPointer <span class="token operator">+</span> <span class="token punctuation">(</span>rightPointer <span class="token operator">-</span> leftPointer<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>midPointer<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 二分索引的值和要查找的值对应，直接返回二分索引</span>            <span class="token keyword">return</span> midPointer<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>midPointer<span class="token punctuation">]</span> <span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动右指针</span>            rightPointer <span class="token operator">=</span> midPointer <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动左指针</span>            leftPointer <span class="token operator">=</span> midPointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 没找到</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>计算中值</p><ul><li><p>m = (l + h) / 2</p></li><li><p>m = l + (h - l) / 2</p></li><li><p>注意</p><blockquote><p>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p></blockquote></li></ul></li><li><p>未找到返回值</p><ul><li><code>-1</code>：以一个错误码表示没有查找到 key</li><li><code>l</code>：将 key 插入到 nums 中的正确位置</li></ul></li><li><p>有重复值的数组</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 左指针</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右指针</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历查找</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 二分索引</span>        <span class="token keyword">int</span> midPointer <span class="token operator">=</span> leftPointer <span class="token operator">+</span> <span class="token punctuation">(</span>rightPointer <span class="token operator">-</span> leftPointer<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>midPointer<span class="token punctuation">]</span> <span class="token operator">>=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动右指针</span>            rightPointer <span class="token operator">=</span> midPointer<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动左指针</span>            leftPointer <span class="token operator">=</span> midPointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 没找到</span>    <span class="token keyword">return</span> leftPointer<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h5 id="5-1-3-2-习题"><a href="#5-1-3-2-习题" class="headerlink" title="5.1.3.2 习题"></a>5.1.3.2 习题</h5><ol><li><p>求开方</p><ol><li><p>概述</p><blockquote><p>一个数 x 的开方 sqrt 一定在 0 ~ x 之间，并且满足 sqrt == x / sqrt。可以利用二分查找在 0 ~ x 之间查找 sqrt</p><p>在循环条件为 l &lt;= h 并且循环退出时，h 总是比 l 小 1，也就是说 h = 2，l = 3，因此最后的返回值应该为 h 而不是 l</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 负数不能开平方</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 左指针</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右指针</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历查找</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;=</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 二分索引</span>        <span class="token keyword">int</span> midPointer <span class="token operator">=</span> leftPointer <span class="token operator">+</span> <span class="token punctuation">(</span>rightPointer <span class="token operator">-</span> leftPointer<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取中值</span>        <span class="token keyword">int</span> sqrt <span class="token operator">=</span> x <span class="token operator">/</span> midPointer<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 整除中值和二分索引</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sqrt <span class="token operator">==</span> midPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> midPointer<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>midPointer <span class="token operator">></span> sqrt<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动右指针</span>            rightPointer <span class="token operator">=</span> midPointer <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动左指针</span>            leftPointer <span class="token operator">=</span> midPointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回右指针</span>    <span class="token keyword">return</span> rightPointer<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>大于给定元素的最小元素</p><ol><li><p>概述</p><blockquote><p>找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">char</span> <span class="token function">nextGreatestLetter</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> letters<span class="token punctuation">,</span> <span class="token keyword">char</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 字符数组长度</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> letters<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左指针</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右指针</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历查找</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;=</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 二分索引</span>        <span class="token keyword">int</span> midPointer <span class="token operator">=</span> leftPointer <span class="token operator">+</span> <span class="token punctuation">(</span>rightPointer <span class="token operator">-</span> leftPointer<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>letters<span class="token punctuation">[</span>midPointer<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动左指针</span>            leftPointer <span class="token operator">=</span> midPointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动右指针</span>            rightPointer <span class="token operator">=</span> midPointer <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 左指针合法就返回对应值，否则返回首元素</span>    <span class="token keyword">return</span> leftPointer <span class="token operator">&lt;</span> length <span class="token operator">?</span> letters<span class="token punctuation">[</span>leftPointer<span class="token punctuation">]</span> <span class="token operator">:</span> letters<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>有序数组的 Single Element</p><ol><li><p>概述</p><blockquote><p>要求以 O(logN) 时间复杂度进行求解，因此不能遍历数组并进行异或操作来求解，这么做的时间复杂度为 O(N)</p><p>令 index 为 Single Element 在数组中的位置。在 index 之后，数组中原来存在的成对状态被改变。如果 m 为偶数，并且 m + 1 &lt; index，那么 nums[m] == nums[m + 1]；m + 1 &gt;= index，那么 nums[m] != nums[m + 1]</p><p>从上面的规律可以知道，如果 nums[m] == nums[m + 1]，那么 index 所在的数组位置为 [m + 2, h]，此时令 l = m + 2；如果 nums[m] != nums[m + 1]，那么 index 所在的数组位置为 [l, m]，此时令 h = m</p><p>因为 h 的赋值表达式为 h = m，那么循环条件也就只能使用 l &lt; h 这种形式</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">singleNonDuplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 左指针</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右指针</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 二分索引</span>        <span class="token keyword">int</span> midPointer <span class="token operator">=</span> leftPointer <span class="token operator">+</span> <span class="token punctuation">(</span>rightPointer <span class="token operator">-</span> leftPointer<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>midPointer <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            midPointer<span class="token operator">--</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 保证 l/h/m 都在偶数位，使得查找区间大小一直都是奇数</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>midPointer<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>midPointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动左指针</span>            leftPointer <span class="token operator">=</span> midPointer <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动右指针</span>            rightPointer <span class="token operator">=</span> midPointer<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>leftPointer<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>第一个错误的版本</p><ol><li><p>概述</p><blockquote><p>如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h = m；否则第一个错误的版本在 [m + 1, h] 之间，令 l = m + 1</p><p>因为 h 的赋值表达式为 h = m，因此循环条件为 l &lt; h</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">firstBadVersion</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 左指针</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 右指针</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 二分索引</span>        <span class="token keyword">int</span> midPointer <span class="token operator">=</span> leftPointer <span class="token operator">+</span> <span class="token punctuation">(</span>rightPointer <span class="token operator">-</span> leftPointer<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isBadVersion</span><span class="token punctuation">(</span>midPointer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动右指针</span>            rightPointer <span class="token operator">=</span> midPointer<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动左指针</span>            leftPointer <span class="token operator">=</span> midPointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> leftPointer<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>旋转数组的最小数字</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 左指针</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右指针</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 二分索引</span>        <span class="token keyword">int</span> midPointer <span class="token operator">=</span> leftPointer <span class="token operator">+</span> <span class="token punctuation">(</span>rightPointer <span class="token operator">-</span> leftPointer<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>midPointer<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>rightPointer<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动右指针</span>            rightPointer <span class="token operator">=</span> midPointer<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动左指针</span>            leftPointer <span class="token operator">=</span> midPointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>leftPointer<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>查找区间</p><ol><li><p>概述</p><blockquote><p>可以用二分查找找出第一个位置和最后一个位置，但是寻找的方法有所不同，需要实现两个二分查找</p><p>将寻找 target 最后一个位置，转换成寻找 target+1 第一个位置，再往前移动一个位置。这样我们只需要实现一个二分查找代码即可</p></blockquote></li><li><p>说明</p><ul><li><code>nums = [2,2], target = 2</code></li><li>如果 h 的取值为 nums.length - 1，那么 last = findFirst(nums, target + 1) - 1 = 1 - 1 = 0。这是因为 findLeft 只会返回 [0, nums.length - 1] 范围的值，对于 findFirst([2,2], 3) ，我们希望返回 3 插入 nums 中的位置，也就是数组最后一个位置再往后一个位置，即 nums.length。所以我们需要将 h 取值为 nums.length，从而使得 findFirst返回的区间更大，能够覆盖 target 大于 nums 最后一个元素的情况</li></ul></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">searchRange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> first <span class="token operator">=</span> <span class="token function">findFirst</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token function">findFirst</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> nums<span class="token punctuation">.</span>length <span class="token operator">||</span> nums<span class="token punctuation">[</span>first<span class="token punctuation">]</span> <span class="token operator">!=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 没找到</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>first<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 左指针</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右指针，注意 rightPointer 的初始值</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 二分索引</span>        <span class="token keyword">int</span> midPointer <span class="token operator">=</span> leftPointer <span class="token operator">+</span> <span class="token punctuation">(</span>rightPointer <span class="token operator">-</span> leftPointer<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>midPointer<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动右指针</span>            rightPointer <span class="token operator">=</span> midPointer<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移动左指针</span>            leftPointer <span class="token operator">=</span> midPointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> leftPointer<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="5-1-4-排序"><a href="#5-1-4-排序" class="headerlink" title="5.1.4 排序"></a>5.1.4 排序</h4><h5 id="5-1-4-1-基础"><a href="#5-1-4-1-基础" class="headerlink" title="5.1.4.1 基础"></a>5.1.4.1 基础</h5><ol><li><p>概述</p><blockquote><p>用于求解 Kth Element 问题，也就是第 K 个元素的问题</p><p>可以使用快速排序的 partition() 进行实现。需要先打乱数组，否则最坏情况下时间复杂度为 O(N2)</p></blockquote></li><li><p>堆</p><ol><li><p>概述</p><blockquote><p>用于求解 TopK Elements 问题，也就是 K 个最小元素的问题</p><p>使用最小堆来实现 TopK 问题，最小堆使用大顶堆来实现，大顶堆的堆顶元素为当前堆的最大元素</p></blockquote></li><li><p>步骤</p><ol><li>不断地往大顶堆中插入新元素，当堆中元素的数量大于 k 时，移除堆顶元素</li><li>当前堆中最大的元素，剩下的元素都为当前添加过的元素中最小的 K 个元素</li><li>插入和移除堆顶元素的时间复杂度都为 log2N</li></ol></li></ol></li><li><p>荷兰国旗问题</p><blockquote><p>荷兰国旗包含三种颜色：红、白、蓝</p><p>有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列</p><p>其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素</p><p>该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色</p></blockquote></li><li><p>小结</p><ul><li>堆也可以用于求解 Kth Element 问题，得到了大小为 K 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是第 K 大的元素</li><li>快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements</li><li>快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题</li></ul></li></ol><h5 id="5-1-4-2-习题"><a href="#5-1-4-2-习题" class="headerlink" title="5.1.4.2 习题"></a>5.1.4.2 习题</h5><ol><li><p>Kth Element</p><ol><li><p>排序实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>堆实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 小顶堆</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 维护堆的大小为 K</span>            pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> pq<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>快速选择实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    k <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k<span class="token punctuation">;</span>    <span class="token keyword">int</span> leftPointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rightPointer <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftPointer <span class="token operator">&lt;</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> targetIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> leftPointer<span class="token punctuation">,</span> rightPointer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>targetIndex <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>targetIndex <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            leftPointer <span class="token operator">=</span> targetIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            rightPointer <span class="token operator">=</span> targetIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> leftPointer<span class="token punctuation">,</span> <span class="token keyword">int</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> leftPosition <span class="token operator">=</span> leftPointer<span class="token punctuation">;</span>    <span class="token keyword">int</span> rightPosition <span class="token operator">=</span> rightPointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">++</span>leftPosition<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>leftPointer<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> leftPosition <span class="token operator">&lt;</span> rightPointer<span class="token punctuation">)</span> <span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">--</span>rightPosition<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>leftPointer<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> rightPosition <span class="token operator">></span> leftPointer<span class="token punctuation">)</span> <span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftPosition <span class="token operator">>=</span> rightPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> leftPosition<span class="token punctuation">,</span> rightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> leftPointer<span class="token punctuation">,</span> rightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> rightPosition<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> valueOne<span class="token punctuation">,</span> <span class="token keyword">int</span> valueTwo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">[</span>valueOne<span class="token punctuation">]</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span>valueOne<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>valueTwo<span class="token punctuation">]</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span>valueTwo<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>出现频率最多的 k 个元素</p><ol><li><p>概述</p><blockquote><p>设置若干个桶，每个桶存储出现频率相同的数</p><p>桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i</p><p>把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> frequencyForNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        frequencyForNum<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> frequencyForNum<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> key <span class="token operator">:</span> frequencyForNum<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> frequency <span class="token operator">=</span> frequencyForNum<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>frequency<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            buckets<span class="token punctuation">[</span>frequency<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        buckets<span class="token punctuation">[</span>frequency<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> topK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> buckets<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> topK<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> topK<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            topK<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            topK<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">-</span> topK<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> topK<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>按照字符出现次数对字符串排序</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">frequencySort</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Integer<span class="token operator">></span> frequencyForNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        frequencyForNum<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> frequencyForNum<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Character<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> frequencyBucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> frequencyForNum<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> f <span class="token operator">=</span> frequencyForNum<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>frequencyBucket<span class="token punctuation">[</span>f<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            frequencyBucket<span class="token punctuation">[</span>f<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        frequencyBucket<span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    StringBuilder str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> frequencyBucket<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>frequencyBucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> frequencyBucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>按颜色进行排序</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortColors</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> zero <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> one <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> two <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>one <span class="token operator">&lt;</span> two<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>one<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token operator">++</span>zero<span class="token punctuation">,</span> one<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>one<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token operator">--</span>two<span class="token punctuation">,</span> one<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token operator">++</span>one<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="5-1-5-贪心"><a href="#5-1-5-贪心" class="headerlink" title="5.1.5 贪心"></a>5.1.5 贪心</h4><h5 id="5-1-5-1-基础"><a href="#5-1-5-1-基础" class="headerlink" title="5.1.5.1 基础"></a>5.1.5.1 基础</h5><ol><li><p>概述</p><blockquote><p>保证每次操作都是局部最优的，并且最后得到的结果是全局最优的</p><p>不存在比贪心策略更优的策略，即贪心策略就是最优策略</p></blockquote></li></ol><h5 id="5-1-5-2-习题"><a href="#5-1-5-2-习题" class="headerlink" title="5.1.5.2 习题"></a>5.1.5.2 习题</h5><ol><li><p>分配饼干</p><ol><li><p>概述</p><blockquote><p>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子</p><p>因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findContentChildren</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>grid <span class="token operator">==</span> null <span class="token operator">||</span> size <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> gi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> si <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>gi <span class="token operator">&lt;</span> grid<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> si <span class="token operator">&lt;</span> size<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>gi<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> size<span class="token punctuation">[</span>si<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            gi<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        si<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> gi<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>不重叠的区间个数</p><ol><li><p>概述</p><blockquote><p>先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数</p><p>在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大</p><p>按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">eraseOverlapIntervals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> Comparator<span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span>o <span class="token operator">-</span><span class="token operator">></span> o<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> end <span class="token operator">=</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        end <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> intervals<span class="token punctuation">.</span>length <span class="token operator">-</span> cnt<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>投飞镖刺破气球</p><ol><li><p>概述</p><blockquote><p>也是计算不重叠的区间个数，不过和 Non-overlapping Intervals 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMinArrowShots</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> points<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>points<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> Comparator<span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span>o <span class="token operator">-</span><span class="token operator">></span> o<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">=</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> points<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>        end <span class="token operator">=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cnt<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>根据身高和序号重组队列</p><ol><li><p>概述</p><blockquote><p>为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置</p><p>身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">reconstructQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> people<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>people <span class="token operator">==</span> null <span class="token operator">||</span> people<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> people<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>people<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">?</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">:</span> people<span class="token punctuation">)</span> <span class="token punctuation">{</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>买卖股票最大的收益</p><ol><li><p>概述</p><blockquote><p>只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> soFarMin <span class="token operator">=</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>soFarMin <span class="token operator">></span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> soFarMin <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> soFarMin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>买卖股票的最大收益 II</p><ol><li><p>概述</p><blockquote><p>对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> profit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            profit <span class="token operator">+=</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> profit<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>种植花朵</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canPlaceFlowers</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> flowerbed<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> flowerbed<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> cnt <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flowerbed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> pre <span class="token operator">=</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> flowerbed<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> next <span class="token operator">=</span> i <span class="token operator">==</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> flowerbed<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> next <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cnt<span class="token operator">++</span><span class="token punctuation">;</span>            flowerbed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cnt <span class="token operator">>=</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>判断是否为子序列</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        index <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>修改一个数成为非递减数组</p><ol><li><p>概述</p><blockquote><p>在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 不影响后续的操作 </p><p>优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作</p><p>还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkPossibility</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> cnt <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cnt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>子数组最大的和</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> preSum <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> maxSum <span class="token operator">=</span> preSum<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        preSum <span class="token operator">=</span> preSum <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> preSum <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        maxSum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxSum<span class="token punctuation">,</span> preSum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> maxSum<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>分隔字符串使同种字符出现在一起</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">partitionLabels</span><span class="token punctuation">(</span>String S<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lastIndexsOfChar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> S<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lastIndexsOfChar<span class="token punctuation">[</span><span class="token function">char2Index</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> partitions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> firstIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>firstIndex <span class="token operator">&lt;</span> S<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> lastIndex <span class="token operator">=</span> firstIndex<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> firstIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> S<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> lastIndex<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> lastIndexsOfChar<span class="token punctuation">[</span><span class="token function">char2Index</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                lastIndex <span class="token operator">=</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        partitions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>lastIndex <span class="token operator">-</span> firstIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        firstIndex <span class="token operator">=</span> lastIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> partitions<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">char2Index</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="5-1-6-分治"><a href="#5-1-6-分治" class="headerlink" title="5.1.6 分治"></a>5.1.6 分治</h4><h5 id="5-1-6-1-基础"><a href="#5-1-6-1-基础" class="headerlink" title="5.1.6.1 基础"></a>5.1.6.1 基础</h5><ol><li><p>概述</p><blockquote><p>缩小规模，分而治之，归并结果</p></blockquote></li></ol><h5 id="5-1-6-2-习题"><a href="#5-1-6-2-习题" class="headerlink" title="5.1.6.2 习题"></a>5.1.6.2 习题</h5><ol><li><p>给表达式加括号</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">diffWaysToCompute</span><span class="token punctuation">(</span>String input<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ways <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> input<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> c <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'-'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> left <span class="token operator">=</span> <span class="token function">diffWaysToCompute</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> right <span class="token operator">=</span> <span class="token function">diffWaysToCompute</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">:</span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">:</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">switch</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">case</span> <span class="token string">'+'</span><span class="token operator">:</span>                            ways<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token keyword">case</span> <span class="token string">'-'</span><span class="token operator">:</span>                            ways<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>l <span class="token operator">-</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token keyword">case</span> <span class="token string">'*'</span><span class="token operator">:</span>                            ways<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>l <span class="token operator">*</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ways<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ways<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ways<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>不同的二叉搜索树</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">generateTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">generateSubtrees</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">generateSubtrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> s<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> e<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> leftSubtrees <span class="token operator">=</span> <span class="token function">generateSubtrees</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> rightSubtrees <span class="token operator">=</span> <span class="token function">generateSubtrees</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>TreeNode left <span class="token operator">:</span> leftSubtrees<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>TreeNode right <span class="token operator">:</span> rightSubtrees<span class="token punctuation">)</span> <span class="token punctuation">{</span>                TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                root<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>                root<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="5-1-7-动态规划"><a href="#5-1-7-动态规划" class="headerlink" title="5.1.7 动态规划"></a>5.1.7 动态规划</h4><h5 id="5-1-7-1-基础"><a href="#5-1-7-1-基础" class="headerlink" title="5.1.7.1 基础"></a>5.1.7.1 基础</h5><ol><li><p>概述</p><blockquote><p>递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算</p></blockquote></li><li><p>类型</p><ul><li><p>斐波那契数列</p><ul><li><p>概述</p><blockquote><p>相邻三数之间存在和的关系，即前面两数之和等于第三数，这样的数字普遍存在，属于一种稳定序列</p></blockquote></li></ul></li><li><p>矩阵路径</p></li><li><p>数组区间</p></li><li><p>分割整数</p></li><li><p>最长递增子序列</p></li><li><p>最长公共子序列</p><ul><li><p>概述</p><blockquote><p>对于两个子序列 S1 和 S2，找出它们最长的公共子序列</p></blockquote></li><li><p>定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况</p><ul><li>当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1</li><li>当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }</li></ul></li><li><p>对于长度为 N 的序列 S1 和长度为 M 的序列 S2，dp[N][M] 就是序列 S1 和序列 S2 的最长公共子序列长度</p></li><li><p>与最长递增子序列相比，最长公共子序列有以下不同点</p><ul><li>针对的是两个序列，求它们的最长公共子序列</li><li>在最长递增子序列中，dp[i] 表示以 Si 为结尾的最长递增子序列长度，子序列必须包含 Si ；在最长公共子序列中，dp[i][j] 表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包含 S1i 和 S2j</li><li>在求最终解时，最长公共子序列中 dp[N][M] 就是最终解，而最长递增子序列中 dp[N] 不是最终解，因为以 SN 为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者</li></ul></li></ul></li><li><p>0-1背包</p><ul><li><p>概述</p><blockquote><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v</p><p>定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论</p><ul><li>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]</li><li>第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v</li></ul><p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大</p></blockquote></li><li><p>0-1 背包的状态转移方程</p><p><img src="/2021/07/25/5-algorithm/githubblog\source_posts\algorithm\003.状态转移方程.png" alt="状态转移方程"></p></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// W 为背包总体积</span><span class="token comment" spellcheck="true">// N 为物品数量</span><span class="token comment" spellcheck="true">// weights 数组存储 N 个物品的重量</span><span class="token comment" spellcheck="true">// values 数组存储 N 个物品的价值</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">knapsack</span><span class="token punctuation">(</span><span class="token keyword">int</span> W<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weights<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>W <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> w <span class="token operator">=</span> weights<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v <span class="token operator">=</span> values<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> W<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> w<span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>W<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>空间优化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">knapsack</span><span class="token punctuation">(</span><span class="token keyword">int</span> W<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weights<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>W <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> w <span class="token operator">=</span> weights<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v <span class="token operator">=</span> values<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> W<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> w<span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>W<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>无法使用贪心的场景</p><blockquote><p>0-1 背包问题无法使用贪心算法来求解，也就是说不能按照先添加性价比最高的物品来达到最优，这是因为这种方式可能造成背包空间的浪费，从而无法达到最优</p></blockquote><ul><li>完全背包：物品数量为无限个</li><li>多重背包：物品数量有限制</li><li>多维费用背包：物品不仅有重量，还有体积，同时考虑这两种限制</li><li>其它：物品之间相互约束或者依赖</li></ul></li></ul></li><li><p>股票交易</p></li><li><p>字符串编辑</p></li></ul></li></ol><h5 id="5-1-7-2-习题"><a href="#5-1-7-2-习题" class="headerlink" title="5.1.7.2 习题"></a>5.1.7.2 习题</h5><ol><li><p>爬楼梯</p><ol><li><p>概述</p><blockquote><p>定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目</p><p>第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和</p><p>考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> pre2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> pre1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> pre1 <span class="token operator">+</span> pre2<span class="token punctuation">;</span>        pre2 <span class="token operator">=</span> pre1<span class="token punctuation">;</span>        pre1 <span class="token operator">=</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> pre1<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>强盗抢劫</p><ol><li><p>概述</p><blockquote><p>定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量</p><p>由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> pre2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pre1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>pre2 <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> pre1<span class="token punctuation">)</span><span class="token punctuation">;</span>        pre2 <span class="token operator">=</span> pre1<span class="token punctuation">;</span>        pre1 <span class="token operator">=</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> pre1<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>强盗在环形街区抢劫</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">rob</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rob</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> pre2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pre1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> first<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> last<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>pre1<span class="token punctuation">,</span> pre2 <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pre2 <span class="token operator">=</span> pre1<span class="token punctuation">;</span>        pre1 <span class="token operator">=</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> pre1<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>信件错排</p><ol><li><p>概述</p><blockquote><p>定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量</p><p>假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面</p><ul><li>i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式</li><li>i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式</li></ul></blockquote></li></ol></li><li><p>矩阵的最小路径和</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 只能从上侧走到该位置</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 只能从左侧走到该位置</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>矩阵的总路径数</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>数学公式法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 是一个组合问题，机器人总共移动的次数 S=m+n-2，向下移动的次数 D=m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> S <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 总共的移动次数</span>    <span class="token keyword">int</span> D <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 向下的移动次数</span>    <span class="token keyword">long</span> ret <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> D<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret <span class="token operator">=</span> ret <span class="token operator">*</span> <span class="token punctuation">(</span>S <span class="token operator">-</span> D <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">/</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>数组区间和</p><ol><li><p>概述</p><blockquote><p>求区间 i ~ j 的和，可以转换为 sum[j + 1] - sum[i]，其中 sum[i] 为 0 ~ i - 1 的和</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">NumArray</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sums<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NumArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sumRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> sums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>数组中等差递增子区间的个数</p><ol><li><p>概述</p><blockquote><p>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数</p><p>当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间</p><p>而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间</p><p>综上，在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1</p><p>因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numberOfArithmeticSlices</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>A <span class="token operator">==</span> null <span class="token operator">||</span> A<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> cnt <span class="token operator">:</span> dp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        total <span class="token operator">+=</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> total<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>分割整数的最大乘积</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>j <span class="token operator">*</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">,</span> j <span class="token operator">*</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>按平方数来分割整数</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> squareList <span class="token operator">=</span> <span class="token function">generateSquareList</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> square <span class="token operator">:</span> squareList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>square <span class="token operator">></span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> square<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">generateSquareList</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> squareList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> diff <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> square <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>square <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        squareList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>square<span class="token punctuation">)</span><span class="token punctuation">;</span>        square <span class="token operator">+=</span> diff<span class="token punctuation">;</span>        diff <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> squareList<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>分割整数构成字母字符串</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'0'</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> one <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>one <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> two <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>two <span class="token operator">&lt;=</span> <span class="token number">26</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>最长递增子序列</p><ol><li><p>概述</p><blockquote><p>已知一个序列 {S1, S2,…,Sn}，取出若干数组成新的序列 {Si1, Si2,…, Sim}，其中 i1、i2 … im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个 <strong>子序列</strong> </p><p>如果在子序列中，当下标 ix &gt; iy 时，Six &gt; Siy，称子序列为原序列的一个 <strong>递增子序列</strong> </p><p>定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 Sn 结尾的序列的最长递增子序列长度</p><p>对于一个递增子序列 {Si1, Si2,…,Sim}，如果 im &lt; n 并且 Sim &lt; Sn，此时 {Si1, Si2,…, Sim, Sn} 为一个递增子序列，递增子序列的长度增加 1</p><p>满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 Sn 就构成了以 Sn 为结尾的最长递增子序列。因此 dp[n] = max{ dp[i]+1 | Si &lt; Sn &amp;&amp; i &lt; n}</p><p>对于一个长度为 N 的序列，最长递增子序列并不一定会以 SN 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，max{ dp[i] | 1 &lt;= i &lt;= N} 即为所求</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>二分实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tails <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>tails<span class="token punctuation">,</span> len<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        tails<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>            len<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tails<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> h <span class="token operator">=</span> len<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>h <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tails<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tails<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            h <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>一组整数对能够构成的最长链</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findLongestChain</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pairs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pairs <span class="token operator">==</span> null <span class="token operator">||</span> pairs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pairs<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> pairs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pairs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> pairs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>最长摆动子序列</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">wiggleMaxLength</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> up <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> down <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            up <span class="token operator">=</span> down <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            down <span class="token operator">=</span> up <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>up<span class="token punctuation">,</span> down<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>最长公共子序列</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>String text1<span class="token punctuation">,</span> String text2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n1 <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n2 <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>text1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> text2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>划分数组为和相等的两部分</p><ol><li><p>概述</p><blockquote><p>可以看成一个背包大小为 sum/2 的 0-1 背包问题</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canPartition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">computeArraySum</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> W <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>W <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 0-1 背包一个物品只能用一次</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> W<span class="token punctuation">;</span> i <span class="token operator">>=</span> num<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 从后往前，先计算 dp[i] 再计算 dp[i-num]</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> num<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>W<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">computeArraySum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum <span class="token operator">+=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>改变一组数的正负号使得它们的和为一给定数</p><ol><li><p>概述</p><blockquote><p>该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解</p><p>可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有</p><p>sum(P) - sum(N) = target<br>sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)<br>2 * sum(P) = target + sum(nums)</p><p>因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> S<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">computeArraySum</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> S <span class="token operator">||</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> S<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> W <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> S<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>W <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> W<span class="token punctuation">;</span> i <span class="token operator">>=</span> num<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> num<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>W<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">computeArraySum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum <span class="token operator">+=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>DFS实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> S<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> S<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> S <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> S <span class="token operator">+</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token operator">+</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> S <span class="token operator">-</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>01 字符构成最多的字符串</p><ol><li><p>概述</p><blockquote><p>是一个多维费用的 0-1 背包问题，有两个背包大小，0 的数量和 1 的数量</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMaxForm</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>strs <span class="token operator">==</span> null <span class="token operator">||</span> strs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String s <span class="token operator">:</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 每个字符串只能用一次</span>        <span class="token keyword">int</span> ones <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> zeros <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                zeros<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                ones<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m<span class="token punctuation">;</span> i <span class="token operator">>=</span> zeros<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token punctuation">;</span> j <span class="token operator">>=</span> ones<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> zeros<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> ones<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>找零钱的最少硬币数</p><ol><li><p>概述</p><blockquote><ul><li>物品：硬币</li><li>物品大小：面额</li><li>物品价值：数量</li></ul><p>因为硬币可以重复使用，因此这是一个完全背包问题。完全背包只需要将 0-1 背包的逆序遍历 dp 数组改为正序遍历即可</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> coins <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> coin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> amount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//将逆序遍历改为正序遍历</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> coin<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>找零钱的硬币数组合</p><ol><li><p>概述</p><blockquote><p>完全背包问题，使用 dp 记录可达成目标的组合数目</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span> amount<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>coins <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> coin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> amount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>字符串按单词列表分割</p><ol><li><p>概述</p><blockquote><p>dict 中的单词没有使用次数的限制，因此这是一个完全背包问题</p><p>该问题涉及到字典中单词的使用顺序，也就是说物品必须按一定顺序放入背包中</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String word <span class="token operator">:</span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 对物品的迭代应该放在最里层</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;=</span> i <span class="token operator">&amp;&amp;</span> word<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">-</span> len<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> len<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>组合总和</p><ol><li><p>概述</p><blockquote><p>涉及顺序的完全背包</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">combinationSum4</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> maximum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    maximum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maximum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> maximum<span class="token punctuation">[</span>i <span class="token operator">-</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> maximum<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>需要冷却期的股票交易</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prices <span class="token operator">==</span> null <span class="token operator">||</span> prices<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sell <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    s1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> buy<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    sell<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> s2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        buy<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s2<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>buy<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sell<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>buy<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>s2<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sell<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>sell<span class="token punctuation">[</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s2<span class="token punctuation">[</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>需要交易费用的股票交易</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">,</span> <span class="token keyword">int</span> fee<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sell <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    s1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> buy<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    sell<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> s2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        buy<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>sell<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s2<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>buy<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sell<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>buy<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> fee <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>s2<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sell<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>sell<span class="token punctuation">[</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s2<span class="token punctuation">[</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>只能进行两次的股票交易</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> firstBuy <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">,</span> firstSell <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> secondBuy <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">,</span> secondSell <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> curPrice <span class="token operator">:</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstBuy <span class="token operator">&lt;</span> <span class="token operator">-</span>curPrice<span class="token punctuation">)</span> <span class="token punctuation">{</span>            firstBuy <span class="token operator">=</span> <span class="token operator">-</span>curPrice<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstSell <span class="token operator">&lt;</span> firstBuy <span class="token operator">+</span> curPrice<span class="token punctuation">)</span> <span class="token punctuation">{</span>            firstSell <span class="token operator">=</span> firstBuy <span class="token operator">+</span> curPrice<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>secondBuy <span class="token operator">&lt;</span> firstSell <span class="token operator">-</span> curPrice<span class="token punctuation">)</span> <span class="token punctuation">{</span>            secondBuy <span class="token operator">=</span> firstSell <span class="token operator">-</span> curPrice<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>secondSell <span class="token operator">&lt;</span> secondBuy <span class="token operator">+</span> curPrice<span class="token punctuation">)</span> <span class="token punctuation">{</span>            secondSell <span class="token operator">=</span> secondBuy <span class="token operator">+</span> curPrice<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> secondSell<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>只能进行 k 次的股票交易</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">>=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 这种情况下该问题退化为普通的股票交易问题</span>        <span class="token keyword">int</span> maxProfit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                maxProfit <span class="token operator">+=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxProfit<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> maxProfit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> localMax <span class="token operator">=</span> maxProfit<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxProfit<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxProfit<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> prices<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> localMax<span class="token punctuation">)</span><span class="token punctuation">;</span>            localMax <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>localMax<span class="token punctuation">,</span> maxProfit<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> maxProfit<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>删除两个字符串的字符使它们相等</p><ol><li><p>概述</p><blockquote><p>可以转换为求两个字符串的最长公共子序列问题</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>String word1<span class="token punctuation">,</span> String word2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> word1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> word2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>word1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> word2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">*</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>编辑距离</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>String word1<span class="token punctuation">,</span> String word2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>word1 <span class="token operator">==</span> null <span class="token operator">||</span> word2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> word1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> word2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>word1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> word2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>复制粘贴字符</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minSteps</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token function">minSteps</span><span class="token punctuation">(</span>n <span class="token operator">/</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minSteps</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> h<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">/</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="5-1-8查找-搜索"><a href="#5-1-8查找-搜索" class="headerlink" title="5.1.8查找(搜索)"></a>5.1.8查找(搜索)</h4><h5 id="5-1-8-1-基础"><a href="#5-1-8-1-基础" class="headerlink" title="5.1.8.1 基础"></a>5.1.8.1 基础</h5><ol><li><p>BFS</p><ul><li><p>概述</p><blockquote><p>广度优先搜索一层一层地进行遍历</p><p>每层遍历都是以上一层遍历的结果作为起点</p><p>遍历一个距离能访问到的所有节点</p><p>遍历过的节点不能再次被遍历</p></blockquote></li><li><p>推论</p><blockquote><p>每一层遍历的节点都与根节点距离相同。设 di 表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 di&lt;= dj。利用这个结论，可以求解最短路径等 <strong>最优解</strong> 问题：第一次遍历到目的节点，其所经过的路径为最短路径。应该注意的是，使用 BFS 只能求解无权图的最短路径，无权图是指从一个节点到另一个节点的代价都记为 1</p></blockquote></li><li><p>注意</p><ul><li>队列：用来存储每一轮遍历得到的节点</li><li>标记：对于遍历过的节点，应该将它标记，防止重复遍历</li></ul></li></ul></li><li><p>DFS</p><ul><li><p>概述</p><blockquote><p>得到一个新节点时立即对新节点进行遍历</p><p>如此反复以这种方式遍历新节点，直到没有新节点了，此时返回</p></blockquote></li><li><p>应用</p><blockquote><p>从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种 <strong>可达性</strong> 问题</p></blockquote></li><li><p>注意</p><ul><li>栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点；可以使用递归栈</li><li>标记：和 BFS 一样同样需要对已经遍历过的节点进行标记</li></ul></li></ul></li><li><p>Backtracking</p><ul><li><p>概述</p><blockquote><p>（回溯）属于 DFS</p><p>普通 DFS 主要用在 <strong>可达性问题</strong> ，这种问题只需要执行到特点的位置然后返回即可</p><p>Backtracking 主要用于求解 排列组合 问题</p><p>Backtracking 不是立即返回，而要继续求解</p></blockquote></li><li><p>注意</p><ul><li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素</li><li>在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素</li></ul></li></ul></li></ol><h5 id="5-1-8-2-习题"><a href="#5-1-8-2-习题" class="headerlink" title="5.1.8.2 习题"></a>5.1.8.2 习题</h5><ol><li><p>计算在网格中从原点到特定点的最短路径长度</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">shortestPathBinaryMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grids<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>grids <span class="token operator">==</span> null <span class="token operator">||</span> grids<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> grids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> direction <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> grids<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> grids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">>></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pathLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pathLength<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>size<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Pair<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> cr <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cc <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>grids<span class="token punctuation">[</span>cr<span class="token punctuation">]</span><span class="token punctuation">[</span>cc<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cr <span class="token operator">==</span> m <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> cc <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> pathLength<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            grids<span class="token punctuation">[</span>cr<span class="token punctuation">]</span><span class="token punctuation">[</span>cc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 标记</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">:</span> direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> nr <span class="token operator">=</span> cr <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nc <span class="token operator">=</span> cc <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nr <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> nr <span class="token operator">>=</span> m <span class="token operator">||</span> nc <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> nc <span class="token operator">>=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>nr<span class="token punctuation">,</span> nc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>组成整数的最小平方数数量</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> squares <span class="token operator">=</span> <span class="token function">generateSquares</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    marked<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        level<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>size<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> s <span class="token operator">:</span> squares<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> next <span class="token operator">=</span> cur <span class="token operator">-</span> s<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> level<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                marked<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 生成小于 n 的平方数序列 * @return 1,4,9,... */</span><span class="token keyword">private</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">generateSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> squares <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> square <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> diff <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>square <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        squares<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>square<span class="token punctuation">)</span><span class="token punctuation">;</span>        square <span class="token operator">+=</span> diff<span class="token punctuation">;</span>        diff <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> squares<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>最短单词路径</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">ladderLength</span><span class="token punctuation">(</span>String beginWord<span class="token punctuation">,</span> String endWord<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordList<span class="token punctuation">)</span> <span class="token punctuation">{</span>    wordList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> wordList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>wordList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>endWord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        end<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">==</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graphic <span class="token operator">=</span> <span class="token function">buildGraphic</span><span class="token punctuation">(</span>wordList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">getShortestPath</span><span class="token punctuation">(</span>graphic<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">buildGraphic</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordList<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> wordList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graphic <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        graphic<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isConnect</span><span class="token punctuation">(</span>wordList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> wordList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                graphic<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> graphic<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isConnect</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> diffCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> diffCnt <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> s2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            diffCnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> diffCnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getShortestPath</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graphic<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>graphic<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>    marked<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> path <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        path<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>size<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> next <span class="token operator">:</span> graphic<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> path<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                marked<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>查找最大的连通面积</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> direction <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxAreaOfIsland</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>grid <span class="token operator">==</span> null <span class="token operator">||</span> grid<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    m <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> maxArea <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxArea <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxArea<span class="token punctuation">,</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> maxArea<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> r <span class="token operator">>=</span> m <span class="token operator">||</span> c <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> c <span class="token operator">>=</span> n <span class="token operator">||</span> grid<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    grid<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">:</span> direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>        area <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> area<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>矩阵中的连通分量数目</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> direction <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numIslands</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>grid <span class="token operator">==</span> null <span class="token operator">||</span> grid<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    m <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> islandsNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                islandsNum<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> islandsNum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> m <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">>=</span> n <span class="token operator">||</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">:</span> direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> j <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>好友关系的连通分量数目</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>    n <span class="token operator">=</span> M<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> circleNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hasVisited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasVisited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> i<span class="token punctuation">,</span> hasVisited<span class="token punctuation">)</span><span class="token punctuation">;</span>            circleNum<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> circleNum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> M<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hasVisited<span class="token punctuation">)</span> <span class="token punctuation">{</span>    hasVisited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>M<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>hasVisited<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> k<span class="token punctuation">,</span> hasVisited<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>填充封闭区域</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> direction <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>board <span class="token operator">==</span> null <span class="token operator">||</span> board<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    m <span class="token operator">=</span> board<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    n <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'T'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'O'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'X'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> r <span class="token operator">>=</span> m <span class="token operator">||</span> c <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> c <span class="token operator">>=</span> n <span class="token operator">||</span> board<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'O'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    board<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'T'</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">:</span> direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> r <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>能到达的太平洋和大西洋的区域</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> direction <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">pacificAtlantic</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    m <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>matrix <span class="token operator">=</span> matrix<span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> canReachP <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> canReachA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> canReachP<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> canReachA<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> canReachP<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> canReachA<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>canReachP<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> canReachA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ret<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> canReach<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>canReach<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    canReach<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">:</span> direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> nextR <span class="token operator">=</span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> r<span class="token punctuation">;</span>        <span class="token keyword">int</span> nextC <span class="token operator">=</span> d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextR <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> nextR <span class="token operator">>=</span> m <span class="token operator">||</span> nextC <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> nextC <span class="token operator">>=</span> n                <span class="token operator">||</span> matrix<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">></span> matrix<span class="token punctuation">[</span>nextR<span class="token punctuation">]</span><span class="token punctuation">[</span>nextC<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>nextR<span class="token punctuation">,</span> nextC<span class="token punctuation">,</span> canReach<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>数字键盘组合</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> KEYS <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">,</span> <span class="token string">"ghi"</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">,</span> <span class="token string">"mno"</span><span class="token punctuation">,</span> <span class="token string">"pqrs"</span><span class="token punctuation">,</span> <span class="token string">"tuv"</span><span class="token punctuation">,</span> <span class="token string">"wxyz"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span>String digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> combinations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>digits <span class="token operator">==</span> null <span class="token operator">||</span> digits<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> combinations<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">doCombination</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> combinations<span class="token punctuation">,</span> digits<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> combinations<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doCombination</span><span class="token punctuation">(</span>StringBuilder prefix<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> combinations<span class="token punctuation">,</span> <span class="token keyword">final</span> String digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> digits<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        combinations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> curDigits <span class="token operator">=</span> digits<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>    String letters <span class="token operator">=</span> KEYS<span class="token punctuation">[</span>curDigits<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> letters<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        prefix<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 添加</span>        <span class="token function">doCombination</span><span class="token punctuation">(</span>prefix<span class="token punctuation">,</span> combinations<span class="token punctuation">,</span> digits<span class="token punctuation">)</span><span class="token punctuation">;</span>        prefix<span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 删除</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>IP 地址划分</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">restoreIpAddresses</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> addresses <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    StringBuilder tempAddress <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">doRestore</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> tempAddress<span class="token punctuation">,</span> addresses<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> addresses<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doRestore</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> StringBuilder tempAddress<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> addresses<span class="token punctuation">,</span> String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">4</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            addresses<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tempAddress<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String part <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>part<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tempAddress<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                part <span class="token operator">=</span> <span class="token string">"."</span> <span class="token operator">+</span> part<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            tempAddress<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>part<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">doRestore</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> tempAddress<span class="token punctuation">,</span> addresses<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            tempAddress<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>tempAddress<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> part<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tempAddress<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>在矩阵中寻找字符串</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> direction <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">exist</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>word <span class="token operator">==</span> null <span class="token operator">||</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>board <span class="token operator">==</span> null <span class="token operator">||</span> board<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    m <span class="token operator">=</span> board<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    n <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hasVisited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> c<span class="token punctuation">,</span> hasVisited<span class="token punctuation">,</span> board<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> curLen<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> <span class="token keyword">final</span> String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curLen <span class="token operator">==</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> r <span class="token operator">>=</span> m <span class="token operator">||</span> c <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> c <span class="token operator">>=</span> n            <span class="token operator">||</span> board<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">!=</span> word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>curLen<span class="token punctuation">)</span> <span class="token operator">||</span> visited<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    visited<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">:</span> direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">backtracking</span><span class="token punctuation">(</span>curLen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> visited<span class="token punctuation">,</span> board<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    visited<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>输出二叉树中所有从根到叶子的路径</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> paths <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> paths<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> values <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">backtracking</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> values<span class="token punctuation">,</span> paths<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> paths<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> values<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> paths<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    values<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLeaf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        paths<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">buildPath</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> values<span class="token punctuation">,</span> paths<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> values<span class="token punctuation">,</span> paths<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    values<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isLeaf</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> node<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> String <span class="token function">buildPath</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StringBuilder str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"->"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>排列</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> permutes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> permuteList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hasVisited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">backtracking</span><span class="token punctuation">(</span>permuteList<span class="token punctuation">,</span> permutes<span class="token punctuation">,</span> hasVisited<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> permutes<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> permuteList<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> permutes<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>permuteList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        permutes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>permuteList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 重新构造一个 List</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> visited<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        permuteList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>permuteList<span class="token punctuation">,</span> permutes<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        permuteList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>permuteList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>含有相同元素求排列</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">permuteUnique</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> permutes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> permuteList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 排序</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hasVisited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">backtracking</span><span class="token punctuation">(</span>permuteList<span class="token punctuation">,</span> permutes<span class="token punctuation">,</span> hasVisited<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> permutes<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> permuteList<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> permutes<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>permuteList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        permutes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>permuteList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> visited<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 防止重复</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        permuteList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>permuteList<span class="token punctuation">,</span> permutes<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        permuteList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>permuteList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>组合</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> combinations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> combineList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">backtracking</span><span class="token punctuation">(</span>combineList<span class="token punctuation">,</span> combinations<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> combinations<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> combineList<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> combinations<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        combinations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>combineList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 剪枝</span>        combineList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>combineList<span class="token punctuation">,</span> combinations<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        combineList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>combineList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>组合求和</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">combinationSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> combinations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> combinations<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> combinations<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> tempCombination<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> combinations<span class="token punctuation">,</span>                          <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        combinations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>tempCombination<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tempCombination<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">backtracking</span><span class="token punctuation">(</span>tempCombination<span class="token punctuation">,</span> combinations<span class="token punctuation">,</span> i<span class="token punctuation">,</span> target <span class="token operator">-</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>            tempCombination<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tempCombination<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>含有相同元素的组合求和</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">combinationSum2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> combinations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> combinations<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>candidates<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> combinations<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> tempCombination<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> combinations<span class="token punctuation">,</span>                          <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hasVisited<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        combinations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>tempCombination<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> candidates<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>hasVisited<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tempCombination<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            hasVisited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token function">backtracking</span><span class="token punctuation">(</span>tempCombination<span class="token punctuation">,</span> combinations<span class="token punctuation">,</span> hasVisited<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> target <span class="token operator">-</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>            hasVisited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            tempCombination<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tempCombination<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>1-9 数字的组合求和</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">combinationSum3</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> combinations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">backtracking</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> combinations<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> combinations<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span>                          List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> tempCombination<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> combinations<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        combinations<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>tempCombination<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tempCombination<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> tempCombination<span class="token punctuation">,</span> combinations<span class="token punctuation">)</span><span class="token punctuation">;</span>        tempCombination<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tempCombination<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>子集</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">subsets</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> subsets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> tempSubset <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> size <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> size<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> tempSubset<span class="token punctuation">,</span> subsets<span class="token punctuation">,</span> size<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不同的子集大小</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> subsets<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> tempSubset<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> subsets<span class="token punctuation">,</span>                          <span class="token keyword">final</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tempSubset<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        subsets<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>tempSubset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tempSubset<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> tempSubset<span class="token punctuation">,</span> subsets<span class="token punctuation">,</span> size<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        tempSubset<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tempSubset<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>含有相同元素求子集</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">subsetsWithDup</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> subsets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> tempSubset <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hasVisited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> size <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> size<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> tempSubset<span class="token punctuation">,</span> subsets<span class="token punctuation">,</span> hasVisited<span class="token punctuation">,</span> size<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不同的子集大小</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> subsets<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> tempSubset<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> subsets<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hasVisited<span class="token punctuation">,</span>                          <span class="token keyword">final</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tempSubset<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        subsets<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>tempSubset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>hasVisited<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        tempSubset<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hasVisited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> tempSubset<span class="token punctuation">,</span> subsets<span class="token punctuation">,</span> hasVisited<span class="token punctuation">,</span> size<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        hasVisited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        tempSubset<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tempSubset<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>分割字符串使得每个部分都是回文数</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">partition</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> partitions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> tempPartition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">doPartition</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> partitions<span class="token punctuation">,</span> tempPartition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> partitions<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doPartition</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> partitions<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> tempPartition<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        partitions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>tempPartition<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tempPartition<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">doPartition</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> partitions<span class="token punctuation">,</span> tempPartition<span class="token punctuation">)</span><span class="token punctuation">;</span>            tempPartition<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tempPartition<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>begin<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>end<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>数独</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rowsUsed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> colsUsed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cubesUsed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">solveSudoku</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>board <span class="token operator">=</span> board<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> num <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            rowsUsed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            colsUsed<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            cubesUsed<span class="token punctuation">[</span><span class="token function">cubeNum</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>row <span class="token operator">&lt;</span> <span class="token number">9</span> <span class="token operator">&amp;&amp;</span> board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        row <span class="token operator">=</span> col <span class="token operator">==</span> <span class="token number">8</span> <span class="token operator">?</span> row <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> row<span class="token punctuation">;</span>        col <span class="token operator">=</span> col <span class="token operator">==</span> <span class="token number">8</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">==</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> num <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> num<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rowsUsed<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">||</span> colsUsed<span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">||</span> cubesUsed<span class="token punctuation">[</span><span class="token function">cubeNum</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        rowsUsed<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> colsUsed<span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> cubesUsed<span class="token punctuation">[</span><span class="token function">cubeNum</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">backtracking</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'.'</span><span class="token punctuation">;</span>        rowsUsed<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> colsUsed<span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> cubesUsed<span class="token punctuation">[</span><span class="token function">cubeNum</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">cubeNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> r <span class="token operator">=</span> i <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> j <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> r <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>N 皇后</p><ol><li><p>概述</p><blockquote><p>在 n*n 的矩阵中摆放 n 个皇后，并且每个皇后不能在同一行，同一列，同一对角线上，求所有的 n 皇后的解</p><p>一行一行地摆放，在确定一行中的那个皇后应该摆在哪一列时，需要用三个标记数组来确定某一列是否合法，这三个标记数组分别为：列标记数组、45 度对角线标记数组和 135 度对角线标记数组</p><p>45 度对角线标记数组的长度为 2 * n - 1，通过下图可以明确 (r, c) 的位置所在的数组下标为 r + c</p><p>135 度对角线标记数组的长度也是 2 * n - 1，(r, c) 的位置所在的数组下标为 n - 1 - (r - c)</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> solutions<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nQueens<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> colUsed<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> diagonals45Used<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> diagonals135Used<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    solutions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    nQueens <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>nQueens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    colUsed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    diagonals45Used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    diagonals135Used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> solutions<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token keyword">int</span> row<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">:</span> nQueens<span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        solutions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> diagonals45Idx <span class="token operator">=</span> row <span class="token operator">+</span> col<span class="token punctuation">;</span>        <span class="token keyword">int</span> diagonals135Idx <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token punctuation">(</span>row <span class="token operator">-</span> col<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>colUsed<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">||</span> diagonals45Used<span class="token punctuation">[</span>diagonals45Idx<span class="token punctuation">]</span> <span class="token operator">||</span> diagonals135Used<span class="token punctuation">[</span>diagonals135Idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        nQueens<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Q'</span><span class="token punctuation">;</span>        colUsed<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> diagonals45Used<span class="token punctuation">[</span>diagonals45Idx<span class="token punctuation">]</span> <span class="token operator">=</span> diagonals135Used<span class="token punctuation">[</span>diagonals135Idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        colUsed<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> diagonals45Used<span class="token punctuation">[</span>diagonals45Idx<span class="token punctuation">]</span> <span class="token operator">=</span> diagonals135Used<span class="token punctuation">[</span>diagonals135Idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        nQueens<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'.'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h3 id="5-2-数据结构"><a href="#5-2-数据结构" class="headerlink" title="5.2 数据结构"></a>5.2 数据结构</h3><h4 id="5-2-1-位运算"><a href="#5-2-1-位运算" class="headerlink" title="5.2.1 位运算"></a>5.2.1 位运算</h4><h5 id="5-2-1-1-基础"><a href="#5-2-1-1-基础" class="headerlink" title="5.2.1.1 基础"></a>5.2.1.1 基础</h5><ol><li><p>约定</p><blockquote><p>0s 表示一串 0，1s 表示一串 1</p></blockquote></li><li><p>特征值</p><table><thead><tr><th>非计算</th><th>且计算</th><th>或计算</th></tr></thead><tbody><tr><td>x ^ 0s = x</td><td>x &amp; 0s = 0</td><td>x | 0s = x</td></tr><tr><td>x ^ 1s = ~x</td><td>x &amp; 1s = x</td><td>x | 1s = 1s</td></tr><tr><td>x ^ x = 0</td><td>x &amp; x = x</td><td>x | x = x</td></tr></tbody></table></li><li><p>操作</p><ul><li><p>利用 x ^ 1s = ~x 的特点，可以将一个数的位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数</p><pre class=" language-java"><code class="language-java"><span class="token number">1</span><span class="token operator">^</span><span class="token number">1</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">=</span> <span class="token number">2</span></code></pre></li><li><p>利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位</p><pre class=" language-java"><code class="language-java"><span class="token number">01011011</span> <span class="token operator">&amp;</span><span class="token number">00111100</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token number">00011000</span></code></pre></li><li><p>利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1</p><pre class=" language-java"><code class="language-java"><span class="token number">01011011</span> <span class="token operator">|</span><span class="token number">00111100</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token number">01111111</span></code></pre></li></ul></li><li><p>技巧</p><blockquote><p>n&amp;(n-1) 去除 n 的位级表示中最低的那一位 1</p><p>例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token number">01011011</span> <span class="token operator">&amp;</span><span class="token number">01011010</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token number">01011010</span></code></pre><blockquote><p>n&amp;(-n) 得到 n 的位级表示中最低的那一位 1。-n 得到 n 的反码加 1，也就是 -n=~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token number">10110100</span> <span class="token operator">&amp;</span><span class="token number">01001100</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token number">00000100</span></code></pre></li><li><p>移位运算</p><blockquote><p>&gt;&gt; n 为算术右移，相当于除以 2n</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// -7 \>\> 2 = -2</span><span class="token number">11111111111111111111111111111001</span>  <span class="token operator">>></span> <span class="token number">2</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token number">11111111111111111111111111111110</span></code></pre><blockquote><p>&gt;&gt;&gt; n 为无符号右移，左边会补上 0</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// -7 \>\>\> 2 = 1073741822</span><span class="token number">11111111111111111111111111111001</span>  <span class="token operator">>>></span> <span class="token number">2</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token number">00111111111111111111111111111111</span></code></pre><blockquote><p>&lt;&lt; n 为算术左移，相当于乘以 2n</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// -7 &lt;&lt; 2 = -28</span><span class="token number">11111111111111111111111111111001</span>  <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token number">11111111111111111111111111100100</span></code></pre></li><li><p>mask计算</p><blockquote><p>要获取 111111111，将 0 取反即可，~0</p><p>要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1&lt;&lt;(i-1) 。例如 1&lt;&lt;4 得到只有第 5 位为 1 的 mask ：00010000</p><p>要得到 1 到 i 位为 1 的 mask，(1&lt;&lt;i)-1 即可，例如将 (1&lt;&lt;4)-1 = 00010000-1 = 00001111</p><p>要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1&lt;&lt;i)-1)</p></blockquote></li><li><p>java中的位操作</p><blockquote><p>static int Integer.bitCount();           // 统计 1 的数量<br>static int Integer.highestOneBit();      // 获得最高位<br>static String toBinaryString(int i);     // 转换为二进制表示的字符串</p></blockquote></li></ol><h5 id="5-2-1-2-习题"><a href="#5-2-1-2-习题" class="headerlink" title="5.2.1.2 习题"></a>5.2.1.2 习题</h5><ol><li><p>统计两个数的二进制表示有多少位不同</p><ol><li><p>对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">^</span> y<span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>z <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>z <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>        z <span class="token operator">=</span> z <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cnt<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>使用 z&amp;(z-1) 去除 z 位级表示最低的那一位</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">^</span> y<span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>z <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        z <span class="token operator">&amp;=</span> <span class="token punctuation">(</span>z <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cnt<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>使用 Integer.bitcount() 来统计 1 个的个数</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">bitCount</span><span class="token punctuation">(</span>x <span class="token operator">^</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>数组中唯一一个不重复的元素</p><ol><li><p>概述</p><blockquote><p>两个相同的数异或的结果为 0，对所有数进行异或操作，最后的结果就是单独出现的那个数</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">:</span> nums<span class="token punctuation">)</span> ret <span class="token operator">=</span> ret <span class="token operator">^</span> n<span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>找出数组中缺失的那个数</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret <span class="token operator">=</span> ret <span class="token operator">^</span> i <span class="token operator">^</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret <span class="token operator">^</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>数组中不重复的两个元素</p><ol><li><p>概述</p><blockquote><p>两个不相等的元素在位级表示上必定会有一位存在不同</p><p>将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果</p><p>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> diff <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> diff <span class="token operator">^=</span> num<span class="token punctuation">;</span>    diff <span class="token operator">&amp;=</span> <span class="token operator">-</span>diff<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 得到最右一位</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">&amp;</span> diff<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> ret<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">^=</span> num<span class="token punctuation">;</span>        <span class="token keyword">else</span> ret<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">^=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>翻转一个数的比特位</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reverseBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        ret <span class="token operator">|=</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">>>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>不用额外变量交换两个整数</p><ol><li><p>概述</p><blockquote><p>a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;</p></blockquote></li></ol></li><li><p>判断一个数是不是 2 的 n 次方</p><ol><li><p>二进制表示只有一个1存在</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> Integer<span class="token punctuation">.</span><span class="token function">bitCount</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>利用 1000 &amp; 0111 == 0 这种性质</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>判断一个数是不是 4 的 n 次方</p><ol><li><p>这种数在二进制表示中有且只有一个奇数位为 1</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPowerOfFour</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> num <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>num <span class="token operator">&amp;</span> <span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>num <span class="token operator">&amp;</span> <span class="token number">0b01010101010101010101010101010101</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>使用正则表达式进行匹配</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPowerOfFour</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"10*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>判断一个数的位级表示是否不会出现连续的 0 和 1</p><ol><li><p>概述</p><blockquote><p>对于 1010 这种位级表示的数，把它向右移动 1 位得到 101，这两个数每个位都不同，因此异或得到的结果为 1111</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasAlternatingBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">^</span> <span class="token punctuation">(</span>n <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">&amp;</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>求一个数的补码</p><ol><li><p>概述</p><blockquote><p>对于 00000101，要求补码可以将它与 00000111 进行异或操作。那么问题就转换为求掩码 00000111</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findComplement</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> mask <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> num <span class="token operator">^</span> mask<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>利用 Java 的 Integer.highestOneBit() 方法来获得含有首 1 的数</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findComplement</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mask <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">highestOneBit</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> num <span class="token operator">^</span> mask<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>对于 10000000 这样的数要扩展成 11111111，可以利用以下方法</p><pre class=" language-java"><code class="language-java">mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">1</span>    <span class="token number">11000000</span>mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">2</span>    <span class="token number">11110000</span>mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">4</span>    <span class="token number">11111111</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findComplement</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mask <span class="token operator">=</span> num<span class="token punctuation">;</span>    mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>    mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">;</span>    mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">;</span>    mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">;</span>    mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>mask <span class="token operator">^</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>实现整数的加法</p><ol><li><p>概述</p><blockquote><p>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位</p><p>递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">^</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>a <span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>字符串数组最大乘积</p><ol><li><p>概述</p><blockquote><p>本题主要问题是判断两个字符串是否含相同字符，由于字符串只含有小写字符，总共 26 位，因此可以用一个 32 位的整数来存储每个字符是否出现过</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> words<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> val <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            val<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;</span> val<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ret <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> words<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>统计从 0 ~ n 每个数的二进制表示中 1 的个数</p><ol><li><p>概述</p><blockquote><p>对于数字 6(110)，它可以看成是 4(100) 再加一个 2(10)，因此 dp[i] = dp[i&amp;(i-1)] + 1</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">countBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ret<span class="token punctuation">[</span>i<span class="token operator">&amp;</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="5-2-2-字符串"><a href="#5-2-2-字符串" class="headerlink" title="5.2.2 字符串"></a>5.2.2 字符串</h4><h5 id="5-2-2-1-基础"><a href="#5-2-2-1-基础" class="headerlink" title="5.2.2.1 基础"></a>5.2.2.1 基础</h5><h5 id="5-2-2-2-习题"><a href="#5-2-2-2-习题" class="headerlink" title="5.2.2.2 习题"></a>5.2.2.2 习题</h5><ol><li><p>字符串循环移位包含</p><ol><li><p>概述</p><blockquote><p>给定两个字符串 s1 和 s2，要求判定 s2 是否能够被 s1 做循环移位得到的字符串包含</p><p>s1 进行循环移位的结果是 s1s1 的子字符串，因此只要判断 s2 是否是 s1s1 的子字符串即可</p></blockquote></li></ol></li><li><p>字符串循环移位</p><ol><li><p>概述</p><blockquote><p>将字符串向右循环移动 k 位</p><p>将 abcd123 中的 abcd 和 123 单独翻转，得到 dcba321，然后对整个字符串进行翻转，得到 123abcd</p></blockquote></li></ol></li><li><p>字符串中单词的翻转</p><ol><li><p>概述</p><blockquote><p>将每个单词翻转，然后将整个字符串翻转</p></blockquote></li></ol></li><li><p>两个字符串包含的字符是否完全相同</p><ol><li><p>概述</p><blockquote><p>可以用 HashMap 来映射字符与出现次数，然后比较两个字符串出现的字符数量是否相同</p><p>由于本题的字符串只包含 26 个小写字符，因此可以使用长度为 26 的整型数组对字符串出现的字符进行统计，不再使用 HashMap</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cnts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cnts<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> t<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cnts<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> cnt <span class="token operator">:</span> cnts<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>计算一组字符集合可以组成的回文字符串的最大长度</p><ol><li><p>概述</p><blockquote><p>使用长度为 256 的整型数组来统计每个字符出现的个数，每个字符有偶数个可以用来构成回文字符串</p><p>因为回文字符串最中间的那个字符可以单独出现，所以如果有单独的字符就把它放到最中间</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cnts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cnts<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> palindrome <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> cnt <span class="token operator">:</span> cnts<span class="token punctuation">)</span> <span class="token punctuation">{</span>        palindrome <span class="token operator">+=</span> <span class="token punctuation">(</span>cnt <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>palindrome <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        palindrome<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 这个条件下 s 中一定有单个未使用的字符存在，可以把这个字符放到回文的最中间</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> palindrome<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>字符串同构</p><ol><li><p>概述</p><blockquote><p>记录一个字符上次出现的位置，如果两个字符串中的字符上次出现的位置一样，那么就属于同构</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isIsomorphic</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preIndexOfS <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preIndexOfT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> sc <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> tc <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>preIndexOfS<span class="token punctuation">[</span>sc<span class="token punctuation">]</span> <span class="token operator">!=</span> preIndexOfT<span class="token punctuation">[</span>tc<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        preIndexOfS<span class="token punctuation">[</span>sc<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        preIndexOfT<span class="token punctuation">[</span>tc<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>回文子字符串个数</p><ol><li><p>概述</p><blockquote><p>从字符串的某一位开始，尝试着去扩展子字符串</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countSubstrings</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">extendSubstrings</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 奇数长度</span>        <span class="token function">extendSubstrings</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 偶数长度</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cnt<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">extendSubstrings</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        start<span class="token operator">--</span><span class="token punctuation">;</span>        end<span class="token operator">++</span><span class="token punctuation">;</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>判断一个整数是否是回文数</p><ol><li><p>概述</p><blockquote><p>要求不能使用额外空间，也就不能将整数转换为字符串进行判断</p><p>将整数分成左右两部分，右边那部分需要转置，然后判断这两部分是否相等</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> x <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        right <span class="token operator">=</span> right <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>        x <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> x <span class="token operator">==</span> right <span class="token operator">||</span> x <span class="token operator">==</span> right <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countBinarySubstrings</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> preLen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> curLen <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curLen<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            preLen <span class="token operator">=</span> curLen<span class="token punctuation">;</span>            curLen <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>preLen <span class="token operator">>=</span> curLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="5-2-3-栈和队列"><a href="#5-2-3-栈和队列" class="headerlink" title="5.2.3 栈和队列"></a>5.2.3 栈和队列</h4><h5 id="5-2-3-1-基础"><a href="#5-2-3-1-基础" class="headerlink" title="5.2.3.1 基础"></a>5.2.3.1 基础</h5><h5 id="5-2-3-2-习题"><a href="#5-2-3-2-习题" class="headerlink" title="5.2.3.2 习题"></a>5.2.3.2 习题</h5><ol><li><p>用栈实现队列</p><ol><li><p>概述</p><blockquote><p>栈的顺序为后进先出，而队列的顺序为先进先出</p><p>使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">in2out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> out<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">in2out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> out<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">in2out</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>out<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>in<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> out<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>用队列实现栈</p><ol><li><p>概述</p><blockquote><p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cnt<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>最小值栈</p><ol><li><p>概述</p><blockquote><p>对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MinStack</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> dataStack<span class="token punctuation">;</span>    <span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> minStack<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> min<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MinStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        dataStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        minStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        min <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        dataStack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        minStack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>min<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        dataStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        minStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        min <span class="token operator">=</span> minStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> minStack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> dataStack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> minStack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>用栈实现括号匹配</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Stack<span class="token operator">&lt;</span>Character<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'('</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'{'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'['</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">char</span> cStack <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> b1 <span class="token operator">=</span> c <span class="token operator">==</span> <span class="token string">')'</span> <span class="token operator">&amp;&amp;</span> cStack <span class="token operator">!=</span> <span class="token string">'('</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> b2 <span class="token operator">=</span> c <span class="token operator">==</span> <span class="token string">']'</span> <span class="token operator">&amp;&amp;</span> cStack <span class="token operator">!=</span> <span class="token string">'['</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> b3 <span class="token operator">=</span> c <span class="token operator">==</span> <span class="token string">'}'</span> <span class="token operator">&amp;&amp;</span> cStack <span class="token operator">!=</span> <span class="token string">'{'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>b1 <span class="token operator">||</span> b2 <span class="token operator">||</span> b3<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>数组中元素与下一个比它大的元素之间的距离</p><ol><li><p>概述</p><blockquote><p>在遍历数组时用栈把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temperatures<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> temperatures<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> indexs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> curIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> curIndex <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> curIndex<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>indexs<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> temperatures<span class="token punctuation">[</span>curIndex<span class="token punctuation">]</span> <span class="token operator">></span> temperatures<span class="token punctuation">[</span>indexs<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> preIndex <span class="token operator">=</span> indexs<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dist<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">=</span> curIndex <span class="token operator">-</span> preIndex<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        indexs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>curIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dist<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>循环数组中比当前元素大的下一个元素</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextGreaterElements</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> pre <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">%</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pre<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>pre<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>            next<span class="token punctuation">[</span>pre<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>            pre<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="5-2-4-链表"><a href="#5-2-4-链表" class="headerlink" title="5.2.4 链表"></a>5.2.4 链表</h4><h5 id="5-2-4-1-基础"><a href="#5-2-4-1-基础" class="headerlink" title="5.2.4.1 基础"></a>5.2.4.1 基础</h5><ol><li><p>概述</p><blockquote><p>链表是空节点，或者有一个值和一个指向下一个链表的指针，因此很多链表问题可以用递归来处理</p></blockquote></li></ol><h5 id="5-2-4-2-习题"><a href="#5-2-4-2-习题" class="headerlink" title="5.2.4.2 习题"></a>5.2.4.2 习题</h5><ol><li><p>找出两个链表的交点</p><ol><li><p>概述</p><blockquote><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a</p><p>当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B</p><p>当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A</p><p>这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点</p><p>如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span> ListNode headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode l1 <span class="token operator">=</span> headA<span class="token punctuation">,</span> l2 <span class="token operator">=</span> headB<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        l1 <span class="token operator">=</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> headB <span class="token operator">:</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        l2 <span class="token operator">=</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> headA <span class="token operator">:</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> l1<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>判断是否存在交点</p><ul><li>把第一个链表的结尾连接到第二个链表的开头，看第二个链表是否存在环</li><li>直接比较两个链表的最后一个节点是否相同</li></ul></li></ol></li><li><p>链表反转</p><ol><li><p>递归实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    ListNode newHead <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>头插法实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode newHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> newHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        newHead<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        head <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>归并两个有序的链表</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> l2<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> l1<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        l1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> l1<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        l2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> l2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>从有序链表中删除重复节点</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">?</span> head<span class="token punctuation">.</span>next <span class="token operator">:</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>删除链表的倒数第 n 个节点</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    slow<span class="token punctuation">.</span>next <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>交换链表中的相邻结点</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode pre <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode l1 <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2 <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        ListNode next <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        l1<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        l2<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>        pre <span class="token operator">=</span> l1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>链表求和</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> l1Stack <span class="token operator">=</span> <span class="token function">buildStack</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> l2Stack <span class="token operator">=</span> <span class="token function">buildStack</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>l1Stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>l2Stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> carry <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> l1Stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> l1Stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> y <span class="token operator">=</span> l2Stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> l2Stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> carry<span class="token punctuation">;</span>        ListNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>        carry <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">buildStack</span><span class="token punctuation">(</span>ListNode l<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        l <span class="token operator">=</span> l<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> stack<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>回文链表</p><ol><li><p>概述</p><blockquote><p>切成两半，把后半段反转，然后比较两半是否相等</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    ListNode slow <span class="token operator">=</span> head<span class="token punctuation">,</span> fast <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> null<span class="token punctuation">)</span> slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 偶数节点，让 slow 指向下一个节点</span>    <span class="token function">cut</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> slow<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 切成两个链表</span>    <span class="token keyword">return</span> <span class="token function">isEqual</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token function">reverse</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">cut</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> ListNode cutNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>next <span class="token operator">!=</span> cutNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> ListNode <span class="token function">reverse</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode newHead <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode nextNode <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> newHead<span class="token punctuation">;</span>        newHead <span class="token operator">=</span> head<span class="token punctuation">;</span>        head <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isEqual</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">!=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>分隔链表</p><ol><li><p>概述</p><blockquote><p>把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">splitListToParts</span><span class="token punctuation">(</span>ListNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ListNode cur <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        N<span class="token operator">++</span><span class="token punctuation">;</span>        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mod <span class="token operator">=</span> N <span class="token operator">%</span> k<span class="token punctuation">;</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> N <span class="token operator">/</span> k<span class="token punctuation">;</span>    ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    cur <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> cur <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token keyword">int</span> curSize <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token punctuation">(</span>mod<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> curSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        cur <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>链表元素按奇偶聚集</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">oddEvenList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode odd <span class="token operator">=</span> head<span class="token punctuation">,</span> even <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> evenHead <span class="token operator">=</span> even<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>even <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> even<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        odd<span class="token punctuation">.</span>next <span class="token operator">=</span> odd<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        odd <span class="token operator">=</span> odd<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        even<span class="token punctuation">.</span>next <span class="token operator">=</span> even<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        even <span class="token operator">=</span> even<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    odd<span class="token punctuation">.</span>next <span class="token operator">=</span> evenHead<span class="token punctuation">;</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="5-2-5-哈希表"><a href="#5-2-5-哈希表" class="headerlink" title="5.2.5 哈希表"></a>5.2.5 哈希表</h4><h5 id="5-2-5-1-基础"><a href="#5-2-5-1-基础" class="headerlink" title="5.2.5.1 基础"></a>5.2.5.1 基础</h5><ol><li><p>概述</p><blockquote><p>哈希表使用 O(N) 空间复杂度存储数据，并且以 O(1) 时间复杂度求解问题</p></blockquote></li><li><p>Java应用</p><ul><li>Java 中的 <strong>HashSet</strong> 用于存储一个集合，可以查找元素是否在集合中<ul><li>如果元素有穷，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在</li></ul></li><li>Java 中的 <strong>HashMap</strong> 主要用于映射关系，从而把两个元素联系起来<ul><li>HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数</li><li>HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计</li></ul></li><li>在对一个内容进行压缩或者其它转换时，利用 HashMap 可以把原始内容和转换后的内容联系起来</li></ul></li></ol><h5 id="5-2-5-2-习题"><a href="#5-2-5-2-习题" class="headerlink" title="5.2.5.2 习题"></a>5.2.5.2 习题</h5><ol><li><p>数组中两个数的和为给定值</p><ol><li><p>概述</p><blockquote><p>可以先对数组进行排序，然后使用双指针方法或者二分查找方法</p><p>这样做的时间复杂度为 O(NlogN)，空间复杂度为 O(1)</p><p>用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i]</p><p>如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数</p><p>该方法的时间复杂度为 O(N)，空间复杂度为 O(N)，使用空间来换取时间</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> indexForNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>indexForNum<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>indexForNum<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            indexForNum<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>判断数组是否含有重复元素</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsDuplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>最长和谐序列</p><ol><li><p>概述</p><blockquote><p>和谐序列中最大数和最小数之差正好为 1，应该注意的是序列的元素不一定是数组的连续元素</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findLHS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> countForNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        countForNum<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> countForNum<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> longest <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> countForNum<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>countForNum<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            longest <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>longest<span class="token punctuation">,</span> countForNum<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> countForNum<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> longest<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>最长连续序列</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> countForNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        countForNum<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">forward</span><span class="token punctuation">(</span>countForNum<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">maxCount</span><span class="token punctuation">(</span>countForNum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">forward</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> countForNum<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>countForNum<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> countForNum<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cnt <span class="token operator">=</span> <span class="token function">forward</span><span class="token punctuation">(</span>countForNum<span class="token punctuation">,</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    countForNum<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> cnt<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">maxCount</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> countForNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> countForNum<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> countForNum<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="5-2-6-数组与矩阵"><a href="#5-2-6-数组与矩阵" class="headerlink" title="5.2.6 数组与矩阵"></a>5.2.6 数组与矩阵</h4><h5 id="5-2-6-1-基础"><a href="#5-2-6-1-基础" class="headerlink" title="5.2.6.1 基础"></a>5.2.6.1 基础</h5><h5 id="5-2-6-2-习题"><a href="#5-2-6-2-习题" class="headerlink" title="5.2.6.2 习题"></a>5.2.6.2 习题</h5><ol><li><p>把数组中的 0 移到末尾</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>改变矩阵维度</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">matrixReshape</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">*</span> n <span class="token operator">!=</span> r <span class="token operator">*</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> reshapedNums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> c<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            reshapedNums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index <span class="token operator">/</span> n<span class="token punctuation">]</span><span class="token punctuation">[</span>index <span class="token operator">%</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> reshapedNums<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>找出数组中最长的连续 1</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMaxConsecutiveOnes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cur <span class="token operator">=</span> x <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> cur <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>有序矩阵查找</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">searchMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> col <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>row <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> col <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span> col<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> row<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>有序矩阵的 Kth Element</p><ol><li><p>二分实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> lo <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> hi <span class="token operator">=</span> matrix<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>lo <span class="token operator">&lt;=</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> mid<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> lo <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> hi <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> lo<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>堆实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    PriorityQueue<span class="token operator">&lt;</span>Tuple<span class="token operator">></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span>Tuple<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> pq<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Tuple</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 小根堆，去掉 k - 1 个堆顶元素，此时堆顶元素就是第 k 的数</span>        Tuple t <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>x <span class="token operator">==</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        pq<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Tuple</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>y<span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>t<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">.</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Tuple</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Tuple<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> val<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Tuple</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Tuple that<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">-</span> that<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数</p><ol><li><p>概述</p><blockquote><p>先对数组进行排序，这种方法时间复杂度为 O(NlogN)</p><p>主要思想是通过交换数组元素，使得数组上的元素在正确的位置上</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findErrorNums</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>找出数组中重复的数，数组值在 [1, n] 之间</p><ol><li><p>二分实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> h <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>h <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> mid<span class="token punctuation">)</span> h <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token keyword">else</span> l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>双指针实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> slow <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> fast <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>        slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">;</span>        fast <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>        slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">;</span>        fast <span class="token operator">=</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> slow<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>数组相邻差值的个数</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">constructArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    ret<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> interval <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> interval<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> ret<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> interval <span class="token operator">:</span> ret<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> interval<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>数组的度</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findShortestSubArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> numsCnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> numsLastIndex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> numsFirstIndex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        numsCnt<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> numsCnt<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        numsLastIndex<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>numsFirstIndex<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            numsFirstIndex<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> maxCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        maxCnt <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxCnt<span class="token punctuation">,</span> numsCnt<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> numsCnt<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">!=</span> maxCnt<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        ret <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> numsLastIndex<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">-</span> numsFirstIndex<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>对角元素相等的矩阵</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isToeplitzMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">check</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">check</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> expectValue<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> col<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">>=</span> matrix<span class="token punctuation">.</span>length <span class="token operator">||</span> col <span class="token operator">>=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">!=</span> expectValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">check</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> expectValue<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>嵌套数组</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">arrayNesting</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 标记该位置已经被访问</span>            j <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>分隔数组</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxChunksToSorted</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        right <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">==</span> i<span class="token punctuation">)</span> ret<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="5-2-7-树"><a href="#5-2-7-树" class="headerlink" title="5.2.7 树"></a>5.2.7 树</h4><h5 id="5-2-7-1-基础"><a href="#5-2-7-1-基础" class="headerlink" title="5.2.7.1 基础"></a>5.2.7.1 基础</h5><ol><li><p>递归</p><blockquote><p>一棵树要么是空树，要么有两个指针，每个指针指向一棵树</p><p>树是一种递归结构，很多树的问题可以使用递归来处理</p></blockquote></li><li><p>层次遍历</p><blockquote><p>使用 BFS 进行层次遍历</p><p>不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数</p><p>只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点</p></blockquote></li><li><p>前中后序遍历</p><blockquote><p>层次遍历使用 BFS 实现，利用的就是 BFS 一层一层遍历的特性；而前序、中序、后序遍历利用了 DFS 实现</p><p>前序、中序、后序遍只是在对节点访问的顺序有一点不同，其它都相同</p></blockquote><ul><li><p>前序</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">visit</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>中序</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">visit</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>后序</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">visit</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>BST</p><blockquote><p>二叉查找树（BST）：根节点大于等于左子树所有节点，小于等于右子树所有节点</p><p>二叉查找树中序遍历有序</p></blockquote></li><li><p>Trie</p><blockquote><p>Trie，又称前缀树或字典树，用于判断字符串是否存在或者是否具有某种字符串前缀</p></blockquote></li></ol><h5 id="5-2-7-2-习题"><a href="#5-2-7-2-习题" class="headerlink" title="5.2.7.2 习题"></a>5.2.7.2 习题</h5><ol><li><p>树的高度</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>平衡树</p><ol><li><p>概述</p><blockquote><p>平衡树左右子树高度差都小于等于 1</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>l <span class="token operator">-</span> r<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> result <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>两节点的最长路径</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">diameterOfBinaryTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">depth</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> leftDepth <span class="token operator">=</span> <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rightDepth <span class="token operator">=</span> <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> leftDepth <span class="token operator">+</span> rightDepth<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftDepth<span class="token punctuation">,</span> rightDepth<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>翻转树</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    TreeNode left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 后面的操作会改变 left 指针，因此先保存下来</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>归并两棵树</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> TreeNode <span class="token function">mergeTrees</span><span class="token punctuation">(</span>TreeNode t1<span class="token punctuation">,</span> TreeNode t2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> t2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> t2<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> t1<span class="token punctuation">;</span>    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>val <span class="token operator">+</span> t2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>判断路径和是否等于一个数</p><ol><li><p>概述</p><blockquote><p>路径和定义为从 root 到 leaf 的所有节点的和</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> sum<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>统计路径和等于一个数的路径数量</p><ol><li><p>概述</p><blockquote><p>路径不一定以 root 开头，也不一定以 leaf 结尾，但是必须连续</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">pathSumStartWithRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> sum<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">pathSumStartWithRoot</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">==</span> sum<span class="token punctuation">)</span> ret<span class="token operator">++</span><span class="token punctuation">;</span>    ret <span class="token operator">+=</span> <span class="token function">pathSumStartWithRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pathSumStartWithRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>子树</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span>TreeNode s<span class="token punctuation">,</span> TreeNode t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">isSubtreeWithRoot</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isSubtreeWithRoot</span><span class="token punctuation">(</span>TreeNode s<span class="token punctuation">,</span> TreeNode t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> s <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null <span class="token operator">||</span> s <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>val <span class="token operator">!=</span> s<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">isSubtreeWithRoot</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isSubtreeWithRoot</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>树的对称</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode t1<span class="token punctuation">,</span> TreeNode t2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> t2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> null <span class="token operator">||</span> t2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>val <span class="token operator">!=</span> t2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>最小路径</p><ol><li><p>概述</p><blockquote><p>树的根节点到叶子节点的最小路径长度</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> right <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left <span class="token operator">+</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>统计左叶子节点的和</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLeaf</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isLeaf</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>相同节点值的最大路径长度</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> path <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestUnivaluePath</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> path<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> leftPath <span class="token operator">=</span> root<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">==</span> root<span class="token punctuation">.</span>val <span class="token operator">?</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rightPath <span class="token operator">=</span> root<span class="token punctuation">.</span>right <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val <span class="token operator">==</span> root<span class="token punctuation">.</span>val <span class="token operator">?</span> right <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    path <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> leftPath <span class="token operator">+</span> rightPath<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftPath<span class="token punctuation">,</span> rightPath<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>间隔遍历</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>TreeNode<span class="token punctuation">,</span> Integer<span class="token operator">></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> val1 <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> val1 <span class="token operator">+=</span> <span class="token function">rob</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">rob</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> val1 <span class="token operator">+=</span> <span class="token function">rob</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">rob</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> val2 <span class="token operator">=</span> <span class="token function">rob</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">rob</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>找出二叉树中第二小的节点</p><ol><li><p>概述</p><blockquote><p>一个节点要么具有 0 个或 2 个子节点，如果有子节点，那么根节点是最小的节点</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findSecondMinimumValue</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> leftVal <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token keyword">int</span> rightVal <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftVal <span class="token operator">==</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> leftVal <span class="token operator">=</span> <span class="token function">findSecondMinimumValue</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rightVal <span class="token operator">==</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> rightVal <span class="token operator">=</span> <span class="token function">findSecondMinimumValue</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftVal <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> rightVal <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>leftVal<span class="token punctuation">,</span> rightVal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftVal <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> leftVal<span class="token punctuation">;</span>    <span class="token keyword">return</span> rightVal<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>一棵树每层节点的平均数</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Double<span class="token operator">></span> <span class="token function">averageOfLevels</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Double<span class="token operator">></span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sum <span class="token operator">+=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ret<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sum <span class="token operator">/</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>得到左下角的节点</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findBottomLeftValue</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        root <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>非递归实现二叉树的前序遍历</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        ret<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 先右后左，保证左子树先遍历</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>非递归实现二叉树的后序遍历</p><ol><li><p>概述</p><blockquote><p>前序遍历为 root -&gt; left -&gt; right，后序遍历为 left -&gt; right -&gt; root。可以修改前序遍历成为 root -&gt; right -&gt; left，那么这个顺序就和后序遍历正好相反</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        ret<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>非递归实现二叉树的中序遍历</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    TreeNode cur <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        TreeNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        cur <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>修剪二叉查找树</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> TreeNode <span class="token function">trimBST</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> R<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> L<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>寻找二叉查找树的第 k 个元素</p><ol><li><p>中序遍历实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    cnt<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>递归实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> leftCnt <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftCnt <span class="token operator">==</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftCnt <span class="token operator">></span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> k <span class="token operator">-</span> leftCnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">count</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">count</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>把二叉查找树每个节点的值都加上比它大的节点的值</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 先遍历右子树</span><span class="token keyword">private</span> <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span> TreeNode <span class="token function">convertBST</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">traver</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">traver</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">traver</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    sum <span class="token operator">+=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>val <span class="token operator">=</span> sum<span class="token punctuation">;</span>    <span class="token function">traver</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>二叉查找树的最近公共祖先</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> TreeNode <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> TreeNode p<span class="token punctuation">,</span> TreeNode q<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>二叉树的最近公共祖先</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> TreeNode <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> TreeNode p<span class="token punctuation">,</span> TreeNode q<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null <span class="token operator">||</span> root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>    TreeNode left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    TreeNode right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> left <span class="token operator">==</span> null <span class="token operator">?</span> right <span class="token operator">:</span> right <span class="token operator">==</span> null <span class="token operator">?</span> left <span class="token operator">:</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>从有序数组中构造二叉查找树</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> TreeNode <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">toBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> TreeNode <span class="token function">toBST</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> sIdx<span class="token punctuation">,</span> <span class="token keyword">int</span> eIdx<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sIdx <span class="token operator">></span> eIdx<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> mIdx <span class="token operator">=</span> <span class="token punctuation">(</span>sIdx <span class="token operator">+</span> eIdx<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span>  <span class="token function">toBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> sIdx<span class="token punctuation">,</span> mIdx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">toBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> eIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>根据有序链表构造平衡的二叉查找树</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> TreeNode <span class="token function">sortedListToBST</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode preMid <span class="token operator">=</span> <span class="token function">preMid</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode mid <span class="token operator">=</span> preMid<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    preMid<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 断开链表</span>    TreeNode t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>mid<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">sortedListToBST</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">sortedListToBST</span><span class="token punctuation">(</span>mid<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> ListNode <span class="token function">preMid</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode slow <span class="token operator">=</span> head<span class="token punctuation">,</span> fast <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    ListNode pre <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        pre <span class="token operator">=</span> slow<span class="token punctuation">;</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> pre<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>在二叉查找树中寻找两个节点，使它们的和为一个给定值</p><ol><li><p>概述</p><blockquote><p>使用中序遍历得到有序数组之后，再利用双指针对数组进行查找</p><p>这一题不能用分别在左右子树两部分来处理这种思想，因为两个待求的节点可能分别在左右子树中</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">findTarget</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> nums<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> j<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    nums<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>在二叉查找树中查找两个节点之差的最小绝对值</p><ol><li><p>概述</p><blockquote><p>利用二叉查找树的中序遍历为有序的性质，计算中序遍历中临近的两个节点之差的绝对值，取最小值</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> minDiff <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span><span class="token keyword">private</span> TreeNode preNode <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMinimumDifference</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> minDiff<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>preNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> minDiff <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minDiff<span class="token punctuation">,</span> node<span class="token punctuation">.</span>val <span class="token operator">-</span> preNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    preNode <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>寻找二叉查找树中出现次数最多的值</p><ol><li><p>概述</p><blockquote><p>答案可能不止一个，也就是有多个值出现的次数一样多</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> curCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> maxCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">private</span> TreeNode preNode <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findMode</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> maxCntNums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> maxCntNums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>maxCntNums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> maxCntNums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>preNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>preNode<span class="token punctuation">.</span>val <span class="token operator">==</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span> curCnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> curCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curCnt <span class="token operator">></span> maxCnt<span class="token punctuation">)</span> <span class="token punctuation">{</span>        maxCnt <span class="token operator">=</span> curCnt<span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>curCnt <span class="token operator">==</span> maxCnt<span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    preNode <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>实现一个 Trie</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        Node<span class="token punctuation">[</span><span class="token punctuation">]</span> childs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> isLeaf<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Node root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">insert</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>String word<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>isLeaf <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">indexForChar</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>childs<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>childs<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">insert</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>childs<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span>String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span>String word<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> node<span class="token punctuation">.</span>isLeaf<span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">indexForChar</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>childs<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">startsWith</span><span class="token punctuation">(</span>String prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">startWith</span><span class="token punctuation">(</span>prefix<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">startWith</span><span class="token punctuation">(</span>String prefix<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">indexForChar</span><span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">startWith</span><span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>childs<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">indexForChar</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>实现一个 Trie，用来求前缀和</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MapSum</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        Node<span class="token punctuation">[</span><span class="token punctuation">]</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Node root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MapSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>value <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">indexForChar</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>child<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>child<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>child<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span>String prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sum</span><span class="token punctuation">(</span>prefix<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span>String prefix<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">indexForChar</span><span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">sum</span><span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>child<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node child <span class="token operator">:</span> node<span class="token punctuation">.</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+=</span> <span class="token function">sum</span><span class="token punctuation">(</span>prefix<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">indexForChar</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol><h4 id="5-2-8-图"><a href="#5-2-8-图" class="headerlink" title="5.2.8 图"></a>5.2.8 图</h4><h5 id="5-2-8-1-基础"><a href="#5-2-8-1-基础" class="headerlink" title="5.2.8.1 基础"></a>5.2.8.1 基础</h5><ol><li><p>二分图</p><blockquote><p>如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么这个图就是二分图</p></blockquote></li><li><p>拓扑排序</p><blockquote><p>常用于在具有先序关系的任务规划中</p></blockquote></li><li><p>并查集</p><blockquote><p>并查集可以动态地连通两个点，并且可以非常快速地判断两个点是否连通</p></blockquote></li></ol><h5 id="5-2-8-2-习题"><a href="#5-2-8-2-习题" class="headerlink" title="5.2.8.2 习题"></a>5.2.8.2 习题</h5><ol><li><p>判断是否为二分图</p><ol><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBipartite</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> colors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>graph<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>colors<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> graph<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 处理图不是连通的情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>colors<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isBipartite</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> colors<span class="token punctuation">,</span> graph<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isBipartite</span><span class="token punctuation">(</span><span class="token keyword">int</span> curNode<span class="token punctuation">,</span> <span class="token keyword">int</span> curColor<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> colors<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>colors<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> colors<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span> <span class="token operator">==</span> curColor<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    colors<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span> <span class="token operator">=</span> curColor<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> nextNode <span class="token operator">:</span> graph<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isBipartite</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">-</span> curColor<span class="token punctuation">,</span> colors<span class="token punctuation">,</span> graph<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>课程安排的合法性</p><ol><li><p>概述</p><blockquote><p>一个课程可能会先修课程，判断给定的先修课程规定是否合法</p><p>本题不需要使用拓扑排序，只需要检测有向图是否存在环即可</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canFinish</span><span class="token punctuation">(</span><span class="token keyword">int</span> numCourses<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graphic <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        graphic<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre <span class="token operator">:</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>        graphic<span class="token punctuation">[</span>pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> globalMarked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> localMarked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasCycle</span><span class="token punctuation">(</span>globalMarked<span class="token punctuation">,</span> localMarked<span class="token punctuation">,</span> graphic<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> globalMarked<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> localMarked<span class="token punctuation">,</span>                         List<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graphic<span class="token punctuation">,</span> <span class="token keyword">int</span> curNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>localMarked<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>globalMarked<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    globalMarked<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    localMarked<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> nextNode <span class="token operator">:</span> graphic<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasCycle</span><span class="token punctuation">(</span>globalMarked<span class="token punctuation">,</span> localMarked<span class="token punctuation">,</span> graphic<span class="token punctuation">,</span> nextNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    localMarked<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>课程安排的顺序</p><ol><li><p>概述</p><blockquote><p>使用 DFS 来实现拓扑排序，使用一个栈存储后序遍历结果，这个栈的逆序结果就是拓扑排序结果</p><p>证明：对于任何先序关系：v-&gt;w，后序遍历结果可以保证 w 先进入栈中，因此栈的逆序结果中 v 会在 w 之前</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span> numCourses<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graphic <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        graphic<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre <span class="token operator">:</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>        graphic<span class="token punctuation">[</span>pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> postOrder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> globalMarked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> localMarked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasCycle</span><span class="token punctuation">(</span>globalMarked<span class="token punctuation">,</span> localMarked<span class="token punctuation">,</span> graphic<span class="token punctuation">,</span> i<span class="token punctuation">,</span> postOrder<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> orders <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> numCourses <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        orders<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> postOrder<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> orders<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> globalMarked<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> localMarked<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graphic<span class="token punctuation">,</span>                         <span class="token keyword">int</span> curNode<span class="token punctuation">,</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> postOrder<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>localMarked<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>globalMarked<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    globalMarked<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    localMarked<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> nextNode <span class="token operator">:</span> graphic<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasCycle</span><span class="token punctuation">(</span>globalMarked<span class="token punctuation">,</span> localMarked<span class="token punctuation">,</span> graphic<span class="token punctuation">,</span> nextNode<span class="token punctuation">,</span> postOrder<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    localMarked<span class="token punctuation">[</span>curNode<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    postOrder<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curNode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>冗余连接</p><ol><li><p>概述</p><blockquote><p>有一系列的边连成的图，找出一条边，移除它之后该图能够成为一棵树</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findRedundantConnection</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> edges<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    UF uf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UF</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> e <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v <span class="token operator">=</span> e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uf<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        uf<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">UF</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> id<span class="token punctuation">;</span>    <span class="token function">UF</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> id<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            id<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> uID <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> vID <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uID <span class="token operator">==</span> vID<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> id<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>id<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> uID<span class="token punctuation">)</span> <span class="token punctuation">{</span>                id<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> vID<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.DataStructureAndAlgorithm</title>
      <link href="2020/12/20/5-datastructureandalgorithm/"/>
      <url>2020/12/20/5-datastructureandalgorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><div style="display:none;">1. 方式   1. 三分理解，七分练习   2. 思考本质，大道至简(太极)   3. 刻意练习，坚持不懈2. 评价   1. 找重复，简算法   2. 优秀的算法介于10-20-30行左右3. 明确核心竞争力—刻意练习后形成的条件反射能力   1. 阶段性总结   2. 注重内功(算法)心法(设计模式)   3. 明确短板(算法，数据结构，设计模式，英语)4. 工作目标(核心竞争力)   1. 业务能力(逐日积累)   2. 技术能力(借外力更快)   3. 管理能力5. 做事和工作   1. 一定要==多问自己为什么==6. 领域学习   1. 将知识分块学习精确控制   2. 知识点辅以练习   3. 定期反馈知识点掌握程度   4. 循环已掌握和未掌握知识点练习和学习新知并行   5. 做到每次复习越来越多，学习越来越少   6. 任务量控制在可执行范围   7. 练习次数和薄弱项7. 反馈   1. 主动反馈      1. 高手代码-github，leetcode，etc      2. 第一视角直播   2. 被动式反馈      1. code review      2. 高手点评8. 系统化思考题目   1. 正确的理解题意   2. 想所有可能的解法择最优   3. 编写代码   4. 列举测试样例9. 刷题   1. 一刷      1. 10-15分不能解直接看答案      2. 背诵，默写好的解法   2. 二刷      1. 立刻自己写      2. 找到最优解，领先80%-90%   3. 三刷      1. 第二天重复做之前的题目      2. 明确不同解法的熟练度      3. 对于不熟悉的解法进行刻意练习   4. 四刷      1. 一周之后在进行重复练习      2. 对于不熟悉的解法进行刻意练习   5. 面试前再次刷题(五刷)10. 职业练习    1. 拆分知识点，刻意练习，反馈11. 解题    1. 和面试官交流充分理解题意    2. 思考解法，选择一种最优的解法    3. 开始编码    4. 测试代码</div><h3 id="1-2-时间复杂度"><a href="#1-2-时间复杂度" class="headerlink" title="1.2 时间复杂度"></a>1.2 时间复杂度</h3><ol><li><p>算法分类</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/01.%E7%AE%97%E6%B3%95.png" alt="算法"></p></li><li><p>数据结构</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="数据结构"></p></li><li><p>环境设置与准备</p><ol><li><p>win：<code>https://github.com/microsoft/terminal</code></p></li><li><p>vscode搭建</p></li><li><p>做题以中文站为主：<code>https://leetcode-cn.com/</code></p></li><li><p>学习进步以外站为主：<code>https://leetcode.com/</code>-most votes</p></li><li><p>注意编码规范</p></li><li><p>操作</p><ol><li><code>home</code>，<code>end</code></li><li>选单词，选整行</li></ol></li><li><p>自顶向下的编程方式</p><blockquote><p>先高层次(主干)逻辑为主；其次辅以附加(次要)逻辑</p></blockquote></li></ol></li><li><p>时空复杂度</p><ol><li><p>时间复杂度</p><ol><li><p>常见的时间复杂度</p><table><thead><tr><th>时间复杂度</th><th>类型</th></tr></thead><tbody><tr><td><code>O(1)</code></td><td>常数阶</td></tr><tr><td><code>O(log n)</code></td><td>对数阶</td></tr><tr><td><code>O(n)</code></td><td>线性阶</td></tr><tr><td><code>O(n^2)</code></td><td>平方阶</td></tr><tr><td><code>O(n^3)</code></td><td>立方阶</td></tr><tr><td><code>O(2^n)</code></td><td>指数阶</td></tr><tr><td><code>O(n!)</code></td><td>阶乘</td></tr></tbody></table></li><li><p>只看最高(最坏的情况)时间复杂度，不考虑常数系数(图像伸缩变化，不影响斜率)的影响</p></li><li><p>图形表示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/03.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="时间复杂度"></p></li><li><p>非线性时间复杂度</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/04.%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="非线性时间复杂度"></p></li><li><p>二叉树的三种遍历方式的时间复杂度都是<code>O(n)</code>；每个节点有且仅访问一次，所以时间复杂度线性于二叉树的节点总数；n是二叉树的节点总数</p></li><li><p>图的遍历时间复杂度也是<code>O(n)</code>；因为每个节点有且仅访问一次；n是图的节点总数</p></li><li><p><code>DFS</code>(深度优先)和<code>BFS</code>(广度优先)的时间复杂度；同样的每个节点仅访问一次，所以时间复杂度是<code>O(n)</code></p></li><li><p>二分查找的时间复杂度是<code>log n</code></p></li></ol></li><li><p>空间复杂度</p></li></ol></li></ol><h2 id="2-线性结构"><a href="#2-线性结构" class="headerlink" title="2. 线性结构"></a>2. 线性结构</h2><h3 id="2-1-数组和链表"><a href="#2-1-数组和链表" class="headerlink" title="2.1 数组和链表"></a>2.1 数组和链表</h3><ol><li><p>高级数据语言</p><ol><li>对于数组的元素不做类型限制，称之为泛型</li></ol></li><li><p>内存管理器</p><blockquote><p>为创建的数组元素分配对应的地址值</p></blockquote></li><li><p>数组</p><blockquote><p>元素依靠索引相互关联</p></blockquote><ol><li>查询快<code>O(1)</code></li><li>增删慢<code>O(n)</code></li></ol></li><li><p>单链表</p><blockquote><p>仅有一个前驱指针指向下一个元素</p></blockquote></li><li><p>循环链表</p><blockquote><p>将单链表的最后一个指针指向头结点</p></blockquote></li><li><p>双向链表(Java中的链表)</p><blockquote><p>每一个元素都有前驱指针和后驱指针来指向相邻元素</p></blockquote><ol><li>查询慢<code>O(n)</code></li><li>增删快<code>O(1)</code></li><li>应用于LRU Cache(最近最少使用)</li></ol></li><li><p>小结数组链表的时间复杂度</p><table><thead><tr><th>类型</th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>前追加</td><td><code>O(n)</code>–&gt;<code>O(1)</code></td><td><code>O(1)</code></td></tr><tr><td>后追加</td><td><code>O(1)</code></td><td><code>O(1)</code></td></tr><tr><td>随机访问</td><td><code>O(1)</code></td><td><code>O(n)</code></td></tr><tr><td>添加</td><td><code>O(n)</code></td><td><code>O(1)</code></td></tr><tr><td>删除</td><td><code>O(n)</code></td><td><code>O(1)</code></td></tr></tbody></table></li></ol><h3 id="2-2-跳表-skip-list"><a href="#2-2-跳表-skip-list" class="headerlink" title="2.2 跳表(skip list)"></a>2.2 跳表(skip list)</h3><ol><li><p>主要应用于redis</p></li><li><p>链表到跳表的改进</p><blockquote><p>主要思想就是进行维度升级(即就是空间换时间)</p></blockquote><ol><li>方式：增加多级索引<ol><li>增加索引的级数：log 2n；n为链表长度 </li></ol></li></ol></li><li><p>时间复杂度</p><ol><li><code>log n</code>（增删查一致）</li></ol></li><li><p>空间复杂度</p><ol><li>O(n)</li></ol></li></ol><h3 id="2-3-数组，链表和跳表应用"><a href="#2-3-数组，链表和跳表应用" class="headerlink" title="2.3 数组，链表和跳表应用"></a>2.3 数组，链表和跳表应用</h3><ol><li><p>数组(移动零)</p><p>题述：给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre><p>说明：</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 1. 移除零元素</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非零元素的索引</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums<span class="token punctuation">[</span>count<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 2. 添加零元素</span><span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    nums<span class="token punctuation">[</span>count<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>数组(装水最多的容器)</p><p>题述：给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</code></pre><p>提示：</p><pre class=" language-text"><code class="language-text">n = height.length2 <= n <= 3 * 1040 <= height[i] <= 3 * 104</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 枚举：left bar l &amp; right bar r ：(r-l)*height_diff(这里的diff是差分)，时间复杂度是O(n^2)</span><span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化最大面积值</span><span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化当前面积值</span><span class="token comment" spellcheck="true">// 外层循环遍历左边界，内循环遍历右边界</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 选取左右边界的最小高作为当前矩形高，并计算左右边界差作为当前矩形长</span>        <span class="token comment" spellcheck="true">// 由此计算当前矩形面积</span>        area <span class="token operator">=</span> <span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">*</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 始终将最大的面积值存放在max变量</span>        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span>area<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 返回最大面积</span><span class="token keyword">return</span> max<span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Description // 双向交叉计算矩形面积取最大值 **/</span><span class="token comment" spellcheck="true">// 初始最大面积值</span><span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化右边界</span><span class="token keyword">int</span> right <span class="token operator">=</span> height<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化左边界</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化当前面积</span><span class="token keyword">int</span> area<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">!=</span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果右边界的高度值大于左边界</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 则当前面积为左边界的高*左右边界之差</span>        area <span class="token operator">=</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 左边界向前走</span>        left <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 否则当前面积为右边界的高*左右边界之差</span>        area <span class="token operator">=</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 右边界向后走(以数组索引递增为正方向)</span>        right <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回最大值的面积值</span>    max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> area<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 返回最大面积</span><span class="token keyword">return</span> max<span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用三元运算符简化最优解</span><span class="token comment" spellcheck="true">// 初始最大面积值</span><span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化右边界</span><span class="token keyword">int</span> right <span class="token operator">=</span> height<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化左边界</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化当前面积</span><span class="token keyword">int</span> area<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">!=</span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计算最小高度，注意这里返回的是left+1和right-1处的高度值</span>    <span class="token keyword">int</span> minHeight <span class="token operator">=</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">?</span> height<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> height<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里+1是补加left和left+1间的矩形面积，同样也是补加right和right-1之间的面积值(谁小补谁)</span>    area <span class="token operator">=</span> minHeight <span class="token operator">*</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> area<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 返回最大面积</span><span class="token keyword">return</span> max<span class="token punctuation">;</span></code></pre></li><li><p>数组(爬楼梯)-70题</p><p>题述：假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1.  1 阶 + 1 阶2.  2 阶</code></pre><pre class=" language-text"><code class="language-text">输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1.  1 阶 + 1 阶 + 1 阶2.  1 阶 + 2 阶3.  2 阶 + 1 阶</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 没思路，先考虑简单情况 --> 泛化(数学归纳法)找到递推公式(找重复)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 1个台阶的方法数</span><span class="token keyword">int</span> one_step_before <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 2个台阶的方法数</span><span class="token keyword">int</span> two_steps_before <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当前台阶总方法数</span><span class="token keyword">int</span> all_ways <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 更新方法数</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    all_ways <span class="token operator">=</span> one_step_before <span class="token operator">+</span> two_steps_before<span class="token punctuation">;</span>    one_step_before <span class="token operator">=</span> two_steps_before<span class="token punctuation">;</span>    two_steps_before <span class="token operator">=</span> all_ways<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 返回指定数字的方法数</span><span class="token keyword">return</span> all_ways<span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        a <span class="token operator">=</span> <span class="token punctuation">(</span>b <span class="token operator">+=</span> a<span class="token punctuation">)</span> <span class="token operator">-</span> a<span class="token punctuation">;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>数组(三数之和)—高频老题</p><p>题述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意</strong>：答案中不可以包含重复的三元组。</p><p>示例：</p><pre class=" language-text"><code class="language-text">给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[  [-1, 0, 1],  [-1, -1, 2]]</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 暴力解法，依次枚举三个数求和，和为0则添加至结果集，有重复则跳出本次循环</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">threeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> sum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历寻找第1个数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 遍历寻找第2个数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 遍历寻找第3个数</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果三个数的和相加等于0；则将三数添加至sum数组</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 如果结果集已有该和为零的序列，则结束本次循环；继续下一次</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>sum<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 为结果集合添加符合要求的数组</span>                    sum<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回最终的结果集</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 双指针解法</span><span class="token comment" spellcheck="true">// 对原始数组进行排序</span>Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化结果集</span>List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 枚举所有的变量</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果当前变量是第一个元素或者相邻两数和不为0，则开始双端遍历</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 左端遍历起点</span>        <span class="token keyword">int</span> lo <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 右端遍历起点</span>        <span class="token keyword">int</span> hi <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化目标值</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果左端序列比右端序列小则一直进行查找</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>lo <span class="token operator">&lt;</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果在左右端找出和为sum的值即将目标值，左端值，右端值添加到结果集合</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">==</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 将符合条件的目标值，左端值和右端值添加至结果集</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>hi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果左端序列小于右端序列；且；左端值等于左端序列之前的值就跳过该序列</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>lo <span class="token operator">&lt;</span> hi <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>lo <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    lo<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 如果左端序列小于右端序列；且；右端值等于右端序列之后的值就跳过该序列</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>lo <span class="token operator">&lt;</span> hi <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>hi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    hi<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 左端序列递增</span>                lo<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 右端序列递减</span>                hi<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">&lt;</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 如果三数和小于0，则继续向前找左端值</span>                lo<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 如果三数和大于0，则继续向后找右端值</span>                hi<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 返回最终的结果集</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span></code></pre></li><li><p>链表</p><ol><li>暴力解法</li><li>快慢指针</li></ol></li><li><p>链表(反转链表)</p><p>题述：反转一个单链表</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: 1->2->3->4->5->NULL输出: 5->4->3->2->1->NULL</code></pre><p>附加：你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化前驱节点</span>    ListNode prevHead <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果头结点不为null</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 记录头结点的指针</span>        ListNode recordNext <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将头结点的指针指向前驱节点</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> prevHead<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将头结点和前驱节点值交换</span>        prevHead <span class="token operator">=</span> head<span class="token punctuation">;</span>        head <span class="token operator">=</span> recordNext<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回最新链表</span>    <span class="token keyword">return</span> prevHead<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法一</span><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">reverseListInt</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> ListNode <span class="token function">reverseListInt</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> ListNode newHead<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果头结点的指针指向null说明链表翻转完成，则返回反转后的链表</span>        <span class="token keyword">return</span> newHead<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 交换头结点和前驱节点的值</span>    ListNode next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> newHead<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将交换后的指针和头结点再次进行交换；直到头结点的指针指向null后返回最新链表</span>    <span class="token keyword">return</span> <span class="token function">reverseListInt</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法二</span><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果头结点的指针指向null说明链表翻转完成，则返回反转后的链表</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 交换头结点和递归交换前驱节点的值</span>    ListNode nextNode <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    ListNode newHead <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将前驱节点的指针指向头结点</span>    nextNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将头结点的指针指向null</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回最新的链表</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>链表(两两交换链表中的节点)</p><p>题述：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/05.%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9.jpg" alt="交换链表节点"></p><pre class=" language-text"><code class="language-text">输入：head = [1,2,3,4]输出：[2,1,4,3]输入：head = []输出：[]输入：head = [1]输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span><span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 记录头结点指针的位置</span>    ListNode prevHead <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 递归将头节点的指针指向头结点指针的指针</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将前驱元素的指针指向头结点</span>    prevHead<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回最新链表</span>    <span class="token keyword">return</span> prevHead<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">algorithm</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将链表的指针指向头结点</span>    dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 记录当前链表</span>    ListNode current <span class="token operator">=</span> dummy<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果当前链表的指针不为null且者前驱元素的指针不为null</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 记录头结点的指针</span>        ListNode first <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 记录头结点前驱元素的指针</span>        ListNode second <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将头结点前驱元素的指针指向头结点前驱的前驱的指针</span>        first<span class="token punctuation">.</span>next <span class="token operator">=</span> second<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将头结点的指针指向头结点前驱元素的指针</span>        current<span class="token punctuation">.</span>next <span class="token operator">=</span> second<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将头结点前去元素的指针指向头结点的指针</span>        current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将当前链表指向头结点前去元素的指针</span>        current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回头结点前驱元素的指针</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>链表(环形链表)</p><p>题述：给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>附加：</p><p>你能用 *O(1)*（即，常量）内存解决此问题吗？</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/06.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A81.png" alt="环形链表1"></p><pre class=" language-text"><code class="language-text">输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/07.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82.png" alt="环形链表2"></p><pre class=" language-text"><code class="language-text">输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/08.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A83.png" alt="环形链表3"></p><pre class=" language-text"><code class="language-text">输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><p>题解：</p><ol><li>使用两个指针，一个快指针，一个慢指针</li><li>慢指针一次走一步，快指针一次走两步</li><li>当快慢指针指向同一个元素说明有环存在，否则无环存在</li></ol><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 快慢指针解法</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化慢指针</span>    ListNode walker <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化快指针</span>    ListNode runner <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果快指针不指向null且快指针的前驱指针不为null</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>runner<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> runner<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将慢指针指向他的前驱指针</span>        walker <span class="token operator">=</span> walker<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将快指针指向他的前驱指针</span>        runner <span class="token operator">=</span> runner<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果快慢指针指向同一个元素说明有环存在</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>walker <span class="token operator">==</span> runner<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 快慢指针指向不是同一个元素</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre></li><li><p>链表(环形链表 II)</p><p>题述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以使用 O(1) 空间解决此题？</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/06.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A81.png" alt="环形链表1"></p><pre class=" language-text"><code class="language-text">输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/07.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82.png" alt="环形链表2"></p><pre class=" language-text"><code class="language-text">输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/08.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A83.png" alt="环形链表3"></p><pre class=" language-text"><code class="language-text">输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化慢指针</span>    ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化快指针</span>    ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果快指针不指向null且快指针的前驱指针不为null</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将慢指针指向其前驱的指针</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将快指针指向前驱的前驱</span>        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果快慢指针相遇，则说明链表有环</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果慢指针没有指向头结点</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 就一直往前走</span>                slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 将头结点指向自身</span>                head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 返回头结点</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>链表(K 个一组翻转链表)</p><p>题述：给你一个链表，<strong>每 k 个节点一组进行翻转</strong>，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/12.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A81.jpg" alt="翻转链表1"></p><pre class=" language-text"><code class="language-text">输入: head = [1,2,3,4,5], k = 2输出: [2,1,4,3,5]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/13.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A82.jpg" alt="翻转链表2"></p><pre class=" language-text"><code class="language-text">输入: head = [1,2,3,4,5], k = 3输出: [3,2,1,4,5]输入: head = [1,2,3,4,5], k = 1输出: [1,2,3,4,5]输入: head = [1], k = 1输出: [1]</code></pre><p><strong>说明：</strong></p><ul><li>你的算法只能使用常数的额外空间。</li><li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li></ul><p><strong>提示</strong>：</p><ol><li>列表中节点的范围是<code>sz</code>.</li><li><code>1 &lt;= sz &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= sz</code></li></ol><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span><span class="token keyword">public</span> ListNode <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> count <span class="token operator">!=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// find the k+1 node</span>        curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// if k+1 node is found</span>        curr <span class="token operator">=</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// reverse list with k+1 node as head</span>        <span class="token comment" spellcheck="true">// head - head-pointer to direct part, </span>        <span class="token comment" spellcheck="true">// curr - head-pointer to reversed part;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// reverse current k-group:</span>            ListNode tmp <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// tmp - next head in direct part</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> curr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// preappending "direct" head to the reversed list</span>            curr <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// move head of reversed part to a new node</span>            head <span class="token operator">=</span> tmp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// move "direct" head to the next node in direct part</span>        <span class="token punctuation">}</span>        head <span class="token operator">=</span> curr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">public</span> ListNode <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ListNode i <span class="token operator">=</span> head<span class="token punctuation">;</span> i <span class="token operator">!=</span> null<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">,</span> i <span class="token operator">=</span> i<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode dmy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dmy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>ListNode prev <span class="token operator">=</span> dmy<span class="token punctuation">,</span> tail <span class="token operator">=</span> head<span class="token punctuation">;</span> n <span class="token operator">>=</span> k<span class="token punctuation">;</span> n <span class="token operator">-=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode next <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            tail<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            tail<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        prev <span class="token operator">=</span> tail<span class="token punctuation">;</span>        tail <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dmy<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 推荐解法</span><span class="token keyword">public</span> ListNode <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化开始节点</span>    ListNode begin<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果头结点的值或头结点的前驱元素不为null或者一个元素为一组反转</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">==</span>null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span>null <span class="token operator">||</span> k<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接返回当前链表</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化头结点的后驱元素</span>    ListNode dummyhead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将头结点后驱元素的指针指向头结点</span>    dummyhead<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将头结点的后驱元素赋给开始节点</span>    begin <span class="token operator">=</span> dummyhead<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化计数器</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果头节点不为null</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 计数器递增</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将计数器值对分组值取余，刚好除尽就进行反转操作</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">%</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将头结点元素和头结点的后驱元素进行位置调换</span>            begin <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将当前链表指向头结点元素</span>            head <span class="token operator">=</span> begin<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将当前链表指向头结点元素</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回开始节点的指针</span>    <span class="token keyword">return</span> dummyhead<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 反转链表</span><span class="token keyword">public</span> ListNode <span class="token function">reverse</span><span class="token punctuation">(</span>ListNode begin<span class="token punctuation">,</span> ListNode end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将开始元素的指针记录</span>    ListNode curr <span class="token operator">=</span> begin<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义两个链表</span>    ListNode next<span class="token punctuation">,</span> first<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将开始元素赋记录</span>    ListNode prev <span class="token operator">=</span> begin<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将开始元素的指针指向反转后的链表</span>    first <span class="token operator">=</span> curr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果反转链表的值和原始链表的结束值不一致，就一直进行交换操作</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token operator">!=</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将反转链表的指针指向原始链表</span>        next <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将反转链表的指针指向开始元素的值</span>        curr<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用反转链表替换原始元素</span>        prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用原始链表替换反转链表</span>        curr <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将开始元素的指针指向最终的元素</span>    begin<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将反转链表的指针指向开始元素的值</span>    first<span class="token punctuation">.</span>next <span class="token operator">=</span> curr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回最终的反转链表</span>    <span class="token keyword">return</span> first<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="2-4-练习"><a href="#2-4-练习" class="headerlink" title="2.4 练习"></a>2.4 练习</h3><ol><li><p>删除排序数组中的重复项</p><p>题述：给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例：</p><pre class=" language-text"><code class="language-text">给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><pre class=" language-text"><code class="language-text">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i < len; i++) {    print(nums[i]);}</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 简单解法</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化重复数字的计数器</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取数组的长度</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历数组拿出每一个元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果当前元素和上一个元素一致，则计数器值+1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 否则将当前元素赋给去重后的最新索引位置的值</span>            nums<span class="token punctuation">[</span>i <span class="token operator">-</span> count<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回最新的数组长度</span>    <span class="token keyword">return</span> len <span class="token operator">-</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Time O(n), Space O(1)</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取数组长度</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果长度小于2直接返回当前数组的长度</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> len<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化非重数组长度计数器</span>    <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历拿出数组中的每一个元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果当前元素和上一个元素相等就将当前元素记录在非重复数组中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>id<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回非重复元素数组的长度</span>    <span class="token keyword">return</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代器遍历最简形式</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化非重数组的长度</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历数组</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 如果当前元素和上一个元素不相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">></span> nums<span class="token punctuation">[</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 就将非重数组索引递增来存储当前元素</span>            nums<span class="token punctuation">[</span>length<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回非重数组的长度</span>    <span class="token keyword">return</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>旋转数组</p><p>题述：给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]</code></pre><p><strong>说明:</strong></p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的<strong>原地</strong>算法。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取k的索引值</span>    k <span class="token operator">%=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 执行旋转</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 旋转数组</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 记录开始位置的值</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将结束位置的值赋给开始位置</span>        nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将开始位置的值赋给结束位置</span>        nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 开始序列递增</span>        start<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 结束序列递减</span>        end<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>合并两个有序链表</p><p>题述：将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/14.%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.jpg" alt="合并有序链表"></p><pre class=" language-text"><code class="language-text">输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]输入：l1 = [], l2 = []输出：[]输入：l1 = [], l2 = [0]输出：[0]</code></pre><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span><span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果链表1为null就返回链表2,如果链表2为null就返回链表1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null <span class="token operator">||</span> l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> l2 <span class="token operator">==</span> null <span class="token operator">?</span> l1 <span class="token operator">:</span> l2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果链表1的值小于链表2的值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将链表1的指针指向链表2</span>        l1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 返回链表1</span>        <span class="token keyword">return</span> l1<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 否则将链表2的指针指向链表1</span>        l2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 返回链表2</span>        <span class="token keyword">return</span> l2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果链表1为null就返回链表2,如果链表2为null就返回链表1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> l2<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> l1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化开始节点</span>    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将开始节点存入当前链表</span>    ListNode curr <span class="token operator">=</span> dummy<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果两个链表都不为null，就对链表的值进行判断</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果链表1的值小于链表2的值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 就将当前链表的指针指向链表1</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将链表1的指针指向链表1</span>            l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 否则将当前链表的指针指向链表2</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将链表2的指针指向链表2</span>            l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将当前链表的指针指向当前链表</span>        curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果当前链表的指针指向链表1且为null就指向链表2，否则指向链表1</span>    curr<span class="token punctuation">.</span>next <span class="token operator">=</span> l1 <span class="token operator">==</span> null <span class="token operator">?</span> l2 <span class="token operator">:</span> l1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回开始元素指针指向的链表</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>合并两个有序数组—88题</p><p>题述：给你两个有序整数数组 <em>nums1</em> 和 <em>nums2</em>，请你将 <em>nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使 <em>nums1</em> 成为一个有序数组。</p><p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code> 。<br>你可以假设 <code>nums1</code> 有足够的空间（空间大小大于或等于 m + n）来保存 <code>nums2</code> 中的元素。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6],       n = 3输出：[1,2,2,3,5,6]输入：nums1 = [1],             m = 1nums2 = [],            n = 0输出：[1]</code></pre><p>提示：</p><ul><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>-109 &lt;= nums1[i], nums2[i] &lt;= 109</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// AC解法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 记录数组1的末尾元素索引</span>    <span class="token keyword">int</span> endOne <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 记录数组2的末尾元素索引</span>    <span class="token keyword">int</span> endTwo <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 记录数组1和数组2衔接处的索引</span>    <span class="token keyword">int</span> midpoint <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果两个数组的起始索引都大于零</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>endOne <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> endTwo <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果数组1的末尾元素比数组2的大</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>endOne<span class="token punctuation">]</span> <span class="token operator">></span> nums2<span class="token punctuation">[</span>endTwo<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 说明数组1的最大值是整个数组的最大值，所以将相邻之前的元素赋值给衔接处之前的位置</span>            nums1<span class="token punctuation">[</span>midpoint<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>endOne<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 否则将数组2之前的元素赋给衔接处之前的位置</span>            nums1<span class="token punctuation">[</span>midpoint<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>endTwo<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果数组2的末尾索引一直大于0</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>endTwo <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 就依次将该所引之前的元素赋给数组1</span>        nums1<span class="token punctuation">[</span>midpoint<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>endTwo<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 简单解法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> nums2<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">:</span> nums1<span class="token punctuation">[</span>i<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 最佳解法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化三个节点的索引，数组1的末尾索引，数组1和数组2衔接处索引，数组2的末尾索引</span>    <span class="token keyword">int</span> tail1 <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> tail2 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> finished <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果数组1和数组2的末端索引值一直大于等于0</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>tail1 <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tail2 <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果数组1末端值大于数组2末端值，则将数组1的末端值赋值给数组衔接处，否则将数组2的末端值赋值给衔接处，总是保证最后一个元素最大</span>        nums1<span class="token punctuation">[</span>finished<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>tail1<span class="token punctuation">]</span> <span class="token operator">></span> nums2<span class="token punctuation">[</span>tail2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span>            nums1<span class="token punctuation">[</span>tail1<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">:</span> nums2<span class="token punctuation">[</span>tail2<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 单独处理数组2，将数组2拼接到后面</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>tail2 <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//only need to combine with remaining nums2</span>        nums1<span class="token punctuation">[</span>finished<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>tail2<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>两数之和</p><p>题述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>你可以按任意顺序返回答案。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。输入：nums = [3,2,4], target = 6输出：[1,2]输入：nums = [3,3], target = 6输出：[0,1]</code></pre><p>提示：</p><ul><li><code>2 &lt;= nums.length &lt;= 103</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><p>只会存在一个有效答案</p><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 一般方法</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化索引数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用于记录数组元素和其索引的映射关系</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历数组拿出每一个元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果集合的键是目标值减去当前元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将当前元素的索引赋给索引数组的第二个位置</span>            result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 根据该键获取集合元素的值赋给索引数组的第一个位置</span>            result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 返回最新的索引数组</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 否则就将当前元素和其索引添加到集合进行映射---主要操作</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回最新的索引数组</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 集合解法// hash解法</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 用于记录数组元素和其索引的映射关系</span>    HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历数组拿出每一个元素</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果集合的键是目标值减去当前元素</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 就根据该键获取集合元素的值和当前元素的索引</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 否则将当前元素作为键其索引做为值添加到集合中</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回最新的索引数组</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>加一</p><p>题述：给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例：</p><pre class=" language-java"><code class="language-java">输入：digits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>解释：输入数组表示数字 <span class="token number">123</span>。输入：digits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>解释：输入数组表示数字 <span class="token number">4321</span>输入：digits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 分情况讨论，+1后需要进位的和+1后不需要进位的</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">plusOne</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取数组长度</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> digits<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从后往前遍历数组，看数组元素是否都等于9</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将数组中所有小于9的元素递增后并返回新数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> digits<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将数组中所有等于9的元素置为0</span>        digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果数组所有元素都等于9，表示+1后需要进行进位，长度比原来大1</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将新数组的0元素置为1</span>    newNumber<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> newNumber<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 一般解法</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">plusOne</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化要加的数字</span>    <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从后往前遍历数组，进行+1</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> digits<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将数组的末尾元素进行+1</span>        digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> carry<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果这个+1后比9小</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// early return</span>            <span class="token comment" spellcheck="true">// 直接返回当前数组</span>            <span class="token keyword">return</span> digits<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 否则将末尾元素置为0</span>        digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 创建新数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>digits<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将新数组的第一个元素置为1</span>    ret<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回最新的数组</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">plusOne</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>digits<span class="token punctuation">,</span>digits<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> digits<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>digits<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        digits<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> digits<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            digits<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>digits<span class="token punctuation">,</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>digits<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">plusOne</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> digits<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> digits<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        i<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>digits<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="2-5-栈"><a href="#2-5-栈" class="headerlink" title="2.5 栈"></a>2.5 栈</h3><ol><li><p>描述</p><blockquote><p>先进后出</p></blockquote></li><li><p>时间复杂度</p><blockquote><p>添加删除都是常数阶；查询是O(n)</p></blockquote></li><li><p>示例操作</p><pre class=" language-java"><code class="language-java">Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 3, 4]</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer topElement <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>topElement<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3的位置："</span> <span class="token operator">+</span> stack<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3的位置：-1</span></code></pre></li></ol><h3 id="2-6-队列"><a href="#2-6-队列" class="headerlink" title="2.6 队列"></a>2.6 队列</h3><ol><li><p>描述</p><blockquote><p>先进先出</p></blockquote></li><li><p>时间复杂度</p><blockquote><p>添加删除都是常数阶；查询是O(n)</p></blockquote></li><li><p>示例代码</p><pre class=" language-java"><code class="language-java">Queue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [one, two, three, four]</span>String polledElement <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>polledElement<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// one</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [two, three, four]</span>String peekedElement <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>peekedElement<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// two</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [two, three, four]</span><span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第一次循环 two</span>    <span class="token comment" spellcheck="true">// 第二次循环 three</span>    <span class="token comment" spellcheck="true">// 第三次循环 four</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2-6-1-优先队列"><a href="#2-6-1-优先队列" class="headerlink" title="2.6.1 优先队列"></a>2.6.1 优先队列</h4><ol><li><p>描述</p><blockquote><p>该数据结构存储元素有优先级别；底层具体实现的数据结构较为多样复杂，如：heap，bst，treap</p></blockquote></li><li><p>时间复杂度</p><blockquote><p>插入是常数阶，查询是Log(n)—按照元素的优先级取出</p></blockquote></li></ol><h4 id="2-6-2-双端队列"><a href="#2-6-2-双端队列" class="headerlink" title="2.6.2 双端队列"></a>2.6.2 双端队列</h4><ol><li><p>描述</p><blockquote><p>栈和队列的结合(queue和stack的结合)</p></blockquote></li><li><p>时间复杂度</p><blockquote><p>添加删除都是常数阶；查询是O(n)</p></blockquote></li><li><p>示例代码</p><pre class=" language-java"><code class="language-java">Deque<span class="token operator">&lt;</span>String<span class="token operator">></span> deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>deque<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>deque<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>deque<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [c, b, a]</span>String peek <span class="token operator">=</span> deque<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>peek<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// c</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [c, b, a]</span><span class="token keyword">while</span> <span class="token punctuation">(</span>deque<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>deque<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第一次循环 c</span>    <span class="token comment" spellcheck="true">// 第二次循环 b</span>    <span class="token comment" spellcheck="true">// 第三次循环 a</span><span class="token punctuation">}</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// []</span></code></pre></li></ol><h3 id="2-7-栈-amp-队列练习"><a href="#2-7-栈-amp-队列练习" class="headerlink" title="2.7 栈&amp;队列练习"></a>2.7 栈&amp;队列练习</h3><h4 id="2-7-1-栈"><a href="#2-7-1-栈" class="headerlink" title="2.7.1 栈"></a>2.7.1 栈</h4><ol><li><p>一个问题有最近相关性就考虑用栈来解决</p></li><li><p>栈(stack)—有效的括号1</p><p>题述：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: "()"输出: true输入: "()[]{}"输出: true输入: "(]"输出: false输入: "([)]"输出: false输入: "{[]}"输出: true</code></pre><p>题解：</p><ol><li>如果是左括号就入栈</li><li>如果是右括号就和栈顶元素进行匹配</li><li>匹配上就将栈顶元素移除栈</li><li>一直这么操作下去直到栈为空或者站内元素不匹配字符串任意字符</li></ol><p>实现：</p><pre class=" language-java"><code class="language-java">Stack<span class="token operator">&lt;</span>Character<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Character<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果字符是左括号就像栈里存入右括号</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'{'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果字符是左中括号就像栈里存入右中括号</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'['</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果字符是左大括号就像栈里存入大右括号</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果栈顶元素和字符串字符不相等就说明不匹配返回false，这里需要对栈进行非空校验</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果栈为空说明全部匹配上</span></code></pre></li><li><p>栈(最小栈)2</p><p>题述：设计一个支持<code>push</code> ，<code>pop</code> ，<code>top</code>操作，并能在常数时间内检索到最小元素的栈。</p><p><code>push(x)</code>—— 将元素 x 推入栈中。<br><code>pop()</code> —— 删除栈顶的元素。<br><code>top()</code> —— 获取栈顶元素。<br><code>getMin()</code> —— 检索栈中的最小元素。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：["MinStack","push","push","push","getMin","pop","top","getMin"][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --> 返回 -3.minStack.pop();minStack.top();      --> 返回 0.minStack.getMin();   --> 返回 -2.</code></pre><p><strong>提示：</strong></p><ul><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** initialize your data structure here. */</span><span class="token keyword">public</span> <span class="token function">MinStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 初始化最小值为0x7fffffff</span><span class="token keyword">int</span> min <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化栈</span>Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// </span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>min<span class="token punctuation">)</span><span class="token punctuation">;</span>        min <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> min<span class="token punctuation">)</span> min <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> min<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>栈(柱状图中最大的矩形)3</p><p>题述：给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/09.%E6%9D%A1%E5%BD%A2%E5%9B%BE%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.png" alt="条形图最大面积"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/10.%E6%9D%A1%E5%BD%A2%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E5%9B%BE.png" alt="条形最大面积图"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><p>示例图1：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/15.%E6%9D%A1%E5%BD%A2%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E5%9B%BE1.jpg" alt="条形最大面积图"></p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [2,1,5,6,2,3]输出: 10输入: heights = [2,4]输出: 4</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;= 105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><p>实现：</p><pre class=" language-text"><code class="language-text">// 暴力解法// 依次遍历左右边界，算出面积值，并轮换比较，求得最大值for i-->(0,n-2)    for j-->(i+1,n-1)        min(i,j),area        update max-->area// 暴力法优化for i-->i(0,n-1)    // 找到i的左右边界，即是左边最近最小的矩形，右边最近最小的矩形    area = height[i] * (rightBar - leftBar)    update max-->area// 栈解法(优化算法的核心——减少重复步骤的产生)// 维护一个有序栈，里面的元素从小到大排列/*    这个题的核心是要保持一个单调递增的stack，每次遇到比栈顶小的元素，pop掉最高的元素    此时最高的元素是局部最小的height，这里就需要利用当前i的index减去栈顶前一个元素的坐标    这样可以得到这个局部的width是多少。这样height*width就是局部最小的面积。    如果当前的i仍然大于栈顶元素，继续进行pop，这样得到下一个局部最小值    最后stack剩下的height index，就是全局下最小的index，因为比他们大的，都被pop掉了    所以直接pop stack，width就是总的len 减去他的index即可    */</code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 暴力解法二</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果bar的高度数组长度为0直接返回；健壮性判断</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>heights <span class="token operator">==</span> null <span class="token operator">||</span> heights<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 左边界bar的最小高度</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lessFromLeft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>heights<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右边界bar的最小高度</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> lessFromRight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>heights<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右边界bar的边界值</span>    lessFromRight<span class="token punctuation">[</span>heights<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左边界bar的边界值</span>    lessFromLeft<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历每一个bar</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 记录每个bar和左边界bar的距离</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当左边界bar距离大于0且该位置对应的高比当前的元素高</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> heights<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">>=</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将p记录为最高bar</span>            p <span class="token operator">=</span> lessFromLeft<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将最高bar值记录为当前元素</span>        lessFromLeft<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 再次遍历数组，寻找最小bar</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> heights<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 当前元素的之前元素索引</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&lt;</span> heights<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> heights<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">>=</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> lessFromRight<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        lessFromRight<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> maxArea <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        maxArea <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxArea<span class="token punctuation">,</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>lessFromRight<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> lessFromLeft<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> maxArea<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 单调栈解法</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> maxArea <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> len <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> h <span class="token operator">>=</span> heights<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> tp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            maxArea <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxArea<span class="token punctuation">,</span> heights<span class="token punctuation">[</span>tp<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> i <span class="token operator">:</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> s<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> maxArea<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>栈(接雨水)6</p><p>题述：给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/11.%E6%8E%A5%E9%9B%A8%E6%B0%B4.png" alt="接雨水"></p><pre class=" language-text"><code class="language-text">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 输入：height = [4,2,0,3,2,5]输出：9</code></pre><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>0 &lt;= n &lt;= 3 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 指针解法</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化数组长度</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化左端索引</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化右端索引</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化结果值</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化左右高度</span>    <span class="token keyword">int</span> maxleft <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> maxright <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果左端索引小于右端索引</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果左边高度小于右边高度</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在看左端的索引是不是比左边最大的高度大</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">>=</span> maxleft<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 是就把左边索引的高度对应值赋给左边最大的bar</span>                maxleft <span class="token operator">=</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 将左端最高bar减去左端高算出容积并返回</span>                res <span class="token operator">+=</span> maxleft <span class="token operator">-</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 左端索引递增</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在看右端的索引是不是比右边最大的高度大</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> maxright<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 是就把右边索引的高度对应值赋给右边最大的bar</span>                maxright <span class="token operator">=</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 右端最高bar减去右端高算出容积并返回</span>                res <span class="token operator">+=</span> maxright <span class="token operator">-</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 右端索引递增</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回最终的容积数</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2-7-2-队列"><a href="#2-7-2-队列" class="headerlink" title="2.7.2 队列"></a>2.7.2 队列</h4><ol><li><p>讲究先来后到的顺序(公平性)</p></li><li><p>队列(滑动窗口最大值)4</p><p>题述：给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7输入：nums = [1], k = 1输出：[1]输入：nums = [1,-1], k = 1输出：[1,-1]输入：nums = [9,11], k = 2输出：[11]输入：nums = [4,-2], k = 2输出：[4]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 暴力解法O(n*k)</span><span class="token comment" spellcheck="true">// 确定窗口的起点位置和终点位置；从起点位置一直找k个元素求出最大值输出(解不出来，超出时间限制)</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 优化的暴力解法</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> max_left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> max_right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    max_left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    max_right<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        max_left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max_left<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        max_right<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">%</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max_right<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sliding_max <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">+</span> k <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sliding_max<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max_right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> max_left<span class="token punctuation">[</span>i <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sliding_max<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 单调解法(队列)</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ri <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// store index</span>    Deque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// remove numbers out of range k</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// remove smaller numbers in k range as they are useless</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            q<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// q contains index... r contains content</span>        q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            r<span class="token punctuation">[</span>ri<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>队列(设计循环双端队列)5</p><p>题述：设计实现双端队列。<br>你的实现需要支持以下操作：</p><p>MyCircularDeque(k)：构造函数,双端队列的大小为k。<br>insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。<br>insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。<br>deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。<br>deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。<br>getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。<br>getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。<br>isEmpty()：检查双端队列是否为空。<br>isFull()：检查双端队列是否满了。</p><p>示例：</p><pre class=" language-text"><code class="language-text">MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3circularDeque.insertLast(1);                    // 返回 truecircularDeque.insertLast(2);                    // 返回 truecircularDeque.insertFront(3);                    // 返回 truecircularDeque.insertFront(4);                    // 已经满了，返回 falsecircularDeque.getRear();                  // 返回 2circularDeque.isFull();                        // 返回 truecircularDeque.deleteLast();                    // 返回 truecircularDeque.insertFront(4);                    // 返回 truecircularDeque.getFront();                // 返回 4</code></pre><p><strong>提示：</strong></p><ul><li>所有值的范围为 [1, 1000]</li><li>操作次数的范围为 [1, 1000]</li><li>请不要使用内置的双端队列库。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyCircularDeque</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> q<span class="token punctuation">;</span>    <span class="token keyword">int</span> head<span class="token punctuation">,</span> tail<span class="token punctuation">,</span> size<span class="token punctuation">,</span> count<span class="token punctuation">,</span> cap<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Initialize your data structure here. Set the size of the deque to be k. */</span>    <span class="token keyword">public</span> <span class="token function">MyCircularDeque</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cap <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">insertFront</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>q<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">insertLast</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>q<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">deleteFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">deleteLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Get the front item from the deque. */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>q<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Get the last item from the deque. */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getRear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>q<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Checks whether the circular deque is empty or not. */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Checks whether the circular deque is full or not. */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cap<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="2-8-哈希表-amp-映射-amp-集合"><a href="#2-8-哈希表-amp-映射-amp-集合" class="headerlink" title="2.8 哈希表&amp;映射&amp;集合"></a>2.8 哈希表&amp;映射&amp;集合</h3><ol><li><p>应用</p><ol><li>map<ol><li>使用hash码实现</li><li>部分使用二叉树实现</li></ol></li><li>set<ol><li>使用hash码实现</li><li>部分使用二叉树实现</li></ol></li></ol></li><li><p>概述</p><ol><li><p>描述</p><blockquote><p>哈希表(hash table) ，也称为散列表，是根据关键码值(key value)而直接进行访问的数据结构</p></blockquote></li><li><p>特点</p><ol><li>通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度</li><li>这种映射关系称为散列函数(hash function)，存放记录的数组称为hash表(或散列表)</li></ol></li><li><p>应用</p><ol><li>用户信息表</li><li>缓存(LRU Cache)</li><li>键值对存储(Redis)</li></ol></li><li><p>hash table原理图</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/16.hash%E8%A1%A8%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="hash表原理图"></p></li><li><p>hash碰撞</p><blockquote><p>对于一个存储元素，由hash函数计算所得到的整数值，有可能两个不同元素的hashcode值是一样的，不过概率很小</p></blockquote></li><li><p>解决hash碰撞</p><ol><li>升级维度(由原来的数组结构升级为数组+链表形式)—拉链式解决冲突的方法</li></ol></li><li><p>增删改查的时间复杂度都是<code>O(1)</code></p></li><li><p>实现</p><ol><li>HashMap/TreeMap—<code>key-value</code>对，key不重复<ol><li>主要掌握put和get原理流程</li></ol></li><li>HashSet/TreeSet—不重复的元素集合<ol><li>主要依赖<code>HashMap/TreeMap</code>来实现</li></ol></li></ol></li></ol></li></ol><h4 id="2-8-1-练习"><a href="#2-8-1-练习" class="headerlink" title="2.8.1 练习"></a>2.8.1 练习</h4><ol><li><p>hash(有效的字母异位词)—242题</p><p>题述：给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: s = "anagram", t = "nagaram"输出: true输入: s = "rat", t = "car"输出: false</code></pre><p><strong>说明:</strong><br>你可以假设字符串只包含小写字母。</p><p><strong>进阶:</strong><br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 一般方法</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> alphabet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        alphabet<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        alphabet<span class="token punctuation">[</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> alphabet<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 时间复杂度较低解法</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> anagram<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> anagramlength <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        anagram<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>index <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>anagram<span class="token punctuation">[</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            anagramlength<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> anagramlength <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>hash(字母异位词分组)—49题</p><p>题述：给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: ["eat", "tea", "tan", "ate", "nat", "bat"]输出:[  ["ate","eat","tea"],  ["nat","tan"],  ["bat"]]输入: strs = [""]输出: [[""]]输入: strs = ["a"]输出: [["a"]]</code></pre><p><strong>说明：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li>所有输入均为小写字母</li><li>不考虑答案输出的顺序。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 排序解法</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>strs <span class="token operator">==</span> null <span class="token operator">||</span> strs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">>></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String s <span class="token operator">:</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ca <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>ca<span class="token punctuation">)</span><span class="token punctuation">;</span>        String keyStr <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ca<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>keyStr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>keyStr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>keyStr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 固定字节数组</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>strs <span class="token operator">==</span> null <span class="token operator">||</span> strs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">>></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String s <span class="token operator">:</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ca<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String keyStr <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ca<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>keyStr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>keyStr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>keyStr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="3-树形结构"><a href="#3-树形结构" class="headerlink" title="3. 树形结构"></a>3. 树形结构</h2><h3 id="3-1-一般树"><a href="#3-1-一般树" class="headerlink" title="3.1 一般树"></a>3.1 一般树</h3><ol><li><p>概述</p><blockquote><p>Linked list 是简化的Tree；Tree是简化的Graph</p></blockquote><ol><li>Tree相比Linked list有两个next指针</li><li>没有环的Graph就是Tree</li></ol></li><li><p>遍历时间复杂度O(n)</p></li></ol><h3 id="3-2-二叉树"><a href="#3-2-二叉树" class="headerlink" title="3.2 二叉树"></a>3.2 二叉树</h3><ol><li>树的遍历<ol><li>前序遍历<code>根-左-右</code></li><li>中序遍历<code>左-根-右</code></li><li>后序遍历<code>左-右-根</code></li></ol></li><li>遍历时间复杂度O(n)；因为无序</li></ol><h3 id="3-3-二叉搜索树"><a href="#3-3-二叉搜索树" class="headerlink" title="3.3 二叉搜索树"></a>3.3 二叉搜索树</h3><ol><li><p>概述</p><blockquote><p>二叉搜索树也称二叉搜索排序树，有序二叉树，排序二叉树；是指一颗空树或者具有下列性质的二叉树</p></blockquote><ol><li>左子树上==所有节点==的值均小于根节点的值</li><li>右子树上==所有节点==的值均大于根节点的值</li><li>以此类推：左，右子树也分别为二叉查找树(这就是重复性)</li></ol></li><li><p>特点</p><blockquote><p>中序遍历是升序遍历</p></blockquote></li><li><p>遍历时间复杂度<code>O(logn)</code></p></li><li><p>常见操作</p><ol><li>查询</li><li>插入新增</li><li>删除</li></ol></li><li><p>极端情况</p><blockquote><p>树退化成单链表，即全部数字升序排列，此时查询时间复杂度是O(n)</p></blockquote></li></ol><h3 id="3-4-练习"><a href="#3-4-练习" class="headerlink" title="3.4 练习"></a>3.4 练习</h3><ol><li><p>Tree(二叉树的中序遍历)</p><p>题述：给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/17.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE1.jpg" alt="二叉树遍历方式图1"></p><pre class=" language-text"><code class="language-text">输入：root = [1,null,2,3]输出：[1,3,2]输入：root = []输出：[]输入：root = [1]输出：[1]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/18.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE2.jpg" alt="二叉树遍历方式图2"></p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：root = [1,2]输出：[2,1]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/19.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE3.jpg" alt="二叉树遍历方式图3"></p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：root = [1,null,2]输出：[1,2]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代方式</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>              stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>            root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                                          list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归实现</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>Tree(二叉树的前序遍历)</p><p>题述：给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/17.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE1.jpg" alt="二叉树遍历方式图1"></p><pre class=" language-text"><code class="language-text">输入：root = [1,null,2,3]输出：[1,2,3]输入：root = []输出：[]输入：root = [1]输出：[1]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/18.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE2.jpg" alt="二叉树遍历方式图2"></p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：root = [1,2]输出：[1,2]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/19.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE3.jpg" alt="二叉树遍历方式图3"></p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：root = [1,null,2]输出：[1,2]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> rights <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            rights<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>rights<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            root <span class="token operator">=</span> rights<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> pre <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    pre<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    pre<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pre<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pre<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>Tree(N叉树的后序遍历)—590题</p><p>题述：给定一个 N 叉树，返回其节点值的<em>后序遍历</em>。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/20.N%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE1.png" alt="N叉树遍历方式图1"></p><pre class=" language-text"><code class="language-text">输入: root = [1,null,3,2,4,null,5,6]输出: [5,6,3,2,4,1]</code></pre><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/21.N%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE2.png" alt="N叉树遍历方式图2"></p><pre class=" language-text"><code class="language-text">输入: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]</code></pre><p><strong>提示：</strong></p><ul><li>树的高度不会超过 <code>1000</code></li><li>树的节点总数在 <code>[0, 10^4]</code> 之间</li></ul><p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Stack<span class="token operator">&lt;</span>Node<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span> root<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>           <span class="token punctuation">}</span>    Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span> root<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">postorder</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>Tree(N叉树的前序遍历)</p><p>题述：给定一个 N 叉树，返回其节点值的<em>前序遍历</em>。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/20.N%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE1.png" alt="N叉树遍历方式图1"></p><pre class=" language-text"><code class="language-text">输入: root = [1,null,3,2,4,null,5,6]输出: [1,3,5,6,2,4]</code></pre><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/21.N%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE2.png" alt="N叉树遍历方式图2"></p><pre class=" language-text"><code class="language-text">输入: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]</code></pre><p><strong>提示：</strong></p><ul><li>树的高度不会超过 <code>1000</code></li><li>树的节点总数在 <code>[0, 10^4]</code> 之间</li></ul><p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>Tree(N叉树的层序遍历)</p><p>题述：给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/20.N%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE1.png" alt="N叉树遍历方式图1"></p><pre class=" language-text"><code class="language-text">输入：root = [1,null,3,2,4,null,5,6]输出：[[1],[3,2,4],[5,6]]</code></pre><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/21.N%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E5%9B%BE2.png" alt="N叉树遍历方式图2"></p><pre class=" language-text"><code class="language-text">输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</code></pre><p><strong>提示：</strong></p><ul><li>树的高度不会超过 <code>1000</code></li><li>树的节点总数在 <code>[0, 10^4]</code> 之间</li></ul><p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h3 id="3-5-泛型递归"><a href="#3-5-泛型递归" class="headerlink" title="3.5 泛型递归"></a>3.5 泛型递归</h3><ol><li><p>适用场景</p><ol><li>节点的定义</li><li>重复性(自相似性)</li></ol></li><li><p>本质</p><blockquote><p>通过函数体来进行循环</p></blockquote></li><li><p>代码模板</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// java递归模板</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> param<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// terminator</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>level <span class="token operator">></span> MAX_LEVEL<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// process result</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// process current logic</span>    <span class="token function">process</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// drill down</span>    <span class="token function">recur</span><span class="token punctuation">(</span>level<span class="token operator">:</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> newParam<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// retore current status</span><span class="token punctuation">}</span></code></pre></li><li><p>思维要点</p><ol><li>不要进行人肉递归(手写递归树)</li><li>找到最近最简方法，将其拆解成可重复解决的问题(重复子问题)</li><li>数学归纳法思维</li></ol></li></ol><h3 id="3-6-练习"><a href="#3-6-练习" class="headerlink" title="3.6 练习"></a>3.6 练习</h3><ol><li><p>递归(括号生成)-22题</p><p>题述：数字n代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且<strong>有效的</strong>括号组合。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：n = 3输出：["((()))","(()())","(())()","()(())","()()()"]输入：n = 1输出：["()"]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token punctuation">,</span> String str<span class="token punctuation">,</span> <span class="token keyword">int</span> open<span class="token punctuation">,</span> <span class="token keyword">int</span> close<span class="token punctuation">,</span> <span class="token keyword">int</span> max<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> max<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>open <span class="token operator">&lt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> str<span class="token operator">+</span><span class="token string">"("</span><span class="token punctuation">,</span> open<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> close<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>close <span class="token operator">&lt;</span> open<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> str<span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">,</span> open<span class="token punctuation">,</span> close<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre></li><li><p>二叉树(翻转二叉树)—226题</p><p>题述：翻转一棵二叉树。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：     4   /   \  2     7 / \   / \1   3 6   9输出：     4   /   \  7     2 / \   / \9   6 3   1</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>二叉树(验证二叉搜索树)—98题</p><p>题述：给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/22.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE1.jpg" alt="二叉树图1"></p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/23.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE2.jpg" alt="二叉树图2"></p><pre class=" language-text"><code class="language-text">输入: root = [2,1,3]输出: true输入: root = [5,1,4,null,null,3,6]输出: false解释: 输入为: [5,1,4,null,null,3,6]。     根节点的值为 5 ，但是其右子节点值为 4 。</code></pre><p><strong>提示：</strong></p><ul><li>二叉树节点的取值范围<code>[1, 104]</code>.</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>二叉树(二叉树的最大深度)—104题</p><p>题述：给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/24.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE3.jpg" alt="二叉树图3"></p><pre class=" language-text"><code class="language-text">输入: root = [3,9,20,null,null,15,7]输出: 3输入: root = [1,null,2]输出: 2输入: root = []输出: 0</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>二叉树(二叉树的最小深度)—111题</p><p>题述：给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/24.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE3.jpg" alt="二叉树图3"></p><pre class=" language-text"><code class="language-text">输入：root = [3,9,20,null,null,15,7]输出：2输入：root = [2,null,3,null,4,null,5,null,6]输出：5</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <code>[0, 105]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>二叉树(二叉树的序列化与反序列化)—297题</p><p>题述：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示:</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/25.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE4.jpg" alt="二叉树图4"></p><pre class=" language-text"><code class="language-text">输入：root = [1,2,3,null,null,4,5]输出：[1,2,3,null,null,4,5]输入：root = []输出：[]输入：root = [1]输出：[1]输入：root = [1,2]输出：[1,2]</code></pre><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 104]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>二叉树(二叉树的最近公共祖先)—236题</p><p>题述：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>示例：给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/26.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE5.png" alt="二叉树图5"></p><pre class=" language-text"><code class="language-text">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>二叉树(从前序与中序遍历序列构造二叉树)—105题</p><p>题述：根据一棵树的前序遍历与中序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>示例：例如，给出</p><pre class=" language-text"><code class="language-text">前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：    3   / \  9  20    /  \   15   7</code></pre></li><li><p>递归(组合)—77题</p><p>题述：给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: n = 4, k = 2输出:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]输入: n = 1, k = 1输出: [[1]]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>递归(全排列)—46题</p><p>题述：给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]输入: nums = [0,1]输出: [[0,1],[1,0]]输入: nums = [1]输出: [[1]]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>All the integers of <code>nums</code> are <strong>unique</strong>.</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>递归(全排列2)—47题</p><p>题述：给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [1,1,2]输出：[[1,1,2], [1,2,1], [2,1,1]]输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h3 id="3-7-字典树和并查集"><a href="#3-7-字典树和并查集" class="headerlink" title="3.7 字典树和并查集"></a>3.7 字典树和并查集</h3><h4 id="3-7-1-简介"><a href="#3-7-1-简介" class="headerlink" title="3.7.1 简介"></a>3.7.1 简介</h4><ol><li><p>并查集代码模板</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// java</span><span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        count <span class="token operator">=</span> n<span class="token punctuation">;</span>        parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> rootP <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rootQ <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rootP <span class="token operator">==</span> rootQ<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        parent<span class="token punctuation">[</span>rootP<span class="token punctuation">]</span> <span class="token operator">=</span> rootQ<span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="3-7-2-练习"><a href="#3-7-2-练习" class="headerlink" title="3.7.2 练习"></a>3.7.2 练习</h4><ol><li><p>实现 Trie (前缀树)—208题</p><p>题述：实现一个 Trie (前缀树)，包含 <code>insert</code>, <code>search</code>, 和 <code>startsWith</code> 这三个操作。</p><p>示例：</p><pre class=" language-text"><code class="language-text">Trie trie = new Trie();trie.insert("apple");trie.search("apple");   // 返回 truetrie.search("app");     // 返回 falsetrie.startsWith("app"); // 返回 truetrie.insert("app");   trie.search("app");     // 返回 true</code></pre><p><strong>说明:</strong></p><ul><li>你可以假设所有的输入都是由小写字母 <code>a-z</code> 构成的。</li><li>保证所有输入均为非空字符串。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>单词搜索 II—21题</p><p>题述：给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。</p><p>单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p><p>示例1：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/48.%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A21.jpg" alt="单词搜索1"></p><pre class=" language-text"><code class="language-text">输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]输出：["eat","oath"]</code></pre><p>示例2：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/49.%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A22.jpg" alt="单词搜索2"></p><pre class=" language-text"><code class="language-text">输入：board = [["a","b"],["c","d"]], words = ["abcb"]输出：[]:</code></pre><p>提示：</p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 12</code></li><li><code>board[i][j] </code>是一个小写英文字母</li><li><code>1 &lt;= words.length &lt;= 3 * 104</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>words[i]</code> 由小写英文字母组成</li><li><code>words</code> 中的所有字符串互不相同</li></ul></li><li><p>省份数量(朋友圈)—547题</p><p>题述：有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><p>示例1：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/50.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F1.jpg" alt="省份数量1"></p><pre class=" language-text"><code class="language-text">[[1,1,0], [1,1,0], [0,0,1]]输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。</code></pre><p>示例2：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/51.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F2.jpg" alt="省份数量2"></p><pre class=" language-text"><code class="language-text">输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]输出：3</code></pre><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 200</code></li><li><code>n == isConnected.length</code></li><li><code>n == isConnected[i].length</code></li><li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li><li><code>isConnected[i][i] == 1</code></li><li><code>isConnected[i][j] == isConnected[j][i]</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>被围绕的区域—130题</p><p>题述：给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code>用 <code>&#39;X&#39;</code> 填充。</p><p>示例：</p><p><img src="/2020/12/20/5-datastructureandalgorithm/githubblog\source_posts\assets\52.被围绕的区域.jpg" alt="被围绕的区域"></p><pre class=" language-text"><code class="language-text">输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。输入：board = [["X"]]输出：[["X"]]</code></pre><p>提示：</p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>board[i][j]</code> 为 <code>X</code> 或 <code>O</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h3 id="3-8-红黑树和AL树"><a href="#3-8-红黑树和AL树" class="headerlink" title="3.8 红黑树和AL树"></a>3.8 红黑树和AL树</h3><ol><li><p>平衡树</p><blockquote></blockquote></li></ol><h2 id="4-算法"><a href="#4-算法" class="headerlink" title="4. 算法"></a>4. 算法</h2><h3 id="4-1-分治和回溯"><a href="#4-1-分治和回溯" class="headerlink" title="4.1 分治和回溯"></a>4.1 分治和回溯</h3><ol><li><p>本质</p><blockquote><p>是一种递归，递归的一个细化类；是一种特殊的递归。</p></blockquote></li><li><p>重复性分类</p><ol><li>最近的重复性<ol><li>重复性构造—回溯</li><li>重复性分解—分治</li></ol></li><li>最优的重复性—动态规划</li></ol></li><li><p>分治代码</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 代码模板</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">divideConquer</span><span class="token punctuation">(</span>problem<span class="token punctuation">,</span> param1<span class="token punctuation">,</span> param2<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// recursion terminator</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>problem <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// prepare data</span>    data <span class="token operator">=</span> <span class="token function">prepare_data</span><span class="token punctuation">(</span>problem<span class="token punctuation">)</span><span class="token punctuation">;</span>    subproblems <span class="token operator">=</span> <span class="token function">split_problem</span><span class="token punctuation">(</span>problem<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// conquer subproblems</span>    subresult1 <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">divide_conquer</span><span class="token punctuation">(</span>subproblem<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p1<span class="token punctuation">,</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    subresult2 <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">divide_conquer</span><span class="token punctuation">(</span>subproblem<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p1<span class="token punctuation">,</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    subresult3 <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">divide_conquer</span><span class="token punctuation">(</span>subproblem<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p1<span class="token punctuation">,</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// peocess and generate the final result</span>    result <span class="token operator">=</span> <span class="token function">process_result</span><span class="token punctuation">(</span>subresult1<span class="token punctuation">,</span> subresult2<span class="token punctuation">,</span> subresult3<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// revert the current level status    </span><span class="token punctuation">}</span></code></pre></li><li><p>回溯</p><blockquote><p>采用试错的思想，尝试分步的去解决一个问题；在分步解决问题的过程中，当通过尝试发现现有的分步答案不能得到有效(正确)的解答的时候，它将取消上一步甚至是上几步的计算，再通过其他的可能的分步解答再次尝试寻找问题的答案。</p></blockquote><ol><li><p>通常使用最简单的递归方法来实现，在反复重复上述的步骤可能出现的两种情况</p><ol><li>找了一个可能存在的正确答案</li><li>在尝试了所有可能的分步方法后宣告该问题没有答案</li></ol></li><li><p>时间复杂度</p><blockquote><p>在最坏情况下，回溯算法会导致一次复杂度为指数的时间计算</p></blockquote></li></ol></li></ol><h3 id="4-2-练习"><a href="#4-2-练习" class="headerlink" title="4.2 练习"></a>4.2 练习</h3><ol><li><p>分治和回溯(Pow(x, n))—50题</p><p>题述：实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：x = 2.00000, n = 10输出：1024.00000输入：x = 2.10000, n = 3输出：9.26100输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25</code></pre><p><strong>提示：</strong></p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li><code>-231 &lt;= n &lt;= 231-1</code></li><li><code>-104 &lt;= xn &lt;= 104</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 分治解法</span><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">myPow</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">/</span>x <span class="token operator">*</span> <span class="token function">myPow</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span>x<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">myPow</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token punctuation">,</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">:</span> x<span class="token operator">*</span><span class="token function">myPow</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token punctuation">,</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对数迭代法</span><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">myPow</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> absN <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>absN <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>absN <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ans <span class="token operator">*=</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        absN <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>        x <span class="token operator">*=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> n <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">/</span> ans <span class="token operator">:</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>分治和回溯(子集)—78题</p><p>题述：给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]输入：nums = [0]输出：[[],[0]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 浅拷贝：把容器中的每一个元素的指针(引用)拷贝了一次</span></code></pre></li><li><p>牛顿迭代法</p><blockquote><p>牛顿迭代法快速寻找平方根</p></blockquote><p>下面这种方法可以很有效地求出根号<code>a</code>的近似值：首先随便猜一个近似值<code>x</code>，然后不断令<code>x</code>等于<code>x</code>和<code>a/x</code>的平均数，迭代个六七次后<code>x</code>的值就已经相当精确了。</p><pre><code>例如，我想求根号2等于多少。假如我猜测的结果为4，虽然错的离谱，但你可以看到使用牛顿迭代法后这个值很快就趋近于根号2了：</code></pre><pre class=" language-text"><code class="language-text">(       4  + 2/   4     ) / 2 = 2.25(    2.25  + 2/   2.25  ) / 2 = 1.56944..( 1.56944..+ 2/1.56944..) / 2 = 1.42189..( 1.42189..+ 2/1.42189..) / 2 = 1.41423......</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/27.%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95.gif" alt="牛顿迭代法"></p><p>这种算法的原理很简单，我们仅仅是不断用<code>(x,f(x))</code>的切线来逼近方程<code>x^2-a=0</code>的根。根号<code>a</code>实际上就是<code>x^2-a=0</code>的一个正实根，这个函数的导数是<code>2x</code>。也就是说，函数上任一点<code>(x,f(x))</code>处的切线斜率是<code>2x</code>。那么，<code>x-f(x)/(2x)</code>就是一个比<code>x</code>更接近的近似值。代入<code>f(x)=x^2-a</code>得到<code>x-(x^2-a)/(2x)</code>，也就是<code>(x+a/x)/2</code>。<br>同样的方法可以用在其它的近似值计算中。<a href="http://www.matrix67.com/blog/article.asp?id=411">Quake III的源码</a>中有一段非常牛B的开方取倒函数。</p><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mysqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> tmpx <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> k <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> k0 <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>k0<span class="token operator">-</span>k<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        k0 <span class="token operator">=</span> k<span class="token punctuation">;</span>        k <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">+</span> tmpx<span class="token operator">/</span>k<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>k<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Quake-III</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mysqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">float</span> tmpx <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span>    <span class="token keyword">float</span> xhalf <span class="token operator">=</span> <span class="token number">0.5f</span><span class="token operator">*</span>tmpx<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>tmpx<span class="token punctuation">;</span>    i <span class="token operator">=</span> <span class="token number">0x5f375a86</span> <span class="token operator">-</span> <span class="token punctuation">(</span>i <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tmpx <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> i<span class="token punctuation">;</span>    tmpx <span class="token operator">=</span> tmpx <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1.5f</span> <span class="token operator">-</span> xhalf<span class="token operator">*</span>tmpx<span class="token operator">*</span>tmpx<span class="token punctuation">)</span><span class="token punctuation">;</span>    tmpx <span class="token operator">=</span> tmpx <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1.5f</span> <span class="token operator">-</span> xhalf<span class="token operator">*</span>tmpx<span class="token operator">*</span>tmpx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token operator">/</span>tmpx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>res <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> x<span class="token punctuation">)</span>        res <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>分治和回溯(多数元素)—169题</p><p>题述：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于[ n/2] 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：[3,2,3]输出：3输入：[2,2,1,1,1,2,2]输出：2</code></pre><p><strong>进阶：</strong></p><ul><li>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 数组解法 </span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> major <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            major <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>major <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> major<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//assume the first element is the answer</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ans <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             count<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//if meet different value,count--</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//if meet the same value, count++ </span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">//if the current best ans is no longer the majority</span>        <span class="token comment" spellcheck="true">// i.e. it's count is not larger than i / 2</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Moore voting algorithm</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">majorityElement3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ret <span class="token operator">=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num<span class="token operator">!=</span>ret<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>分治和回溯(电话号码的字母组合)—17题</p><p>题述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/28.%E7%94%B5%E8%AF%9D%E6%8B%A8%E5%8F%B7%E9%94%AE%E7%9B%98.png" alt="电话拨号键盘"></p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：digits = "23"输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]输入：digits = ""输出：[]输入：digits = "2"输出：["a","b","c"]</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>分治和回溯(N皇后)—51题</p><p>题述：n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/29.N%E7%9A%87%E5%90%8E.jpg" alt="N皇后"></p><pre class=" language-text"><code class="language-text">输入：n = 4输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]解释：如上图所示，4 皇后问题存在两个不同的解法。输入：n = 1输出：[["Q"]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h3 id="4-3-深度优先搜索—DFS"><a href="#4-3-深度优先搜索—DFS" class="headerlink" title="4.3 深度优先搜索—DFS"></a>4.3 深度优先搜索—DFS</h3><ol><li><p>概述</p><blockquote><p>绝大多数情况下处理的都是暴力搜索，即大部分情况把所有节点全部遍历一次</p></blockquote></li><li><p>搜索</p><ol><li>每个节点有且仅有只能访问一次，以优化时间复杂度</li></ol></li><li><p>对于树中节点访问顺序的不同可分为</p><ol><li>深度优先搜索</li><li>广度优先搜索</li><li>其他优先搜索(加权优先搜索)—又称为启发式搜索</li></ol></li><li><p>代码模板</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 深度优先搜索</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> allResults <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> allResults<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// process current node</span>    <span class="token comment" spellcheck="true">// logic here</span>    <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>allResults<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// already visited</span>    <span class="token keyword">return</span> allResults<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">travel</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span><span class="token keyword">int</span> level<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> results<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>results<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>level<span class="token punctuation">)</span><span class="token punctuation">{</span>        results<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    results<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 非递归写法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    Stack stack <span class="token operator">=</span> <span class="token punctuation">[</span>tree<span class="token punctuation">.</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        nodes <span class="token operator">=</span> <span class="token function">gentate_related_nodes</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// other processing work</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="4-4-广度优先搜索—BFS"><a href="#4-4-广度优先搜索—BFS" class="headerlink" title="4.4 广度优先搜索—BFS"></a>4.4 广度优先搜索—BFS</h3><ol><li><p>代码模板</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 广度优先搜索</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> allResults <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> allResults<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// process current node here</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>nodes<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> nodes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> results <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            TreeNode node <span class="token operator">=</span> nodes<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            results<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        allResults<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> allResults<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 非递归写法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        nodes <span class="token operator">=</span> <span class="token function">gentate_related_nodes</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// other processing work</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="4-5-练习"><a href="#4-5-练习" class="headerlink" title="4.5 练习"></a>4.5 练习</h3><ol><li><p>二叉树的层序遍历—102题(面试前三热点题)</p><p>题述：给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>示例：二叉树：<code>[3,9,20,null,null,15,7]</code></p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/30.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%861.jpg" alt="二叉树的层序遍历1"></p><pre class=" language-text"><code class="language-text">输入: root = [3,9,20,null,null,15,7]输出: [[3],[9,20],[15,7]]输入: root = [1]输出: [[1]]输入: root = []输出: []</code></pre><p><strong>提示：</strong></p><ul><li>树的节点的取值范围是 <code>[0, 2000]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 队列解法</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> wrapList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> wrapList<span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> levelNum <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> subList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>levelNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            subList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        wrapList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>subList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> wrapList<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>最小基因变化—433题</p><p>题述：一条基因序列由一个带有8个字符的字符串表示，其中每个字符都属于 “A”, “C”, “G”, “T”中的任意一个。</p><p>假设我们要调查一个基因序列的变化。一次基因变化意味着这个基因序列中的一个字符发生了变化。</p><p>例如，基因序列由”AACCGGTT” 变化至 “AACCGGTA” 即发生了一次基因变化。</p><p>与此同时，每一次基因变化的结果，都需要是一个合法的基因串，即该结果属于一个基因库。</p><p>现在给定3个参数 — start, end, bank，分别代表起始基因序列，目标基因序列及基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数。如果无法实现目标变化，请返回 -1。</p><p><strong>注意：</strong></p><ol><li>起始基因序列默认是合法的，但是它并不一定会出现在基因库中。</li><li>如果一个起始基因序列需要多次变化，那么它每一次变化之后的基因序列都必须是合法的。</li><li>假定起始基因序列与目标基因序列是不一样的。</li></ol><p>示例：</p><pre class=" language-text"><code class="language-text">start: "AACCGGTT"end:   "AACCGGTA"bank: ["AACCGGTA"]返回值: 1start: "AACCGGTT"end:   "AAACGGTA"bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]返回值: 2start: "AAAAACCC"end:   "AACCCCCC"bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]返回值: 3</code></pre><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minMutation</span><span class="token punctuation">(</span>String start<span class="token punctuation">,</span> String end<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> bank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Set<span class="token operator">&lt;</span>String<span class="token operator">></span> bankSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>String b<span class="token operator">:</span> bank<span class="token punctuation">)</span> <span class="token punctuation">{</span>        bankSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> charSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'G'</span><span class="token punctuation">,</span> <span class="token string">'T'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>String<span class="token operator">></span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>    visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>size<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String curr <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> level<span class="token punctuation">;</span>            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> currArray <span class="token operator">=</span> curr<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currArray<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">char</span> old <span class="token operator">=</span> currArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">:</span> charSet<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    currArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>                    String next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>currArray<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> bankSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>                        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                currArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> old<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        level<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minMutation</span><span class="token punctuation">(</span>String start<span class="token punctuation">,</span> String end<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> bank<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">recurse</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> bank<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> count <span class="token operator">==</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> count <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">recurse</span><span class="token punctuation">(</span>String start<span class="token punctuation">,</span> String end<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> bank<span class="token punctuation">,</span> <span class="token keyword">int</span> soFar<span class="token punctuation">,</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> visited<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> end<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        count <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> soFar<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>String e <span class="token operator">:</span> bank<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> diff <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> e<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                diff<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>diff <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>diff <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">recurse</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> end<span class="token punctuation">,</span> bank<span class="token punctuation">,</span> soFar<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>            visited<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>在每个树行中找最大值—515题</p><p>题述：您需要在二叉树的每一行中找到最大的值。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/31.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%862.jpg" alt="二叉树的层序遍历2"></p><pre class=" language-text"><code class="language-text">输入: root = [1,3,2,5,3,null,9]输出: [1,3,9]输入: root = [1,2,3]输出: [1,3]输入: root = [1]输出: [1]输入: root = [1,null,2]输出: [1,2]输入: root = []输出: []</code></pre><p><strong>提示：</strong></p><ul><li>The number of nodes in the tree will be in the range <code>[0, 104]</code>.</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">largestValues</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">helper</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//expand list size</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>d <span class="token operator">==</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//or set value</span>        res<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">,</span> d<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">,</span> d<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>单词接龙—127题</p><p>题述：字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p><ul><li>序列中第一个单词是 beginWord 。</li><li>序列中最后一个单词是 endWord 。</li><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典 wordList 中的单词。</li></ul><p>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p><p>示例：</p><pre class=" language-java"><code class="language-java">输入：beginWord <span class="token operator">=</span> <span class="token string">"hit"</span><span class="token punctuation">,</span> endWord <span class="token operator">=</span> <span class="token string">"cog"</span><span class="token punctuation">,</span> wordList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hot"</span><span class="token punctuation">,</span><span class="token string">"dot"</span><span class="token punctuation">,</span><span class="token string">"dog"</span><span class="token punctuation">,</span><span class="token string">"lot"</span><span class="token punctuation">,</span><span class="token string">"log"</span><span class="token punctuation">,</span><span class="token string">"cog"</span><span class="token punctuation">]</span>输出：<span class="token number">5</span>解释：一个最短转换序列是 <span class="token string">"hit"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"hot"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"dot"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"dog"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"cog"</span><span class="token punctuation">,</span> 返回它的长度 <span class="token number">5</span>。输入：beginWord <span class="token operator">=</span> <span class="token string">"hit"</span><span class="token punctuation">,</span> endWord <span class="token operator">=</span> <span class="token string">"cog"</span><span class="token punctuation">,</span> wordList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hot"</span><span class="token punctuation">,</span><span class="token string">"dot"</span><span class="token punctuation">,</span><span class="token string">"dog"</span><span class="token punctuation">,</span><span class="token string">"lot"</span><span class="token punctuation">,</span><span class="token string">"log"</span><span class="token punctuation">]</span>输出：<span class="token number">0</span>解释：endWord <span class="token string">"cog"</span> 不在字典中，所以无法进行转换。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= beginWord.length &lt;= 10</code></li><li><code>endWord.length == beginWord.length</code></li><li><code>1 &lt;= wordList.length &lt;= 5000</code></li><li><code>wordList[i].length == beginWord.length</code></li><li><code>beginWord、endWord 和 wordList[i] 由小写英文字母组成</code></li><li><code>beginWord != endWord</code></li><li><code>wordList 中的所有字符串 互不相同</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">ladderLength</span><span class="token punctuation">(</span>String beginWord<span class="token punctuation">,</span> String endWord<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> wordList<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Set<span class="token operator">&lt;</span>String<span class="token operator">></span> dict <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>wordList<span class="token punctuation">)</span><span class="token punctuation">,</span> qs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> qe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    qs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dict<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>endWord<span class="token punctuation">)</span><span class="token punctuation">)</span> qe<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>endWord<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all transformed words must be in dict (including endWord)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">!</span>qs<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> nq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String w <span class="token operator">:</span> qs<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> w<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ch <span class="token operator">=</span> w<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token string">'z'</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> w<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// beginWord and endWord not the same, so bypass itself</span>                    ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>                    String nb <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>qe<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// meet from two ends</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>dict<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nb<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> vis<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nb<span class="token punctuation">)</span><span class="token punctuation">)</span> nq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// not meet yet, vis is safe to use</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        qs <span class="token operator">=</span> <span class="token punctuation">(</span>nq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> qe<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> nq <span class="token operator">:</span> qe<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// switch to small one to traverse from other end</span>        qe <span class="token operator">=</span> <span class="token punctuation">(</span>qs <span class="token operator">==</span> nq<span class="token punctuation">)</span> <span class="token operator">?</span> qe <span class="token operator">:</span> nq<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>单词接龙 II—126题</p><p>题述：给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换后得到的单词必须是字典中的单词。</li></ol><p><strong>说明：</strong></p><ul><li>如果不存在这样的转换序列，返回一个空列表。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li></ul><p>示例：</p><pre class=" language-java"><code class="language-java">输入<span class="token operator">:</span>beginWord <span class="token operator">=</span> <span class="token string">"hit"</span><span class="token punctuation">,</span>endWord <span class="token operator">=</span> <span class="token string">"cog"</span><span class="token punctuation">,</span>wordList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hot"</span><span class="token punctuation">,</span><span class="token string">"dot"</span><span class="token punctuation">,</span><span class="token string">"dog"</span><span class="token punctuation">,</span><span class="token string">"lot"</span><span class="token punctuation">,</span><span class="token string">"log"</span><span class="token punctuation">,</span><span class="token string">"cog"</span><span class="token punctuation">]</span>输出<span class="token operator">:</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token string">"hit"</span><span class="token punctuation">,</span><span class="token string">"hot"</span><span class="token punctuation">,</span><span class="token string">"dot"</span><span class="token punctuation">,</span><span class="token string">"dog"</span><span class="token punctuation">,</span><span class="token string">"cog"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"hit"</span><span class="token punctuation">,</span><span class="token string">"hot"</span><span class="token punctuation">,</span><span class="token string">"lot"</span><span class="token punctuation">,</span><span class="token string">"log"</span><span class="token punctuation">,</span><span class="token string">"cog"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>输入<span class="token operator">:</span>beginWord <span class="token operator">=</span> <span class="token string">"hit"</span>endWord <span class="token operator">=</span> <span class="token string">"cog"</span>wordList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hot"</span><span class="token punctuation">,</span><span class="token string">"dot"</span><span class="token punctuation">,</span><span class="token string">"dog"</span><span class="token punctuation">,</span><span class="token string">"lot"</span><span class="token punctuation">,</span><span class="token string">"log"</span><span class="token punctuation">]</span>输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>解释<span class="token operator">:</span> endWord <span class="token string">"cog"</span> 不在字典中，所以不存在符合要求的转换序列。</code></pre><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>岛屿数量—200题</p><p>题述：给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：grid = [  ["1","1","1","1","0"],  ["1","1","0","1","0"],  ["1","1","0","0","0"],  ["0","0","0","0","0"]]输出：1输入：grid = [  ["1","1","0","0","0"],  ["1","1","0","0","0"],  ["0","0","1","0","0"],  ["0","0","0","1","1"]]输出：3</code></pre><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>扫雷游戏—529题</p><p>题述：让我们一起来玩扫雷游戏！</p><p>给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。</p><p>现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p><p>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。<br>如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的未挖出方块都应该被递归地揭露。<br>如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。<br>如果在此次点击中，若无更多方块可被揭露，则返回面板。</p><p>示例1：</p><pre class=" language-java"><code class="language-java">输入<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'M'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>Click <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>输出<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'M'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/32.%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F1.png" alt="扫雷游戏1"></p><p>示例2：</p><pre class=" language-text"><code class="language-text">输入: [['B', '1', 'E', '1', 'B'], ['B', '1', 'M', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B']]Click : [1,2]输出: [['B', '1', 'E', '1', 'B'], ['B', '1', 'X', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B']]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/33.%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F2.png" alt="扫雷游戏2"></p><p><strong>注意：</strong></p><ol><li>输入矩阵的宽和高的范围为 [1,50]。</li><li>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。</li><li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li><li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。</li></ol><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h3 id="4-6-贪心算法"><a href="#4-6-贪心算法" class="headerlink" title="4.6 贪心算法"></a>4.6 贪心算法</h3><h4 id="4-6-1-简介"><a href="#4-6-1-简介" class="headerlink" title="4.6.1 简介"></a>4.6.1 简介</h4><ol><li><p>概述</p><blockquote><p>是一种在每一步选择中都采取在当前状态下最好或最优(即最有利)的选择，从而希望结果是全局最好或最优的算法</p></blockquote></li><li><p>区分</p><blockquote><p>贪心算法与动态规划的区别：贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p></blockquote></li><li><p>贪心&amp;回溯&amp;动态规划</p><ol><li>贪心：当下做局部最优判断</li><li>回溯：能够回退</li><li>动态规划：最优判断+回退</li></ol></li><li><p>贪心算法特点</p><blockquote><p>一个问题可以通过贪心算法解决，那么贪心算法必然是最优解决方案；由于贪心算法具有高效性以及所求结果比较接近最优解决方案，所以常用做辅助算法或者直接解决一些对结果要求不是特别精确的问题。</p></blockquote></li><li><p>应用</p><ol><li>图中求最小生成树</li><li>求哈夫曼编码</li><li>在工程和生活中一般不用贪心算法</li></ol></li><li><p>处处最优不一定得到全局最优，全局最优势必放弃处处最优。</p></li><li><p>适用场景</p><blockquote><p>一般地，一个问题能够分解为若干子问题来解决，而子问题的最优解能==<strong>递推</strong>==到最终问题的最优解；这种子问题的最优解称为最优子结构。</p></blockquote><blockquote><p>贪心算法会对每个子问题的解决方案都做出选择，且不能回退。</p></blockquote></li></ol><h4 id="4-6-2-练习"><a href="#4-6-2-练习" class="headerlink" title="4.6.2 练习"></a>4.6.2 练习</h4><ol><li><p>零钱兑换—322题</p><p>题述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1输入：coins = [2], amount = 3输出：-1输入：coins = [1], amount = 0输出：0输入：coins = [1], amount = 1输出：1输入：coins = [1], amount = 2输出：2</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>amount<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">++</span>sum <span class="token operator">&lt;=</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">>=</span> coin <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>sum<span class="token operator">-</span>coin<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> dp<span class="token punctuation">[</span>sum<span class="token operator">-</span>coin<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                min <span class="token operator">=</span> min<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">?</span> temp <span class="token operator">:</span> <span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> min <span class="token operator">?</span> temp <span class="token operator">:</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        dp<span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>柠檬水找零—860题</p><p>题述：在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：[5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。输入：[5,5,10]输出：true输入：[10,10]输出：false输入：[5,5,10,10,20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= bills.length &lt;= 10000</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lemonadeChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bills<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> five <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> bills<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            five<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            five<span class="token operator">--</span><span class="token punctuation">;</span>             ten<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ten <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ten<span class="token operator">--</span><span class="token punctuation">;</span>             five<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            five <span class="token operator">-=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>five <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lemonadeChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bills<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> bill <span class="token operator">:</span> bills<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>bill<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">10</span><span class="token operator">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">--</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> j<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">20</span><span class="token operator">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    i<span class="token operator">--</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">3</span><span class="token punctuation">)</span> i <span class="token operator">-=</span> <span class="token number">3</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                k<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>买卖股票的最佳时机 II—122题</p><p>题述：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li><li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>分发饼干—455题</p><p>题述：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: g = [1,2,3], s = [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。输入: g = [1,2], s = [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= s.length &lt;= 3 * 10^4</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>模拟行走机器人—874题</p><p>题述：机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ：</p><p>-2 ：向左转 90 度<br>-1 ：向右转 90 度<br>1 &lt;= x &lt;= 9 ：向前移动 x 个单位长度<br>在网格上有一些格子被视为障碍物 obstacles 。第 i 个障碍物位于网格点  obstacles[i] = (xi, yi) 。</p><p>机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。</p><p>返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 5 ，则返回 25 ）</p><p><strong>注意：</strong></p><ul><li>北表示 <code>+Y</code> 方向。</li><li>东表示 <code>+X</code> 方向。</li><li>南表示 <code>-Y</code> 方向。</li><li>西表示 <code>-X</code> 方向。</li></ul><p>示例：</p><pre class=" language-text"><code class="language-text">输入：commands = [4,-1,3], obstacles = []输出：25解释：机器人开始位于 (0, 0)：1. 向北移动 4 个单位，到达 (0, 4)2. 右转3. 向东移动 3 个单位，到达 (3, 4)距离原点最远的是 (3, 4) ，距离为 32 + 42 = 25输入：commands = [4,-1,4,-2,4], obstacles = [[2,4]]输出：65解释：机器人开始位于 (0, 0)：1. 向北移动 4 个单位，到达 (0, 4)2. 右转3. 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4)4. 左转5. 向北走 4 个单位，到达 (1, 8)距离原点最远的是 (1, 8) ，距离为 12 + 82 = 65</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= commands.length &lt;= 10^4</code></li><li><code>commands[i] is one of the values in the list [-2,-1,1,2,3,4,5,6,7,8,9].</code></li><li><code>0 &lt;= obstacles.length &lt;= 10^4</code></li><li><code>-3 * 10^4 &lt;= xi, yi &lt;= 3 * 10^4</code></li></ul><p>答案保证小于 231</p><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>跳跃游戏—55题</p><p>题述：给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>跳跃游戏 II—45题</p><p>题述：给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。输入: nums = [2,3,0,1,4]输出: 2     </code></pre><p><strong>说明:</strong></p><p>假设你总是可以到达数组的最后一个位置。</p><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h3 id="4-7-二分查找"><a href="#4-7-二分查找" class="headerlink" title="4.7 二分查找"></a>4.7 二分查找</h3><h4 id="4-7-1-简介"><a href="#4-7-1-简介" class="headerlink" title="4.7.1 简介"></a>4.7.1 简介</h4><ol><li><p>概述</p><ol><li>化繁为简</li></ol></li><li><p>二分查找的前提</p><ol><li>目标函数单调性(单调递增或者单调递减)</li><li>存在上下界(bounded)</li><li>能够通过索引访问(index accessible)</li></ol></li><li><p>代码模板</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> mid<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> left<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// find the target!</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="4-7-2-练习"><a href="#4-7-2-练习" class="headerlink" title="4.7.2 练习"></a>4.7.2 练习</h4><ol><li><p>x 的平方根—69题</p><p>题述：实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: 4输出: 2输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= x &lt;= 2^31 - 1</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">></span> x<span class="token operator">/</span>mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> x<span class="token operator">/</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>有效的完全平方数—367题</p><p>题述：给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。</p><p><strong>说明：</strong>不要使用任何内置的库函数，如  sqrt。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：16输出：True输入：14输出：False</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num &lt;= 2^31 - 1</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>搜索旋转排序数组—33题</p><p>题述：整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [4,5,6,7,0,1,2], target = 0输出：4输入：nums = [4,5,6,7,0,1,2], target = 3输出：-1输入：nums = [1], target = 0输出：-1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code>中的每个值都 独一无二</li><li><code>nums</code>肯定会在某个点上旋转</li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(log n)</code> 的解决方案吗？</p><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>搜索二维矩阵—74题</p><p>题述：编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。</p><p>示例1：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/34.%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B51.jpg" alt="二维矩阵1"></p><pre class=" language-text"><code class="language-text">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3输出：true</code></pre><p>示例2：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/35.%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B52.jpg" alt="二维矩阵2"></p><pre class=" language-text"><code class="language-text">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>-10^4 &lt;= matrix[i][j], target &lt;= 10^4</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>寻找旋转排序数组中的最小值—153题</p><p>题述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。</p><p>请找出其中最小的元素。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [3,4,5,1,2]输出：1输入：nums = [4,5,6,7,0,1,2]输出：0输入：nums = [1]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code>中的所有整数都是唯一的</li><li><code>nums</code>原来是一个升序排序的数组，但在预先未知的某个点上进行了旋转</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 迭代解法</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            r <span class="token operator">=</span> m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归解法</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">findMin</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low <span class="token operator">==</span> high<span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">findMin</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">findMin</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方</p></li></ol><h3 id="4-8-动态规划"><a href="#4-8-动态规划" class="headerlink" title="4.8 动态规划"></a>4.8 动态规划</h3><h4 id="4-8-1-简介"><a href="#4-8-1-简介" class="headerlink" title="4.8.1 简介"></a>4.8.1 简介</h4><ol><li><p>递归代码模板</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Java</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// terminator</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">></span> MAX_LEVEL<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// process result</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// process current logic</span>    <span class="token function">process</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// drill down</span>    <span class="token function">recur</span><span class="token punctuation">(</span> level<span class="token operator">:</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> newParam<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// restore current status</span><span class="token punctuation">}</span></code></pre></li><li><p>分治代码模板</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Java</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">divide_conquer</span><span class="token punctuation">(</span>Problem problem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>problem <span class="token operator">==</span> NULL<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">process_last_result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    subProblems <span class="token operator">=</span> <span class="token function">split_problem</span><span class="token punctuation">(</span>problem<span class="token punctuation">)</span><span class="token punctuation">;</span>    res0 <span class="token operator">=</span> <span class="token function">divide_conquer</span><span class="token punctuation">(</span>subProblems<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res1 <span class="token operator">=</span> <span class="token function">divide_conquer</span><span class="token punctuation">(</span>subProblems<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    result <span class="token operator">=</span> <span class="token function">process_result</span><span class="token punctuation">(</span>res0<span class="token punctuation">,</span> res1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>动态规划定义</p><blockquote></blockquote></li></ol><h4 id="4-8-2-练习"><a href="#4-8-2-练习" class="headerlink" title="4.8.2 练习"></a>4.8.2 练习</h4><ol><li><p>不同路径—62题</p><p>题述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/36.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.png" alt="不同路径"></p><pre class=" language-text"><code class="language-text">输入：m = 3, n = 7输出：28输入：m = 3, n = 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -> 向下 -> 向下2. 向下 -> 向下 -> 向右3. 向下 -> 向右 -> 向下输入：m = 7, n = 3输出：28输入：m = 3, n = 3输出：6</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></li><li><p>不同路径 II—63题</p><p>题述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p>示例1：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/37.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%841.jpg" alt="不同路径1"></p><pre class=" language-text"><code class="language-text">输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -> 向右 -> 向下 -> 向下2. 向下 -> 向下 -> 向右 -> 向右</code></pre><p>示例2：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/38.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842.jpg" alt="不同路径2"></p><pre class=" language-text"><code class="language-text">输入：obstacleGrid = [[0,1],[0,0]]输出：1</code></pre><p>提示：</p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j] 为 0 或 1</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>最长公共子序列—1143题</p><p>题述：给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：text1 = "abcde", text2 = "ace" 输出：3  解释：最长公共子序列是 "ace"，它的长度为 3。输入：text1 = "abc", text2 = "abc"输出：3解释：最长公共子序列是 "abc"，它的长度为 3。输入：text1 = "abc", text2 = "def"输出：0解释：两个字符串没有公共子序列，返回 0。</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= text1.length &lt;= 1000</code></li><li><code>1 &lt;= text2.length &lt;= 1000</code></li><li>输入的字符串只含有小写英文字符。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>MIT动态规划课程最短路径算法</p><blockquote><p><a href="https://www.bilibili.com/video/av53233912?from=search&amp;seid=2847395688604491997">https://www.bilibili.com/video/av53233912?from=search&amp;seid=2847395688604491997</a></p></blockquote></li><li><p>爬楼梯—70题</p><p>题述：假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1.  1 阶 + 1 阶2.  2 阶输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1.  1 阶 + 1 阶 + 1 阶2.  1 阶 + 2 阶3.  2 阶 + 1 阶</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 动态规划解法</span></code></pre></li><li><p>三角形最小路径和—120题</p><p>题述：给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]输出：11解释：如下面简图所示：   2  3 4 6 5 74 1 8 3自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。输入：triangle = [[-10]]输出：-10</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= triangle.length &lt;= 200</code></li><li><code>triangle[0].length == 1</code></li><li><code>triangle[i].length == triangle[i - 1].length + 1</code></li><li><code>-10^4 &lt;= triangle[i][j] &lt;= 10^4</code></li></ul><p><strong>进阶：</strong></p><ul><li>你可以只使用 <code>O(n)</code> 的额外空间（<code>n</code> 为三角形的总行数）来解决这个问题吗？</li></ul><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>最大子序和—53题</p><p>题述：给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。输入：nums = [1]输出：1输入：nums = [0]输出：0输入：nums = [-1]输出：-1输入：nums = [-100000]输出：-100000</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>乘积最大子数组—152题</p><p>题述：给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>零钱兑换—322题</p><p>题述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1输入：coins = [2], amount = 3输出：-1输入：coins = [1], amount = 0输出：0输入：coins = [1], amount = 1输出：1输入：coins = [1], amount = 2输出：2</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 2^31 - 1</code></li><li><code>0 &lt;= amount &lt;= 10^4</code></li></ul><p>实现</p><pre class=" language-text"><code class="language-text"></code></pre></li><li><p>打家劫舍—198题</p><p>题述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。     偷窃到的最高金额 = 1 + 3 = 4 。输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>打家劫舍 II—213题</p><p>题述：你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。输入：nums = [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。     偷窃到的最高金额 = 1 + 3 = 4 。输入：nums = [0]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>买卖股票的最佳时机—121题</p><p>题述：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 10^5</code></li><li><code>0 &lt;= prices[i] &lt;= 10^4</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>买卖股票的最佳时机 II—122题</p><p>题述：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li><li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>买卖股票的最佳时机 III—123题</p><p>题述：给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：prices = [3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。     输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。        注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。        因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0输入：prices = [1]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 10^5</code></li><li><code>0 &lt;= prices[i] &lt;= 10^5</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>最佳买卖股票时机含冷冻期—309题</p><p>题述：给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</code></pre><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>买卖股票的最佳时机 IV—188题</p><p>题述：给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：k = 2, prices = [2,4,1]输出：2解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。输入：k = 2, prices = [3,2,6,5,0,3]输出：7解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= k &lt;= 100</code></li><li><code>0 &lt;= prices.length &lt;= 1000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>买卖股票的最佳时机含手续费—714题</p><p>题述：给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: prices = [1, 3, 2, 8, 4, 9], fee = 2输出: 8解释: 能够达到的最大利润:  在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</code></pre><p><strong>注意:</strong></p><ul><li><code>0 &lt; prices.length &lt;= 50000</code>.</li><li><code>0 &lt; prices[i] &lt; 50000</code>.</li><li><code>0 &lt;= fee &lt; 50000</code>.</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>完全平方数—279题</p><p>题述：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：n = 12输出：3 解释：12 = 4 + 4 + 4输入：n = 13输出：2解释：13 = 4 + 9</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^4</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p><font color="red">编辑距离—72题</font></p><p>题述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><pre class=" language-text"><code class="language-text">输入：word1 = "horse", word2 = "ros"输出：3解释：horse -> rorse (将 'h' 替换为 'r')rorse -> rose (删除 'r')rose -> ros (删除 'e')输入：word1 = "intention", word2 = "execution"输出：5解释：intention -> inention (删除 't')inention -> enention (将 'i' 替换为 'e')enention -> exention (将 'n' 替换为 'x')exention -> exection (将 'n' 替换为 'c')exection -> execution (插入 'u')</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>跳跃游戏—55题</p><p>题述：给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>跳跃游戏 II—45题</p><p>题述：给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。Input: nums = [2,3,0,1,4]Output: 2</code></pre><p><strong>说明:</strong></p><p>假设你总是可以到达数组的最后一个位置。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>不同路径 III—980题</p><p>题述：在二维网格 grid 上，有 4 种类型的方格：</p><ul><li><p>1 表示起始方格。且只有一个起始方格。</p></li><li><p>2 表示结束方格，且只有一个结束方格。</p></li><li><p>0 表示我们可以走过的空方格。</p></li><li><p>-1 表示我们无法跨越的障碍。</p></li></ul><p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。</p><p><strong>每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格</strong>。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]输出：2解释：我们有以下两条路径：1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]输出：4解释：我们有以下四条路径： 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)输入：[[0,1],[2,0]]输出：0解释：没有一条路能完全穿过每一个空的方格一次。请注意，起始和结束方格可以位于网格中的任意位置。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= grid.length * grid[0].length &lt;= 20</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>零钱兑换 II—518题</p><p>题述：给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: amount = 5, coins = [1, 2, 5]输出: 4解释: 有四种方式可以凑成总金额:5=55=2+2+15=2+1+1+15=1+1+1+1+1输入: amount = 3, coins = [2]输出: 0解释: 只用面额2的硬币不能凑成总金额3。输入: amount = 10, coins = [10] 输出: 1</code></pre><p><strong>注意:</strong></p><p>你可以假设：</p><ul><li>0 &lt;= amount (总金额) &lt;= 5000</li><li>1 &lt;= coin (硬币面额) &lt;= 5000</li><li>硬币种类不超过 500 种</li><li>结果符合 32 位符号整数</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span> amount<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> coin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> amount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>coin<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>最长有效括号—32题</p><p>题述：给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：s = "(()"输出：2解释：最长有效括号子串是 "()"输入：s = ")()())"输出：4解释：最长有效括号子串是 "()()"输入：s = ""输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>s[i]</code> 为 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>最小路径和—64题</p><p>题述：给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/39.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.jpg" alt="最小路径和"></p><pre class=" language-text"><code class="language-text">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]输出：7解释：因为路径 1→3→1→1→1 的总和最小。输入：grid = [[1,2,3],[4,5,6]]输出：12</code></pre><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>解码方法—91题</p><p>题述：一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><pre class=" language-text"><code class="language-text">'A' -> 1'B' -> 2...'Z' -> 26</code></pre><p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”111” 可以将 “1” 中的每个 “1” 映射为 “A” ，从而得到 “AAA” ，或者可以将 “11” 和 “1”（分别为 “K” 和 “A” ）映射为 “KA” 。注意，”06” 不能映射为 “F” ，因为 “6” 和 “06” 不同。</p><p>给你一个只含数字的 非空 字符串 num ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：s = "12"输出：2解释：它可以解码为 "AB"（1 2）或者 "L"（12）。输入：s = "226"输出：3解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。输入：s = "0"输出：0解释：没有字符映射到以 0 开头的数字。含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。输入：s = "06"输出：0解释："06" 不能映射到 "F" ，因为字符串开头的 0 无法指向一个有效的字符。 </code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含数字，并且可能包含前导零。</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>最大正方形—221题</p><p>题述：在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p><p>示例1：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/40.%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A21.jpg" alt="最大正方形1"></p><pre class=" language-text"><code class="language-text">输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]输出：4</code></pre><p>示例2：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/41.%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A22.jpg" alt="最大正方形2"></p><pre class=" language-text"><code class="language-text">输入：matrix = [["0","1"],["1","0"]]输出：1输入：matrix = [["0"]]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>matrix[i][j] </code>为 <code>&#39;0&#39;</code> 或<code> &#39;1&#39;</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>矩形区域不超过 K 的最大数值和—363题</p><p>题述：给定一个非空二维矩阵 <em>matrix</em> 和一个整数 <em>k</em>，找到这个矩阵内部不大于 <em>k</em> 的最大矩形和。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: matrix = [[1,0,1],[0,-2,3]], k = 2输出: 2 解释: 矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。</code></pre><p><strong>说明：</strong></p><ol><li>矩阵内的矩形区域面积必须大于 0。</li><li>如果行数远大于列数，你将如何解答呢？</li></ol><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>青蛙过河—403题</p><p>题述：一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。</p><p>给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。</p><p>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p><p>请注意：</p><p>石子的数量 ≥ 2 且 &lt; 1100；<br>每一个石子的位置序号都是一个非负整数，且其 &lt; 231；<br>第一个石子的位置永远是0。<br>示例 :</p><pre class=" language-text"><code class="language-text">[0,1,3,5,6,8,12,17]总共有8个石子。第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,第三个石子在序号为3的单元格的位置， 以此定义整个数组...最后一个石子处于序号为17的单元格的位置。返回 true。即青蛙可以成功过河，按照如下方案跳跃： 跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 跳2个单位到第4块石子, 然后跳3个单位到第6块石子, 跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。[0,1,2,3,4,8,9,11]返回 false。青蛙没有办法过河。 这是因为第5和第6个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= stones.length &lt;= 2000</code></li><li><code>0 &lt;= stones[i] &lt;= 231 - 1</code></li><li><code>stones[0] == 0</code></li></ul><p>实现</p><pre class=" language-text"><code class="language-text"></code></pre></li><li><p>分割数组的最大值—410题</p><p>题述：给定一个非负整数数组 <code>nums</code> 和一个整数 <code>m</code> ，你需要将这个数组分成 <code>m</code> 个非空的连续子数组。</p><p>设计一个算法使得这 <code>m</code> 个子数组各自和的最大值最小。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [7,2,5,10,8], m = 2输出：18解释：一共有四种方法将 nums 分割为 2 个子数组。 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。输入：nums = [1,2,3,4,5], m = 2输出：9输入：nums = [1,4,4], m = 3输出：4</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 106</code></li><li><code>1 &lt;= m &lt;= min(50, nums.length)</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>学生出勤记录 II—552题</p><p>题述：给定一个正整数 n，返回长度为 n 的所有可被视为可奖励的出勤记录的数量。 答案可能非常大，你只需返回结果mod 109 + 7的值。</p><p>学生出勤记录是只包含以下三个字符的字符串：</p><ol><li>‘A’ : Absent，缺勤</li><li>‘L’ : Late，迟到</li><li>‘P’ : Present，到场</li></ol><p>如果记录不包含多于一个’A’（缺勤）或超过两个连续的’L’（迟到），则该记录被视为可奖励的。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: n = 2输出: 8 解释：有8个长度为2的记录将被视为可奖励："PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL"只有"AA"不会被视为可奖励，因为缺勤次数超过一次。</code></pre><p><strong>注意：n</strong> 的值不会超过100000。</p><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>任务调度器—621题</p><p>题述：给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p><p>然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的 最短时间 。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：tasks = ["A","A","A","B","B","B"], n = 2输出：8解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 输入：tasks = ["A","A","A","B","B","B"], n = 0输出：6解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0["A","A","A","B","B","B"]["A","B","A","B","A","B"]["B","B","B","A","A","A"]...诸如此类输入：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2输出：16解释：一种可能的解决方案是：     A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= task.length &lt;= 104</code></li><li><code>tasks[i]</code> 是大写英文字母</li><li><code>n</code> 的取值范围为 <code>[0, 100]</code></li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>回文子串—647题</p><p>题述：给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入："abc"输出：3解释：三个回文子串: "a", "b", "c"输入："aaa"输出：6解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"</code></pre><p><strong>提示：</strong></p><ul><li>输入的字符串长度不会超过 1000 。</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>最小覆盖子串—76题</p><p>题述：给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：s = "ADOBECODEBANC", t = "ABC"输出："BANC"输入：s = "a", t = "a"输出："a"</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 10^5</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p><strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>戳气球—312题</p><p>题述：有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p><p>求所能获得硬币的最大数量。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [3,1,5,8]输出：167解释：nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167输入：nums = [1,5]输出：10</code></pre><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> iNums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> iNums<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    iNums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> iNums<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> left <span class="token operator">&lt;</span> n <span class="token operator">-</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> left <span class="token operator">+</span> k<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> right<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span>                                           iNums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">*</span> iNums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> iNums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="4-9-高级搜索"><a href="#4-9-高级搜索" class="headerlink" title="4.9 高级搜索"></a>4.9 高级搜索</h3><h4 id="4-9-1-简介"><a href="#4-9-1-简介" class="headerlink" title="4.9.1 简介"></a>4.9.1 简介</h4><ol><li><p>A*代码模板</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AStar</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> BAR <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 障碍值</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> PATH <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 路径</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> DIRECT_VALUE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 横竖移动代价</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> OBLIQUE_VALUE <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 斜移动代价</span>    Queue<span class="token operator">&lt;</span>Node<span class="token operator">></span> openList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span>Node<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 优先队列(升序)</span>    List<span class="token operator">&lt;</span>Node<span class="token operator">></span> closeList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Node<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 开始算法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span>MapInfo mapInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mapInfo <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// clean</span>        openList<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        closeList<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 开始搜索</span>        openList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>mapInfo<span class="token punctuation">.</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">moveNodes</span><span class="token punctuation">(</span>mapInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 移动当前结点     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">moveNodes</span><span class="token punctuation">(</span>MapInfo mapInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>openList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node current <span class="token operator">=</span> openList<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        closeList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addNeighborNodeInOpen</span><span class="token punctuation">(</span>mapInfo<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isCoordInClose</span><span class="token punctuation">(</span>mapInfo<span class="token punctuation">.</span>end<span class="token punctuation">.</span>coord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">drawPath</span><span class="token punctuation">(</span>mapInfo<span class="token punctuation">.</span>maps<span class="token punctuation">,</span> mapInfo<span class="token punctuation">.</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 在二维数组中绘制路径     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">drawPath</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> maps<span class="token punctuation">,</span> Node end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">==</span> null <span class="token operator">||</span> maps <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"总代价："</span> <span class="token operator">+</span> end<span class="token punctuation">.</span>G<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Coord c <span class="token operator">=</span> end<span class="token punctuation">.</span>coord<span class="token punctuation">;</span>            maps<span class="token punctuation">[</span>c<span class="token punctuation">.</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">.</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> PATH<span class="token punctuation">;</span>            end <span class="token operator">=</span> end<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 添加所有邻结点到open表     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addNeighborNodeInOpen</span><span class="token punctuation">(</span>MapInfo mapInfo<span class="token punctuation">,</span> Node current<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> current<span class="token punctuation">.</span>coord<span class="token punctuation">.</span>x<span class="token punctuation">;</span>        <span class="token keyword">int</span> y <span class="token operator">=</span> current<span class="token punctuation">.</span>coord<span class="token punctuation">.</span>y<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 左</span>        <span class="token function">addNeighborNodeInOpen</span><span class="token punctuation">(</span>mapInfo<span class="token punctuation">,</span> current<span class="token punctuation">,</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">,</span> DIRECT_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 上</span>        <span class="token function">addNeighborNodeInOpen</span><span class="token punctuation">(</span>mapInfo<span class="token punctuation">,</span> current<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> DIRECT_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 右</span>        <span class="token function">addNeighborNodeInOpen</span><span class="token punctuation">(</span>mapInfo<span class="token punctuation">,</span> current<span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">,</span> DIRECT_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 下</span>        <span class="token function">addNeighborNodeInOpen</span><span class="token punctuation">(</span>mapInfo<span class="token punctuation">,</span> current<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> DIRECT_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 左上</span>        <span class="token function">addNeighborNodeInOpen</span><span class="token punctuation">(</span>mapInfo<span class="token punctuation">,</span> current<span class="token punctuation">,</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> OBLIQUE_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 右上</span>        <span class="token function">addNeighborNodeInOpen</span><span class="token punctuation">(</span>mapInfo<span class="token punctuation">,</span> current<span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> OBLIQUE_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 右下</span>        <span class="token function">addNeighborNodeInOpen</span><span class="token punctuation">(</span>mapInfo<span class="token punctuation">,</span> current<span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> OBLIQUE_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 左下</span>        <span class="token function">addNeighborNodeInOpen</span><span class="token punctuation">(</span>mapInfo<span class="token punctuation">,</span> current<span class="token punctuation">,</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> OBLIQUE_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 添加一个邻结点到open表     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addNeighborNodeInOpen</span><span class="token punctuation">(</span>MapInfo mapInfo<span class="token punctuation">,</span> Node current<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">canAddNodeToOpen</span><span class="token punctuation">(</span>mapInfo<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node end <span class="token operator">=</span> mapInfo<span class="token punctuation">.</span>end<span class="token punctuation">;</span>            Coord coord <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coord</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> G <span class="token operator">=</span> current<span class="token punctuation">.</span>G <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 计算邻结点的G值</span>            Node child <span class="token operator">=</span> <span class="token function">findNodeInOpen</span><span class="token punctuation">(</span>coord<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> H <span class="token operator">=</span> <span class="token function">calcH</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span>coord<span class="token punctuation">,</span> coord<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 计算H值</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEndNode</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span>coord<span class="token punctuation">,</span> coord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    child <span class="token operator">=</span> end<span class="token punctuation">;</span>                    child<span class="token punctuation">.</span>parent <span class="token operator">=</span> current<span class="token punctuation">;</span>                    child<span class="token punctuation">.</span>G <span class="token operator">=</span> G<span class="token punctuation">;</span>                    child<span class="token punctuation">.</span>H <span class="token operator">=</span> H<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>coord<span class="token punctuation">,</span> current<span class="token punctuation">,</span> G<span class="token punctuation">,</span> H<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                openList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>G <span class="token operator">></span> G<span class="token punctuation">)</span> <span class="token punctuation">{</span>                child<span class="token punctuation">.</span>G <span class="token operator">=</span> G<span class="token punctuation">;</span>                child<span class="token punctuation">.</span>parent <span class="token operator">=</span> current<span class="token punctuation">;</span>                openList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从Open列表中查找结点     */</span>    <span class="token keyword">private</span> Node <span class="token function">findNodeInOpen</span><span class="token punctuation">(</span>Coord coord<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>coord <span class="token operator">==</span> null <span class="token operator">||</span> openList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node node <span class="token operator">:</span> openList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>coord<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>coord<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> node<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 计算H的估值：“曼哈顿”法，坐标分别取差值相加     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">calcH</span><span class="token punctuation">(</span>Coord end<span class="token punctuation">,</span> Coord coord<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span>x <span class="token operator">-</span> coord<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span>y <span class="token operator">-</span> coord<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 判断结点是否是最终结点     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isEndNode</span><span class="token punctuation">(</span>Coord end<span class="token punctuation">,</span> Coord coord<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> coord <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> end<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>coord<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 判断结点能否放入Open列表     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">canAddNodeToOpen</span><span class="token punctuation">(</span>MapInfo mapInfo<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 是否在地图中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> x <span class="token operator">>=</span> mapInfo<span class="token punctuation">.</span>width <span class="token operator">||</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">>=</span> mapInfo<span class="token punctuation">.</span>hight<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 判断是否是不可通过的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mapInfo<span class="token punctuation">.</span>maps<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">==</span> BAR<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 判断结点是否存在close表</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isCoordInClose</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 判断坐标是否在close表中     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isCoordInClose</span><span class="token punctuation">(</span>Coord coord<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> coord <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token function">isCoordInClose</span><span class="token punctuation">(</span>coord<span class="token punctuation">.</span>x<span class="token punctuation">,</span> coord<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 判断坐标是否在close表中     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isCoordInClose</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>closeList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node node <span class="token operator">:</span> closeList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>coord<span class="token punctuation">.</span>x <span class="token operator">==</span> x <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>coord<span class="token punctuation">.</span>y <span class="token operator">==</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="4-9-2-练习"><a href="#4-9-2-练习" class="headerlink" title="4.9.2 练习"></a>4.9.2 练习</h4><ol><li><p>有效的数独—36题</p><p>题述：判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><ol><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/42.%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC.png" alt="有效数独"></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入:[  ["5","3",".",".","7",".",".",".","."],  ["6",".",".","1","9","5",".",".","."],  [".","9","8",".",".",".",".","6","."],  ["8",".",".",".","6",".",".",".","3"],  ["4",".",".","8",".","3",".",".","1"],  ["7",".",".",".","2",".",".",".","6"],  [".","6",".",".",".",".","2","8","."],  [".",".",".","4","1","9",".",".","5"],  [".",".",".",".","8",".",".","7","9"]]输出: true输入:[  ["8","3",".",".","7",".",".",".","."],  ["6",".",".","1","9","5",".",".","."],  [".","9","8",".",".",".",".","6","."],  ["8",".",".",".","6",".",".",".","3"],  ["4",".",".","8",".","3",".",".","1"],  ["7",".",".",".","2",".",".",".","6"],  [".","6",".",".",".",".","2","8","."],  [".",".",".","4","1","9",".",".","5"],  [".",".",".",".","8",".",".","7","9"]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</code></pre><p>说明:</p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li>给定数独序列只包含数字 <code>1-9</code> 和字符<code>&#39;.&#39;</code>。</li><li>给定数独永远是 <code>9x9</code> 形式的。</li></ul><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>解数独—37题</p><p>题述：编写一个程序，通过填充空格来解决数独问题。</p><p>一个数独的解法需遵循如下规则：</p><ol><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li></ol><p>空白格用 ‘.’ 表示。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/42.%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC.png" alt="解数独"></p><p>一个数独。</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/43.%E8%A7%A3%E6%95%B0%E7%8B%AC.png" alt="解数独"></p><p>答案被标成红色。</p><pre class=" language-text"><code class="language-text">输入: board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]输出: [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]</code></pre><p><strong>提示：</strong></p><ul><li>给定的数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li><li>你可以假设给定的数独只有唯一解。</li><li>给定数独永远是 <code>9x9</code> 形式的。</li></ul></li><li><p>二进制矩阵中的最短路径—1091题</p><p>题述：给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。</p><p>二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：</p><p>路径途经的所有单元格都的值都是 0 。<br>路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。<br>畅通路径的长度 是该路径途经的单元格总数。</p><p>示例1：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/44.%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%841.png" alt="二进制矩阵的最短路径1"></p><pre class=" language-text"><code class="language-text">输入：grid = [[0,1],[1,0]]输出：2</code></pre><p>示例2：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/45.%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%842.png" alt="二进制矩阵的最短路径2"></p><pre class=" language-text"><code class="language-text">输入：grid = [[0,0,0],[1,1,0],[1,1,0]]输出：4输入：grid = [[1,0,0],[1,1,0],[1,1,0]]输出：-1</code></pre><p><strong>提示：</strong></p><ul><li><code>n == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>滑动谜题—773题</p><p>题述：在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示.</p><p>一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换.</p><p>最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。</p><p>给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：board = [[1,2,3],[4,0,5]]输出：1解释：交换 0 和 5 ，1 步完成输入：board = [[1,2,3],[5,4,0]]输出：-1解释：没有办法完成谜板    输入：board = [[4,1,2],[5,0,3]]输出：5解释：最少完成谜板的最少移动次数是 5 ，一种移动路径:尚未移动: [[4,1,2],[5,0,3]]移动 1 次: [[4,1,2],[0,5,3]]移动 2 次: [[0,1,2],[4,5,3]]移动 3 次: [[1,0,2],[4,5,3]]移动 4 次: [[1,2,0],[4,5,3]]移动 5 次: [[1,2,3],[4,5,0]]输入：board = [[3,2,4],[1,5,0]]输出：14</code></pre><p><strong>提示：</strong></p><ul><li><code>board</code> 是一个如上所述的 2 x 3 的数组.</li><li><code>board[i][j]</code> 是一个 <code>[0, 1, 2, 3, 4, 5]</code> 的排列.</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h3 id="4-10-位运算"><a href="#4-10-位运算" class="headerlink" title="4.10 位运算"></a>4.10 位运算</h3><h4 id="4-10-1-简介"><a href="#4-10-1-简介" class="headerlink" title="4.10.1 简介"></a>4.10.1 简介</h4><h4 id="4-10-2-练习"><a href="#4-10-2-练习" class="headerlink" title="4.10.2 练习"></a>4.10.2 练习</h4><ol><li><p>位1的个数—191题</p><p>题述：编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">汉明重量</a>）。</p><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</li></ul><p>示例：</p><pre class=" language-text"><code class="language-text">输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。</code></pre><p><strong>注意：</strong></p><ul><li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li></ul><p><strong>进阶</strong>：</p><ul><li>如果多次调用这个函数，你将如何优化你的算法？</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>2的幂—231题</p><p>题述：给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p><p>示例</p><pre class=" language-text"><code class="language-text">输入: 1输出: true解释: 20 = 1输入: 16输出: true解释: 24 = 16输入: 218输出: false</code></pre></li><li><p>颠倒二进制位—190题</p><p>题述：颠倒给定的 32 位无符号整数的二进制位。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</code></pre><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</li></ul><p><strong>进阶</strong>:<br>如果多次调用这个函数，你将如何优化你的算法？</p><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>N皇后 II—52题</p><p>题述：n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/29.N%E7%9A%87%E5%90%8E.jpg" alt="N皇后"></p><pre class=" language-text"><code class="language-text">输入：n = 4输出：2解释：如上图所示，4 皇后问题存在两个不同的解法。输入：n = 1输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>比特位计数—338题</p><p>题述：给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: 2输出: [0,1,1]输入: 5输出: [0,1,1,2,1,2]</code></pre><p>进阶:</p><ul><li>给出时间复杂度为<code>O(n*sizeof(integer))</code>的解答非常容易。但你可以在线性时间<code>O(n)</code>内用一趟扫描做到吗？</li><li>要求算法的空间复杂度为<code>O(n)</code>。</li><li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h3 id="4-11-布隆过滤器和LRU缓存"><a href="#4-11-布隆过滤器和LRU缓存" class="headerlink" title="4.11 布隆过滤器和LRU缓存"></a>4.11 布隆过滤器和LRU缓存</h3><h4 id="4-11-1-简介"><a href="#4-11-1-简介" class="headerlink" title="4.11.1 简介"></a>4.11.1 简介</h4><ol><li><p>使用场景</p><ol><li>检查英语单词是否拼写正确</li><li>网络爬虫中，一个网站是否被访问过</li><li>邮箱的垃圾邮件过滤功能</li></ol></li><li><p>场景一般解决方法</p><ol><li>数组</li><li>链表</li><li>树，平衡二叉树</li><li>Map，红黑树</li><li>哈希表</li></ol></li><li><p>哈希函数</p><blockquote><p>将任意大小的数据转换成特定大小的数据的函数，转换后的数据称为哈希值或哈希编码</p></blockquote><p>图示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/46.%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86.png" alt="哈希函数原理"></p><p>哈希函数是实现哈希表和布隆过滤器的基础</p></li><li><p>布隆过滤器介绍</p><ol><li>一个很长的二进制向量 （位数组）</li><li>一系列随机函数 (哈希)</li><li>空间效率和查询效率高</li><li>有一定的误判率（哈希表是精确匹配）</li></ol></li><li><p>布隆过滤器原理</p><blockquote><p>核心实现是一个超大的位数组和几个哈希函数</p></blockquote><p>假设位数组的长度为m，哈希函数的个数为k</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/47.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" alt="布隆过滤器示例图"></p><p>以上图为例，具体的操作流程：假设集合里面有3个元素&#123;x, y, z&#125;，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置位0。对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1。查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中。注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因。</p></li><li><p>布隆过滤器添加元素</p><ol><li>将要添加的元素给k个哈希函数</li><li>得到对应于位数组上的k个位置</li><li>将这k个位置设为1</li></ol></li><li><p>布隆过滤器查询元素</p><ol><li>将要查询的元素给k个哈希函数</li><li>得到对应于位数组上的k个位置</li><li>如果k个位置有一个为0，则肯定不在集合中</li><li>如果k个位置全部为1，则可能在集合中</li></ol></li><li><p>应用</p><ol><li>缓存穿透</li><li>垃圾邮件识别</li><li>集合判重</li></ol></li><li><p>布隆过滤器实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BloomFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> BitSet hashes<span class="token punctuation">;</span>    <span class="token keyword">private</span> RandomInRange prng<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> k<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Number of hash functions</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">double</span> LN2 <span class="token operator">=</span> <span class="token number">0.6931471805599453</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ln(2)</span>    <span class="token comment" spellcheck="true">/**     * Create a new bloom filter.     *     * @param n Expected number of elements     * @param m Desired size of the container in bits     **/</span>    <span class="token keyword">public</span> <span class="token function">BloomFilter</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        k <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>LN2 <span class="token operator">*</span> m <span class="token operator">/</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hashes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BitSet</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>prng <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomInRange</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Create a bloom filter of 1Mib.     *     * @param n Expected number of elements     **/</span>    <span class="token keyword">public</span> <span class="token function">BloomFilter</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Add an element to the container     **/</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        prng<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>RandomInRange r <span class="token operator">:</span> prng<span class="token punctuation">)</span> hashes<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * If the element is in the container, returns true.     * If the element is not in the container, returns true with a probability ≈ e^(-ln(2)² * m/n), otherwise false.     * So, when m is large enough, the return value can be interpreted as:     * - true  : the element is probably in the container     * - false : the element is definitely not in the container     **/</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        prng<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>RandomInRange r <span class="token operator">:</span> prng<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hashes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Removes all of the elements from this filter.     **/</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        hashes<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Create a copy of the current filter     **/</span>    <span class="token keyword">public</span> BloomFilter <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>BloomFilter<span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Generate a unique hash representing the filter     **/</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> hashes<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">^</span> k<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Test if the filters have equal bitsets.     * WARNING: two filters may contain the same elements, but not be equal     * (if the filters have different size for example).     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>BloomFilter other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hashes<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>hashes<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>k <span class="token operator">==</span> other<span class="token punctuation">.</span>k<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Merge another bloom filter into the current one.     * After this operation, the current bloom filter contains all elements in     * other.     **/</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>BloomFilter other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>other<span class="token punctuation">.</span>k <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>k <span class="token operator">||</span> other<span class="token punctuation">.</span>hashes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hashes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Incompatible bloom filters"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hashes<span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>hashes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">RandomInRange</span>            <span class="token keyword">implements</span> <span class="token class-name">Iterable</span><span class="token operator">&lt;</span>RandomInRange<span class="token operator">></span><span class="token punctuation">,</span> Iterator<span class="token operator">&lt;</span>RandomInRange<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> Random prng<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> max<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Maximum value returned + 1</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Number of random elements to generate</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Number of elements generated</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// The current value</span>        <span class="token function">RandomInRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> maximum<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            max <span class="token operator">=</span> maximum<span class="token punctuation">;</span>            count <span class="token operator">=</span> k<span class="token punctuation">;</span>            prng <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            prng<span class="token punctuation">.</span><span class="token function">setSeed</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>RandomInRange<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> RandomInRange <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            value <span class="token operator">=</span> prng<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> max<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> value <span class="token operator">=</span> <span class="token operator">-</span>value<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>LRU缓存</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 缓存映射表     */</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> DLinkNode<span class="token operator">></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 缓存大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 缓存容量     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 链表头部和尾部     */</span>    <span class="token keyword">private</span> DLinkNode head<span class="token punctuation">,</span> tail<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//初始化缓存大小，容量和头尾节点</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>        tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取节点          * @param key 节点的键          * @return 返回节点的值     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        DLinkNode node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//移动到链表头部</span>        <span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 添加节点          * @param key 节点的键          * @param value 节点的值     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        DLinkNode node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            DLinkNode newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkNode</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//添加到链表头部            </span>            <span class="token function">addToHead</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>size<span class="token punctuation">;</span>            如果缓存已满，需要清理尾部节点                <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">></span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    DLinkNode tail <span class="token operator">=</span> <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tail<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">--</span>size<span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//移动到链表头部            </span>            <span class="token function">moveToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除尾结点          *          * @return 返回删除的节点     */</span>    <span class="token keyword">private</span> DLinkNode <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        DLinkNode node <span class="token operator">=</span> tail<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除节点          * @param node 需要删除的节点     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeNode</span><span class="token punctuation">(</span>DLinkNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 把节点添加到链表头部          *          * @param node 要添加的节点     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addToHead</span><span class="token punctuation">(</span>DLinkNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 把节点移动到头部          * @param node 需要移动的节点     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">moveToHead</span><span class="token punctuation">(</span>DLinkNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 链表节点类     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DLinkNode</span> <span class="token punctuation">{</span>        Integer key<span class="token punctuation">;</span>        Integer value<span class="token punctuation">;</span>        DLinkNode prev<span class="token punctuation">;</span>        DLinkNode next<span class="token punctuation">;</span>        <span class="token function">DLinkNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token function">DLinkNode</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">,</span> Integer value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="4-11-2-练习"><a href="#4-11-2-练习" class="headerlink" title="4.11.2 练习"></a>4.11.2 练习</h4><ol><li><p>LRU 缓存机制—146题</p><p>题述：运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 {1=1}lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}lRUCache.get(1);    // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.get(2);    // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}lRUCache.get(1);    // 返回 -1 (未找到)lRUCache.get(3);    // 返回 3lRUCache.get(4);    // 返回 4</code></pre><p>提示：</p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 3000</code></li><li><code>0 &lt;= value &lt;= 104</code></li><li>最多调用 <code>3 * 10^4</code> 次 <code>get</code> 和 <code>put</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h2 id="5-重要算法"><a href="#5-重要算法" class="headerlink" title="5. 重要算法"></a>5. 重要算法</h2><h3 id="5-1-排序算法"><a href="#5-1-排序算法" class="headerlink" title="5.1 排序算法"></a>5.1 排序算法</h3><h4 id="5-1-1-十大排序算法"><a href="#5-1-1-十大排序算法" class="headerlink" title="5.1.1 十大排序算法"></a>5.1.1 十大排序算法</h4><ol><li><p>算法复杂度</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/53.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="排序算法时间复杂度"></p></li><li><p>解释</p><ol><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li></ol></li></ol><h5 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a>1. 冒泡排序（Bubble Sort）</h5><ol><li><p>算法描述</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ol></li><li><p>演示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/54.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序"></p></li><li><p>实现</p><pre class=" language-java"><code class="language-java">function <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>var i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>var j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 相邻元素两两对比</span>                var temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 元素交换</span>                arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h5 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2. 选择排序（Selection Sort）"></a>2. 选择排序（Selection Sort）</h5><ol><li><p>算法描述</p></li><li><p>演示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/55.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序"></p></li><li><p>实现</p><pre class=" language-java"><code class="language-java">function <span class="token function">selectionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    var minIndex<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>var i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>var j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 寻找最小的数</span>                minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 将最小数的索引保存</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre></li></ol><h5 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.  插入排序（Insertion Sort）"></a>3.  插入排序（Insertion Sort）</h5><ol><li><p>算法描述</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol></li><li><p>演示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/56.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p></li><li><p>实现</p><pre class=" language-java"><code class="language-java">function <span class="token function">insertionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    var preIndex<span class="token punctuation">,</span> current<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>var i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        preIndex <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        current <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">></span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>            preIndex<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h5 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4. 希尔排序（Shell Sort）"></a>4. 希尔排序（Shell Sort）</h5><ol><li><p>算法描述</p><ol><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol></li><li><p>演示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/57.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="希尔排序"></p></li><li><p>实现</p><pre class=" language-java"><code class="language-java">function <span class="token function">shellSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>var gap <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>gap <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>var i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            var j <span class="token operator">=</span> i<span class="token punctuation">;</span>            var current <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> gap <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> current <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>                j <span class="token operator">=</span> j <span class="token operator">-</span> gap<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h5 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5. 归并排序（Merge Sort）"></a>5. 归并排序（Merge Sort）</h5><ol><li><p>算法描述</p><ol><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol></li><li><p>演示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/58.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p></li><li><p>实现</p><pre class=" language-java"><code class="language-java">function <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    var middle <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    left <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">,</span>    right <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>middle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>function <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>length<span class="token operator">></span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">.</span>length<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h5 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6. 快速排序（Quick Sort）"></a>6. 快速排序（Quick Sort）</h5><ol><li><p>算法描述</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol></li><li><p>演示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/59.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序"></p></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Java</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">&lt;=</span> begin<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">quickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">quickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//pivot: 标杆位置，counter: 小于pivot的元素的个数</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> end<span class="token punctuation">,</span> counter <span class="token operator">=</span> begin<span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">[</span>counter<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>counter<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                 counter<span class="token operator">++</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>counter<span class="token punctuation">]</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span>counter<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>     <span class="token keyword">return</span> counter<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h5 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7. 堆排序（Heap Sort）"></a>7. 堆排序（Heap Sort）</h5><ol><li><p>算法描述</p><ol><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ol></li><li><p>演示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/60.%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p></li><li><p>实现</p><pre class=" language-java"><code class="language-java">var len<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span>function <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 建立大顶堆</span>    len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>var i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>function <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 堆调整</span>    var left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>    right <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span>    largest <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        largest <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        largest <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>function <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span>function <span class="token function">heapSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>var i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        len<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h5 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8. 计数排序（Counting Sort）"></a>8. 计数排序（Counting Sort）</h5><ol><li><p>算法描述</p><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ol></li><li><p>演示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/61.%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="计数排序"></p></li><li><p>实现</p><pre class=" language-java"><code class="language-java">function <span class="token function">countingSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>maxValue <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    sortedIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    arrLen <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">,</span>    bucketLen <span class="token operator">=</span> maxValue <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>var i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>var j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bucketLen<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>sortedIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h5 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9. 桶排序（Bucket Sort）"></a>9. 桶排序（Bucket Sort）</h5><ol><li><p>算法描述</p><ol><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ol></li><li><p>演示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/62.%E6%A1%B6%E6%8E%92%E5%BA%8F.png" alt="桶排序"></p></li><li><p>实现</p><pre class=" language-java"><code class="language-java">function <span class="token function">bucketSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> bucketSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    var i<span class="token punctuation">;</span>    var minValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    var maxValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            minValue <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 输入数据的最小值</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxValue <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 输入数据的最大值</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 桶的初始化</span>    var DEFAULT_BUCKET_SIZE <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 设置桶的默认数量为5</span>    bucketSize <span class="token operator">=</span> bucketSize <span class="token operator">||</span> DEFAULT_BUCKET_SIZE<span class="token punctuation">;</span>    var bucketCount <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxValue <span class="token operator">-</span> minValue<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      var buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>bucketCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> buckets<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 利用映射函数将数据分配到各个桶中</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        buckets<span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minValue<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    arr<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> buckets<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">insertionSort</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 对每个桶进行排序，这里使用了插入排序</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>var j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h5 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10. 基数排序（Radix Sort）"></a>10. 基数排序（Radix Sort）</h5><ol><li><p>算法描述</p><ol><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li></ol></li><li><p>演示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/63.%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序"></p></li><li><p>实现</p><pre class=" language-java"><code class="language-java">var counter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>function <span class="token function">radixSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> maxDigit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var mod <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    var dev <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>var i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxDigit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> dev <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">,</span> mod <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>var j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            var bucket <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">%</span> mod<span class="token punctuation">)</span> <span class="token operator">/</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>bucket<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                counter<span class="token punctuation">[</span>bucket<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            counter<span class="token punctuation">[</span>bucket<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        var pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>var j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> counter<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            var value <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>value <span class="token operator">=</span> counter<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="5-2-高阶动态规划"><a href="#5-2-高阶动态规划" class="headerlink" title="5.2 高阶动态规划"></a>5.2 高阶动态规划</h3><h4 id="5-2-1-简介"><a href="#5-2-1-简介" class="headerlink" title="5.2.1 简介"></a>5.2.1 简介</h4><h4 id="5-2-2-练习"><a href="#5-2-2-练习" class="headerlink" title="5.2.2 练习"></a>5.2.2 练习</h4><ol><li><p>使用最小花费爬楼梯—746题</p><p>题述：数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出：6解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</code></pre><p><strong>提示：</strong></p><ul><li><code>cost</code> 的长度范围是 <code>[2, 1000]</code>。</li><li><code>cost[i]</code> 将会是一个整型数据，范围为 <code>[0, 999]</code> 。</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>最长递增子序列—300题</p><p>题述：给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。输入：nums = [0,1,0,3,2,3]输出：4输入：nums = [7,7,7,7,7,7,7]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你可以设计时间复杂度为 O(n2) 的解决方案吗？</li><li>你能将算法的时间复杂度降低到 O(n log(n)) 吗?</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>最大矩形—85题</p><p>题述：给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/JK/algorithm/64.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.jpg" alt="最大矩形"></p><pre class=" language-text"><code class="language-text">输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]输出：6解释：最大矩形如上图所示。输入：matrix = []输出：0输入：matrix = [["0"]]输出：0输入：matrix = [["1"]]输出：1输入：matrix = [["0","0"]]输出：0</code></pre><p>提示：</p><ul><li><code>rows == matrix.length</code></li><li><code>cols == matrix[0].length</code></li><li><code>0 &lt;= row, cols &lt;= 200</code></li><li><code>matrix[i][j] </code>为 <code>&#39;0&#39;</code> 或<code> &#39;1&#39;</code></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>不同子序列—115题</p><p>题述：给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：s = "rabbbit", t = "rabbit"输出：3解释：如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。(上箭头符号 ^ 表示选取的字母)rabbbit^^^^ ^^rabbbit^^ ^^^^rabbbit^^^ ^^^输入：s = "babgbag", t = "bag"输出：5解释：如下图所示, 有 5 种可以从 s 中得到 "bag" 的方案。 (上箭头符号 ^ 表示选取的字母)babgbag^^ ^babgbag^^    ^babgbag^    ^^babgbag  ^  ^^babgbag    ^^^</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>赛车—818题</p><p>题述：你的赛车起始停留在位置 0，速度为 +1，正行驶在一个无限长的数轴上。（车也可以向负数方向行驶。）</p><p>你的车会根据一系列由 A（加速）和 R（倒车）组成的指令进行自动驾驶 。</p><p>当车得到指令 “A” 时, 将会做出以下操作： position += speed, speed *= 2。</p><p>当车得到指令 “R” 时, 将会做出以下操作：如果当前速度是正数，则将车速调整为 speed = -1 ；否则将车速调整为 speed = 1。  (当前所处位置不变。)</p><p>例如，当得到一系列指令 “AAR” 后, 你的车将会走过位置 0-&gt;1-&gt;3-&gt;3，并且速度变化为 1-&gt;2-&gt;4-&gt;-1。</p><p>现在给定一个目标位置，请给出能够到达目标位置的最短指令列表的长度。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: target = 3输出: 2解释: 最短指令列表为 "AA"位置变化为 0->1->3输入: target = 6输出: 5解释: 最短指令列表为 "AAARA"位置变化为 0->1->3->7->7->6</code></pre><p><strong>说明:</strong></p><ul><li><code>1 &lt;= target（目标位置） &lt;= 10000</code>。</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h3 id="5-3-字符串算法"><a href="#5-3-字符串算法" class="headerlink" title="5.3 字符串算法"></a>5.3 字符串算法</h3><h4 id="5-3-1-Atoi代码示例"><a href="#5-3-1-Atoi代码示例" class="headerlink" title="5.3.1 Atoi代码示例"></a>5.3.1 Atoi代码示例</h4><ol><li><p>示例</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Java</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">myAtoi</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sign <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//1. Empty string</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//2. Remove Spaces</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">' '</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        index<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//3. Handle signs</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sign <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        index<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//4. Convert number and avoid overflow</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> digit <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>digit <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> digit <span class="token operator">></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//check if total will be overflow after 10 times and add digit</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">&lt;</span> total <span class="token operator">||</span>            Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">==</span> total <span class="token operator">&amp;&amp;</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">&lt;</span> digit<span class="token punctuation">)</span>            <span class="token keyword">return</span> sign <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        total <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> total <span class="token operator">+</span> digit<span class="token punctuation">;</span>        index<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> total <span class="token operator">*</span> sign<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="5-3-2-字符串基础"><a href="#5-3-2-字符串基础" class="headerlink" title="5.3.2 字符串基础"></a>5.3.2 字符串基础</h4><ol><li><p>转换成小写字母—709题</p><p>题述：实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: "Hello"输出: "hello"输入: "here"输出: "here"输入: "LOVELY"输出: "lovely"</code></pre><p>实现：</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>最后一个单词的长度—58题</p><p>题述：给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。</p><p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><p>示例：</p><pre class=" language-java"><code class="language-java">输入：s <span class="token operator">=</span> <span class="token string">"Hello World"</span>输出：<span class="token number">5</span>输入：s <span class="token operator">=</span> <span class="token string">" "</span>输出：<span class="token number">0</span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅有英文字母和空格 <code>&#39; &#39;</code> 组成</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>宝石与石头—771题</p><p>题述： 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: J = "aA", S = "aAAbbbb"输出: 3输入: J = "z", S = "ZZ"输出: 0</code></pre><p><strong>注意:</strong></p><ul><li><code>S</code> 和 <code>J</code> 最多含有50个字母。</li><li> <code>J</code> 中的字符不重复。</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>字符串中的第一个唯一字符—387题</p><p>题述： 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p>示例：</p><pre class=" language-text"><code class="language-text">s = "leetcode"返回 0s = "loveleetcode"返回 2</code></pre><p><strong>提示：</strong>你可以假定该字符串只包含小写字母。</p><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>字符串转换整数 (atoi)—8题</p><p>题述： 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p><p>函数 myAtoi(string s) 的算法如下：</p><ul><li>读入字符串并丢弃无用的前导空格</li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li><li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li><li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li><li>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。</li><li>返回整数作为最终结果。</li></ul><p><strong>注意：</strong></p><ul><li><p>本题中的空白字符只包括空格字符 ‘ ‘ 。</p></li><li><p>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</p></li></ul><p>示例：</p><pre class=" language-text"><code class="language-text">输入：s = "42"输出：42解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。第 1 步："42"（当前没有读入字符，因为没有前导空格）         ^第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）         ^第 3 步："42"（读入 "42"）           ^解析得到整数 42 。由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。输入：s = "   -42"输出：-42解释：第 1 步："   -42"（读入前导空格，但忽视掉）            ^第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）             ^第 3 步："   -42"（读入 "42"）               ^解析得到整数 -42 。由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。输入：s = "4193 with words"输出：4193解释：第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）         ^第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）         ^第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）             ^解析得到整数 4193 。由于 "4193" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。输入：s = "words and 987"输出：0解释：第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）         ^第 2 步："words and 987"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）         ^第 3 步："words and 987"（由于当前字符 'w' 不是一个数字，所以读入停止）         ^解析得到整数 0 ，因为没有读入任何数字。由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。输入：s = "-91283472332"输出：-2147483648解释：第 1 步："-91283472332"（当前没有读入字符，因为没有前导空格）         ^第 2 步："-91283472332"（读入 '-' 字符，所以结果应该是负数）          ^第 3 步："-91283472332"（读入 "91283472332"）                     ^解析得到整数 -91283472332 。由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 200</code></li><li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h4 id="5-3-3-字符串操作"><a href="#5-3-3-字符串操作" class="headerlink" title="5.3.3 字符串操作"></a>5.3.3 字符串操作</h4><ol><li><p>最长公共前缀—14题</p><p>题述：编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：strs = ["flower","flow","flight"]输出："fl"输入：strs = ["dog","racecar","car"]输出：""解释：输入不存在公共前缀。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> 仅由小写英文字母组成</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>反转字符串—344题</p><p>题述：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 </p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：["h","e","l","l","o"]输出：["o","l","l","e","h"]输入：["H","a","n","n","a","h"]输出：["h","a","n","n","a","H"]</code></pre><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>反转字符串 II—541题</p><p>题述：给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</p><ul><li>如果剩余字符少于 k 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</li></ul><p>示例：</p><pre class=" language-text"><code class="language-text">输入: s = "abcdefg", k = 2输出: "bacdfeg"</code></pre><p><strong>提示：</strong></p><ol><li>该字符串只包含小写英文字母。</li><li>给定字符串的长度和 <code>k</code> 在 <code>[1, 10000]</code> 范围内。</li></ol><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>翻转字符串里的单词—151题</p><p>题述：给定一个字符串，逐个翻转字符串中的每个单词。</p><p>说明：</p><ul><li>无空格字符构成一个 单词 。</li><li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 </li></ul><p>示例：</p><pre class=" language-text"><code class="language-text">输入："the sky is blue"输出："blue is sky the"输入："  hello world!  "输出："world! hello"解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。输入："a good   example"输出："example good a"解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。输入：s = "  Bob    Loves  Alice   "输出："Alice Loves Bob"输入：s = "Alice does not even like bob"输出："bob like even not does Alice"</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><p><strong>进阶：</strong></p><ul><li>请尝试使用 <em>O</em>(1) 额外空间复杂度的原地解法。</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>反转字符串中的单词 III—557题</p><p>题述：给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入："Let's take LeetCode contest"输出："s'teL ekat edoCteeL tsetnoc"</code></pre><p><strong>提示：</strong></p><ul><li>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>仅仅反转字母—917题</p><p>题述：给定一个字符串 <code>S</code>，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入："ab-cd"输出："dc-ba"输入："a-bC-dEf-ghIj"输出："j-Ih-gfE-dCba"输入："Test1ng-Leet=code-Q!"输出："Qedo1ct-eeLg=ntse-T!"</code></pre><p><strong>提示：</strong></p><ol><li><code>S.length &lt;= 100</code></li><li><code>33 &lt;= S[i].ASCIIcode &lt;= 122</code> </li><li><code>S</code> 中不包含 <code>\</code> or <code>&quot;</code></li></ol><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h4 id="5-3-4-异位词"><a href="#5-3-4-异位词" class="headerlink" title="5.3.4 异位词"></a>5.3.4 异位词</h4><ol><li><p>找到字符串中所有字母异位词—438题</p><p>题述： 给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p>说明：</p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序。</li></ul><p>示例：</p><pre class=" language-text"><code class="language-text">输入:s: "cbaebabacd" p: "abc"输出:[0, 6]解释:起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。输入:s: "abab" p: "ab"输出:[0, 1, 2]解释:起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。</code></pre><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h4 id="5-3-5-回文串"><a href="#5-3-5-回文串" class="headerlink" title="5.3.5 回文串"></a>5.3.5 回文串</h4><ol><li><p>验证回文串—125题</p><p>题述：给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: "A man, a plan, a canal: Panama"输出: true输入: "race a car"输出: false</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 2 * 105</code><ul><li><code>s</code> 是 ASCII 字符.</li></ul></li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>验证回文字符串 Ⅱ—680题</p><p>题述：给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p><p>示例：</p><pre class=" language-text"><code class="language-text">输入: "aba"输出: True输入: "abca"输出: True解释: 你可以删除c字符。</code></pre><p><strong>注意:</strong></p><ul><li><p>字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。</p><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li></ul></li><li><p>最长回文子串—5题</p><p>题述：给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。 </p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：s = "babad"输出："bab"解释："aba" 同样是符合题意的答案。输入：s = "cbbd"输出："bb"输入：s = "a"输出："a"输入：s = "ac"输出："a"</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol><h4 id="5-3-6-字符串-DP问题"><a href="#5-3-6-字符串-DP问题" class="headerlink" title="5.3.6 字符串+DP问题"></a>5.3.6 字符串+DP问题</h4><ol><li><p>正则表达式匹配—10题</p><p>题述：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘<em>‘ 的正则表达式匹配。</em></p><ul><li>‘.’ 匹配任意单个字符</li><li>‘*’ 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 </p><p>示例：</p><pre class=" language-text"><code class="language-text">输入：s = "aa" p = "a"输出：false解释："a" 无法匹配 "aa" 整个字符串。输入：s = "aa" p = "a*"输出：true解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。输入：s = "ab" p = ".*"输出：true解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。输入：s = "aab" p = "c*a*b"输出：true解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。输入：s = "mississippi" p = "mis*is*p*."输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 20</code></li><li><code>0 &lt;= p.length &lt;= 30</code></li><li><code>s </code>可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code>可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符<code>.</code>和<code> *</code>。</li><li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li></ul><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li><li><p>通配符匹配—44题</p><p>题述：给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p><ul><li> ‘?’ 可以匹配任何单个字符。</li><li>‘*’ 可以匹配任意字符串（包括空字符串）。</li></ul><p>两个字符串完全匹配才算匹配成功。</p><p>说明:</p><ul><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</li></ul><p>示例：</p><pre class=" language-text"><code class="language-text">输入:s = "aa"p = "a"输出: false解释: "a" 无法匹配 "aa" 整个字符串。输入:s = "aa"p = "*"输出: true解释: '*' 可以匹配任意字符串。输入:s = "cb"p = "?a"输出: false解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。输入:s = "adceb"p = "*a*b"输出: true解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".输入:s = "acdcb"p = "a*c?b"输出: false</code></pre><p>实现</p><pre class=" language-java"><code class="language-java"></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.JavaInterview</title>
      <link href="2020/11/21/5-javainterview/"/>
      <url>2020/11/21/5-javainterview/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面试"><a href="#Java面试" class="headerlink" title="Java面试"></a>Java面试</h1><h2 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1. Java基础"></a>1. Java基础</h2><ol><li>抽象类和接口的区别<ol><li>抽象类只能单继承，而接口可以多实现</li><li>接口的方法都是<code>public</code>修饰，而抽象类允许私有方法</li><li><code>jdk8</code>以前接口只能有抽象方法，而抽象类可以有普通和静态方法</li></ol></li><li><code>==</code>和<code>equals</code>的区别<ol><li><code>==</code>是值比较</li><li><code>equals</code>是比较对象内容是否相同</li><li>在比较自定义类是否相同需要重写<code>equals</code>方法，不然是值比较</li></ol></li><li><code>String</code><ol><li>由<code>final</code>修饰的不可改变的量</li><li><code>StingBuffer</code>：多线程环境下拼接效率高，有同步锁，所以线程安全</li><li><code>StringBuilder</code>：单线程环境下拼接效率高，没有同步锁，所以效率最高</li><li><code>new</code>字符串时首先会在常量池中找，没有就创建两个对象，一个在堆中，一个在常量池中；有就只在堆中创建一个对象</li></ol></li><li><code>final/finaly/finalize</code>区别<ol><li><code>final</code>修饰的量不可改变，修饰的方法不能重写，修饰的类不能被继承</li><li><code>finaly</code>是异常捕获用于兜底的操作，一般用于释放资源</li><li><code>finalize</code>是垃圾回收时，被回收对象调用执行的方法</li></ol></li><li><code>Servlet</code>生命周期<ol><li>初始化阶段，调用<code>init</code>方法</li><li>响应请求阶段，处理请求</li><li>终止销毁</li></ol></li><li><code>IO</code><ol><li><code>Block-IO</code><ol><li>字节流<ol><li><code>InputStream</code></li><li><code>OutputStream</code></li></ol></li><li>字符流<ol><li><code>Reader</code></li><li><code>Writer</code></li></ol></li><li>交互方式：同步阻塞式</li></ol></li><li><code>MonBlock-IO</code><ol><li>多路复用式的同步非阻塞式<code>IO</code></li><li>组成<ol><li><code>Channels</code><ol><li><code>FileChannel</code></li><li><code>DatagramChannel</code></li><li><code>SocketChannel</code></li><li><code>ServerSocketChannel</code></li></ol></li><li><code>Buffers</code><ol><li><code>ByteBuffer</code></li></ol></li><li><code>Selectors</code></li></ol></li><li><code>select</code>，<code>poll</code>，<code>epoll</code></li></ol></li><li><code>Asynchronous IO</code><ol><li>基于事件和回调机制的<code>IO</code></li><li>基于回调：实现<code>CompletionHandler</code>接口，调用时触发回调函数</li><li>返回<code>Future</code>：通过<code>isDone</code>方法检查是否准备好，通过<code>get</code>方法等待返回数据</li></ol></li><li>Netty</li></ol></li><li>异常<ol><li><code>Error</code>：程序无法处理的系统错误，编译器不做检查</li><li><code>Exception</code>：程序可以处理的异常，捕获后可能恢复<ol><li><code>!RuntimeException</code>：编译期异常，在编译时必须处理的异常</li><li><code>RuntimeException</code>：运行时异常</li></ol></li><li>抛出异常：创建异常对象交给运行时系统处理</li><li>捕获异常：寻找合适的异常处理器处理异常，否则终止运行</li><li><code>finally</code>优于<code>catch</code>块中的<code>return</code>执行，如果<code>finally</code>和<code>catch</code>都有<code>return</code>，则<code>catch</code>中的<code>return</code>会覆盖掉<code>finally</code>中的<code>return</code>值</li><li>异常处理规则<ol><li>具体明确：抛出的异常应能通过异常类名和<code>message</code>准说明异常的类型和异常产生的原因</li><li>提早抛出：尽可能早的发现并抛出异常，便于精确定位问题</li><li>延迟捕获：异常的捕获和处理尽可能的延迟，让掌握更多信息的作用域来处理异常</li></ol></li><li>异常梳理设计原则<ol><li>创建一个异常类继承自<code>RuntimeException</code>异常来统一处理</li><li>其余异常统一转为<code>AppException</code></li><li>在<code>catch</code>后，抛出自定义异常的子类，并提供足以定位的信息</li><li>由前端接收<code>AppException</code>做统一处理</li></ol></li><li>异常处理消耗性能的地方<ol><li><code>try-catch</code>块影响<code>JVM</code>优化</li><li>异常对象实例需要保存栈快照等信息，开销较大</li></ol></li></ol></li></ol><h2 id="2-Java集合-容器"><a href="#2-Java集合-容器" class="headerlink" title="2. Java集合(容器)"></a>2. Java集合(容器)</h2><ol><li><code>List</code>:<ol><li>特点<ol><li>有序可重复</li><li>可以通过索引值来操作元素</li></ol></li><li>实现类<ol><li><code>ArrayList</code><ol><li>底层是数组，利用数组的下标进行元素访问</li><li>初始大小为<font color="#FFFF00">10</font> ，扩容为原来的<font color="#FFFF00">0.5</font>倍，扩容是基于数组的复制，比较耗费内存</li><li>查询快，增删慢</li></ol></li><li><code>LinkedList</code><ol><li>底层是双向链表，链表存储指向前后节点的引用和元素</li><li>增删快，查询慢</li></ol></li></ol></li></ol></li><li><code>Map</code><ol><li>特点<br>1. </li><li>实现类<ol><li><code>HashMap</code><ol><li>底层原理<ol><li>1.8之前底层是数组+链表，1.8之后是数组+链表+红黑树</li><li>链表的出现就是解决Hash值相同，由<code>HashCode</code>值决定存放的位置</li><li>链表转为红黑树—当数组长度大于<font color="#FFFF00">64</font>且链表长度大于<font color="#FFFF00">8</font>时会将链表转为红黑树</li><li>初始值为<font color="#FFFF00">16</font>，当负载因子达到<font color="#FFFF00">0.75</font>时，就会扩容为原来的<font color="#FFFF00">2</font>倍</li><li>一般用于单线程环境</li></ol></li><li><code>put</code>流程<ol><li>如果<code>HashMap</code>未被初始化，则先进行初始化</li><li>对<code>key</code>求<code>hash</code>值，然后通过<code>hashcode</code>方法计算下标值</li><li>如果没有<code>hash</code>碰撞，直接放入桶中</li><li>如果有<code>hash</code>碰撞，以链表的方式链接到后面</li><li>如果链表的长度超过<font color="#FFFF00">8</font>时，就把链表转为红黑树</li><li>如果链表的长度小于<font color="#FFFF00">6</font>时，就把红黑树转为链表</li><li>如果节点满了，则进行扩容，扩容为原来的<font color="#FFFF00">2</font>倍后进行重排</li></ol></li><li>减少<code>hash</code>碰撞<ol><li>扰动函数：使元素分布均匀，减少碰撞几率</li><li>使用<code>final</code>对象，这些对象已经重写<code>equals</code>和<code>hashcode</code>方法</li></ol></li><li>扩容<ol><li>基础容量为<font color="#FFFF00">16</font>，负载因子达到<font color="#FFFF00">0.75</font>时扩容为原来的<font color="#FFFF00">2</font>倍</li><li>多线程环境下，调整大小会存在条件竞争，容易造成死锁</li><li><code>rehashing</code>是比较耗时的过程</li></ol></li><li>解决线程不安全<ol><li>调用<code>Collections</code>的<code>synchronizedMap</code>为<code>HashMap</code>实例对象加锁</li><li><code>synchronizedMap</code>方法为<code>hashMap</code>实例对象加<code>synchronized</code>锁，锁是<code>mutex</code>互斥锁</li></ol></li></ol></li><li><code>LinkedHashMap</code></li><li><code>TreeMap</code></li><li><code>HashTable</code>：线程安全，有同步锁</li></ol></li></ol></li><li><code>Queue</code></li><li><code>Set</code><ol><li>特点<ol><li>无序，不可重复，但<code>TreeSet</code>有序</li></ol></li><li>实现类<ol><li><code>HashSet</code>：底层是<code>HashMap</code>，由<code>Hashcode</code>和<code>equals</code>方法保证元素唯一性</li><li><code>TreeSet</code>：底层是<code>TreeMap</code>，元素有序<ol><li>自然排序：让所属对象的方法实现<code>comparable</code>接口的无参构造</li><li>比较器排序：<code>comparator</code>带参构造</li></ol></li><li><code>LinkedHashSet</code></li></ol></li></ol></li><li><code>JUC</code><ol><li><code>CAS</code>是<code>JUC</code>的基础</li><li><code>AQS</code>是<code>JUC</code>的<code>locks</code>包的基础</li><li>包的分类<ol><li>线程执行器<code>executor</code></li><li>锁<code>locks</code></li><li>原子变量<code>atomic</code></li><li>并发工具类<code>tools</code><ol><li>闭锁<code>CountDownLatch</code>：让主线程等待一组事件发生后继续执行</li><li>栅栏<code>CyclicBarrier</code>：阻塞当前线程，等待其他线程</li><li>信号量<code>Semaphore</code>：控制某个资源可被同时访问的线程个数</li><li>交换器<code>Exchanger</code>：两个线程达到同步点后，相互交换数据</li></ol></li><li>并发集合<code>Collections</code><ol><li><code>BlockingQueue</code>：提供可阻塞的入队和出队操作(都是线程安全的)<ol><li>主要用于生产者-消费者模式：将任务的生产和消费进行隔离</li><li><code>ArrayBlockingQueue</code>：一个由数组结构组成的有界阻塞队列</li><li><code>LinkedBlockingQueue</code>：一个由链表结构组成的有/无界阻塞队列</li><li><code>PriorityBlockingQueue</code>：一个支持优先级排序的无界阻塞队列</li><li><code>DealyQueue</code>：一个使用优先级队列实现的无界阻塞队列</li><li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列</li><li><code>LinkedTransferQueue</code>：一个由链表结构组成的无界阻塞队列</li><li><code>LinkedBlockingDeque</code>：一个由链表结构组成的双向阻塞队列</li><li><code>ConcurrentHashMap</code><ol><li>JDK8以前：使用更细粒度的锁，由一个<code>Segmen</code>t数组和多个<code>HashEntry</code>组成，实现了锁分离，即每个元素的锁是不一样的</li><li>JDK8之后：使用<code>CAS+synchronized</code>使锁更细化</li><li>存在于JUC包下，不允许存储null键值</li><li>put逻辑<ol><li>判断<code>Node[]</code>数组是否初始化，没有就先初始化</li><li>通过<code>hash</code>定位数组的索引坐标，是否有<code>node</code>节点，如果没有则使用<code>CAS</code>进行添加(链表的头结点)，添加失败则进入下次循环</li><li>检查内部正在扩容，就帮助它一块扩容</li><li>如果<code>f!=null</code>，则使用<code>synchronized</code>锁住元素(锁是链表/红黑树的头元素)<ol><li>如果<code>Node</code>(链表结构)则执行链表的添加操作</li><li>如果<code>Node</code>(树结构)则执行树的添加操作</li></ol></li><li>判断链表的长度是否达到临界值<font color="#FFFF00">8</font>(可修改的默认值)，达到8就将链表转为红黑树</li></ol></li><li>锁<ol><li>首先使用无锁操作<code>CAS</code>插入头节点，失败就循环重试</li><li>若已有头节点，则尝试获取头节点的同步锁，再进行操作</li></ol></li><li><code>Size</code>方法和<code>MappingCount</code>方法异同</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol><h2 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3. 多线程"></a>3. 多线程</h2><ol><li>进程和线程<ol><li>进程<ol><li>是资源分配时的最小单元(独占一块内存，相互之间互不干扰)</li><li>可以看做是独立应用，线程只是进程的不同执行路径</li></ol></li><li>线程<ol><li>是<code>CPU</code>调度的最小单元(共享进程的内存资源，可以更细粒度的控制任务)</li></ol></li><li>进程和线程的关系<ol><li>运行一个程序会产生一个进程，进程至少包含一个线程</li><li>每个进程对应一个<code>JVM</code>实例，多线程共享<code>JVM</code>里的堆</li><li><code>Java</code>采用单线程编程模型，程序会自动创建主线程</li><li>主线程可以创建子线程，在子线程之后完成执行</li></ol></li></ol></li><li><code>start</code>和<code>run</code>方法<ol><li><code>start</code>用于启动线程，而<code>run</code>用于运行线程</li><li><code>start</code>方法会创建子线程并启动，而<code>run</code>方法是线程的一个普通方法调用</li></ol></li><li>实现线程<ol><li>继承<code>Thread</code>类，而<code>Thread</code>类底层也是实现了<code>Runnable</code>接口</li><li>直接实现<code>Runnable</code>接口，重写<code>run</code>方法</li><li>实现<code>Callable</code>接口，重写<code>call</code>方法</li><li>处理线程的返回值<ol><li>主线程等待法</li><li>使用线程的<code>join</code>方法用以阻塞等待子线程处理完毕</li><li>实现<code>Callable</code>接口，获取<code>call</code>方法的返回值</li><li>通过线程池来获取返回值</li></ol></li></ol></li><li>线程状态<ol><li>新建：创建后还没有启动的线程</li><li>运行：包含正在运行和等待运行的线程</li><li>无限等待：不会被分配<code>CPU</code>执行，需要显示被唤醒</li><li>限期等待：在一定时间后会由系统自动唤醒</li><li>阻塞：等待获取排他锁</li><li>结束：已终止线程的状态，执行结束</li></ol></li><li>等待线程和唤醒线程<ol><li>等待线程<ol><li><code>wait</code><ol><li>是<code>Object</code>类中的方法</li><li>只能在<code>synchronized</code>方法或<code>synchronized</code>块中使用</li><li>不仅释放<code>CPU</code>，而且会释放已经占有的同步资源锁</li></ol></li><li><code>sleep</code><ol><li>是线程类特有的方法</li><li>可以在任何地方调用</li><li>只会让出<code>cpu</code>，不会导致锁行为的改变</li></ol></li></ol></li><li>唤醒线程<ol><li>池<ol><li>锁池<code>EntryList</code>：等待获取锁的池</li><li>等待池<code>WaitSet</code>：等待线程的池</li></ol></li><li><code>notify</code><ol><li>只会随机选取一个处于等待池中的线程进入锁池中去竞争获取锁</li></ol></li><li><code>notifyAll</code><ol><li>会让所有处于等待池中的线程全部进入锁池去竞争获取锁</li></ol></li></ol></li><li>函数<ol><li><code>yield</code><ol><li>告知线程调度器当前(调用者)线程愿意让出<code>CPU</code>的暗示，但是线程调度器会忽略这个暗示</li><li>不会影响锁的行为(不会使当前线程让出已经占用的锁)</li></ol></li><li><code>interrupt</code><ol><li>停止线程：<code>stop</code>方法，<code>suspend</code>方法，<code>resume</code>方法</li><li>调用<code>interrupt</code>如果线程处于阻塞状态，那么线程立即退出阻塞状态，抛出<code>InterruptedException</code>异常</li><li>调用<code>interrupt</code>如果线程处于正常运行，那么会将其中断标志位设置为<code>true</code>，被中断标识的线程仍可以正常运行</li><li>需要被调用<code>interrupt</code>的线程配合中断</li></ol></li></ol></li><li>锁—解决多线程操作共享数据带来的数据不安全<ol><li>互斥锁<ol><li>互斥性：在同一时刻只允许一个线程持有某个对象锁</li><li>可见性：确保在锁被释放前，对共享变量的修改是对后面线程是可见的</li></ol></li><li>同步锁<ol><li>获取对象锁<ol><li>同步代码块，锁 是<code>this</code></li><li>同步非静态方法，锁是当前对象的实例对象</li></ol></li><li>获取类锁<ol><li>同步代码块，锁是类的字节码文件</li><li>同步静态方法，锁是当前对象的类对象</li></ol></li><li>原理<ol><li>基于<code>Java</code>对象头和<code>Monitor</code>实现</li><li>对象在内存中的布局<ol><li>对象头：<code>Mark Word</code>和<code>Class Metadata Address</code>组成<ol><li><code>Mark Word</code>：存储对象的运行时数据，默认存储对象的<code>HashCode</code>，分代年龄，锁类型，锁标志位等</li><li><code>Class Metadata Address</code>：是指针，指向对象的类元数据</li></ol></li><li><code>Monitor</code><ol><li>每个<code>Java</code>对象自身存在的内部锁—<code>java</code>对象可以作为锁的原因</li><li>重入：一个线程试图获取自己持有对象锁的临界资源时</li><li>阻塞：一个线程试图获取由其他线程持有的对象锁的临界资源时</li></ol></li><li>实例数据</li><li>对齐填充</li></ol></li><li>早期的<code>synchronized</code>锁<ol><li>属于重量级锁，依赖于<code>Mutex Lock</code>实现</li><li>线程之间的切换需要从用户态转到核心态，开销大</li></ol></li><li>自旋锁：通过让线程忙于循环等待锁的释放，不让出<code>CPU</code>的执行权；若锁被其他线程长时间占用，则会带来许多性能上的开销</li><li>自适应自旋锁：自旋的次数由前一次在同一个锁上自旋的时间以及锁的拥有者状态来决定</li><li>锁消除：JIT在编译时，对运行上下文进行扫描，消除不可能存在竞争的锁</li><li>状态<ol><li>无锁</li><li>偏向锁：减少同一线程获取锁的代价，不适用于锁竞争比较激烈的情况</li><li>轻量级锁</li><li>重量级锁</li><li>锁升级：无锁—偏向锁—轻量级锁—重量级锁</li></ol></li></ol></li></ol></li><li><code>ReentranLock</code>(重入锁)<ol><li>位于<code>Java.util.concurrent.locks</code>包下</li><li>和<code>CountDownLatch</code>，<code>FutureTask</code>，<code>Semaphore</code>一样基于<code>AQS</code>实现<ol><li><code>AQS</code>：<code>AbstractQueueSynchronizer</code></li></ol></li><li>实现比<code>synchronized</code>更细粒度的控制，如<code>fairness</code>(公平锁)<ol><li>公平锁：获取锁的顺序按先后调用<code>lock</code>方法的顺序</li><li>非公平锁：抢占机制，优先度高的抢到的几率大</li></ol></li><li>调用<code>lock</code>方法后，必须调用<code>unlock</code>释放锁</li><li>区分<code>synchronized</code>锁<ol><li><code>synchronized</code>是关键字，而<code>ReentranLock</code>是类</li><li><code>ReentranLock</code>可以对锁的等待时间进行设置，避免死锁</li><li><code>ReentranLock</code>可以获取各种锁的信息，可以灵活的实现多路通知</li><li><code>synchronized</code>操作的是<code>Mark Word</code>，<code>lock</code>锁操作的是<code>Unsafe</code>类的<code>park</code>方法</li></ol></li></ol></li><li>JMM—<code>Java Memory Model</code><ol><li>主内存<ol><li>存储<code>Java</code>实例对象</li><li>包括成员变量，类信息，常量，静态变量等</li><li>属于数据共享区域，多线程并发操作时会引发线程安全问题</li></ol></li><li>工作内存<ol><li>存储的是当前方法的所有本地变量信息，本地变量对其他线程不可见</li><li>字节码行号指示器，<code>Native</code>方法信息</li><li>属于线程私有数据区域，不存在线程安全问题</li></ol></li><li>区分<code>Java</code>内存划分<ol><li><code>JMM</code>描述的是一组规则，围绕原子性，有序性，可见性展开</li><li>同<code>Java</code>内存相似，都存在共享区和私有区</li><li>方法里的基本数据类型和本地变量直接存储在工作内存的栈帧结构中</li><li>引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中</li><li>成员变量：<code>static</code>变量，类信息均会存储在主内存中</li></ol></li><li>指令重排序<ol><li>在单线程情况下不能改变程序运行的结果</li><li>存在数据依赖关系的不允许重排序</li><li>无法通过<code>Happens-before</code>原则推导出来的，才能进行指令重排序<ol><li><code>A</code>操作的结果需要对<code>B</code>操作可见，则<code>A</code>和<code>B</code>存在<code>happens-before</code>关系</li><li><code>happens-before</code>的原则<ol><li>程序次序规则：一个线程内，按照代码顺序，先写的代码先执行</li><li>锁定规则：一个<code>unLock</code>操作优先后面对同一个锁的<code>lock</code>操作</li><li><code>Volatile</code>变量规则：一个变量的写操作优先于后面对这个变量的读操作</li><li>传递规则：如果<code>A</code>操作优于<code>B</code>操作，<code>B</code>操作优于<code>C</code>操作，那么<code>A</code>操作优于<code>C</code>操作</li><li>线程启动规则：<code>Thread</code>对象的<code>start</code>方法优先执行在该线程的每一个动作之前</li><li>线程中断规则：对线程<code>interrupt</code>方法的调用优于被中断线程的代码检测到中断事件前发生</li><li>线程终结规则：线程中所有的操作都优于线程终止检测事件</li><li>对象终结规则：一个对象的初始化完成优于其<code>finalize</code>方法执行</li></ol></li></ol></li></ol></li><li><code>Volatile</code><ol><li><code>JVM</code>提供轻量级同步机制</li><li>由<code>Volatile</code>修饰的共享变量对所有线程总是可见的</li><li>禁止指令的重排序优化<ol><li>内存屏障<ol><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性</li></ol></li><li>通过插入内存屏障指令来禁止在内存屏障前后的指令执行重排序优化</li><li>强制刷出<code>CPU</code>的缓存数据，因此在<code>cpu</code>上的任何线程都能读取到这些数据的最新版本</li></ol></li><li>可见性分析<ol><li>定义一个<code>Volatile</code>变量时，<code>JMM</code>会把该线程对应的工作内存中的共享变量刷新到主内存中</li><li>读取一个<code>Volatile</code>变量时，<code>JMM</code>会把该线程对应的工作内存置为无效</li></ol></li></ol></li><li><code>Volatile</code>和<code>synchronized</code>的区别<ol><li><code>Volatile</code>本质是告知<code>JVM</code>当前变量在寄存器(工作内存)中的值不确定需要从主内存中读取，<code>synchronized</code>只是锁定当前变量</li><li><code>Volatile</code>仅用于变量级别，<code>synchronized</code>可以用在变量，方法，类上</li><li><code>Volatile</code>不会造成线程阻塞，<code>synchronized</code>会造成线程阻塞</li><li><code>Volatile</code>标记的变量不会被编译器优化，<code>synchronized</code>标记的变量会被编译器优化</li></ol></li></ol></li><li><code>CAS(</code>乐观所锁)—一种高效实现线程安全性的方法<ol><li>支持原子更新操作，适用于计数器，序列发生器等场景</li><li>属于乐观锁机制，号称<code>lock-free</code></li><li><code>CAS</code>操作失败 后开发者决定是否继续尝试，还是执行别的操作</li><li>包含三个操作数：内存位置，预期原值和新值</li><li>缺点<ol><li>若循环时间长，则开销大</li><li>只能保证一个共享变量的原子操作</li><li><code>ABA</code>问题—一个变量<code>A</code>改变到<code>B</code>未被检测出来，导致两次读取的值都是<code>A</code>—通过<code>AtomicStampedReference</code>类改变</li></ol></li></ol></li></ol></li><li>线程池<ol><li><code>Executor</code>接口<ol><li><code>Executor</code>：运行新任务的简单接口，将任务提交和任务执行细节解耦</li><li><code>ExecutorService</code>：具备管理执行器和任务生命周期的方法，提交任务 机制更完善</li><li><code>SchduledExecutorService</code>：支持<code>Future</code>和定时任务</li></ol></li><li>5种不同场景的线程池创建<ol><li><code>newFixedThreadPool(int nThread)</code>：指定工作线程数量的线程池</li><li><code>newCachedThreadPool()</code>：短时间处理大量工作任务的线程池</li><li><code>newSingleThreadExecutor()</code>：创建唯一的工作线程来执行任务，如果该线程一结束，会有另一个线程取代它</li><li><code>newSingleThreadScheduledExecutor()</code>和<code>newScheduledThreadExecutor(int corePoolSize)</code>：定时或者周期性的工作调度线程池，两个的区别在于单一工作线程还是多线程</li><li><code>newWorkStealingPool()</code>：内部构建<code>ForkJoinPool</code>，利用<code>working-stealing</code>算法，并行的执行任务，不保证处理顺序<ol><li><code>Fork/Join</code>框架<ol><li>把大任务分割为有限的小任务执行，把每个小 任务的执行结果汇总得到大任务结果的框架</li></ol></li><li><code>work-stealing</code>算法：某个线程从其他队列里窃取任务来执行</li></ol></li><li>确定线程池的大小<ol><li><code>CPU</code>密集型：线程数=核数+1</li><li><code>IO</code>密集型：线程数=核数*（1+平均等待时间/平均工作时间）</li></ol></li></ol></li><li>优势<ol><li>降低资源的消耗</li><li>提高线程的可管理性</li></ol></li><li><code>ThreadPoolExecutor</code>构造函数<ol><li><code>corePoolSize</code>：核心线程数量</li><li><code>maximunPoolSize</code>：线程不够用时，最多可创建的线程数</li><li><code>workQueue</code>：任务等待队列</li><li><code>keepAliveTime</code>：抢占顺序不一定</li><li><code>ThreadFactory</code>：创建新线程</li><li><code>Handler</code>：线程池的饱和策略<ol><li><code>AbortPolicy</code>：直接抛出异常，默认策略</li><li><code>CallerRunsPolicy</code>：用调用者所在的线程来执行任务，并执行当前任务</li><li><code>DiscardOldPolicy</code>：丢弃队列中最靠前的任务，并执行当前任务</li><li><code>DiscardPolicy</code>：直接丢弃任务</li><li>通过实现<code>RejectedExecutorHandler</code>接口来自定义<code>Handler</code></li></ol></li></ol></li><li><code>executor</code>流程<ol><li>如果线程数少于<code>corePoolSize</code>，则直接创建新线程来执行任务，即使线程池中其他线程是空闲的</li><li>如果线程池中的线程数量大于等于<code>corePoolSize</code>而小于<code>maximumPoolSize</code>，只有当<code>workQueue</code>满时才去创建新线程处理任务</li><li>如果<code>corePoolSize</code>和<code>maximumPoolSize</code>值相同，则创建的线程池大小固定的，这是如果有新任务，若<code>workQueue</code>未满，则将请求放入<code>workQueue</code>中，等待有空闲的线程去从<code>workQueue</code>中取出任务并执行</li><li>如果运行的线程数大于等于<code>maximumPoolSize</code>，这时如果<code>workQueue</code>已满，则通过<code>Handler</code>所指定的策略来处理任务</li></ol></li><li>线程池的状态<ol><li><code>Runing</code>：能够接受新任务提交，也可以处理阻塞队列中的任务</li><li><code>Shutdown</code>：不在接受新提交的任务，但可以处理存量任务</li><li><code>Stop</code>：不在接受新提交的任务，也不处理存量任务</li><li><code>Tidying</code>：所有任务都已终止</li><li><code>Terminated：terminated</code>方法执行后进入该状态(仅作标识)</li></ol></li></ol></li></ol></li></ol><h2 id="4-JVM"><a href="#4-JVM" class="headerlink" title="4. JVM"></a>4. JVM</h2><ol><li><p><code>Java</code>跨平台原理</p><ul><li>基于不同平台的<code>JVM</code>实现，即在不同平台安装对应的<code>JDK</code>就能运行<code>Java</code>程序</li></ul></li><li><p><code>Java</code>反射</p><ul><li>动态获取任意类，对象的属性和方法</li><li>这种在运行状态中动态获取信息以及调用对象方法的特性称为<code>Java</code>的反射机制</li><li><code>API</code>：<code>getDeclaredMethod(getMethod)</code>：接收方法名，方法名对应的字节码对象</li><li>本质：把<code>Java</code>类中的方法和属性映射为<code>Java</code>对象</li></ul></li><li><p>类加载机制</p><ul><li>虚拟机将<code>class</code>文件加载进内存的行为</li><li>加载流程<ul><li>通过<code>ClassLoader</code>加载<code>class</code>字节码文件，生成<code>class</code>对象</li><li>检查<code>class</code>的正确性和安全性</li><li>为变量分配内存空间和设置初始值</li><li><code>JVM</code>常量池中的符号引用转为直接引用</li><li>执行类变量赋值和静态代码块</li></ul></li><li>双亲委派机制<ul><li>一个类收到类加载请求时，会将请求委派给父类，如果父类不能加载才由子类去完成加载</li><li>避免同样的字节码文件被加载多次</li></ul></li><li>四种类加载器<ul><li>启动类加载器：用于加载<code>Java</code>的核心类库</li><li>扩展类加载器：用于加载<code>Java</code>的扩展库</li><li>系统类加载器：根据<code>Java</code>的类路径来加载<code>Java</code>类</li><li>用户自定义类加载器：通过继承<code>Classloader</code>类的方式实现</li></ul></li><li><code>LoaderClass</code>和<code>forName</code><ul><li>在运行时都能知道该类的属性和方法</li></ul></li></ul></li><li><p>内存结构 </p><ol><li>线程私有<ol><li>虚拟机栈，本地方法栈，程序计数器<ol><li>虚拟机栈<ol><li><code>Java</code>方法执行的基础</li><li>包含多个栈帧(栈帧用于存储局部变量表，操作数栈，动态链接，方法出口)</li></ol></li><li>本地方法栈<ol><li>和虚拟机栈类似，主要用于标注<code>native</code>方法</li></ol></li><li>程序计数器<ol><li>当前线程所执行的字节码行号指示器(逻辑指示器)</li><li>改变计数器的值来选取下一条所需执行的字节码指令</li><li>和线程是一对一关系(即线程有)</li><li>对<code>Java</code>方法计数，如果是<code>native</code>方法则计数器值<code>undefined</code></li></ol></li></ol></li></ol></li><li>线程共享<ol><li>堆<ol><li>对象实例的分配区域</li><li><code>GC</code>管理的主要区域</li><li>JDK7以后常量池存在于堆中，方便<code>GC(</code>之前存在于永久代中，浪费内存)</li></ol></li><li>元空间(<code>MetaSpace</code>)和永久代(<code>PermGen)</code>—是方法区的实现<ol><li>都是用来存储<code>class</code>的相关信息</li><li>元空间使用的本地内存，而永久代使用的是<code>JVM</code>内存，所以元空间替代了永久代</li><li>字符串常量池存在于永久代中，容易出现性能问题和内存溢出</li><li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li><li>永久代为<code>GC</code>带来不必要的复杂性</li></ol></li><li>堆和栈的区别<ol><li>联系：引用对象，数组时，栈里定义变量保存在堆中的地址</li><li>管理方式：栈可以自动释放，堆需要<code>GC</code></li><li>空间：栈比堆小</li><li>碎片：栈内存产生的碎片远小于堆</li><li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li><li>效率：栈的效率比堆高</li></ol></li></ol></li></ol></li><li><p><code>GC</code>机制</p><ol><li>没有被其他对象引用时，就判定为垃圾</li><li>垃圾判定算法<ol><li>引用计数法<ol><li>通过判断对象的引用数量来决定对象是否可以被回收</li><li>为每个对象创建一个引用计数器，被引用的计数器值<code>+1</code>，完成引用后计数器值<code>-1</code></li><li>当引用计数器值为<code>0</code>时，就认定该对象为垃圾</li><li>优点：执行效率高，程序执行受影响小</li><li>缺点：无法检测出循环引用的情况，导致内存泄漏(子类和父类之间循环引用，计数器值就没有为0的情况)</li></ol></li><li>可达性分析算法—基于图论<ol><li>判断对象的引用链是否可达，不可达就认定为垃圾</li><li><code>GC Root</code>对象<ol><li>虚拟机栈中引用的对象(栈帧中的本地变量表)</li><li>方法区中常量引用的对象</li><li>方法区中静态属性引用的对象</li><li>本地方法栈中<code>JNI</code>(<code>native</code>方法)引用的对象</li><li>活跃线程引用的对象</li></ol></li></ol></li></ol></li><li>垃圾回收算法<ol><li>标记-清除算法<ol><li>标记：从跟集合进行扫描，对存活的对象进行标记</li><li>清除：对堆内存从到尾进行线程遍历，回收不可达的对象</li><li>缺点：产生碎片块多</li></ol></li><li>复制算法<ol><li>分为对象面和空闲面</li><li>对象在对象面上创建</li><li>将存活的对象从对象面复制到空闲面</li><li>将对象面的所有对象从内存中清除</li><li>优点<ol><li>解决碎片化问题</li><li>顺序分配内存，简单高效</li><li>适用于对象存活率低的场景(如年轻代)</li></ol></li></ol></li><li>标记-整理算法<ol><li>标记：从跟集合进行扫描，对存活的对象进行标记</li><li>整理：移动所有存活的对象，且按照内存地址依次排序，然后将末端内存地址以后的内存全部回收</li></ol></li><li>分代收集算法<ol><li>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法，提高了JVM的回收效率</li><li>JDK8以前分为年轻代，老年代，永久代；JDK8开始取消永久代</li><li><code>Minor GC</code>发生在年轻代中的收集动作，采用的是复制算法<ol><li>尽可能快速的收集哪些生命周期短的对象</li><li>主要分为<code>Eden</code>区和两个<code>Survivor</code>区(包含一个<code>from</code>区和<code>to</code>区)[<code>Eden:from:to=8:1:1</code>]</li><li>每次触发<code>GC</code>后存活的对象年龄值<code>+1</code>，默认是<code>15</code>岁后进入老年代</li></ol></li><li><code>Full GC</code><ol><li>经历一定次数(默认是15次)的<code>Minor GC</code>后依然存活的对象开始进入老年代</li><li><code>Survivor</code>区存放不下的大对象直接进入老年代</li><li>发生在老年代的收集动作，存放生命周期较长的对象；采用标记-清除算法和标记-整理算法</li><li>触发<code>Full GC</code><ol><li>老年代和永久代空间不足</li><li><code>CMS GC</code>时出现promotion failed，concurrent mode failure</li><li><code>Minor GC</code>升级老年代的平均大小大于老年代的剩余空间</li><li>调用<code>System.gc()</code>方法—只是提醒虚拟机需要在这里进行回收，具体的回收操作由虚拟机自己决定</li><li>通过<code>RMI</code>来进行<code>RPC</code>或管理<code>JDK</code>引用，默认每<code>1</code>小时进行一次<code>Full GC</code></li></ol></li></ol></li></ol></li><li>调优参数<ol><li><code>-XX:SurvivorRatio</code>：设置<code>Eden</code>和<code>Survivor</code>的比值，默认是<code>8:1</code></li><li><code>-XX:NewRatio</code>：设置老年代和年轻代内存大小的比例</li><li><code>-XX:MaxTenuringThreshold</code>：对象从年轻代升级为老年代需要出发<code>Minor GC</code>的次数</li></ol></li><li><code>Stop_the_World</code><ol><li><code>JVM</code>由于要执行<code>GC</code>而停止了应用程序的执行</li><li>任何一种<code>GC</code>都会发生</li><li>通过避免减少<code>Stop_the_World</code>的发生时间来提高程序性能</li></ol></li><li><code>Safepoint</code>(安全点)<ol><li>触发<code>GC</code>的快照点</li><li>分析过程中对象引用关系不会产生变化的点</li><li><code>Safepoint</code>可能点：方法调用，循环跳转，异常跳转等</li><li>要确保安全点数量适中</li></ol></li></ol></li><li>垃圾收集器<ol><li>新生代垃圾收集器<ol><li><code>Serial</code>收集器<ol><li>单线程收集，进行垃圾收集时，必须暂停所有的工作线程</li><li>简单高效，<code>Client</code>模式下默认的年轻代收集器</li></ol></li><li><code>ParNew</code>收集器<ol><li>多线程收集器，其余和<code>Serial</code>相同</li><li>单线程执行效率不如<code>Serial</code>，在多核环境下才有优势</li></ol></li><li><code>Parallel Scavenge</code>收集器<ol><li>更关注系统的吞吐量</li><li>在多核执行才有优势，<code>Server</code>模式下默认的年轻代收集器</li></ol></li></ol></li><li>老年代垃圾收集器<ol><li><code>Serial Old</code>收集器<ol><li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li><li>简单高效，<code>Client</code>模式下默认的老年代收集器</li></ol></li><li><code>Parallel Old</code>收集器<ol><li>多线程，吞吐量优先</li></ol></li><li><code>CMS</code>收集器<ol><li>初始标记：<code>Stop_the_World</code></li><li>并发标记：并发追溯标记，程序不会停顿</li><li>并发预清理：查找执行文件并发标记阶段从年轻代晋升老年代的对象</li><li>重新标记：暂停虚拟机，扫描<code>CMS</code>堆中的剩余对象</li><li>并发清理：清理垃圾对象，程序不会停顿</li><li>并发重置：重置<code>CMS</code>收集器的数据结构</li></ol></li><li><code>Garbage First</code>收集器<ol><li>并发和并行</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li><li>将<code>Java</code>堆内存划分为多个大小相等的<code>Region</code></li></ol></li><li><code>finalize</code>方法</li><li><code>Java</code>中的强引用，软引用，弱引用，虚引用<ol><li>强引用<ol><li>最普遍的引用，抛出<code>OutMemoryError</code>终止程序也不会回收具有强引用的对象</li><li>通过将对象置为<code>null</code>来弱化其引用，使其被回收</li></ol></li><li>软引用<ol><li>对象处于有用但非必须的状态</li><li>只有当空间不足时，<code>GC</code>会回收该引用对象的内存</li><li>用来实现高速缓存</li></ol></li><li>弱引用<ol><li>非必须引用对象，比软引用更弱一些</li><li><code>GC</code>触发时会被回收</li><li>被回收的几率不大，因为<code>GC</code>线程的优先级比较低</li><li>适用于偶尔使用的对象</li></ol></li><li>虚引用<ol><li>不会决定对象的生命周期</li><li>任何时候都可能会被<code>GC</code></li><li>用于跟踪垃圾回收器的回收活动，起到哨兵作用</li><li>必须和引用队列联合使用</li></ol></li><li>引用队列<ol><li>没有实际的存储结构，存储逻辑依赖于内部节点之间的关系来表达</li><li>存储关联被<code>GC</code>的软引用，弱引用，以及虚引用</li></ol></li><li><code>JVM</code>调优<ol><li>调优参数含义<ol><li><code>-Xss</code>：表示每个虚拟机栈(堆栈)的大小</li><li><code>-Xms</code>：堆的初始值</li><li><code>-Xmx</code>：堆能达到的最大值(一般情况下将<code>-Xms</code>和<code>-Xmx</code>值设置相同，避免扩容时的内存抖动而影响程序运行时的稳定性)</li></ol></li><li>内存分配策略<ol><li>静态存储：编译时确定每个数据目标在运行时的存储空间</li><li>栈式存储：数据区在编译时未知，运行时模块入口前确定</li><li>堆式存储：编译时或运行时模块入口都无法确定，动态分配</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li><li><p>内存溢出</p><blockquote><p>程序在申请内存的时候，没有足够的内存供其使用</p></blockquote><ul><li>死循环</li><li>递归</li><li>大对象太多，<code>Java</code>中的大对象是可以直接进入老年代的</li></ul></li><li></li></ol><h2 id="5-数据库"><a href="#5-数据库" class="headerlink" title="5. 数据库"></a>5. 数据库</h2><h3 id="5-1-MySQL"><a href="#5-1-MySQL" class="headerlink" title="5.1 MySQL"></a>5.1 MySQL</h3><h4 id="5-1-1-基础"><a href="#5-1-1-基础" class="headerlink" title="5.1.1 基础"></a>5.1.1 基础</h4><ol><li>关系型数据库<ul><li>数据库模块<ul><li>存储模块—<code>OS</code>文件系统(将数据持久化存储到硬盘，磁盘中)</li><li>程序实例—用逻辑结构来映射物理结构<ul><li>存储管理</li><li>缓存机制</li><li><code>sql</code>解析模块</li><li>日志管理</li><li>权限划分</li><li>容灾机制</li><li>索引管理</li><li>锁管理</li></ul></li></ul></li></ul></li><li>索引<ul><li>作用：提高查询效率</li><li>实例：主键，唯一键(<code>id</code>)，让数据具备一定区分性的字段等可以作为索引</li><li>数据结构<ul><li>生成索引建立二叉树进行二分查找</li><li>生成索引建立<code>B</code>树结构进行查找</li><li>生成索引建立<code>B+</code>树结构进行查找</li><li>生成索引，建立<code>hash</code>结构进行查找</li></ul></li></ul></li><li>树结构介绍<ul><li>二叉查找树<ul><li>查询效率：<code>O(logn)</code></li><li>左子树：左子树节点值均小于根节点值</li><li>右子树：右子树节点值均大于根节点值</li><li>注意：二叉树在有限次增删改之后会变成线性结构，此时查询效率为<code>O(n)</code></li><li>解决：利用树的旋转特性，将二叉树转为平衡二叉树，这样查询效率会维持在<code>O(logn)</code></li><li>平衡二叉树：大数据量情况下，由于每个节点只能有两个叶子节点，大大增加了树的层级和存储空间；会浪费大量的磁盘<code>IO</code></li></ul></li><li><code>B</code>树<ul><li>一种多路平衡查找树，每个节点最多有<code>M</code>个子节点，称为<code>M</code>阶<code>B</code>树，但至少有两个子节点</li><li>查询效率<code>O(logn)</code></li></ul></li><li><code>B+</code>树<ul><li>每个叶子节点的指针数和关键字数相同，同阶的B+树比B树能存储更多的关键字</li><li>优势<ul><li>磁盘读写代价更低</li><li>查询效率更为稳定</li><li>更有利于数据库的扫描(<code>B+</code>树只需遍历所有的叶子节点就能对全部的关键字进行扫描)</li></ul></li></ul></li><li><code>Hash</code>索引<ul><li>根据<code>Hash</code>函数计算一次便能找到所需元素</li><li>仅仅满足<code>=</code>，<code>in</code>等等值查询，不能使用范围查询</li><li>不能进行排序操作，因为经过<code>Hash</code>运算后的值和运算前的键值对应，而查找是<code>Hash</code>索引对应的值，不能匹配到</li><li>不能避免全表 扫描</li></ul></li><li><code>BitMap</code><ul><li>仅<code>Oracle</code>支持</li><li>锁的粒度较大，新增和修改操作时，在同一位图的数据操作都会被阻塞</li></ul></li></ul></li><li>密集索引和稀疏索引<ul><li>密集索引：每个搜索码值都对应一个索引值</li><li>稀疏索引：只为索引码的某些值建立索引项</li></ul></li><li><code>InnoDB</code><ul><li>若一个主键被定义，则该主键则作为密集索引</li><li>若无主键定义，则该表第一个唯一非空索引值作为密集索引</li><li>若无以上，<code>innodb</code>内部会生成一个隐藏主键(密集索引)</li><li>数据和索引是存储在一起的，<code>MyIsAM</code>数据和索引是分开的</li></ul></li><li>优化步骤<ol><li>根据慢查询日志定位慢查询<code>sql</code><ol><li>变量<ol><li>慢查询日志：<code>slow_query_log</code></li><li>慢查询文件路径：<code>slow_query_log_file</code></li><li>慢查询时间：<code>long_query_time</code></li><li>开启慢查询日志：<code>set global slow_query_log = on;</code></li></ol></li><li>状态<ol><li><code>slow_queries</code>：慢查询数量</li></ol></li></ol></li><li>使用<code>explain</code>等工具分析 <code>sql</code><ol><li><code>type</code>：查找数据行的方式，<code>index</code>(索引)&gt;all(全表扫描)</li><li><code>extra</code>：<code>Using filesort</code>和<code>Using temporary</code>意味着不走索引，应该进行优化</li></ol></li><li>修改<code>sql</code>或者尽量让<code>sql</code>走索引<ol><li>修改<code>sql</code>走索引</li><li>为查询字段添加索引</li></ol></li></ol></li><li>原则<ul><li>最左前缀匹配原则，<code>mysql</code>会一直向右匹配，直到范围限定，如果范围之间有索引，则只有第一个条件会走索引，其他不会走索引</li><li><code>=</code>和<code>in</code>查询无需考虑索引顺序</li></ul></li></ol><p>索引相当于目录在书中的地位，内容远远多于目录时才适合建立。</p><ol><li><p>锁</p><ul><li><p><code>MyIsAM</code>和<code>InnoDB</code>锁的区别</p><ul><li><code>MyIsAM</code>默认使用表级锁，不支持行级锁</li><li><code>InnoDB</code>默认使用行级锁，也支持表级锁</li></ul></li><li><p>排他锁和共享锁的区别</p><table><thead><tr><th></th><th>排他锁</th><th>共享锁</th></tr></thead><tbody><tr><td>排他锁</td><td>冲突</td><td>冲突</td></tr><tr><td>共享锁</td><td>冲突</td><td>兼容</td></tr></tbody></table></li><li><p>乐观锁和悲观锁</p></li><li><p><code>MyIsAM</code>和<code>InnoDB</code>使用场景</p><ul><li><code>MyIsAM</code><ul><li>频繁的执行全表<code>count</code>语句</li><li>对数据进行增删频率不高，查询频率非常高</li><li>没有事务</li></ul></li><li><code>InnoDB</code><ul><li>数据增删改查的频率都非常频繁</li><li>可靠性要求比较高，要求支持事务</li></ul></li></ul></li><li><p>当前读和快照读</p></li><li><p><code>RC</code>，<code>RR</code>级别下的<code>InnoDB</code>非阻塞读实现</p><ul><li><code>RR</code>避免幻读，加行锁<code>+Gap</code>锁(<code>gap</code>锁用于非唯一索引和不走索引时)</li></ul></li></ul></li><li><p>事务的四大特性</p><ul><li><code>ACID</code></li><li>原子性，一致性，隔离性，持久性</li><li>隔离级别<ul><li>读已提交(<code>RC</code>)—解决脏读：一个事物读到另一个事务未提交的数据</li><li>可重复读(<code>RR</code>)—解决不重复读：一个数据前后两次读到的数据不一致</li><li>串行化—解决幻读：一个事物读到自己未提交的事务</li></ul></li></ul></li><li><p>锁的分类</p><ol><li>读锁又称为共享锁</li><li>写锁又称为排他锁</li><li>共享锁和排他锁，只有两个事务都是共享锁时不冲突</li><li>排他锁：增删改操作</li><li>共享锁：查询操作</li><li>悲观锁：在数据处理过程中将数据锁定，排他锁就是悲观锁的体现；为数据处理的安全性提供保证，同时也增加了产生死锁的机会</li><li>乐观锁：认为一般不会发生冲突，只有在更新数据时才会进行检测，如果冲突就返回错误信息(时间戳或数据版本)</li></ol></li><li><p><code>RC</code></p><ol><li><code>Oracle</code>默认的提交方式</li><li>实现快照读(非阻塞读)<ol><li>数据行必须有<code>DB_TRX_ID</code>，<code>DB_ROLL_PTR</code>，<code>DB_ROW_ID</code>字段</li><li><code>undo</code>日志</li><li><code>read view</code></li></ol></li></ol></li><li><p><code>RR</code></p><ol><li><code>MySQL</code>默认的提交方式</li><li>行锁<code>+gap</code>锁</li><li><code>gap</code>锁<ol><li>精确查找的时候，所有记录都有对应不会加<code>gap</code>锁</li><li><code>where</code>条件部分命中，会加<code>gap</code>锁</li><li>用于非唯一索引或不走索引的当前读中</li></ol></li></ol></li><li><p>关键语法</p><ul><li><code>Group by</code><ul><li><code>Select</code>语句中的列名必须为分组用到的列或列函数</li><li>只能是针对同一张表的字段进行分组</li></ul></li><li><code>having</code><ul><li>通常和<code>Group By</code>一起使用，<code>where</code>过滤行，<code>having</code>过滤组</li><li>如果省略了<code>where</code>，<code>having</code>的作用和<code>where</code>相同</li></ul></li></ul></li></ol><h4 id="5-1-2-数据库读写分离"><a href="#5-1-2-数据库读写分离" class="headerlink" title="5.1.2 数据库读写分离"></a>5.1.2 数据库读写分离</h4><h4 id="5-1-3-分库分表"><a href="#5-1-3-分库分表" class="headerlink" title="5.1.3 分库分表"></a>5.1.3 分库分表</h4><h4 id="5-1-4-数据库表全局唯一主键id"><a href="#5-1-4-数据库表全局唯一主键id" class="headerlink" title="5.1.4 数据库表全局唯一主键id"></a>5.1.4 数据库表全局唯一主键id</h4><h3 id="5-2-Oracle"><a href="#5-2-Oracle" class="headerlink" title="5.2 Oracle"></a>5.2 Oracle</h3><h2 id="6-服务器-主要用于集群"><a href="#6-服务器-主要用于集群" class="headerlink" title="6. 服务器(主要用于集群)"></a>6. 服务器(主要用于集群)</h2><h3 id="6-1-网络基础"><a href="#6-1-网络基础" class="headerlink" title="6.1 网络基础"></a>6.1 网络基础</h3><h4 id="6-1-1-基础概念"><a href="#6-1-1-基础概念" class="headerlink" title="6.1.1 基础概念"></a>6.1.1 基础概念</h4><ol><li><p>OSI网络基础</p><ul><li><p>七层模型</p><ul><li>物理层：电子接口通信信道上的原始比特流传输</li><li>数据链路层：将原始比特流转为逻辑传输线路</li><li>网络层：控制子网的运行，分组传输，路由选择</li><li>传输层：保证会话层的数据段有效的到达网络层</li><li>会话层：建立和管理应用层的会话</li><li>表示层：</li></ul></li><li><p>TCP</p><ul><li><p>流程</p><ul><li>面向连接的，可靠的，基于字节流的传输层通信协议</li><li>将应用层的数据流分割为报文段并发送给目标节点的TCP层</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和来检验数据在传输过程中是否有误</li></ul></li><li><p>标识</p><ul><li>URG：紧急指针标志</li><li>ACK：确认序号标志</li><li>PSH：push标志</li><li>PST：重置连接标志</li><li>SYN：同步序号，用于建立连接过程</li><li>FIN：finish标志，用于释放连接</li></ul></li><li><p>三次握手</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/01.TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%8A%B6%E6%80%81.png" alt="三次握手"></p><ul><li>说明<ul><li>建立连接时，客户端发送syn包到服务器，并进入syn_send状态，等待服务器确认。</li><li>服务器收到syn包，必须确认客户的syn包为接收值+1，同时自己也发送一个syn包，即syn+ack包，此时服务器进入syn_recv状态</li><li>客户端受到服务器的syn+ack包，向服务器发送确认包ack为接收服务的值+1，此时包发送完毕，客户端和服务器端进入restablished状态完成三次握手</li></ul></li></ul></li><li><p>四次挥手</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/02.TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p><ul><li>说明<ul><li>客户端发送fin字段来请求关闭连接到服务器，客户端进入fin_wait_1状态</li><li>服务器端接收到fin字段后，发送ack给客户端，确认序号为收到的序号+1，此时服务器进入close_wait状态</li><li>服务器发送fin字段，用来关闭服务器到客户端的数据传送，服务器进入last_ack状态</li><li>客户端收到fin后，进入time_wait状态，向服务器发送ack确认序号为收到序号+1，服务器进入closed状态，完成四次挥手</li></ul></li><li>服务器出现close_wait状态的原因<ul><li>服务器端未进行释放资源的操作</li><li>处理请求的线程配置不合理</li></ul></li></ul></li></ul></li></ul></li><li><p>UDP和TCP</p><ol><li><p>UDP</p><ul><li>特点<ul><li>面向非连接，不维护连接状态，支持同时向多个客户端传输相同的消息</li><li>数据包报头只有8个字节，额外开销小</li><li>吞吐量只受限于数据生成的速率，传输速率以及机器性能</li><li>尽最大努力交付，不保证交付的可靠性，不需要维持复杂的连接状态</li><li>面向报文，不对应用程序提交报文信息进行拆分合并</li></ul></li></ul></li><li><p>TCP和UDP对比</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>TCP</td><td>1. 面向连接<br>2. 传输可靠<br>3. 传输有序</td><td>1. 传输速度慢<br>2. 重量级传输协议</td></tr><tr><td>UDP</td><td>1. 传输速度高<br>2. 轻量级传输协议</td><td>1. 面向无连接<br>2. 不保证可靠性<br>3. 不保证有序性</td></tr></tbody></table></li><li><p>TCP的滑动窗口</p><blockquote><p>TCP使用滑动窗口做流量控制与乱序重排</p></blockquote><ul><li>保证TCP的可靠性</li><li>保证TCP的流控特性</li></ul></li></ol></li></ol><h4 id="6-1-2-HTTP和HTTPS"><a href="#6-1-2-HTTP和HTTPS" class="headerlink" title="6.1.2 HTTP和HTTPS"></a>6.1.2 HTTP和HTTPS</h4><ol><li><p>HTTP</p><ul><li><p>特点</p><ul><li>支持客户和服务器模式</li><li>简单快速灵活</li><li>无连接，无状态</li></ul></li><li><p>步骤</p><ul><li>根据DNS解析的域名地址访问服务器</li><li>和服务器之间建立TCP连接(三次握手)</li><li>客户端发送HTTP请求到web服务器</li><li>服务器接收请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>浏览器释放连接(四次挥手)</li></ul></li><li><p>状态码</p><ul><li>200：请求成功</li><li>401：未授权</li><li>403：服务被拒绝</li><li>404：未找到资源</li><li>500：服务器端错误，代码异常</li><li>503：服务器当前不能处理请求，需要等待，常见于服务启动尚未被注册中心发现。</li></ul></li><li><p>get和post的区别</p><table><thead><tr><th></th><th>get</th><th>post</th></tr></thead><tbody><tr><td>HTTP报文</td><td>将请求信息放在URL地址栏中</td><td>放在报文主体中</td></tr><tr><td>数据库</td><td>符合幂等性和安全性</td><td>不符合</td></tr><tr><td>其他</td><td>可以被缓存，被存储</td><td>不可以被缓存存储</td></tr></tbody></table></li><li><p>cookie和session的区别</p><ul><li>cookie保存在客户端浏览器相对不安全，大小为4k限制 </li><li>session保存在服务器端相对安全，借助于cookie实现，无大小限制</li></ul></li></ul></li><li><p>HTTPS</p><ul><li>加密<ul><li>对称加密：加密和解密都使用同一个密钥</li><li>非对称加密：加密使用的密钥和解密使用的密钥不同</li><li>哈希算法：将任意长度值的信息转换为固定长度的汉字，算法不可逆，常见的是MD5</li><li>数字签名：证明某个消息或者文件是某人发出/认同的</li></ul></li><li>HTTPS流程<ul><li>浏览器将支持的加密算法信息发送给服务器</li><li>服务器选择一套浏览器支持的加密算法，以证书的形式发送给浏览器</li><li>浏览器验证证书的合法性，并结合证书公钥加密信息发送给服务器</li><li>服务器使用私钥解密信息，验证哈希，加密响应消息发送给浏览器</li><li>浏览器解密响应消息，并对消息验证真假，之后进行加密交互数据</li></ul></li></ul></li><li><p>HTTP和HTTPS区别</p><table><thead><tr><th></th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>证书</td><td>不需要CA证书</td><td>需要到CA申请证书</td></tr><tr><td>传输</td><td>明文传输</td><td>密文传输<br>使用HTTP+加密+认证+完整性保护</td></tr><tr><td>端口</td><td>使用80端口</td><td>使用443端口</td></tr></tbody></table></li></ol><h4 id="6-1-3-其他"><a href="#6-1-3-其他" class="headerlink" title="6.1.3 其他"></a>6.1.3 其他</h4><ol><li><p><code>socket</code></p><blockquote><p>是TCP/IP协议的抽象，是操作系统对外开放的接口</p></blockquote></li><li><p><code>Linux</code></p><ol><li>查找指定文件：<code>find path [options] params</code></li><li>查找符合条件的文本：<code>grep [options] pattern file</code></li><li>对文件内容进行统计：<code>awk [options] cmd file</code></li><li>批量替换文档内容：<code>sed [options] &#39;sed command&#39; filename</code></li></ol></li></ol><h3 id="6-2-Nginx"><a href="#6-2-Nginx" class="headerlink" title="6.2 Nginx"></a>6.2 Nginx</h3><ol><li><p>项目规模</p><ol><li>2-3人团队，用户量100-500</li><li>5-10人团队，用户量1000-10000</li><li>20-30人团队，用户量5w-50w</li><li>50-100人团队，用户量百万级</li><li>100+人团队，用户量千万级</li><li>1000+人团队，用户量亿级</li></ol></li><li><p>单体架构</p><ul><li>优点<ul><li>小团队即可完成开发</li><li>迭代周期短，开发速度快</li><li>打包方便，运维简单</li></ul></li><li>缺点<ul><li>单节点宕机造成所有服务不可用</li><li>耦合度太高(迭代，测试，部署)</li><li>单节点并发能力有限</li></ul></li></ul></li><li><p>集群</p><blockquote><p>多服务器共同实现同一个业务</p></blockquote><ol><li><p>特点</p><ol><li>计算器<strong>群体</strong>构成整个业务系统</li><li>这个<strong>群体</strong>构成一个整体，不能独立存在</li><li><strong>人多力量大</strong>，群体提升并发与可用性</li></ol></li><li><p>优点</p><ol><li>高性能</li><li>高可用</li><li>高扩展性</li></ol></li><li><p>TIP</p><ol><li><p>用户会话</p><blockquote><p>多个服务器之间会话不共享，所以要使用分布式会话</p></blockquote></li><li><p>定时任务</p><blockquote><p>所有的计算机节点，在定时时刻做一些通用事务</p></blockquote></li><li><p>内网互通是保持集群的前提</p></li></ol></li></ol></li><li><p>分布式</p><blockquote><p>每一个计算机节点都实现的业务不同</p></blockquote></li></ol><h4 id="6-2-1-Nginx入门"><a href="#6-2-1-Nginx入门" class="headerlink" title="6.2.1 Nginx入门"></a>6.2.1 Nginx入门</h4><ol><li><p>概述</p><blockquote><p>一个高性能的HTTP和反向代理的web服务器；也提供IMAP/POP3/SMTP服务 </p></blockquote></li><li><p>应用</p><ol><li>主要用于反向代理</li><li>静态资源部署</li></ol></li><li><p>正向代理</p><ol><li><p>用户请求–&gt;代理服务器–&gt;目标服务器；目标服务器–&gt;用户</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/03.%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt="正向代理"></p></li></ol></li><li><p>反向代理</p><blockquote><p>用户请求目标服务器，由反向代理服务器决定访问那个目标资源IP</p></blockquote><ol><li><p>示意</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/04.%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="反向代理"></p></li><li><p>官网</p><blockquote><p>nginx.org；选择stale version进行对应系统版本下载</p></blockquote></li></ol></li><li><p>Nginx进程模型</p><ol><li>master进程：主进程；主要用于管理一些worker进程</li><li>worker进程：工作进程</li></ol></li><li><p>worker抢占机制</p><blockquote><p>master主进程监听80端口，由一个master主进程fork了三个worker进程；三个worker进程会抢占一个accept_mutex(互斥锁)，这个锁和Client请求对应；那个worker抢到了accept_mutex锁，那个进程去处理用户请求</p></blockquote></li><li><p>事件处理</p><ol><li><p>传统方式</p><blockquote><p>同步阻塞请求模型</p></blockquote></li><li><p>nginx事件处理</p><blockquote><p>异步非阻塞模型；即多路复用器</p></blockquote></li></ol></li><li><p>Nginx配置文件</p><ol><li><p>配置结构</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/05.%E9%85%8D%E7%BD%AE%E7%BB%93%E6%9E%84.png" alt="配置结构"></p></li><li><p>配置文件(由指令块组成)</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 工作进程worker的用户名称</span><span class="token attr-name">user</span> <span class="token attr-value"> nobody;</span><span class="token comment" spellcheck="true"># worker进程数目</span><span class="token attr-name">worker_processes</span> <span class="token attr-value"> 1;</span><span class="token comment" spellcheck="true"># 默认错误日志；路径 日志级别；nginx日志级别：debug，Info，notice，warn，error，crit</span><span class="token attr-name">error_log</span> <span class="token attr-value"> logs/error.log;</span><span class="token comment" spellcheck="true"># error_log  logs/error.log  notice;</span><span class="token comment" spellcheck="true">#error_log  logs/error.log  info;</span><span class="token comment" spellcheck="true"># nginx进程号</span><span class="token attr-name">pid</span> <span class="token attr-value">       logs/nginx.pid;</span><span class="token attr-name">events</span> <span class="token attr-value">{</span><span class="token comment" spellcheck="true">    # 默认使用epoll</span><span class="token attr-name">    use</span> <span class="token attr-value">epoll;</span><span class="token comment" spellcheck="true">    # 每个worker允许连接的客户端最大连接数</span><span class="token attr-name">    worker_connections</span> <span class="token attr-value"> 1024;</span>}<span class="token attr-name">http</span> <span class="token attr-value">{</span><span class="token comment" spellcheck="true">    # 包含的外部文件</span><span class="token attr-name">    include</span> <span class="token attr-value">      mime.types;</span><span class="token comment" spellcheck="true">    # 默认的type类型</span><span class="token attr-name">    default_type</span> <span class="token attr-value"> application/octet-stream;</span><span class="token comment" spellcheck="true">    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><span class="token comment" spellcheck="true">    #                  '$status $body_bytes_sent "$http_referer" '</span><span class="token comment" spellcheck="true">    #                  '"$http_user_agent" "$http_x_forwarded_for"';</span><span class="token comment" spellcheck="true">    #access_log  logs/access.log  main;</span><span class="token comment" spellcheck="true">    # 用于文件的高效传输，默认打开</span><span class="token attr-name">    sendfile</span> <span class="token attr-value">       on;</span><span class="token comment" spellcheck="true">    # 配合sendfile进行高效传输，等数据包到一定大小在进行传输</span><span class="token attr-name">    tcp_nopush</span> <span class="token attr-value">    on;</span><span class="token comment" spellcheck="true">    # 客户端连接服务器的超时时间，以s为单位；keepalive_timeout  0;</span><span class="token attr-name">    keepalive_timeout</span> <span class="token attr-value"> 65;</span><span class="token comment" spellcheck="true">    # 使用gzip技术压缩，提高传输速率，节约带宽</span><span class="token attr-name">    gzip</span> <span class="token attr-value"> on;</span><span class="token comment" spellcheck="true">    # 限制最小压缩，小于1字节的不会被压缩</span><span class="token attr-name">    gzip_min_length</span> <span class="token attr-value">1;</span><span class="token comment" spellcheck="true">    # 定义压缩级别(即压缩比，文件越大，压缩越多，但是CPU使用会越多)；取值范围1-9</span><span class="token attr-name">    gzip_comp_level</span> <span class="token attr-value">3;</span><span class="token comment" spellcheck="true">    # 定义文件压缩的类型</span><span class="token attr-name">    gzip_types</span> <span class="token attr-value">text/plain application/javascript application/x-javascript text/css application/xml text/javascript application//x-httpd-php image/jpg image/gif image/png application/json</span><span class="token comment" spellcheck="true">    # 虚拟主机</span><span class="token attr-name">    server</span> <span class="token attr-value">{</span><span class="token comment" spellcheck="true">        # 监听端口号</span><span class="token attr-name">        listen</span> <span class="token attr-value">      80;</span><span class="token comment" spellcheck="true">        # 监听的域名</span><span class="token attr-name">        server_name</span> <span class="token attr-value"> localhost;</span><span class="token comment" spellcheck="true">        #charset koi8-r;</span><span class="token comment" spellcheck="true">        #access_log  logs/host.access.log  main;</span><span class="token comment" spellcheck="true">        # 路由</span><span class="token attr-name">        location</span> <span class="token attr-value">/ {</span><span class="token attr-name">            root</span> <span class="token attr-value">  html;</span><span class="token attr-name">            index</span> <span class="token attr-value"> index.html index.htm;</span>        }<span class="token comment" spellcheck="true">        #error_page  404              /404.html;</span><span class="token comment" spellcheck="true">        # redirect server error pages to the static page /50x.html</span><span class="token comment" spellcheck="true">        # 默认错误页面</span><span class="token attr-name">        error_page</span> <span class="token attr-value">  500 502 503 504  /50x.html;</span><span class="token attr-name">        location</span> <span class="token punctuation">=</span> <span class="token attr-value">/50x.html {</span><span class="token attr-name">            root</span> <span class="token attr-value">  html;</span>        }<span class="token comment" spellcheck="true">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><span class="token comment" spellcheck="true">        #</span><span class="token comment" spellcheck="true">        #location ~ \.php$ {</span><span class="token comment" spellcheck="true">        #    proxy_pass   http://127.0.0.1;</span><span class="token comment" spellcheck="true">        #}</span><span class="token comment" spellcheck="true">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><span class="token comment" spellcheck="true">        #</span><span class="token comment" spellcheck="true">        #location ~ \.php$ {</span><span class="token comment" spellcheck="true">        #    root           html;</span><span class="token comment" spellcheck="true">        #    fastcgi_pass   127.0.0.1:9000;</span><span class="token comment" spellcheck="true">        #    fastcgi_index  index.php;</span><span class="token comment" spellcheck="true">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><span class="token comment" spellcheck="true">        #    include        fastcgi_params;</span><span class="token comment" spellcheck="true">        #}</span><span class="token comment" spellcheck="true">        # deny access to .htaccess files, if Apache's document root</span><span class="token comment" spellcheck="true">        # concurs with nginx's one</span><span class="token comment" spellcheck="true">        #</span><span class="token comment" spellcheck="true">        #location ~ /\.ht {</span><span class="token comment" spellcheck="true">        #    deny  all;</span><span class="token comment" spellcheck="true">        #}</span>    }<span class="token comment" spellcheck="true">    # another virtual host using mix of IP-, name-, and port-based configuration</span><span class="token comment" spellcheck="true">    #</span><span class="token comment" spellcheck="true">    #server {</span><span class="token comment" spellcheck="true">    #    listen       8000;</span><span class="token comment" spellcheck="true">    #    listen       somename:8080;</span><span class="token comment" spellcheck="true">    #    server_name  somename  alias  another.alias;</span><span class="token comment" spellcheck="true">    #    location / {</span><span class="token comment" spellcheck="true">    #        root   html;</span><span class="token comment" spellcheck="true">    #        index  index.html index.htm;</span><span class="token comment" spellcheck="true">    #    }</span><span class="token comment" spellcheck="true">    #}</span><span class="token comment" spellcheck="true">    # HTTPS server</span><span class="token comment" spellcheck="true">    #</span><span class="token comment" spellcheck="true">    #server {</span><span class="token comment" spellcheck="true">    #    listen       443 ssl;</span><span class="token comment" spellcheck="true">    #    server_name  localhost;</span><span class="token comment" spellcheck="true">    #    ssl_certificate      cert.pem;</span><span class="token comment" spellcheck="true">    #    ssl_certificate_key  cert.key;</span><span class="token comment" spellcheck="true">    #    ssl_session_cache    shared:SSL:1m;</span><span class="token comment" spellcheck="true">    #    ssl_session_timeout  5m;</span><span class="token comment" spellcheck="true">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><span class="token comment" spellcheck="true">    #    ssl_prefer_server_ciphers  on;</span><span class="token comment" spellcheck="true">    #    location / {</span><span class="token comment" spellcheck="true">    #        root   html;</span><span class="token comment" spellcheck="true">    #        index  index.html index.htm;</span><span class="token comment" spellcheck="true">    #    }</span><span class="token comment" spellcheck="true">    #}</span>}</code></pre></li></ol></li><li><p><code>nginx</code>命令</p><ol><li><code>./nginx -s stop</code>：暴力退出，无论此时nginx是否被响应，都予停止</li><li><code>./nginx -s quit</code>：优雅退出，停止分发新请求，已有连接完成传输时退出；适用于http协议</li><li><code>./nginx -t</code>：检测配置文件修改是否正确命令，正确则显示OK</li><li><code>./nginx -v</code>：小v，查看<code>nginx</code>版本号</li><li><code>./nginx -V</code>：大V，展示版本号，gcc编译环境等具体信息</li><li><code>./nginx -h</code>：查看帮助信息</li></ol></li><li><p>日志切割</p><ol><li><p>手动—创建如下<code>shell</code>脚本(放在/usr/local/nginx/sbin/目录下)</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashLOG_PATH="/var/log/nginx/"RECORD_TIME=$(date -d "yesterday" +%Y-%m-%d+%H:%M)PID=/var/run/nginx/nginx.pidmv ${LOG_PATH}/access.log ${LOG_PATH}/access.${RECORD_TIME}.logmv ${LOG_PATH}/error.log ${LOG_PATH}/error.${RECORD_TIME}.log#向Nginx主进程发送信号，用于重新打开日志文件kill -USR1 `cat $PID`</code></pre></li><li><p>自动</p><ol><li><p>安装插件</p><p><code>yum install crontabs</code></p></li><li><p>使用<code>crontabs -e</code>添加任务，使用<code>crontabs -l</code>查看任务</p><p><code>*/1 * * * * /usr/local/nginx/sbin/cut_my_log.sh</code></p></li><li><p>重启定时任务</p><p><code>service crond restart</code></p></li></ol></li><li><p>常用命令</p><pre class=" language-shell"><code class="language-shell">service crond start # 启动服务service crond stop # 关闭服务service crond restart # 重启服务service crond reload # 重新载入配置crontab -e # 编辑任务crontab -l # 查看任务列表</code></pre></li><li><p>Cron表达式</p><table><thead><tr><th>项目</th><th>分</th><th>时</th><th>日</th><th>月</th><th>星期</th><th>年(可选)</th></tr></thead><tbody><tr><td>取值范围</td><td>0-59</td><td>0-23</td><td>1-31</td><td>1-12</td><td>1-7</td><td>2019/2020/2021</td></tr></tbody></table></li></ol></li><li><p>location匹配规则</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 空格 ：默认匹配，普通匹配</span><span class="token attr-name">location</span> <span class="token attr-value">/ {</span><span class="token attr-name">    root</span> <span class="token attr-value">/home;</span>}<span class="token comment" spellcheck="true"># = ：精确匹配</span><span class="token attr-name">location</span> <span class="token punctuation">=</span> <span class="token attr-value">/imooc/img/face1.png {</span><span class="token attr-name">    root</span> <span class="token attr-value">/home;</span>}<span class="token comment" spellcheck="true"># ~* ：匹配正则表达式，不区分大小写；符合图片的显示</span><span class="token attr-name">location</span> <span class="token attr-value">~ \.(GIF|jpg|png|jpeg) {</span><span class="token attr-name">    root</span> <span class="token attr-value">/home;</span>}<span class="token comment" spellcheck="true"># ~ ：匹配正则表达式，区分大小写；GIF必须大写才能匹配到</span><span class="token attr-name">location</span> <span class="token attr-value">~ \.(GIF|jpg|png|jpeg) {</span><span class="token attr-name">    root</span> <span class="token attr-value">/home;</span>}<span class="token comment" spellcheck="true"># ^~ ：以某个字符路径开头</span><span class="token attr-name">location</span> <span class="token attr-value">^~ /imooc/img {</span><span class="token attr-name">    root</span> <span class="token attr-value">/home;</span>}</code></pre></li><li><p>Nginx跨域</p><blockquote><p>由于浏览器的同源策略限制，不同域名之间资源不共享。</p></blockquote><ol><li><p>CORS跨域资源共享</p><ol><li>cross origin resource sharing</li><li>允许浏览器进行跨域资源访问</li></ol></li><li><p>实现方式</p><ol><li><p>jsonp</p></li><li><p>SpringBoot Cors</p></li><li><p>Nginx</p><blockquote><p>服务器端不存在浏览器的同源策略限制(原理)</p></blockquote><p>实现</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token comment" spellcheck="true">    # 监听端口号</span><span class="token attr-name">    listen</span> <span class="token attr-value">      80;</span><span class="token comment" spellcheck="true">    # 监听的域名</span><span class="token attr-name">    server_name</span> <span class="token attr-value"> localhost;</span><span class="token comment" spellcheck="true">    #允许跨域请求的域，*代表所有</span><span class="token attr-name">    add_header</span> <span class="token attr-value">'Access-Control-Allow-Origin' *;</span><span class="token comment" spellcheck="true">    #允许带上cookie请求</span><span class="token attr-name">    add_header</span> <span class="token attr-value">'Access-Control-Allow-Credentials' 'true';</span><span class="token comment" spellcheck="true">    #允许请求的方法，比如 GET/POST/PUT/DELETE</span><span class="token attr-name">    add_header</span> <span class="token attr-value">'Access-Control-Allow-Methods' *;</span><span class="token comment" spellcheck="true">    #允许请求的header</span><span class="token attr-name">    add_header</span> <span class="token attr-value">'Access-Control-Allow-Headers' *;</span>}</code></pre></li></ol></li></ol></li><li><p>静态资源防盗链</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token comment" spellcheck="true">    # 监听端口号</span><span class="token attr-name">    listen</span> <span class="token attr-value">      80;</span><span class="token comment" spellcheck="true">    # 监听的域名</span><span class="token attr-name">    server_name</span> <span class="token attr-value"> localhost;</span><span class="token comment" spellcheck="true">    #对源站点验证；非mjh一级域名下的网站资源不共享</span><span class="token attr-name">    valid_referers</span> <span class="token attr-value">*.mjh.com;</span><span class="token comment" spellcheck="true">    #非法引入会进入下方判断</span><span class="token attr-name">    if</span> <span class="token attr-value">($invalid_referer) {</span><span class="token attr-name">        return</span> <span class="token attr-value">404;</span>    }}</code></pre></li><li><p>Nginx模块体系</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/06.Nginx%E6%A8%A1%E5%9D%97%E4%BD%93%E7%B3%BB.png" alt="Nginx模块体系"></p></li></ol><h4 id="6-2-2-Nginx集群与负载均衡"><a href="#6-2-2-Nginx集群与负载均衡" class="headerlink" title="6.2.2 Nginx集群与负载均衡"></a>6.2.2 Nginx集群与负载均衡</h4><ol><li><p>概述</p><blockquote><p>通过配置文件即可实现集群和负载均衡</p></blockquote></li><li><p><font color="red">负载均衡</font></p><ol><li><p>四层负载均衡</p><ul><li>F5：硬负载均衡</li><li>LVS：四层负载均衡</li><li>Haproxy：四层负载均衡</li><li>Nginx：四层负载均衡</li></ul></li><li><p>七层负载均衡</p><ul><li>Nginx：七层负载均衡</li><li>Haproxy：七层负载均衡</li><li>Apache：七层负载均衡</li></ul></li><li><p>DNS地域负载均衡</p><blockquote><p>通过DNS服务器处理，采取就近原则进行访问</p></blockquote></li></ol></li><li><p>Nginx搭建Tomcat集群</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 配置上游服务器</span><span class="token attr-name">upstream</span> <span class="token attr-value">tomcats {</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.171;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.172;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.173;</span>}<span class="token comment" spellcheck="true"># 配置Nginx代理</span><span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">    listen</span> <span class="token attr-value">80;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">www.tomcats.com;</span><span class="token attr-name">    location</span> <span class="token attr-value">/ {</span><span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://tomcats;</span>    }}</code></pre></li><li><p>使用JMeter测试单机和集群的并发异常率</p><ol><li><p>单机版5000次并发访问数据</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/07.%E5%8D%95%E6%9C%BA%E7%89%885000%E6%AC%A1%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE.png" alt="单机版5000次并发访问数据"></p></li><li><p>单机版2w次并发访问数据</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/08.%E5%8D%95%E6%9C%BA%E7%89%8820000%E6%AC%A1%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE.png" alt="单机版20000次并发访问数据"></p></li><li><p>集群(2台内网Tomcat)并发访问数据</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/09.%E9%9B%86%E7%BE%A4%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE.png" alt="集群并发访问数据"></p></li></ol></li><li><p>负载均衡策略</p><ol><li><p>轮询</p><blockquote><p>Tomcat集群默认的负载均衡策略：将浏览器请求平均的分配到每一台服务器上(针对服务器配置相同时)</p></blockquote><ul><li><p>加权轮训</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 配置上游服务器</span><span class="token attr-name">upstream</span> <span class="token attr-value">tomcats {</span><span class="token comment" spellcheck="true">    # weight为权值指令，默认值是1，值越大，分发的请求越多</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.171 weight=1;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.172 weight=2;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.173 weight=5;</span>}</code></pre></li></ul></li><li><p><code>upstream</code>指令参数</p><ul><li><code>max_conns</code>：限制服务器的最大连接数；默认值是0，表示不做任何限制；最大值是10</li><li><code>slow_start</code>：使服务器缓慢的加入集群，体现在该服务器的权值变化(<code>0-&gt;max</code>)[商业版本才支持的参数]</li><li><code>down</code>：用于标识该服务器处于不可用的状态，即用户不能访问该服务器的资源</li><li><code>backup</code>：标识该服务器是一台备用机，集群中所有服务器都正常时不会访问该服务器；当集群中的所有服务器挂掉了，才会被用户访问到</li><li><code>max_fails</code>：最大的失败次数，如果达到该值，则认为该服务器宕机</li><li><code>fail_timeout</code>：失败的时间段，达到该时间值，则认为该服务器宕机</li><li><code>max_fails</code>和<code>fail_timeout</code>组合使用，在满足时间值的前提上达到指定次数，认为该服务器宕机</li></ul></li><li><p><code>keepalive</code></p><blockquote><p>提高吞吐量</p></blockquote><ul><li><p>把所有连接作为一个长连接</p></li><li><p>配置</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 使用keepalive配置长连接</span><span class="token attr-name">upstream</span> <span class="token attr-value">tomcats {</span><span class="token comment" spellcheck="true">    # weight为权值指令，默认值是1，值越大，分发的请求越多</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.171 weight=1;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.172 weight=2;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.173 weight=5;</span><span class="token attr-name">    keepalive</span> <span class="token attr-value">32;</span>}<span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">    listen</span> <span class="token attr-value">80;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">www.tomcats.com;</span><span class="token attr-name">    location</span> <span class="token attr-value">/ {</span><span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://tomcats;</span><span class="token attr-name">        proxy_http_version</span> <span class="token attr-value">1.1;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">Connection "";</span>    }}</code></pre></li></ul></li><li><p><code>ip-hash</code></p><blockquote><p>根据用户请求的IP由hash函数计算一个hash值，然后根据这个值分发到特定的服务器上；保证同一用户的多次请求session是一致的(后端某个服务器和IP计算的特定hash值相同)</p></blockquote><p><strong>hash算法原理：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/10.hash%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86.png" alt="hash算法原理"></p><ul><li>说明<ul><li><code>node_counts</code>：当前集群的节点总数</li><li><code>index</code>：服务器对应的索引值</li></ul></li><li>配置</li></ul><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 配置上游服务器</span><span class="token attr-name">upstream</span> <span class="token attr-value">tomcats {</span>    ip_hash;<span class="token comment" spellcheck="true">    # weight为权值指令，默认值是1，值越大，分发的请求越多</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.171;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.172;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.173;</span>}<span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">    listen</span> <span class="token attr-value">80;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">Nginx服务器IP;</span><span class="token attr-name">    location</span> <span class="token attr-value">/ {</span><span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://tomcats;</span>    }}</code></pre><ul><li><p>Hash算法存在问题</p><blockquote><p>当集群中有一台服务器宕机，所有IP地址对应的Hash值都有会发生变化，进而导致Session改变</p></blockquote></li><li><p>解决—(一致性Hash算法)</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/11.%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95.png" alt="一致性Hash算法"></p></li><li><p>服务器宕机情况</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/12.%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%95%E6%9C%BA%E6%83%85%E5%86%B5.png" alt="服务器宕机情况"></p><p>只有访问在已经宕机的服务器的用户<code>Session</code>会丢失，其他用户的<code>Session</code>不受影响</p></li><li><p>集群新增服务器</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/13.%E9%9B%86%E7%BE%A4%E6%96%B0%E5%A2%9E%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="集群新增服务器"></p><p>只有计算在新增服务器上的用户<code>Session</code>会发生变化，其他用户的<code>Session</code>依然不变</p></li></ul></li><li><p>负载均衡原理</p><ol><li><p>ip_hash：<code>hash(url)%node_counts = index</code></p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 配置上游服务器</span><span class="token attr-name">upstream</span> <span class="token attr-value">tomcats {</span><span class="token attr-name">    hash</span> <span class="token attr-value">$request_uri;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.171;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.172;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.173;</span>}</code></pre></li><li><p>least_conn：将请求分配给集群中连接数最小的服务器</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 配置上游服务器</span><span class="token attr-name">upstream</span> <span class="token attr-value">tomcats {</span>    least_conn;<span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.171;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.172;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.173;</span>}</code></pre></li></ol></li></ol></li><li><p>Nginx控制浏览器缓存</p><ol><li><p>静态资源缓存策略</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/14.%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.png" alt="静态资源缓存策略"></p></li><li><p>Nginx设置浏览器缓存过期时间</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">    listen</span> <span class="token attr-value">80;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">Nginx服务器IP;</span><span class="token attr-name">    location</span> <span class="token attr-value">/static {</span><span class="token comment" spellcheck="true">        # 为static资源设置别名</span><span class="token attr-name">        alias</span> <span class="token attr-value">/home/mjh;</span><span class="token comment" spellcheck="true">        # 形式一：设置浏览器的缓存过期时间，10s之后过期</span><span class="token attr-name">        expires</span> <span class="token attr-value">10s;</span><span class="token comment" spellcheck="true">        # 形式二：设置浏览器的缓存过期时间，晚上10:30之后过期</span><span class="token attr-name">        expires</span> <span class="token attr-value">@22h30m;</span>    }}</code></pre><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><code>expires [time]</code></td><td>在该时间后过期</td></tr><tr><td><code>expires @[time]</code></td><td>在该时间点过期</td></tr><tr><td><code>expires -[time]</code></td><td>在该时间之前过期</td></tr><tr><td><code>expires off</code></td><td>关闭浏览器的默认缓存机制</td></tr><tr><td><code>expires max</code></td><td>设置缓存永不过期</td></tr></tbody></table><ol><li>Nginx缓存路径设置</li></ol><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># proxy_cache_path</span><span class="token comment" spellcheck="true">#     keys_zone 设置共享内以及占用的空间大小</span><span class="token comment" spellcheck="true">#     max_size 设置缓存大小</span><span class="token comment" spellcheck="true">#     inactive 超过此时间，则自动清理缓存</span><span class="token comment" spellcheck="true">#     use_temp_path 关闭临时目录</span><span class="token attr-name">proxy_cache_path</span> <span class="token attr-value">/usr/local/nginx/upstream_cache keys_zone=mycache:5m max_size=1g inactive=1m use_temp_path=0ff</span><span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">    listen</span> <span class="token attr-value">80;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">Nginx服务器IP;</span><span class="token comment" spellcheck="true">    # 开启并且使用缓存</span><span class="token attr-name">    proxy_cache</span> <span class="token attr-value">mycache;</span><span class="token comment" spellcheck="true">    # 设置200和304状态码的过期时间</span><span class="token attr-name">    procy_cache_valid</span> <span class="token attr-value">200 204 8h;</span>}</code></pre></li></ol></li><li><p>Nginx配置https域名证书</p><ol><li><p>安装SSL模块(http_ssl_module)</p><ul><li><p>进入到nginx的解压目录： /home/software/nginx-1.16.1新增http_ssl_module模块</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">./configure</span> <span class="token attr-value">\--prefix=/usr/local/nginx \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_gzip_static_module \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi \--with-http_ssl_module</span></code></pre></li><li><p>编译安装</p><pre class=" language-shell"><code class="language-shell">makemake install</code></pre></li><li><p>检测是否安装SSL成功</p><pre class=" language-shell"><code class="language-shell">../sbin/nginx/ -V# 结果会有--with-http_ssl_module出现</code></pre></li></ul></li><li><p>配置HTTPS</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">    listen</span> <span class="token attr-value">443;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">www.imoocdsp.com;</span><span class="token comment" spellcheck="true">    # 开启ssl</span><span class="token attr-name">    ssl</span> <span class="token attr-value">on;</span><span class="token comment" spellcheck="true">    # 配置ssl证书</span><span class="token attr-name">    ssl_certificate</span> <span class="token attr-value">1_www.imoocdsp.com_bundle.crt;</span><span class="token comment" spellcheck="true">    # 配置证书秘钥</span><span class="token attr-name">    ssl_certificate_key</span> <span class="token attr-value">2_www.imoocdsp.com.key;</span><span class="token comment" spellcheck="true">    # ssl会话cache</span><span class="token attr-name">    ssl_session_cache</span> <span class="token attr-value">shared:SSL:1m;</span><span class="token comment" spellcheck="true">    # ssl会话超时时间</span><span class="token attr-name">    ssl_session_timeout</span> <span class="token attr-value">5m;</span><span class="token comment" spellcheck="true">    # 配置加密套件，写法遵循 openssl 标准</span><span class="token attr-name">    ssl_protocols</span> <span class="token attr-value">TLSv1 TLSv1.1 TLSv1.2;</span><span class="token attr-name">    ssl_ciphers</span> <span class="token attr-value">ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><span class="token attr-name">    ssl_prefer_server_ciphers</span> <span class="token attr-value">on;</span><span class="token attr-name">    location</span> <span class="token attr-value">/ {</span><span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://tomcats/;</span><span class="token attr-name">        index</span> <span class="token attr-value">index.html index.htm;</span>    }}</code></pre></li></ol></li><li><p>动静分离</p><blockquote><p>本质是分布式的</p></blockquote><ul><li>特点<ul><li>前后端解耦</li><li>静态部署Nginx</li><li>接口服务化</li></ul></li><li>静态数据：css/js/html/image/videos/audios</li><li>动态数据：得到的响应会和上一次不同</li><li>动静分离的方式CDN(内容分发网络)</li><li>动静分离的方式Nginx</li><li>存在问题<ul><li>跨域资源访问异常(解决)<ul><li>Springboot</li><li>Nginx</li><li>jsonp</li></ul></li><li>分布式会话非同一个会话对象(解决)<ul><li>分布式缓存Redis</li></ul></li></ul></li></ul></li></ol><h4 id="6-2-3-Nginx应用"><a href="#6-2-3-Nginx应用" class="headerlink" title="6.2.3 Nginx应用"></a>6.2.3 Nginx应用</h4><ol><li><p>下载安装Nginx</p></li><li><p>配置反向代理</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">upstream</span> <span class="token attr-value">api.mjhcode.com {</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.171;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.172;</span><span class="token attr-name">    server</span> <span class="token attr-value">192.168.1.173;</span>}<span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">    listen</span> <span class="token attr-value">80;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">api.mjhcode.com;</span><span class="token attr-name">    location</span> <span class="token attr-value">~ {</span><span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://api.mjhcode.com;</span>    }}</code></pre></li><li><p>作用</p><ol><li>负载均衡(Tomcat集群)</li><li>网关</li><li>反向代理(Tomcat集群)</li><li>动静分离</li></ol></li></ol><h4 id="6-2-4-Nginx高可用"><a href="#6-2-4-Nginx高可用" class="headerlink" title="6.2.4 Nginx高可用"></a>6.2.4 Nginx高可用</h4><blockquote><p>解决单台Nginx服务器宕机故障，用于构建Nginx集群。</p></blockquote><ol><li><p>Keepalived</p><blockquote><p>实现服务器端的集群控制，主要用在Nginx上</p></blockquote><ul><li>特点<ol><li>解决单点故障</li><li>组件免费</li><li>实现高可用的HA机制</li><li>基于VRRP协议<ul><li>虚拟路由冗余协议</li><li>解决网络单机故障的路由协议</li><li>构建有多个路由器master backup</li><li>虚拟ip-vip</li></ul></li></ol></li></ul></li><li><p>Keepalived双机主备原理</p><blockquote><p>主，备机之间的物理配置必须保持一致</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/15.Keepalived%E5%8F%8C%E6%9C%BA%E4%B8%BB%E5%A4%87%E5%8E%9F%E7%90%86.png" alt="Keepalived双机主备原理"></p></li><li><p>keepAlived配置</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">global_defs</span> <span class="token attr-value">{</span><span class="token comment" spellcheck="true">    # 路由id：当前安装keepalived的节点主机标识符，保证全局唯一(主备不同的地方)</span><span class="token comment" spellcheck="true">    # 虚拟ip映射的真实ip</span><span class="token attr-name">    router_id</span> <span class="token attr-value">keep_171</span>}<span class="token attr-name">vrrp_instance</span> <span class="token attr-value">VI_1 {</span><span class="token comment" spellcheck="true">    # 表示状态是MASTER主机还是备用机BACKUP(主备不同的地方)</span><span class="token attr-name">    state</span> <span class="token attr-value">MASTER</span><span class="token comment" spellcheck="true">    # 该实例绑定的网卡</span><span class="token attr-name">    interface</span> <span class="token attr-value">ens33</span><span class="token comment" spellcheck="true">    # 保证主备节点一致即可</span><span class="token attr-name">    virtual_router_id</span> <span class="token attr-value">51</span><span class="token comment" spellcheck="true">    # 权重，master权重一般高于backup，如果有多个，那就是选举，谁的权重高，谁就当选</span><span class="token comment" spellcheck="true">    # (主备不同的地方)</span><span class="token attr-name">    priority</span> <span class="token attr-value">100</span><span class="token comment" spellcheck="true">    # 主备之间同步检查时间间隔，单位秒</span><span class="token attr-name">    advert_int</span> <span class="token attr-value">2</span><span class="token comment" spellcheck="true">    # 认证权限密码，防止非法节点进入</span><span class="token attr-name">    authentication</span> <span class="token attr-value">{</span><span class="token attr-name">        auth_type</span> <span class="token attr-value">PASS</span><span class="token attr-name">        auth_pass</span> <span class="token attr-value">1111</span>    }<span class="token comment" spellcheck="true">    # 虚拟出来的ip，可以有多个（vip）；用户访问的IP地址</span><span class="token attr-name">    virtual_ipaddress</span> <span class="token attr-value">{</span>        192.168.1.161    }}</code></pre></li><li><p>keepAlived注册为系统服务</p><ol><li><p>进入到keepAlived解压后的目录中，再进入keepAlived目录，递进到etc目下会有两个文件<code>init.d</code>和<code>sysconfig</code></p></li><li><p>执行拷贝命令</p><p><code>cp init.d/keepalived etc/intit.d/</code></p><p><code>cp sysconfig/keepalived etc/sysconfig/</code></p></li><li><p>刷新系统配置</p><p><code>systemctl deamon-reload</code></p></li><li><p>操作keepAlived</p><pre class=" language-shell"><code class="language-shell"># 启动systemctl start keepalived.service# 停止systemctl stop keepalived.service# 重启systemctl restart keepalived.service</code></pre></li></ol></li><li><p>配置Nginx自动重启</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashA=`ps -C nginx --no-header |wc -l`# 判断nginx是否宕机，如果宕机了，尝试重启if [ $A -eq 0 ];then    /usr/local/nginx/sbin/nginx    # 等待一小会再次检查nginx，如果没有启动成功，则停止keepalived，使其启动备用机    sleep 3    if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then        killall keepalived    fifi</code></pre><ul><li><p>增加运行权限</p><p><code>chmod +x /etc/keepalived/check_nginx_alive_or_not.sh</code></p></li></ul></li><li><p>为keepalived配置增加Nginx监听</p><pre class=" language-shell"><code class="language-shell">vrrp_script check_nginx_alive {    script "/etc/keepalived/check_nginx_alive_or_not.sh"    interval 2 # 每隔两秒运行上一行脚本    weight 10 # 如果脚本运行失败，则升级权重+10}vrrp_instance VI_1 {    # 监听运行vrrp_script脚本    track_script {        check_nginx_alive # 追踪 nginx 脚本    }}</code></pre></li><li><p>keepalived双主热备原理</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/16.keepalived%E5%8F%8C%E4%B8%BB%E7%83%AD%E5%A4%87%E5%8E%9F%E7%90%86.png" alt="keepalived双主热备原理"></p><ul><li><p>在多台服务器的keepalived配置文件中互相配置master和backup信息</p><blockquote><p>注意主节点和对应的备用节点的虚拟ip是相互对应的</p></blockquote></li></ul></li><li><p>操作流程</p><ol><li>上传keepAlived</li><li>进入./configure目录</li><li>make</li><li>make install</li><li>/etc/keepalived</li><li>把keepAlived注册到系统服务</li></ol></li></ol><h4 id="6-2-5-LVS-负载均衡器"><a href="#6-2-5-LVS-负载均衡器" class="headerlink" title="6.2.5 LVS(负载均衡器)"></a>6.2.5 LVS(负载均衡器)</h4><ol><li><p>概述(Linux Virtual Server)</p><blockquote><p>一个Linux操作系统上的虚拟服务；负载均衡项目</p></blockquote></li><li><p>流程图</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/17.LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="LVS负载均衡"></p></li><li><p>LVS+Nginx组合</p><ol><li>LVS基于四层，工作效率高</li><li>单个Nginx承受不不住压力，需要集群</li><li>LVS充当集群的调度者</li><li>Nginx接受请求来回，LVS可以只接受不响应</li></ol></li><li><p>LVS模式</p><ol><li><p>NAT</p><blockquote><p>基于网络地址的转发</p></blockquote></li><li><p>TUN</p><blockquote><p>IP隧道</p></blockquote></li><li><p>DR模式</p><blockquote><p>直接路由</p></blockquote></li></ol></li><li><p>ARP</p><ol><li>arp-ignore：ARP响应级别(处理请求)<ol><li><code>0</code>：只要本机配置了ip，就能响应请求</li><li><code>1</code>：请求的目标地址达到对应的网络接口，才会响应请求</li></ol></li><li>arp-announce：ARP通告行为(返回响应)<ol><li><code>0</code>：本机上任何网路接口都向外通告，所有的网卡都能接受到通告</li><li><code>1</code>：尽可能避免本网卡与不匹配的目标进行通告</li><li><code>2</code>：只在本网卡通告</li></ol></li></ol></li><li><p>使用pvsadm配置集群规则</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/18.pvsadm%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%99.png" alt="pvsadm配置集群规则"></p></li><li><p>LVS持久化机制</p></li><li><p>keepAlived+LVS+Nginx配置master</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">global_defs</span> <span class="token attr-value">{</span><span class="token comment" spellcheck="true">    # 路由id：当前安装keepalived的节点主机标识符，保证全局唯一(主备不同的地方)</span><span class="token comment" spellcheck="true">    # 虚拟ip映射的真实ip</span><span class="token attr-name">    router_id</span> <span class="token attr-value">LVS_151</span>}<span class="token attr-name">vrrp_instance</span> <span class="token attr-value">VI_1 {</span><span class="token comment" spellcheck="true">    # 表示状态是MASTER主机还是备用机BACKUP(主备不同的地方)</span><span class="token attr-name">    state</span> <span class="token attr-value">MASTER</span><span class="token comment" spellcheck="true">    # 该实例绑定的网卡</span><span class="token attr-name">    interface</span> <span class="token attr-value">ens33</span><span class="token comment" spellcheck="true">    # 保证主备节点一致即可</span><span class="token attr-name">    virtual_router_id</span> <span class="token attr-value">51</span><span class="token comment" spellcheck="true">    # 权重，master权重一般高于backup，如果有多个，那就是选举，谁的权重高，谁就当选</span><span class="token comment" spellcheck="true">    # (主备不同的地方)</span><span class="token attr-name">    priority</span> <span class="token attr-value">100</span><span class="token comment" spellcheck="true">    # 主备之间同步检查时间间隔，单位秒</span><span class="token attr-name">    advert_int</span> <span class="token attr-value">2</span><span class="token comment" spellcheck="true">    # 认证权限密码，防止非法节点进入</span><span class="token attr-name">    authentication</span> <span class="token attr-value">{</span><span class="token attr-name">        auth_type</span> <span class="token attr-value">PASS</span><span class="token attr-name">        auth_pass</span> <span class="token attr-value">1111</span>    }<span class="token comment" spellcheck="true">    # 虚拟出来的ip，可以有多个（vip）；用户访问的IP地址</span><span class="token attr-name">    virtual_ipaddress</span> <span class="token attr-value">{</span>        192.168.1.150    }}<span class="token comment" spellcheck="true"># 配置集群地址访问的IP+端口，端口和nginx保持一致，都是80</span><span class="token attr-name">virtual_server</span> <span class="token attr-value">192.168.1.150 80 {</span><span class="token comment" spellcheck="true">    # 健康检查的时间，单位：秒</span><span class="token attr-name">    delay_loop</span> <span class="token attr-value">6</span><span class="token comment" spellcheck="true">    # 配置负载均衡的算法，默认是轮询</span><span class="token attr-name">    lb_algo</span> <span class="token attr-value">rr</span><span class="token comment" spellcheck="true">    # 设置LVS的模式，NAT|TUN|DR</span><span class="token attr-name">    lb_kind</span> <span class="token attr-value">DR</span><span class="token comment" spellcheck="true">    # 设置会话持久化的时间</span><span class="token attr-name">    persistence_timeout</span> <span class="token attr-value">5</span><span class="token comment" spellcheck="true">    # 协议 -t</span><span class="token attr-name">    protocol</span> <span class="token attr-value">TCP</span><span class="token comment" spellcheck="true">    # 负载均衡的真实服务器，也就是nginx节点的具体ip地址</span><span class="token attr-name">    real_server</span> <span class="token attr-value">192.168.1.171 80 {</span><span class="token comment" spellcheck="true">        # 轮询的默认权重配比设置为1</span><span class="token attr-name">        weight</span> <span class="token attr-value">1</span><span class="token comment" spellcheck="true">        # 健康检查</span><span class="token attr-name">        TCP_CHECK</span> <span class="token attr-value">{</span><span class="token comment" spellcheck="true">            # 检查的80端口</span><span class="token attr-name">            connect_port</span> <span class="token attr-value">80</span><span class="token comment" spellcheck="true">            # 超时时间 2s</span><span class="token attr-name">            connect_timeout</span> <span class="token attr-value">2</span><span class="token comment" spellcheck="true">            # 重试次数 2次</span><span class="token attr-name">            nb_get_retry</span> <span class="token attr-value">2</span><span class="token comment" spellcheck="true">            # 间隔时间 3s</span><span class="token attr-name">            delay_before_retry</span> <span class="token attr-value">3</span>        }    }<span class="token attr-name">    real_server</span> <span class="token attr-value">192.168.1.172 80 {</span><span class="token attr-name">        weight</span> <span class="token attr-value">1</span><span class="token comment" spellcheck="true">        # 健康检查</span><span class="token attr-name">        TCP_CHECK</span> <span class="token attr-value">{</span><span class="token comment" spellcheck="true">            # 检查的80端口</span><span class="token attr-name">            connect_port</span> <span class="token attr-value">80</span><span class="token comment" spellcheck="true">            # 超时时间 2s</span><span class="token attr-name">            connect_timeout</span> <span class="token attr-value">2</span><span class="token comment" spellcheck="true">            # 重试次数 2次</span><span class="token attr-name">            nb_get_retry</span> <span class="token attr-value">2</span><span class="token comment" spellcheck="true">            # 间隔时间 3s</span><span class="token attr-name">            delay_before_retry</span> <span class="token attr-value">3</span>        }    }}</code></pre></li><li><p>keepAlived+LVS+Nginx配置backup</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">global_defs</span> <span class="token attr-value">{</span><span class="token comment" spellcheck="true">    # 路由id：当前安装keepalived的节点主机标识符，保证全局唯一(主备不同的地方)</span><span class="token comment" spellcheck="true">    # 虚拟ip映射的真实ip</span><span class="token attr-name">    router_id</span> <span class="token attr-value">LVS_152</span>}<span class="token attr-name">vrrp_instance</span> <span class="token attr-value">VI_1 {</span><span class="token comment" spellcheck="true">    # 表示状态是MASTER主机还是备用机BACKUP(主备不同的地方)</span><span class="token attr-name">    state</span> <span class="token attr-value">BACKUP</span><span class="token comment" spellcheck="true">    # 该实例绑定的网卡</span><span class="token attr-name">    interface</span> <span class="token attr-value">ens33</span><span class="token comment" spellcheck="true">    # 保证主备节点一致即可</span><span class="token attr-name">    virtual_router_id</span> <span class="token attr-value">51</span><span class="token comment" spellcheck="true">    # 权重，master权重一般高于backup，如果有多个，那就是选举，谁的权重高，谁就当选</span><span class="token comment" spellcheck="true">    # (主备不同的地方)</span><span class="token attr-name">    priority</span> <span class="token attr-value">50</span><span class="token comment" spellcheck="true">    # 主备之间同步检查时间间隔，单位秒</span><span class="token attr-name">    advert_int</span> <span class="token attr-value">2</span><span class="token comment" spellcheck="true">    # 认证权限密码，防止非法节点进入</span><span class="token attr-name">    authentication</span> <span class="token attr-value">{</span><span class="token attr-name">        auth_type</span> <span class="token attr-value">PASS</span><span class="token attr-name">        auth_pass</span> <span class="token attr-value">1111</span>    }<span class="token comment" spellcheck="true">    # 虚拟出来的ip，可以有多个（vip）；用户访问的IP地址</span><span class="token attr-name">    virtual_ipaddress</span> <span class="token attr-value">{</span>        192.168.1.150    }}<span class="token comment" spellcheck="true"># 配置集群地址访问的IP+端口，端口和nginx保持一致，都是80</span><span class="token attr-name">virtual_server</span> <span class="token attr-value">192.168.1.150 80 {</span><span class="token comment" spellcheck="true">    # 健康检查的时间，单位：秒</span><span class="token attr-name">    delay_loop</span> <span class="token attr-value">6</span><span class="token comment" spellcheck="true">    # 配置负载均衡的算法，默认是轮询</span><span class="token attr-name">    lb_algo</span> <span class="token attr-value">rr</span><span class="token comment" spellcheck="true">    # 设置LVS的模式，NAT|TUN|DR</span><span class="token attr-name">    lb_kind</span> <span class="token attr-value">DR</span><span class="token comment" spellcheck="true">    # 设置会话持久化的时间</span><span class="token attr-name">    persistence_timeout</span> <span class="token attr-value">5</span><span class="token comment" spellcheck="true">    # 协议 -t</span><span class="token attr-name">    protocol</span> <span class="token attr-value">TCP</span><span class="token comment" spellcheck="true">    # 负载均衡的真实服务器，也就是nginx节点的具体ip地址</span><span class="token attr-name">    real_server</span> <span class="token attr-value">192.168.1.171 80 {</span><span class="token comment" spellcheck="true">        # 轮询的默认权重配比设置为1</span><span class="token attr-name">        weight</span> <span class="token attr-value">1</span><span class="token comment" spellcheck="true">        # 健康检查</span><span class="token attr-name">        TCP_CHECK</span> <span class="token attr-value">{</span><span class="token comment" spellcheck="true">            # 检查的80端口</span><span class="token attr-name">            connect_port</span> <span class="token attr-value">80</span><span class="token comment" spellcheck="true">            # 超时时间 2s</span><span class="token attr-name">            connect_timeout</span> <span class="token attr-value">2</span><span class="token comment" spellcheck="true">            # 重试次数 2次</span><span class="token attr-name">            nb_get_retry</span> <span class="token attr-value">2</span><span class="token comment" spellcheck="true">            # 间隔时间 3s</span><span class="token attr-name">            delay_before_retry</span> <span class="token attr-value">3</span>        }    }<span class="token attr-name">    real_server</span> <span class="token attr-value">192.168.1.172 80 {</span><span class="token attr-name">        weight</span> <span class="token attr-value">1</span><span class="token comment" spellcheck="true">        # 健康检查</span><span class="token attr-name">        TCP_CHECK</span> <span class="token attr-value">{</span><span class="token comment" spellcheck="true">            # 检查的80端口</span><span class="token attr-name">            connect_port</span> <span class="token attr-value">80</span><span class="token comment" spellcheck="true">            # 超时时间 2s</span><span class="token attr-name">            connect_timeout</span> <span class="token attr-value">2</span><span class="token comment" spellcheck="true">            # 重试次数 2次</span><span class="token attr-name">            nb_get_retry</span> <span class="token attr-value">2</span><span class="token comment" spellcheck="true">            # 间隔时间 3s</span><span class="token attr-name">            delay_before_retry</span> <span class="token attr-value">3</span>        }    }}</code></pre></li></ol><h2 id="7-分布式"><a href="#7-分布式" class="headerlink" title="7. 分布式"></a>7. 分布式</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><ol><li><p>单体架构——<font color="red">一个人做多件事</font></p></li><li><p>分布式架构—<font color="red">多个人做多件事</font></p></li><li><p>集群—<font color="red">多个人做一件事</font></p><blockquote><p>不同的业务(功能模块)分散部署在不同的服务器；每个子系统负责一个或者多个不同的业务模块；各服务之间可以交互通信，设计是对用户透明的；发展为集群分布式系统架构</p></blockquote></li><li><p>微服务是分布式的子集</p></li><li><p>优点</p><ol><li>业务解耦</li><li>系统模块化，可重用化</li><li>提升系统并发量</li><li>优化运维部署效率</li></ol></li><li><p>缺点</p><ol><li>架构复杂，上手难</li><li>部署多个子系统复杂</li><li>系统之间通信耗时</li><li>调试复杂</li></ol></li><li><p>设计原则</p><ol><li>异步解耦</li><li>幂等一致性</li><li>拆分原则</li><li>融合分布式中间件</li><li>容错高可用</li></ol></li><li><p>集群架构</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/19.%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt="集群高可用架构"></p><ul><li>存在问题：高访问量的时候，直接访问数据库性能低下；引入缓存来提高数据访问性能</li></ul></li></ol><h3 id="7-2-缓存中间件—Redis"><a href="#7-2-缓存中间件—Redis" class="headerlink" title="7.2 缓存中间件—Redis"></a>7.2 缓存中间件—Redis</h3><h4 id="7-2-1-概述"><a href="#7-2-1-概述" class="headerlink" title="7.2.1 概述"></a>7.2.1 概述</h4><ol><li><p>图示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/20.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6.png" alt="分布式缓存中间件"></p></li><li><p>NoSQL</p><ol><li>用于大数据量存储</li><li>水平(横向)扩展方便高效</li><li>高性能读写</li><li>高可用</li><li>存数据，做缓存</li></ol></li><li><p>NoSQL分类</p><ol><li>键值对数据库<ul><li><code>Memcache</code>：代码层次类似于<code>Hash</code><ul><li>支持简单的数据类型</li><li>内存使用率高</li><li>多核，多线程</li><li>不支持数据持久化存储和主从复制，以及分片</li></ul></li><li><code>Redis</code><ul><li>数据类型丰富</li><li>单线程，单核</li><li>支持数据磁盘持久化和主从复制，以及分片</li><li>每秒100000+QPS，QPS即每秒内查询次数</li></ul></li></ul></li><li>列存储数据库—Hbase，Cassandra</li><li>文档型数据库—MongoDB，CouchDB</li><li>图形数据库—Neo4J，FlockDB</li></ol></li><li><p>分布式缓存优势</p><ul><li>提升读写速度</li><li>降低数据库查询压力</li><li>跨服务器缓存</li><li>内存式缓存</li></ul></li><li><p>Redis</p><ol><li>非关系型，分布式，开源，可水平扩展</li><li>分布式缓存中间件</li><li>key-value存储</li><li>提供海量的数据存储访问</li><li>数据存储在内存里，读写快</li></ol></li></ol><h4 id="7-2-2-数据类型"><a href="#7-2-2-数据类型" class="headerlink" title="7.2.2 数据类型"></a>7.2.2 数据类型</h4><ol><li><p><code>String</code></p><blockquote><p>基本数据类型，二进制安全</p></blockquote><ul><li>存放键值对</li><li>操作：get，set，del</li><li>设置过期时间：<code>EXPIRE age 30</code></li><li>累加1：<code>incr num</code>==<code>num++</code></li><li>累减1：<code>decr num</code>==<code>num--</code></li><li>获取指定范围字符串：<code>getrange key start end</code></li></ul></li><li><p><code>hash</code></p><ul><li><code>Hash：String</code>组成的字典，适合存储对象</li></ul></li><li><p><code>list</code></p><ul><li>一个允许存放重复数据的列表对象；列表，按照String元素插入顺序排序</li></ul></li><li><p><code>set</code></p><ul><li>一个不允许存放重复数据的列表对象</li></ul></li><li><p><code>zset</code></p><ul><li>排序set列表对象；通过分数类为集合中的成员进行从小到大的排序</li></ul></li><li><p><code>HyperLogLog</code>：用于支持存储地理位置信息</p></li><li><p>命令网址<code>redisdoc.com/index.html</code></p></li></ol><h4 id="7-2-3-Redis线程模型和使用"><a href="#7-2-3-Redis线程模型和使用" class="headerlink" title="7.2.3 Redis线程模型和使用"></a>7.2.3 Redis线程模型和使用</h4><ol><li><p>阻塞和非阻塞</p></li><li><p>多路复用器</p></li><li><p>Springboot整合Redis</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--引入 Redis 依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>配置Redis</p><pre class=" language-yml"><code class="language-yml">spring:  redis:    database: 1    host: 192.168.1.191    port: 6379    password: imooc</code></pre></li><li><p>优势</p><ol><li>完全基于内存，没有磁盘IO操作，执行效率高</li><li>数据结构简单，对数据操作也简单</li><li>采用单线程也能处理高并发，多核也可以启动多实例</li><li>使用多了IO复用模型，即非阻塞式IO，采用多路复用函数</li></ol></li><li><p>应用一轮播图缓存</p><ol><li>后台运营系统，一旦广告（轮播图）发生更改，就可以删除缓存，然后重置</li><li>定时重置，在指定时间点进行重置</li><li>每个轮播图有一个可能是广告，每个广告都会有一个过期时间，过期重置</li></ol></li><li><p>应用二购物车缓存</p><ol><li>首次查询数据库后就缓存查询结果</li><li>非首次访问直接查询redis</li></ol></li><li><p>大数据查询固定前缀的<code>key</code></p><ul><li>使用<code>scan count match key*</code></li></ul></li></ol><h4 id="7-2-4-Redis核心"><a href="#7-2-4-Redis核心" class="headerlink" title="7.2.4 Redis核心"></a>7.2.4 Redis核心</h4><ol><li><p>发布与订阅</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/21.%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.png" alt="发布订阅模式"></p></li><li><p>持久化机制</p><ol><li><p><code>RDB</code></p><ol><li>保存某个时间点的全部数据快照方式，文件小，恢复快，数据丢失风险大</li><li>触发<ul><li><code>redis.conf</code>文件配置的<code>save m n</code>定时触发</li><li>主从复制，主节点自动触发</li><li>执行<code>Debug Reload</code>时</li><li>执行<code>Shutdown</code>时</li></ul></li></ol></li><li><p><code>AOF</code></p><ul><li>Redis的默认方式</li><li>保存到写状态，文件可读，适合保存增量数据；数据丢失风险小，但文件呢体积较大，恢复时间较长</li></ul><p>解决：混合模式—<code>RDB</code>做镜像的全量持久化，而<code>AOF</code>做增量的持久化</p></li></ol></li><li><p>主从复制(集群)</p><ul><li><p>主master用于写操作</p></li><li><p>从slave用于读操作</p></li><li><p><code>Pipeline</code>：批量执行<code>Redis</code>指令，节省多次<code>IO</code>往返的时间</p></li><li><p>同步原理 </p><ul><li>从节点发送同步命令到主节点</li><li>主节点启动一个后台进程，将<code>Redis</code>中的数据快照保存到文件中</li><li>主节点将保存数据快照期间接收到的写命令缓存起来</li><li>主节点完成文件操作后，将该文件发送给从节点</li><li>使用新的<code>AOF</code>文件替换旧的<code>AOF</code>文件</li><li>主节点将这期间收集的增量命令发送给从节点</li></ul></li><li><p>模式</p><ul><li>一主一从</li><li>一主两从(一从两次从)</li></ul></li><li><p>原理图</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/22.Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.png" alt="Redis主从复制原理"></p></li></ul></li><li><p>缓存过期处理与内存淘汰机制</p><ol><li><p>过期处理</p><ol><li>定期删除</li><li>惰性删除</li></ol></li><li><p>内存淘汰机制</p><ol><li>MEMORY MANAGEMENT</li><li>maxmemory</li></ol><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/23.Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.png" alt="内存淘汰策略"></p></li></ol></li><li><p>哨兵</p><blockquote><p>检测Redis集群的健康状况，主节点挂掉，会选举出新的主节点，以提高可用性。</p><p>主从复制的基石，由哨兵们监控集群状态，主节点宕机后根据定义规则选举新的主节点，保证系统的运行</p></blockquote><ul><li>流言协议：在杂乱无章中寻求一致；用于主从切换<ul><li>消息节点向其他节点随机发送消息，最终消息会趋于一致性</li></ul></li><li>原理<ul><li>分片：按照一定规则划分数据，分散存储在多个节点上</li><li>获取：一致性哈希算法，对<code>2^32</code>取模，将<code>hash</code>值空间组成虚拟环</li></ul></li></ul><p>主从容灾</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/24.%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E9%80%89%E4%B8%BE%E4%B8%BB%E8%8A%82%E7%82%B9.png" alt="哨兵机制选举主节点"></p><p>部署要求</p><ul><li>哨兵节点要至少有3个或奇数个节点</li><li>哨兵分布式部署在不同的计算机节点</li><li>一组哨兵只监听一组主从</li></ul><p>整合Springboot</p><pre class=" language-yml"><code class="language-yml">spring:  # 哨兵模式  redis:    database: 1    password: imooc    sentinel:      master: imooc-master      nodes: 192.168.1.191:26379,192.168.1.192:26379,192.168.1.193:26379  # 集群模式  redis:    database: 1    password: imooc    cluster:      nodes: 192.168.1.201:6379,192.168.1.202:6379,192.168.1.120:6379</code></pre><p>slot分配与存储</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/25.slot%E5%88%86%E9%85%8D%E4%B8%8E%E5%AD%98%E5%82%A8.png" alt="slot分配与存储"></p></li><li><p>缓存穿透（非法访问）</p><blockquote><p>前端大量的数据请求跳过Redis缓存，直接访问数据库的形式；而数据库也没有该数据，可能造成数据库瘫痪</p></blockquote><p>解决方案—布隆过滤器</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/26.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="布隆过滤器"></p></li><li><p>缓存雪崩（高并发时，缓存失效）</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/27.%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png" alt="缓存雪崩"></p><p>解决方案</p><ol><li>设置热点key永不过期</li><li>key的过期时间设置不相同</li><li>多级缓存</li></ol></li><li><p>批量查询优化</p><ol><li>multiGet—redis的mGet方法</li><li>pipeline</li></ol></li></ol><h3 id="7-3-分布式会话与单点登录"><a href="#7-3-分布式会话与单点登录" class="headerlink" title="7.3 分布式会话与单点登录"></a>7.3 分布式会话与单点登录</h3><ol><li><p>分布式会话</p><blockquote><p>客户端与服务器的一次交互过程；HTTP是无状态会话，即不区分客户端的多个请求是否同一个用户</p></blockquote><ul><li><p>Tomcat是有状态的会话，会话Session保存在服务器内存里</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/28.Tomcat%E4%BC%9A%E8%AF%9D%E6%B5%81%E7%A8%8B.png" alt="单台Tomcat会话流程"></p><p>用户首次访问服务端，这个时候会话产生，并且设置jsessionid放入cookie中，后续每次请求都会携带jsessionid以保持用户状态</p></li><li><p>动静分离会话</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/29.%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E4%BC%9A%E8%AF%9D%E6%B5%81%E7%A8%8B.png" alt="动静分离会话流程"></p><p>由于动静分离，前端发起http请求，不会携带任何状态，当用户第一次请求以后，手动为其设置一个token，作为用户会话，放入redis中，作为redis-session，并且这个token设置后存放到前端cookie中(小程序可以放入本地缓存)，如此在后续交互过程中，前端只需要传递token给后端，后端即可识别用户。</p></li><li><p>集群分布式系统会话</p><p>集群或分布式本质就是多个系统，假如有两个服务器节点，分别是AB，可以是集群，可以是分布式系统，一开始用户和A交互，那么这个用户状态可以保存到Redis中，作为A系统的会话系统；随后用户访问B系统，那么B系统也和Redis相关联(使用token关联)，如此AB系统产生的会话就统一了，当然cookie会随着用户访问携带，这就是分布式会话，通过Redis来保存用户状态。</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/30.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E4%B8%80%E8%87%B4%E6%80%A7.png" alt="分布式会话状态一致性"></p></li><li><p>集成Spring</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--引入 spring-session 依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.session<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-session-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><pre class=" language-yml"><code class="language-yml"># 引入依赖后设置分布式会话存储介质spring:  session:    store-type: redis</code></pre></li></ul></li><li><p>分布式会话拦截器（用户鉴权）</p></li><li><p>single sign on，简称SSO</p><blockquote><p>单点登录可以通过基于用户会话的共享，分为两种，分布式会话实现和</p></blockquote><ul><li><p>Cookie+Redis实现SSO</p><blockquote><p>前端用户数据基于cookie和token标识，后端通过Redis和token标识</p></blockquote></li><li><p>顶级域名不同的单点登录，即cookie不共享</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/31.%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%90%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.png" alt="顶级域名不同的单点登录"></p><p>多个系统之间的登录会通过一个独立的登录系统去做统一的验证，实现了统一登录，那么这个就称之为CAS系统；全称Central Authentication Service即中央认证服务，是一个单点登录的解决方案，实现不同顶级域名之间的单点登录。</p></li><li><p>CAS时序图</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/32.CAS%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="CAS单点登录时序图"></p></li><li><p>整合Spring</p><ul><li>引入相关依赖坐标</li><li>配置到Spring的资源(yml)文件</li></ul></li></ul></li></ol><h3 id="7-4-分布式搜索引擎Elasticsearch"><a href="#7-4-分布式搜索引擎Elasticsearch" class="headerlink" title="7.4 分布式搜索引擎Elasticsearch"></a>7.4 分布式搜索引擎Elasticsearch</h3><h4 id="7-4-1-概述"><a href="#7-4-1-概述" class="headerlink" title="7.4.1 概述"></a>7.4.1 概述</h4><ol><li>一般搜索弊端<ol><li>不支持多词查询</li><li>不支持拆词查询</li><li>搜索内容不能高亮</li><li>海量数据查询</li></ol></li><li>搜索引擎</li><li>分布式存储与搜索</li><li>倒排序索引</li><li>lucene&amp;solr&amp;ElasticSearch<ol><li>lucene是类库</li><li>solr&amp;ElasticSearch都基于lucene</li></ol></li><li>ES概念<ol><li>索引—index（数据库的表）</li><li>类型—type（数据库的表逻辑类型）</li><li>文档—document（数据库的行）</li><li>字段—fields（数据库的列）</li><li>映射—mapping（数据库的表结构定义）</li><li>近实时—NRT（Near real time）</li><li>节点—node（服务器）</li><li>shard replica（数据分片与备份）</li></ol></li></ol><h4 id="7-4-2-ES集群原理"><a href="#7-4-2-ES集群原理" class="headerlink" title="7.4.2 ES集群原理"></a>7.4.2 ES集群原理</h4><ol><li><p>原理图</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/33.ES%E9%9B%86%E7%BE%A4%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ES集群示意图"></p></li><li><p>正排索引和倒排索引</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/34.%E6%AD%A3%E6%8E%92%E7%B4%A2%E5%BC%95%E5%92%8C%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%AF%B9%E6%AF%94.png" alt="正排索引和倒排索引对比"></p><blockquote><p>倒排索引源于实际应用中需要根据属性的值来查找记录；这种索引表中的每一项都包括一个属性值和包含该属性值的各个记录地址；由于不是根据记录来确定属性，而是根据属性来确定记录的位置，所以称为倒排索引</p></blockquote></li><li><p>集群管理工具—es-header</p><ol><li><p>集群状态</p><ol><li>green：所有的主分片和副本都已分配，该集群是100%可用的</li><li>yellow：所有的主分片已经分片了，但至少还有一个副本是缺失的，不会有数据丢失，所以搜索结果依然完整；不过高可用在一定程度上被弱化，如果消失的分片过多，就会丢失数据，相当于警告级别</li><li>red：至少一个主分片(以及它的全部副本)都在缺失中，意味着数据缺少，搜索只能返回部分数据，而分到这个缺失分片的写入请求会返回异常</li></ol></li><li><p>mappings—映射</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"realname"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                <span class="token property">"index"</span><span class="token operator">:</span> <span class="token string">"true"</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token property">"username"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                <span class="token property">"index"</span><span class="token operator">:</span> <span class="token string">"false"</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span># 分词analyze</code></pre></li><li><p>主要数据类型</p><ol><li>text，keyword，String</li><li>long，interger，short，byte</li><li>double，float</li><li>date</li><li>object</li><li>数组的元素数据类型必须一致</li></ol></li></ol></li><li><p>ES集群概念</p><ol><li><p>集群分片</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/36.ES%E9%9B%86%E7%BE%A4%E5%88%86%E9%85%8D.png" alt="ES集群分配"></p></li><li><p>集群宕机</p></li><li><p>集群脑裂</p><blockquote><p>已经挂掉的master重新恢复正常，自己选举自己为master；从而导致集群中有多个master的情形</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/37.%E9%9B%86%E7%BE%A4%E8%84%91%E8%A3%82%E5%9B%BE%E7%A4%BA.png" alt="集群脑裂图示"></p><ul><li>解决：修改投票人数：<code>discovery.zen.minimum_master_nodes</code>=N/2+1</li></ul></li><li><p>集群文档读写</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/38.ES%E6%96%87%E6%A1%A3%E5%86%99%E5%8E%9F%E7%90%86.png" alt="ES文档写原理"></p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/39.ES%E6%96%87%E6%A1%A3%E8%AF%BB%E5%8E%9F%E7%90%86.png" alt="ES文档读原理"></p></li></ol></li></ol><h4 id="7-4-3-ES应用"><a href="#7-4-3-ES应用" class="headerlink" title="7.4.3 ES应用"></a>7.4.3 ES应用</h4><ol><li><p>索引操作</p><pre class=" language-json"><code class="language-json"># 添加索引 index：默认<span class="token boolean">true</span>，设置为<span class="token boolean">false</span>的话，那么这个字段就不会被索引PUT /index_test<span class="token punctuation">{</span>    <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"index"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"number_of_shards"</span><span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>            <span class="token property">"number_of_replicas"</span><span class="token operator">:</span> <span class="token string">"0"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span># 查看索引GET _cat/indices?v# 删除索引DELETE /index_test</code></pre></li><li><p>文档的基本操作</p><pre class=" language-json"><code class="language-json">POST /my_doc/_doc/<span class="token number">1</span> -> <span class="token punctuation">{</span>索引名<span class="token punctuation">}</span>/_doc/<span class="token punctuation">{</span>索引ID<span class="token punctuation">}</span>（是指索引在es中的id，而不是这条记录的id）# <span class="token number">1</span>. 添加文档<span class="token punctuation">{</span>    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">1004</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"imooc-4"</span><span class="token punctuation">,</span>    <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token string">"imooc is good~！"</span><span class="token punctuation">,</span>    <span class="token property">"create_date"</span><span class="token operator">:</span> <span class="token string">"2019-12-27"</span><span class="token punctuation">}</span># <span class="token number">2</span>. 修改文档—局部更新，每次修改后，version会更改POST /my_doc/_doc/<span class="token number">1</span>/_update<span class="token punctuation">{</span>    <span class="token property">"doc"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"慕课"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span># <span class="token number">3</span>. 修改文档—全量替换，每次修改后，version会更改PUT /my_doc/_doc/<span class="token number">1</span><span class="token punctuation">{</span>    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">1001</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"imooc-1"</span><span class="token punctuation">,</span>    <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token string">"imooc is very good, 慕课网非常牛！"</span><span class="token punctuation">,</span>    <span class="token property">"create_date"</span><span class="token operator">:</span> <span class="token string">"2019-12-24"</span><span class="token punctuation">}</span># <span class="token number">4</span>. 删除文档DELETE /my_doc/_doc/<span class="token number">1</span># <span class="token number">5</span>. 查询操作GET /index_demo/_doc/<span class="token number">1</span>————————查询指定索引的数据GET /index_demo/_doc/_search——————————查询该文档的全量数据# <span class="token number">6</span>. 判断文档是否存在HEAD /index_demo/_doc/<span class="token number">1</span></code></pre></li><li><p>元数据</p><table><thead><tr><th>字段</th><th>解释</th></tr></thead><tbody><tr><td><code>_index</code></td><td>文档数据所属那个索引，理解为数据库的某张表即可</td></tr><tr><td><code>_type</code></td><td>文档数据属于哪个类型，新版本使用 _doc 。</td></tr><tr><td><code>_id</code></td><td>文档数据的唯一标识，类似数据库中某张表的主键。可以自动生成或者手动指定</td></tr><tr><td><code>_score</code></td><td>查询相关度，是否契合用户匹配，分数越高用户的搜索体验越高</td></tr><tr><td><code>_version</code></td><td>版本号</td></tr><tr><td><code>_source</code></td><td>文档数据，json格式</td></tr></tbody></table></li><li><p>乐观锁（ES使用<code>version</code>+[<code>_primary_term</code>，<code>_seq_no</code>]）</p><ol><li>一条共享数据，并发的被多个用户(线程)去操作；会和自身的版本号做一个对比，如果版本号匹配，则操作成功；否则操作失败。</li><li>参数<ol><li><code>_primary_term</code>：文档位置，编号</li><li><code>_seq_no</code>：和<code>version</code>意思一致</li></ol></li></ol></li><li><p>分词操作</p><ol><li><p>默认分词</p><ol><li><code>standard</code>模式：默认分词，单词会被拆分，大小会转换为小写</li><li><code>simple</code>模式：按照非字母分词。大写转为小写</li><li><code>whitespace</code>模式：按照空格分词。忽略大小写</li><li><code>stop</code>模式：去除无意义单词，比如 the / a / an / is …</li><li><code>keyword</code>模式：不做分词。把整个文本作为一个单独的关键词</li></ol></li><li><p>IK分词器</p><ol><li><p><code>ik_max_word</code>：无论中英文，都分为最大词汇的集合</p></li><li><p><code>ik_smart</code>：粗粒度分词器</p></li><li><p>也可以实现自定义词库进行分词查询</p><ol><li><p>在IKAnalyzer.cfg.xml文件中新增</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ext_dict<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>custom.dic<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span></code></pre></li><li><p>在{es}/plugins/ik/config下，创建vim custom.dic</p></li></ol></li></ol></li></ol></li><li><p>搜索</p><ol><li><p>QueryString搜索</p><pre class=" language-json"><code class="language-json"># QueryString查询GET /shop/_doc/_search?q=desc<span class="token operator">:</span>慕课网GET /shop/_doc/_search?q=nickname<span class="token operator">:</span>慕&amp;q=age<span class="token operator">:</span><span class="token number">25</span># text与keyword搜索对比测试(keyword不会被倒排索引，不会被分词<span class="token punctuation">)</span>GET /shop/_doc/_search?q=nickname<span class="token operator">:</span>superGET /shop/_doc/_search?q=username<span class="token operator">:</span>superGET /shop/_doc/_search?q=username<span class="token operator">:</span>super hero</code></pre></li><li><p>QueryString用的很少，一旦参数复杂就难以构建，所以大多查询都会使用dsl来进行查询更好</p><ul><li>Domain Specific Language</li><li>特定领域语言</li><li>基于JSON格式的数据查询</li><li>查询更灵活，有利于复杂查询</li></ul></li><li><p>语法格式为一个json object，内容都是key-value键值对，json可以嵌套。key可以是一些es的关键字，也可以是某个field字段，后面会遇到</p><pre class=" language-json"><code class="language-json"># 查询关键字POST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token string">"慕课网"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>查询所有</p><pre class=" language-json"><code class="language-json"># 查询所有GET /shop/_doc/_searchPOST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"match_all"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"_source"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">,</span> <span class="token string">"nickname"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><pre class=" language-json"><code class="language-json"># 分页查询POST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"match_all"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"from"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">}</span></code></pre></li><li><p>对比：match会对 慕课网 先进行分词（其实就是全文检索），在查询，而term则不会，直接把 慕课网 作为一个整的词汇去搜索</p><pre class=" language-json"><code class="language-json"># term精确搜索与match分词搜索POST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"term"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token string">"慕课网"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token string">"慕课网"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-json"><code class="language-json"># terms 多个词语匹配检索POST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"terms"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"慕课网"</span><span class="token punctuation">,</span> <span class="token string">"学习"</span><span class="token punctuation">,</span> <span class="token string">"骚年"</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>match_phrase 短语匹配</p><pre class=" language-json"><code class="language-json"># match_phrase 短语匹配POST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"match_phrase"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"query"</span><span class="token operator">:</span> <span class="token string">"大学 毕业 研究生"</span><span class="token punctuation">,</span>                <span class="token property">"slop"</span><span class="token operator">:</span> <span class="token number">2</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>match—operator<br>or：搜索内容分词后，只要存在一个词语匹配就展示结果；默认方式<br>and：搜索内容分词后，都要满足词语匹配</p><pre class=" language-json"><code class="language-json"># match（operator）/idsPOST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token string">"慕课网"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>minimum_should_match</p><pre class=" language-json"><code class="language-json"># minimum_should_match<span class="token operator">:</span> 最低匹配精度，至少有<span class="token punctuation">[</span>分词后的词语个数<span class="token punctuation">]</span>x百分百，得出一个数据值取整POST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"query"</span><span class="token operator">:</span> <span class="token string">"女友生日送我好玩的xbox游戏机"</span><span class="token punctuation">,</span>                <span class="token property">"minimum_should_match"</span><span class="token operator">:</span> <span class="token string">"60%"</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>根据文档主键ids搜索</p><pre class=" language-json"><code class="language-json"># 根据文档主键ids搜索POST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"ids"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"_doc"</span><span class="token punctuation">,</span>            <span class="token property">"values"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"111"</span><span class="token punctuation">,</span><span class="token string">"112"</span><span class="token punctuation">,</span><span class="token string">"113"</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"_source"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">,</span> <span class="token string">"nickname"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre></li><li><p>multi_match</p><pre class=" language-json"><code class="language-json"># multi_match 满足match在多个字段中进行查询的需求POST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"multi_match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"query"</span><span class="token operator">:</span> <span class="token string">"皮特帕克慕课网"</span><span class="token punctuation">,</span>            <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"desc"</span><span class="token punctuation">,</span> <span class="token string">"nickname"</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>boost 权重</p><blockquote><p>nickname^10 代表搜索提升10倍相关性，也就是说用户搜索的时候其实以这个nickname为主，desc为辅，nickname的匹配相关度当然要提高权重比例了</p></blockquote><pre class=" language-json"><code class="language-json"># boost 权重，为某个字段设置权重，权重越高，文档相关性得分就越高。通畅来说搜索商品名称要比商品简介的权重更高。POST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"multi_match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"query"</span><span class="token operator">:</span> <span class="token string">"皮特帕克慕课网"</span><span class="token punctuation">,</span>            <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"desc"</span><span class="token punctuation">,</span> <span class="token string">"nickname^10"</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>组合多重查询</p><p> must：查询必须匹配搜索条件，譬如 and<br> should：查询匹配满足1个以上条件，譬如 or<br> must_not：不匹配搜索条件，一个都不要满足</p><pre class=" language-json"><code class="language-json"># 组合多重查询POST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"bool"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"must"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">{</span>                    <span class="token property">"multi_match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                        <span class="token property">"query"</span><span class="token operator">:</span> <span class="token string">"慕课网"</span><span class="token punctuation">,</span>                         <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                            <span class="token string">"desc"</span><span class="token punctuation">,</span>                             <span class="token string">"nickname"</span>                        <span class="token punctuation">]</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                 <span class="token punctuation">{</span>                    <span class="token property">"term"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                        <span class="token property">"sex"</span><span class="token operator">:</span> <span class="token number">1</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                 <span class="token punctuation">{</span>                    <span class="token property">"term"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                        <span class="token property">"birthday"</span><span class="token operator">:</span> <span class="token string">"1996-01-14"</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>   </code></pre></li><li><p>过滤器</p><blockquote><p>对搜索出来的结果进行数据过滤。不会到es库里去搜，不会去计算文档的相关度分数，所以过滤的性能会比较高，过滤器可以和全文搜索结合在一起使用；</p><p>post_filter元素是一个顶层元素，只会对搜索结果进行过滤。不会计算数据的匹配度相关性分数，不会根据分数去排序，query则相反，会计算分数，也会按照分数排序</p></blockquote><p> query：根据用户搜索条件检索匹配记录<br> post_filter：用于查询后，对结果数据的筛选</p><pre class=" language-json"><code class="language-json">POST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token string">"慕课网游戏"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token property">"post_filter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"range"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"money"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"gt"</span><span class="token operator">:</span> <span class="token number">60</span><span class="token punctuation">,</span>                 <span class="token property">"lt"</span><span class="token operator">:</span> <span class="token number">1000</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>排序</p><p> es的排序同sql，可以desc也可以asc。也支持组合排序</p><pre class=" language-json"><code class="language-json">POST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token string">"慕课网游戏"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token property">"post_filter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"range"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"money"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"gt"</span><span class="token operator">:</span> <span class="token number">55.8</span><span class="token punctuation">,</span>                 <span class="token property">"lte"</span><span class="token operator">:</span> <span class="token number">155.8</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token property">"sort"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token property">"age"</span><span class="token operator">:</span> <span class="token string">"desc"</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token punctuation">{</span>            <span class="token property">"money"</span><span class="token operator">:</span> <span class="token string">"desc"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span># 由于文本会被分词，所以往往要去做排序会报错，通常我们可以为这个字段增加额外的一个附属属性，类型为keyword，用于做排序POST /shop2/_mapping<span class="token punctuation">{</span>    <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"long"</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token property">"nickname"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>             <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"ik_max_word"</span><span class="token punctuation">,</span>             <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"keyword"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>高亮</p><pre class=" language-json"><code class="language-json">POST /shop/_doc/_search<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token string">"慕课网"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token property">"highlight"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"pre_tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"&lt;tag>"</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>         <span class="token property">"post_tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"&lt;/tag>"</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>         <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>分页</p><ol><li><p>深度分页</p><p>   <img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/35.%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E5%9B%BE%E7%A4%BA.png" alt="深度分页图示"></p><p>   参数<code>index.max_result_window</code>：最大页数值</p></li><li><p>scroll 滚动搜索</p><blockquote><p>一次性查询1万+数据，往往会造成性能影响，因为数据量太多了。这个时候可以使用滚动搜索，也就是 scroll 。</p><p>滚动搜索可以先查询出一些数据，然后再紧接着依次往下查询。在第一次查询的时候会有一个滚动id，相当于一个 锚标记 ，随后再次滚动搜索会需要上一次搜索id，根据这个进行下一次的搜索请求。每次搜索都是基于一个历史的数据快照，查询数据的期间，如果有数据变更，那么和搜索是没有关系的，搜索的内容还是快照内容</p></blockquote><pre class=" language-json"><code class="language-json">POST /shop/_search?scroll=1m<span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"match_all"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"sort"</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"_doc"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">}</span>POST /_search/scroll<span class="token punctuation">{</span>    <span class="token property">"scroll"</span><span class="token operator">:</span> <span class="token string">"1m"</span><span class="token punctuation">,</span>    <span class="token property">"scroll_id"</span> <span class="token operator">:</span> <span class="token string">"your last scroll_id"</span><span class="token punctuation">}</span></code></pre><ul><li>scroll=1m，相当于是一个session会话时间，搜索保持的上下文时间为1分钟。</li></ul></li></ol></li><li><p>批量操作</p><ol><li><p>_mget</p><pre class=" language-json"><code class="language-json">POST /shop/_doc/_mget<span class="token punctuation">{</span>    <span class="token property">"ids"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"100"</span><span class="token punctuation">,</span><span class="token string">"101"</span><span class="token punctuation">,</span><span class="token string">"102"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre></li><li><p>bulk</p><ul><li><p>action 必须是以下选项之一:</p><ul><li>create：如果文档不存在，那么就创建它。存在会报错。发生异常报错不会影响其他操作。</li><li>index：创建一个新文档或者替换一个现有的文档。</li><li>update：部分更新一个文档。</li><li>delete：删除一个文档</li></ul><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span> action<span class="token operator">:</span> <span class="token punctuation">{</span> metadata <span class="token punctuation">}</span><span class="token punctuation">}</span>\n<span class="token punctuation">{</span> request body <span class="token punctuation">}</span>\n<span class="token punctuation">{</span> action<span class="token operator">:</span> <span class="token punctuation">{</span> metadata <span class="token punctuation">}</span><span class="token punctuation">}</span>\n<span class="token punctuation">{</span> request body <span class="token punctuation">}</span>\n</code></pre></li><li><p><code>&#123; action: &#123; metadata &#125;&#125;</code> 代表批量操作的类型，可以是新增、删除或修改</p></li><li><p><code>\n</code> 是每行结尾必须填写的一个规范，每一行包括最后一行都要写，用于es的解析</p></li><li><p><code>&#123; request body &#125;</code> 是请求body，增加和修改操作需要，删除操作则不需要</p></li><li><p><code>metadata</code> 中需要指定要操作的文档的 _index 、 _type 和 _id ， _index 、 _type 也可以在url中指定</p><pre class=" language-json"><code class="language-json"># create新增文档数据，在metadata中指定index以及typePOST /_bulk<span class="token punctuation">{</span><span class="token property">"create"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"_index"</span><span class="token operator">:</span> <span class="token string">"shop2"</span><span class="token punctuation">,</span> <span class="token property">"_type"</span><span class="token operator">:</span> <span class="token string">"_doc"</span><span class="token punctuation">,</span> <span class="token property">"_id"</span><span class="token operator">:</span> <span class="token string">"2001"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"2001"</span><span class="token punctuation">,</span> <span class="token property">"nickname"</span><span class="token operator">:</span> <span class="token string">"name2001"</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"create"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"_index"</span><span class="token operator">:</span> <span class="token string">"shop2"</span><span class="token punctuation">,</span> <span class="token property">"_type"</span><span class="token operator">:</span> <span class="token string">"_doc"</span><span class="token punctuation">,</span> <span class="token property">"_id"</span><span class="token operator">:</span> <span class="token string">"2002"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"2002"</span><span class="token punctuation">,</span> <span class="token property">"nickname"</span><span class="token operator">:</span> <span class="token string">"name2002"</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"create"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"_index"</span><span class="token operator">:</span> <span class="token string">"shop2"</span><span class="token punctuation">,</span> <span class="token property">"_type"</span><span class="token operator">:</span> <span class="token string">"_doc"</span><span class="token punctuation">,</span> <span class="token property">"_id"</span><span class="token operator">:</span> <span class="token string">"2003"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"2003"</span><span class="token punctuation">,</span> <span class="token property">"nickname"</span><span class="token operator">:</span> <span class="token string">"name2003"</span><span class="token punctuation">}</span># create创建已有id文档，在url中指定index和typePOST /shop/_doc/_bulk<span class="token punctuation">{</span><span class="token property">"create"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"_id"</span><span class="token operator">:</span> <span class="token string">"2003"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"2003"</span><span class="token punctuation">,</span> <span class="token property">"nickname"</span><span class="token operator">:</span> <span class="token string">"name2003"</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"create"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"_id"</span><span class="token operator">:</span> <span class="token string">"2004"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"2004"</span><span class="token punctuation">,</span> <span class="token property">"nickname"</span><span class="token operator">:</span> <span class="token string">"name2004"</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"create"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"_id"</span><span class="token operator">:</span> <span class="token string">"2005"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"2005"</span><span class="token punctuation">,</span> <span class="token property">"nickname"</span><span class="token operator">:</span> <span class="token string">"name2005"</span><span class="token punctuation">}</span># index创建，已有文档id会被覆盖，不存在的id则新增POST /shop/_doc/_bulk<span class="token punctuation">{</span><span class="token property">"index"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"_id"</span><span class="token operator">:</span> <span class="token string">"2004"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"2004"</span><span class="token punctuation">,</span> <span class="token property">"nickname"</span><span class="token operator">:</span> <span class="token string">"index2004"</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"index"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"_id"</span><span class="token operator">:</span> <span class="token string">"2007"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"2007"</span><span class="token punctuation">,</span> <span class="token property">"nickname"</span><span class="token operator">:</span> <span class="token string">"name2007"</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"index"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"_id"</span><span class="token operator">:</span> <span class="token string">"2008"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"2008"</span><span class="token punctuation">,</span> <span class="token property">"nickname"</span><span class="token operator">:</span> <span class="token string">"name2008"</span><span class="token punctuation">}</span></code></pre></li></ul></li></ol></li><li><p>整合到Springboot</p><ol><li><p>引入依赖坐标</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-elasticsearch<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--&lt;version>2.1.5.RELEASE&lt;/version>--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.2.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>配置yml</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">data</span><span class="token punctuation">:</span>    <span class="token key atrule">elasticsearch</span><span class="token punctuation">:</span>      <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> es6      <span class="token key atrule">cluster-nodes</span><span class="token punctuation">:</span> 192.168.1.187<span class="token punctuation">:</span><span class="token number">9300</span></code></pre></li><li><p>注意</p><blockquote><p>不建议使用ElasticSearchTemplate 对索引进行管理(创建索引，更新索引，删除索引)</p><p>索引就像数据库或者数据库中的表，一般不会通过java代码频繁的去创建修改删除数据库或者表的；只会针对数据做CRUD的操作</p><p>在ES中也是同理，尽量使用ElasticSearchTemplate对文档数据进行CRUD操作</p></blockquote></li></ol></li><li><p>logstash数据同步</p><pre><code>1. 数据采集2. 以id或update_time作为同步边界3. logstash-input-jdbc插件4. 预先创建索引</code></pre></li></ol><h3 id="7-5-分布式文件系统-FastDFS-OSS"><a href="#7-5-分布式文件系统-FastDFS-OSS" class="headerlink" title="7.5 分布式文件系统(FastDFS+OSS)"></a>7.5 分布式文件系统(FastDFS+OSS)</h3><ol><li><p>一般文件上传的问题</p><ol><li>单向存储</li><li>不支持集群</li><li>文件数据冗余</li><li>可扩展性差</li></ol></li><li><p>分布式文件存储系统</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/40.%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.png" alt="分布式文件存储系统"></p></li><li><p>FastDFS</p><blockquote><p>是一个开源的轻量级分布式文件系统，对文件进行管理；包括文件存储，文件同步，文件访问(上传，下载)；解决了大容量存储和负载均衡问题</p></blockquote><ul><li><p>主要构成：跟踪器（Tracker）和存储节点（Storage）；跟踪器主要是调度工作，在访问上起到负载均衡作用</p></li><li><p>架构图</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/41.FastDFS%E6%9E%B6%E6%9E%84.png" alt="FastDFS架构"></p></li><li><p>上传</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/42.FastDfS%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.png" alt="FastDfS文件上传"></p></li><li><p>下载</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/43.FastDfS%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD.png" alt="FastDfS文件下载"></p></li></ul></li><li><p>整合SpringBoot</p><ol><li><p>引入依赖坐标</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.taobao<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>fastdfs_client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.26.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>配置yml</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">spring</span><span class="token punctuation">:</span><span class="token attr-name">  fdfs</span><span class="token punctuation">:</span><span class="token attr-name">    connect-timeout</span><span class="token punctuation">:</span> <span class="token attr-value">30    # 连接的超时时间</span><span class="token attr-name">    so-timeout</span><span class="token punctuation">:</span> <span class="token attr-value">30    # 读取的超时时间</span><span class="token attr-name">    tracker-list</span><span class="token punctuation">:</span> <span class="token attr-value">192.168.1.155:22122 # tracer服务所在ip地址和端口号</span></code></pre></li></ol></li><li><p>缺点</p><ol><li>水平扩容</li><li>运维复杂</li><li>开发复杂</li></ol></li><li><p>三方存储</p><ol><li>SDK使用简单</li><li>提供强大的文件处理功能</li><li>零运维成本</li><li>图形化管理控制台</li><li>方便CDN加速</li></ol></li></ol><h3 id="7-6-分布式消息队列"><a href="#7-6-分布式消息队列" class="headerlink" title="7.6 分布式消息队列"></a>7.6 分布式消息队列</h3><ol><li>redis异步队列<ul><li>使用<code>List</code>做为队列，<code>RPush</code>产生消息，<code>LPop</code>消费消息<ul><li>缺点：没有等待队列有值就进行消费</li><li>解决<ol><li>通过应用层引入<code>Sleep</code>机制调用<code>LPop</code>重新消费</li><li>阻塞直到队列有消息或者超时；缺点：只能提供一个消费者消费</li><li>主题订阅模式；缺点：无法保证消息可达性</li></ol></li></ul></li></ul></li></ol><h4 id="7-6-1-RabbitMQ"><a href="#7-6-1-RabbitMQ" class="headerlink" title="7.6.1 RabbitMQ"></a>7.6.1 RabbitMQ</h4><ol><li><p>分布式消息队列</p><ol><li>MQ应用场景<ol><li>服务解耦</li><li>削峰填谷</li><li>异步化缓冲</li></ol></li><li>注意点<ol><li>生产端可靠性投递</li><li>消费端幂等</li><li>高可用，低延迟，可靠性，堆积能力，扩展性</li></ol></li><li>主流的分布式消息队列<ul><li>Active MQ</li><li>Rabbit MQ</li><li>Rocket MQ</li><li>kafka MQ</li><li>对比</li></ul></li><li>技术选型<ul><li>MQ的性能，优缺点，对应的业务场景</li><li>集群架构模式，分布式，可扩展，高可用，可维护性</li><li>综合成本问题，集群规模，人员成本</li><li>未来方向，规划，思考</li></ul></li></ol></li><li><p>RabbitMQ实战</p><ol><li><p>概述</p><blockquote><p>一个开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据</p><p>用erlang语言编写</p><p>基于AMQP协议实现</p></blockquote><ul><li><p>优势</p><ul><li>开源</li><li>性能优秀</li><li>稳定性保障</li><li>提供可靠性消息投递模式，返回模式</li><li>和SpringAMQP完美整合，API丰富</li><li>集群模式丰富，表达式配置，HA模式，镜像队列模型</li><li>保证数据不丢失的情况下做到高可用，高可靠</li></ul></li><li><p>高性能原因</p><ul><li>采用Erlang语言，Erlang有着和原生Socket一样的延迟</li></ul></li><li><p>AMQP—高级消息队列协议</p><blockquote><p>具有现代特征的二进制协议</p><p>一个提供统一消息服务的应用层标准高级消息队列协议</p><p>应用层协议的一个开发标准，为面向消息的中间件设计</p></blockquote><ul><li><p>AMQP协议模型</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/52.AMQP%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B.png" alt="AMQP协议模型"></p></li><li><p>AMQP核心概念</p><p><code>Server</code>：又称Broker，接受客户端的连接，实现AMQP实体服务</p><p><code>Connection</code>：连接，应用程序与Broker的网络连接</p><p><code>Channel</code>：网络信道，几乎所有操作都在Channel中进行，Channel是进行消息读写的通道；客户端可建立多个Channel，每个Channel代表一个会话任务</p><p><code>Message</code>：消息，服务器和应用程序之间传送的数据，由Properties和Body组成；Properties对消息进行修饰，比如消息优先级，延迟等高级特性；Body就是消息的主体内容</p><p><code>Virtual host</code>：虚拟地址，用于进行逻辑隔离，最上层的消息路由；一个Virtual host可以有若干个Exchange和Queue，但是名称不能相同</p><p><code>Exchange</code>：交换机，接收消息，根据路由键转发消息到绑定的队列</p><p><code>Binding</code>：Exchange和Queue之间的虚拟连接，binding可以包含routing key</p><p><code>Routing key</code>：一个路由规则，虚拟机用于确定如何路由一个特定消息</p><p><code>Queue</code>：也称为Message Queue，消息队列，保存消息并将其转发给消费者</p></li></ul></li><li><p>RabbitMQ整体架构图</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/53.RabbitMQ%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="RabbitMQ整体架构图"></p></li><li><p>RabbitMQ消息轮转图</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/54.RabbitMQ%E6%B6%88%E6%81%AF%E8%BD%AE%E8%BD%AC%E5%9B%BE.png" alt="RabbitMQ消息轮转图"></p></li><li><p>消息投递保障</p><ul><li><p>生产端的100%可靠性投递</p><ul><li>保障消息的成功发出</li><li>保障MQ节点的成功接收</li><li>发送端收到MQ节点(Broker)</li><li>完善的消息进行补偿机制</li></ul></li><li><p>生产端解决方案</p><ul><li><p>消息落库(持久化到数据库)，对消息状态进行标志</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/55.RabbitMQ%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92%E6%96%B9%E6%A1%88%E6%B5%81%E7%A8%8B1.png" alt="RabbitMQ消息可靠性投递方案流程1"></p></li><li><p>消息的延迟投递，做二次确认，回调检查</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/56.RabbitMQ%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92%E6%96%B9%E6%A1%88%E6%B5%81%E7%A8%8B2.png" alt="RabbitMQ消息可靠性投递方案流程2"></p></li></ul></li><li><p>幂等性</p><blockquote><p>对事物的无穷次操作的结果是一样的</p></blockquote><ul><li>消费端的幂等性保障<ul><li>唯一ID+指纹码机制，利用数据库主键去重<ul><li>优势：实现简单</li><li>缺点：高并发下有数据库写入的性能瓶颈</li><li>解决：跟进ID进行分库分表进行算法路由</li></ul></li><li>利用Redis的原子性去实现</li></ul></li></ul></li></ul></li></ul></li><li><p>四种集群架构</p><ul><li><p>主备模式</p><blockquote><p>warren(兔子窝)，一个主/备方案(主节点如果挂了，从节点提供服务，和ActiveMQ利用zookeeper做主/备一样)</p></blockquote><ul><li><p>RabbitMQ主备模型</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/44.RabbitMQ%E4%B8%BB%E5%A4%87%E6%A8%A1%E5%9E%8B.png" alt="RabbitMQ主备模型"></p></li><li><p>主备模式-HaProxy配置</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">listen</span> <span class="token attr-value">rabbitmq_cluster</span><span class="token attr-name">bind</span> <span class="token attr-value">0.0.0.0:5672</span><span class="token comment" spellcheck="true"># 配置TCP模式</span><span class="token attr-name">mode</span> <span class="token attr-value">tcp</span><span class="token comment" spellcheck="true"># 简单轮询</span><span class="token attr-name">balance</span> <span class="token attr-value">roundrobin</span><span class="token comment" spellcheck="true"># 主节点</span><span class="token attr-name">server</span> <span class="token attr-value">bhz76 192.167.11.76:5672 check inter 5000 rise 2 fall 2</span><span class="token comment" spellcheck="true"># 备用节点</span><span class="token attr-name">server</span> <span class="token attr-value">bhz77 192.167.11.76:5672 backup check inter 5000 rise 2 fall 2</span><span class="token comment" spellcheck="true"># rabbitmq集群节点配置inter每隔5秒对mq集群做健康检查，2次正确证明服务器可用，2次失败证明服务器不可用，并且配置主备机制</span></code></pre></li></ul></li><li><p>远程模式</p><blockquote><p>远距离通信和复制，实现双活的一种模式，简称Shovel模式</p><p>Shovel就是把消息进行不同数据中心的复制工作，可以跨地域的让两个MQ集群互联</p></blockquote><ul><li><p>Shovel架构模型</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/45.Shovel%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B.png" alt="Shovel架构模型"></p></li><li><p>Shovel拓扑模型</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/58.Shovel%E6%8B%93%E6%89%91%E6%A8%A1%E5%9E%8B.png" alt="Shovel拓扑模型"></p></li><li><p>Shovel集群配置步骤</p><ul><li><p>启动RabbitMQ插件</p><ul><li>rabbitmq-plugins enable amqp_client</li><li>rabbitmq-plugins enable rabbitmq-shovel</li></ul></li><li><p>创建RabbitMQ.config文件</p><ul><li>touch /etc/rabbitmq/rabbitmq.config</li></ul></li><li><p>添加配置</p></li><li><p>源与目的服务器使用相同的配置文件</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/46.Shovel%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90.png" alt="Shovel配置文件解析"></p></li></ul></li></ul></li><li><p>镜像模式</p><blockquote><p>集群模式使用最多的就是Mirror镜像模式，保证100%数据不丢失(一般是3节点)</p></blockquote><ul><li><p>Mirror镜像队列</p><ul><li>高可靠</li><li>数据同步</li><li>3节点</li></ul></li><li><p>Mirror镜像队列集群架构</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/47.RabbitMQ%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png" alt="RabbitMQ镜像模式集群架构"></p></li></ul></li><li><p>多活模式</p><blockquote><p>实现异地数据复制的主流模式，因为Shovel模式配置比较复杂，所以一般异地集群使用的都是双活或多活模型来实现的</p><p>这种模型需要依赖RabbitMQ的federation插件，可以实现持续的可靠的AMQP数据通信，多活模式实际配置与应用简单</p><p>采用双中心模式，即多中心在两套及以上数据中心中各部署一套RabbitMQ集群，各中心的RabbitMQ服务除了需要为业务提供正常的消息服务外，中心之间还需实现部分队列消息共享</p></blockquote><ul><li><p>多活集群架构</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/48.%E5%A4%9A%E6%B4%BB%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B.png" alt="多活集群架构模型"></p></li><li><p>Federation插件</p><blockquote><p>一个不需要构建Cluster，也可以在Brokers之间传输消息的高性能插件</p><p>使用AMQP通信协议，可以接受不连续的传输</p></blockquote><ul><li>是Downstream从Upstream主动拉取消息，但不是拉取所有消息，必须是在Downstream上已经定义Bindings关系的Exchange</li><li>必须有实际的物理Queue来接收消息，才会从Upstream拉取消息到Downstream</li><li>使用AMQP协议实施代理间通信，Downstream将绑定关系组合在一起，绑定/解除命令将发送到Upstream交换机</li><li>Federation Exchange只接收具有订阅的消息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/49.%E5%A4%9A%E6%B4%BB%E6%A8%A1%E5%BC%8FFederation%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF.png" alt="多活模式Federation订阅消息"></p></li></ul></li></ul></li><li><p>RabbitMQ整合SpringBoot的步骤</p><ol><li><p>引入Maven依赖</p></li><li><p>配置Application.properties文件</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 生产者核心配置</span><span class="token comment" spellcheck="true"># 是否启用消息确认模式</span><span class="token attr-name">spring.rabbitmq.pulisher-confirms</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token comment" spellcheck="true"># 设置return消息模式，要和Mandatory一起使用</span><span class="token attr-name">spring.rabbitmq.pulisher-returns</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.rabbitmq.template.mandatory</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token comment" spellcheck="true"># 消费者核心配置</span><span class="token attr-name">spring.rabbitmq.listener.simple.acknowledge-mode</span><span class="token punctuation">=</span><span class="token attr-value">MANUAL</span><span class="token attr-name">spring.rabbitmq.listener.simple.concurrency</span><span class="token punctuation">=</span><span class="token attr-value">1</span><span class="token attr-name">spring.rabbitmq.listener.simple.max-concurrency</span><span class="token punctuation">=</span><span class="token attr-value">5</span></code></pre></li><li><p>@RabbitListener注解</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/57.@RabbitListener%E6%B3%A8%E8%A7%A3%E8%A7%A3%E9%87%8A.png" alt="@RabbitListener注解解释"></p></li></ol></li></ol></li><li><p>RabbitMQ可靠性投递基础组件封装</p></li></ol><h4 id="7-6-2-kafka"><a href="#7-6-2-kafka" class="headerlink" title="7.6.2 kafka"></a>7.6.2 kafka</h4><ol><li><p>kafka应用实战</p><ul><li><p>概述</p><blockquote><p>是LinkedIn开源的分布式消息系统，目前归属于Apache顶级项目</p><p>基于Pull模式来处理消息消费，追求高吞吐量，用于日志收集和传输</p><p>0.8版本开始支持赋值，不支持事务，对消息的重复，丢失，错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务</p></blockquote></li><li><p>特点</p><ul><li>跨平台</li><li>分布式</li><li>伸缩性</li><li>实时性</li></ul></li><li><p>高性能</p><ul><li>顺序写</li><li>Page Cache</li><li>空中接力</li><li>高效读写</li><li>后台异步</li><li>主动Flush</li><li>IO的预读策略</li></ul></li><li><p>Page Cache</p><blockquote><p>页面缓存</p><p>操作系统实现的一种主要的磁盘缓存</p><p>减少对磁盘IO的操作；把磁盘中的数据缓存到内存中，把对磁盘的访问，变成对内存的访问</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/50.PageCache%E7%BC%93%E5%AD%98%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B.png" alt="PageCache缓存访问流程"></p></li><li><p>Kafka集群模型</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MK/architect/ChapterTwo/51.Kafka%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%9E%8B.png" alt="Kafka集群模型"></p></li></ul></li><li><p>kafka高吞吐量日志收集实战</p></li><li><p>架构思考：分布式日志，跟踪，告警，分析平台</p></li></ol><h3 id="7-7-分布式锁"><a href="#7-7-分布式锁" class="headerlink" title="7.7 分布式锁"></a>7.7 分布式锁</h3><ol><li>面临问题<ul><li>互斥性</li><li>安全性</li><li>死锁</li><li>容错</li></ul></li><li>解决<ul><li>使用<code>set</code>方法设置键的过期时间并给键添加一个随机字符，避免键集中过期时造成的卡顿</li></ul></li></ol><h3 id="7-8-分布式事务与数据一致性"><a href="#7-8-分布式事务与数据一致性" class="headerlink" title="7.8 分布式事务与数据一致性"></a>7.8 分布式事务与数据一致性</h3><h3 id="7-9-接口幂等设计与分布式限流"><a href="#7-9-接口幂等设计与分布式限流" class="headerlink" title="7.9 接口幂等设计与分布式限流"></a>7.9 接口幂等设计与分布式限流</h3><h2 id="7-MongoDB"><a href="#7-MongoDB" class="headerlink" title="7. MongoDB"></a>7. MongoDB</h2><h2 id="8-Mybatis"><a href="#8-Mybatis" class="headerlink" title="8. Mybatis"></a>8. Mybatis</h2><h2 id="9-Spring"><a href="#9-Spring" class="headerlink" title="9. Spring"></a>9. Spring</h2><ol><li>IOC<ol><li>控制反转IOC：Spring最核心的部分，主要是用来创建对象</li><li>依赖注入DI：把第层类作为参数传递给上层类，实现上层对下层的”控制”<ol><li>是IOC的一种特殊实现</li><li>Setter</li><li>Interface</li><li>Constructor</li><li>Annotation</li></ol></li><li>依赖查找DL：IOC的另一种实现</li><li>优势<ol><li>避免在各处使用new来创建类，并且可以做到统一维护</li><li>创建实例的时候不需要了解其中的细节</li></ol></li><li>功能<ol><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调方法</li></ol></li><li>核心接口<ol><li>BeanDefinition：主要用来描述Bean的定义</li><li>BeanDefinitionRegistry：提供向IOC容器注册BeanDefinition对象的方法</li><li>BeanFactory：Spring最核心的接口<ol><li>提供IOC的配置机制</li><li>包含Bean的各种定义，便于实例化Bean</li><li>建立Bean之间的依赖关系</li><li>Bean生命周期的控制</li></ol></li><li>ApplicationContext<ol><li>继承BeanFactory接口，能够管理和装配Bean</li></ol></li></ol></li></ol></li><li>AOP</li></ol><h2 id="10-SpringMVC"><a href="#10-SpringMVC" class="headerlink" title="10. SpringMVC"></a>10. SpringMVC</h2><h2 id="11-Dubbo-zookeeper"><a href="#11-Dubbo-zookeeper" class="headerlink" title="11. Dubbo+zookeeper"></a>11. Dubbo+zookeeper</h2><h2 id="12-SpringCloud"><a href="#12-SpringCloud" class="headerlink" title="12. SpringCloud"></a>12. SpringCloud</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2019/11/01/hello-world/"/>
      <url>2019/11/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>0.JavaBase</title>
      <link href="2018/07/13/0-javabase/"/>
      <url>2018/07/13/0-javabase/</url>
      
        <content type="html"><![CDATA[<h1 id="Java理论"><a href="#Java理论" class="headerlink" title="Java理论"></a>Java理论</h1><h2 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1. Java基础"></a>1. Java基础</h2><h3 id="1-1-基础"><a href="#1-1-基础" class="headerlink" title="1.1 基础"></a>1.1 基础</h3><h4 id="1-1-1-数据类型"><a href="#1-1-1-数据类型" class="headerlink" title="1.1.1 数据类型"></a>1.1.1 数据类型</h4><ol><li><p>基础数据类型</p><table><thead><tr><th>类型</th><th>byte</th><th>short</th><th>int</th><th>char</th><th>float</th><th>long</th><th>double</th><th>boolean</th></tr></thead><tbody><tr><td>位</td><td>8</td><td>16</td><td>32</td><td>16</td><td>32</td><td>64</td><td>64</td><td>~</td></tr></tbody></table><ul><li>注意<ul><li>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定</li><li>JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false</li><li>JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的</li></ul></li></ul></li><li><p>包装类型</p><blockquote><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成</p></blockquote><pre class=" language-java"><code class="language-java">Integer x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 装箱 调用了 Integer.valueOf(2)</span><span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 拆箱 调用了 X.intValue()</span></code></pre></li></ol><h4 id="1-1-2-缓存池"><a href="#1-1-2-缓存池" class="headerlink" title="1.1.2 缓存池"></a>1.1.2 缓存池</h4><ol><li><p>new Integer(123) 与 Integer.valueOf(123) 的区别</p><ul><li>new Integer(123) 每次都会新建一个对象</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用</li></ul></li><li><p>valueOf() 方法的实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容</span><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>        <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>Java 8 中，Integer 缓存池的大小默认为 -128~127</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Integer cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// high value may be configured by property</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>    String integerCacheHighPropValue <span class="token operator">=</span>        sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>VM<span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">"java.lang.Integer.IntegerCache.high"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Maximum array size is Integer.MAX_VALUE</span>            h <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> NumberFormatException nfe<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// If the property cannot be parsed into an int, ignore it.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    high <span class="token operator">=</span> h<span class="token punctuation">;</span>    cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// range [-128, 127] must be interned (JLS7 5.1.7)</span>    <span class="token keyword">assert</span> IntegerCache<span class="token punctuation">.</span>high <span class="token operator">>=</span> <span class="token number">127</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象</p><pre class=" language-java"><code class="language-java">Integer m <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>Integer n <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre></li><li><p>基本类型对应的缓冲池</p><blockquote><p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象</p></blockquote><table><thead><tr><th>类型</th><th>boolean</th><th>byte</th><th>short</th><th>int</th><th>char</th></tr></thead><tbody><tr><td>范围</td><td>values true and false</td><td>all byte values</td><td>values between -128 and 127</td><td>values between -128 and 127</td><td>in the range \u0000 to \u007F</td></tr></tbody></table><ul><li>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127</li><li>但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=&lt;size&gt; 来指定这个缓冲池的大小</li><li>该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界</li></ul></li></ol><h4 id="1-1-3-字符串"><a href="#1-1-3-字符串" class="headerlink" title="1.1.3 字符串"></a>1.1.3 字符串</h4><ul><li><p>概述</p><blockquote><p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p></blockquote></li><li><p>在 Java 8 中，String 内部使用 char 数组存储数据</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>    <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>    <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** The identifier of the encoding used to encode the bytes in {@code value}. */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span> coder<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>不可变的优势</p><ul><li><p>可以缓存 hash 值</p><blockquote><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算</p></blockquote></li><li><p>String Pool 的需要</p><blockquote><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool</p></blockquote></li><li><p>安全性</p><blockquote><p>String 经常作为参数，String 不可变性可以保证参数不可变</p><p>例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是</p></blockquote></li><li><p>线程安全</p><blockquote><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用</p></blockquote></li></ul></li><li><p>小结</p><ul><li>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组</li><li>并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变</li></ul></li><li><p>String, StringBuffer and StringBuilder</p><ul><li>可变性<ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul></li><li>线程安全<ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul></li></ul></li><li><p>String Pool</p><blockquote><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定</p><p>不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中</p><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用</p><p>否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用</p></blockquote><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// false</span>String s3 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s4 <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// true</span></code></pre></li><li><p>采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中</p><pre class=" language-java"><code class="language-java">String s5 <span class="token operator">=</span> <span class="token string">"bbb"</span><span class="token punctuation">;</span>String s6 <span class="token operator">=</span> <span class="token string">"bbb"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s5 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true</span></code></pre></li><li><p>String Pool历史</p><ul><li>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代</li><li>在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误</li></ul></li><li><p>new String(“abc”)</p><blockquote><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）</p></blockquote><ul><li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量</li><li>使用 new 的方式会在堆中创建一个字符串对象</li></ul></li><li><p>解释new String(“abc”)</p><ul><li><p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewStringTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>使用 javap -verbose 进行反编译，得到以下内容</p><blockquote><p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量</p><p>在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ...</span>Constant pool<span class="token operator">:</span><span class="token comment" spellcheck="true">// ...</span>   #<span class="token number">2</span> <span class="token operator">=</span> Class              #<span class="token number">18</span>            <span class="token comment" spellcheck="true">// java/lang/String</span>   #<span class="token number">3</span> <span class="token operator">=</span> String             #<span class="token number">19</span>            <span class="token comment" spellcheck="true">// abc</span><span class="token comment" spellcheck="true">// ...</span>  #<span class="token number">18</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>String  #<span class="token number">19</span> <span class="token operator">=</span> Utf8               abc<span class="token comment" spellcheck="true">// ...</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V    flags<span class="token operator">:</span> ACC_PUBLIC<span class="token punctuation">,</span> ACC_STATIC    Code<span class="token operator">:</span>      stack<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>         <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// class java/lang/String</span>         <span class="token number">3</span><span class="token operator">:</span> dup         <span class="token number">4</span><span class="token operator">:</span> ldc           #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// String abc</span>         <span class="token number">6</span><span class="token operator">:</span> invokespecial #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/lang/String."&lt;init>":(Ljava/lang/String;)V</span>         <span class="token number">9</span><span class="token operator">:</span> astore_1<span class="token comment" spellcheck="true">// ...</span></code></pre></li><li><p>String 构造函数的源码</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组</span><span class="token keyword">public</span> <span class="token function">String</span><span class="token punctuation">(</span>String original<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> original<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> original<span class="token punctuation">.</span>hash<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li></ul><h4 id="1-1-4-运算符"><a href="#1-1-4-运算符" class="headerlink" title="1.1.4 运算符"></a>1.1.4 运算符</h4><ol><li><p>参数传递</p><blockquote><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递</p><p>将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中</p><p>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象</p></blockquote></li><li><p>特殊情形</p><blockquote><p>在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象</p><p>在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// A和B互不影响</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PassByValueExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Dog dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getObjectAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Dog@4554617c</span>        <span class="token function">func</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getObjectAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Dog@4554617c</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// A</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Dog dog<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getObjectAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Dog@4554617c</span>        dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getObjectAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Dog@74a14482</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// B</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>float 与 double</p><blockquote><p>Java 不能隐式执行向下转型，因为这会使得精度降低</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型</span><span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">1.1f</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确定义</span><span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">1.1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误定义</span></code></pre></li><li><p>隐式类型转换</p><blockquote><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">short</span> s1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// s1 = s1 + 1;</span><span class="token comment" spellcheck="true">// 使用 += 或者 ++ 运算符会执行隐式类型转换</span>s1 <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>s1<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 上面的语句相当于将 s1 + 1 的计算结果进行了向下转型</span>s1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>s1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>switch</p><blockquote><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象</p><p>switch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断</p><p>如果值过于复杂，那么还是用 if 比较合适</p></blockquote></li></ol><h4 id="1-1-5-关键字"><a href="#1-1-5-关键字" class="headerlink" title="1.1.5 关键字"></a>1.1.5 关键字</h4><ol><li><p>final</p><ul><li><p>数据</p><blockquote><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量</p></blockquote><ul><li>对于基本类型，final 使数值不变</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// x = 2;  // cannot assign value to final variable 'x'</span><span class="token keyword">final</span> A y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre></li><li><p>方法</p><ul><li>声明方法不能被子类重写</li><li>private 方法隐式地被指定为 final</li><li>子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法</li></ul></li><li><p>类</p><blockquote><p>声明类不允许被继承</p></blockquote></li></ul></li><li><p>static</p><ul><li><p>静态变量</p><blockquote><p>又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它</p><p>静态变量在内存中只存在一份</p></blockquote></li><li><p>实例变量</p><blockquote><p>每创建一个实例就会产生一个实例变量，它与该实例同生共死</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 实例变量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 静态变量</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// int x = A.x;  // Non-static field 'x' cannot be referenced from a static context</span>        A a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> a<span class="token punctuation">.</span>x<span class="token punctuation">;</span>        <span class="token keyword">int</span> y <span class="token operator">=</span> A<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>静态方法</p><blockquote><p>静态方法在类加载的时候就存在了，它不依赖于任何实例</p><p>静态方法必须有实现，也就是说它不能是抽象方法</p><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联</p></blockquote></li><li><p>静态代码块</p><blockquote><p>静态语句块在类初始化时运行一次</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        A a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        A a2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>静态内部类</p><blockquote><p>非静态内部类依赖于外部类的实例</p><p>需要先创建外部类实例，才能用这个实例去创建非静态内部类</p><p>静态内部类不能访问外部类的非静态的变量和方法</p></blockquote></li><li><p>静态包</p><blockquote><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低</p></blockquote><pre class=" language-jav"><code class="language-jav">import static com.xxx.ClassName.*</code></pre></li><li><p>初始化顺序</p><blockquote><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String staticField <span class="token operator">=</span> <span class="token string">"静态变量"</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态语句块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String field <span class="token operator">=</span> <span class="token string">"实例变量"</span><span class="token punctuation">;</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通语句块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 最后才是构造函数的初始化</span><span class="token keyword">public</span> <span class="token function">InitialOrderTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>存在继承的情况下，初始化顺序为</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul></li></ul></li></ol><h4 id="1-1-6-对象方法"><a href="#1-1-6-对象方法" class="headerlink" title="1.1.6 对象方法"></a>1.1.6 对象方法</h4><ul><li><p>通用方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token keyword">protected</span> <span class="token keyword">native</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException<span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token keyword">int</span> nanos<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException</code></pre></li><li><p>equals()</p><ul><li>等价关系，满足以下条件<ul><li>自反性</li><li>对称性</li><li>传递性</li><li>一致性</li><li>任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</li></ul></li><li>等价与相等<ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价</li></ul></li><li>实现<ul><li>检查是否为同一个对象的引用，如果是直接返回 true</li><li>检查是否是同一个类型，如果不是，直接返回 false</li><li>将 Object 对象进行转型</li><li>判断每个关键域是否相等</li></ul></li></ul></li><li><p>hashCode()</p><blockquote><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价</p><p>等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价</p><p>因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值</p></blockquote><ul><li><p>注意</p><ul><li>覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等</li><li>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法</li></ul></li><li><p>泊松分布</p><blockquote><p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上,要求了哈希函数要把所有域的值都考虑进来,可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数</p><p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失</p><p>一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化</p></blockquote></li></ul></li><li><p>toString()</p><blockquote><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示</p></blockquote></li><li><p>clone()</p><blockquote><p>是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法</p><p>clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法</p><p>Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException</p></blockquote><ul><li><p>浅拷贝</p><blockquote><p>拷贝对象和原始对象的引用类型引用同一个对象</p></blockquote></li><li><p>深拷贝</p><blockquote><p>拷贝对象和原始对象的引用类型引用不同对象</p></blockquote></li><li><p>clone()的替代方案</p><blockquote><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换</p><p>最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象</p></blockquote></li></ul></li></ul><h4 id="1-1-7-面向对象"><a href="#1-1-7-面向对象" class="headerlink" title="1.1.7 面向对象"></a>1.1.7 面向对象</h4><ol><li><p>继承</p><ul><li><p>访问权限</p><blockquote><p>三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见</p><p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来</p><p>模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装</p><p>因此访问权限应当尽可能地使每个类或者成员不被外界访问</p><p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别;这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则</p></blockquote></li><li><p>类可见表示其它类可以用这个类创建实例对象</p></li><li><p>成员可见表示其它类可以用这个类的实例对象访问到该成员</p></li><li><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改</p></li></ul></li><li><p>抽象类和接口</p><ul><li><p>抽象类</p><blockquote><p>抽象类和抽象方法都使用 abstract 关键字进行声明</p><p>一个类中包含抽象方法，那么这个类必须声明为抽象类</p><p>抽象类不能被实例化，只能被继承</p></blockquote></li><li><p>接口</p><blockquote><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现</p><p>Java 8 开始，接口也可以拥有默认的方法实现</p><p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected</p><p>Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去</p><p>接口的字段默认都是 static 和 final 的</p></blockquote></li></ul></li><li><p>super</p><blockquote><p>可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作</p><p>子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数</p><p>使用 super 关键字来引用父类的方法实现</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperExample</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SuperExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperExample.func()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperExtendExample</span> <span class="token keyword">extends</span> <span class="token class-name">SuperExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> z<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SuperExtendExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 委托父类完成一些初始化工作</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>z <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用super关键字来引用父类方法的实现</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperExtendExample.func()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>SuperExample e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperExtendExample</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>e<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// SuperExample.func()</span>          <span class="token comment" spellcheck="true">// SuperExtendExample.func()</span></code></pre></li><li><p>重写与重载</p><ul><li><p>重写</p><blockquote><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法</p><p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件</p></blockquote><ul><li><p>限制</p><ul><li>子类方法的访问权限必须大于等于父类方法</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</li></ul></li><li><p>方法调用</p><blockquote><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承</p><p>否则就要对参数进行转型，转成父类之后看是否有对应的方法</p></blockquote></li><li><p>方法调用优先级</p><p><code>this.func(this)</code>&gt;<code>super.func(this)</code>&gt;<code>this.func(super)</code>&gt;<code>super.func(super)</code></p></li></ul></li><li><p>重载</p><blockquote><p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同</p><p>返回值不同，其它都相同不算是重载</p></blockquote></li></ul></li></ol><h4 id="1-1-8-反射"><a href="#1-1-8-反射" class="headerlink" title="1.1.8 反射"></a>1.1.8 反射</h4><ol><li><p>概述</p><blockquote><p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息</p><p>当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象</p><p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中</p><p>使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象</p></blockquote></li><li><p>作用</p><blockquote><p>提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来</p></blockquote></li><li><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类</p><ul><li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段</li><li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法</li><li><strong>Constructor</strong> ：可以用 Constructor 的 newInstance() 创建新的对象</li></ul></li><li><p>优点</p><ul><li><p>可扩展性</p><blockquote><p>应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类</p></blockquote></li><li><p>类浏览器和可视化开发环境</p><blockquote><p>一个类浏览器需要可以枚举类的成员</p><p>可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码</p></blockquote></li><li><p>调试器和测试工具</p><blockquote><p>调试器需要能够检查一个类里的私有成员</p><p>测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率</p></blockquote></li></ul></li><li><p>缺点</p><ul><li><p>性能开销</p><blockquote><p>反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化</p></blockquote></li><li><p>安全限制</p><blockquote><p>使用反射技术要求程序必须在一个没有安全限制的环境中运行</p></blockquote></li><li><p>内部暴露</p><blockquote><p>使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性</p><p>反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化</p></blockquote></li></ul></li></ol><h4 id="1-1-9-其他"><a href="#1-1-9-其他" class="headerlink" title="1.1.9 其他"></a>1.1.9 其他</h4><ol><li><p>异常</p><blockquote><p>Throwable 可以用来表示任何可以作为异常抛出的类</p><p>Error 和 Exception</p></blockquote><ul><li>Error 用来表示 JVM 无法处理的错误</li><li>Exception<ul><li>受检异常 ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复</li><li>非受检异常 ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception</li></ul></li></ul></li><li><p>泛型</p><blockquote><p>即“参数化类型”,将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）</p><p>在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型</p></blockquote></li><li><p>新特性</p><ul><li><p>注解</p><blockquote><p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能</p></blockquote></li><li><p>新特性</p><table><thead><tr><th align="left">Java8</th><th align="left">Lambda Expressions</th><th align="left">Pipelines and Streams</th><th align="left">Date and Time API</th><th align="left">Default Methods</th><th align="left">Type Annotations</th><th align="left">Nashhorn JavaScript Engine</th><th align="left">Concurrent Accumulators</th><th align="left">Parallel operations</th><th align="left">PermGen Error Removed</th></tr></thead><tbody><tr><td align="left">Java7</td><td align="left">Strings in Switch Statement</td><td align="left">Type Inference for Generic Instance Creation</td><td align="left">Multiple Exception Handling</td><td align="left">Support for Dynamic Languages</td><td align="left">Try with Resources</td><td align="left">Java nio Package</td><td align="left">Binary Literals, Underscore in literals</td><td align="left">Diamond Syntax</td><td align="left"></td></tr></tbody></table></li></ul></li><li><p>JRE or JDK</p><ul><li>JRE：Java 运行环境的简称，为 Java 的运行提供了所需的环境</li><li>JDK：Java 开发工具包，提供了 Java 的开发及运行环境；Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac</li></ul></li></ol><h3 id="1-2-容器"><a href="#1-2-容器" class="headerlink" title="1.2 容器"></a>1.2 容器</h3><ol><li><p>概述</p><blockquote><p>主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表</p></blockquote></li></ol><h4 id="1-2-1-接口"><a href="#1-2-1-接口" class="headerlink" title="1.2.1 接口"></a>1.2.1 接口</h4><ol><li>Collection<ol><li>Set<ul><li>TreeSet：基于红黑树实现，支持有序性操作，查找的时间复杂度为O(logN)</li><li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作；失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的</li><li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序</li></ul></li><li>List<ul><li>ArrayList：基于动态数组实现，支持随机访问</li><li>Vector：和 ArrayList 类似，但它是线程安全的</li><li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元</li></ul></li><li>Queue<ul><li>LinkedList：可以用它来实现双向队列</li><li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列</li></ul></li></ol></li><li>Map<ul><li>TreeMap：基于红黑树实现</li><li>HashMap：基于哈希表实现</li><li>HashTable：和 HashMap 类似，但它是线程安全的，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁</li><li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序</li></ul></li></ol><h4 id="1-2-2-设计模式"><a href="#1-2-2-设计模式" class="headerlink" title="1.2.2 设计模式"></a>1.2.2 设计模式</h4><ol><li><p>迭代器模式</p><blockquote><p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元</p></blockquote></li><li><p>适配器模式</p><blockquote><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型</p><p>asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组</p></blockquote></li></ol><h4 id="1-2-3-源码分析"><a href="#1-2-3-源码分析" class="headerlink" title="1.2.3 源码分析"></a>1.2.3 源码分析</h4><ol><li><p>概述</p><blockquote><p>源码分析基于 JDK 1.8</p></blockquote></li><li><p>分析</p><ul><li><p>ArrayList</p><ul><li><p>概述</p><blockquote><p>基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span>        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> RandomAccess<span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</code></pre></li><li><p>扩容</p><blockquote><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，即 oldCapacity+oldCapacity/2</p><p>其中 oldCapacity &gt;&gt; 1 需要取整，所以新容量大约是旧容量的 1.5 倍左右</p><p>oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 数组的默认大小为 10</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>        minCapacity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>删除</p><blockquote><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>序列化</p><blockquote><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化</p><p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化</p><p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// non-private to simplify nested class access</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectInputStream s<span class="token punctuation">)</span>    <span class="token keyword">throws</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>    elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Read in size, and any hidden stuff</span>    s<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Read in capacity</span>    s<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ignored</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// be like clone(), allocate array based upon size not capacity</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> elementData<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Read in all elements in the proper order.</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectOutputStream s<span class="token punctuation">)</span>    <span class="token keyword">throws</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Write out element count, and any hidden stuff</span>    <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">defaultWriteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Write out size as capacity for behavioural compatibility with clone()</span>    s<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Write out all elements in the proper order.</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>序列化操作</p><blockquote><p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似</p></blockquote><pre class=" language-java"><code class="language-java">ArrayList list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ObjectOutputStream oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>Fail-Fast</p><blockquote><p>modCount 用来记录 ArrayList 结构发生变化的次数</p><p>结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException</p></blockquote></li></ul></li><li><p>HashMap</p><ul><li><p>存储结构</p><blockquote><p>内部包含了一个 Entry 类型的数组 table</p><p>Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表</p><p>数组中的每个位置被当成一个桶，一个桶存放一个链表</p><p>HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>    V value<span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>    <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> v<span class="token punctuation">;</span>        next <span class="token operator">=</span> n<span class="token punctuation">;</span>        key <span class="token operator">=</span> k<span class="token punctuation">;</span>        hash <span class="token operator">=</span> h<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        Map<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token punctuation">)</span>o<span class="token punctuation">;</span>        Object k1 <span class="token operator">=</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object k2 <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k1 <span class="token operator">==</span> k2 <span class="token operator">||</span> <span class="token punctuation">(</span>k1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> k1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Object v1 <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object v2 <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>v1 <span class="token operator">==</span> v2 <span class="token operator">||</span> <span class="token punctuation">(</span>v1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> v1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>拉链法原理</p><blockquote><p>查找</p><ul><li>计算键值对所在的桶</li><li>在链表上顺序查找，时间复杂度显然和链表的长度成正比</li></ul></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 新建一个 HashMap，默认大小为 16</span><span class="token comment" spellcheck="true">// 插入&lt;K1,V1> 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</span><span class="token comment" spellcheck="true">// 插入&lt;K2,V2> 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</span><span class="token comment" spellcheck="true">// 插入&lt;K3,V3> 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2> 前面。</span><span class="token comment" spellcheck="true">// 应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3> 不是插在 &lt;K2,V2> 后面，而是插入在链表头部</span>HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"K1"</span><span class="token punctuation">,</span> <span class="token string">"V1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"K2"</span><span class="token punctuation">,</span> <span class="token string">"V2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"K3"</span><span class="token punctuation">,</span> <span class="token string">"V3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>put操作</p><blockquote><p>HashMap 允许插入键为 null 的键值对</p><p>因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放</p><p>HashMap 使用第 0 个桶存放键为 null 的键值对</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 键为 null 单独处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 确定桶下标</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 插入新键值对</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 头插法，链表头部指向新的键值对</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    value <span class="token operator">=</span> v<span class="token punctuation">;</span>    next <span class="token operator">=</span> n<span class="token punctuation">;</span>    key <span class="token operator">=</span> k<span class="token punctuation">;</span>    hash <span class="token operator">=</span> h<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p>确定桶下标</p><blockquote><p>很多操作都需要先确定一个键值对所在的桶下标</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>计算hash值</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> h <span class="token operator">&amp;&amp;</span> k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Hashing<span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>取模</p><ul><li><p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质</p><pre class=" language-java"><code class="language-java">x   <span class="token operator">:</span> <span class="token number">00010000</span>x<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">00001111</span></code></pre></li><li><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数</p><pre class=" language-java"><code class="language-java">y       <span class="token operator">:</span> <span class="token number">10110010</span>x<span class="token operator">-</span><span class="token number">1</span>     <span class="token operator">:</span> <span class="token number">00001111</span>y<span class="token operator">&amp;</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">00000010</span></code></pre></li><li><p>这个性质和 y 对 x 取模效果是一样的</p><pre class=" language-java"><code class="language-java">y   <span class="token operator">:</span> <span class="token number">10110010</span>x   <span class="token operator">:</span> <span class="token number">00010000</span>y<span class="token operator">%</span>x <span class="token operator">:</span> <span class="token number">00000010</span></code></pre></li><li><p>位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能</p></li></ul></li><li><p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>扩容-基本原理</p><blockquote><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)</p><p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大</p><p>HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证</p></blockquote></li><li><p>扩容-主要参数</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>capacity</td><td>table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td></tr><tr><td>size</td><td>键值对数量。</td></tr><tr><td>threshold</td><td>size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td></tr><tr><td>loadFactor</td><td>装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</td></tr></tbody></table><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token keyword">transient</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span></code></pre><blockquote><p>需要扩容时，令 capacity 为原来的两倍</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size<span class="token operator">++</span> <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>        threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">)</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> src <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> src<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> src<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            src<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>                e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                e <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>扩容-重新计算桶下标</p><blockquote><p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上</p><p>HashMap 使用 hash%capacity 来确定桶下标</p><p>HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32</span>capacity     <span class="token operator">:</span> <span class="token number">00010000</span><span class="token keyword">new</span> <span class="token class-name">capacity</span> <span class="token operator">:</span> <span class="token number">00100000</span></code></pre><p>对于一个key，它的哈希值hash在第5位</p><ul><li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致</li><li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16</li></ul></li><li><p>计算数组容量</p><blockquote><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到</span>mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">1</span>    <span class="token number">11011000</span>mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">2</span>    <span class="token number">11111110</span>mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">4</span>    <span class="token number">11111111</span><span class="token comment" spellcheck="true">// mask+1 是大于原始数字的最小的 2 的 n 次方</span>num     <span class="token number">10010000</span>mask<span class="token operator">+</span><span class="token number">1</span> <span class="token number">100000000</span></code></pre></li><li><p>HashMap中计算数组容量的代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>链表转红黑树</p><blockquote><p>从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树</p></blockquote></li><li><p>比较</p><ul><li>Hashtable 使用 synchronized 来进行同步</li><li>HashMap 可以插入键为 null 的 Entry</li><li>HashMap 的迭代器是 fail-fast 迭代器</li><li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的</li></ul></li></ul></li></ul></li><li><p>LinkedList</p><ul><li><p>概述</p><blockquote><p>基于双向链表实现，使用 Node 存储链表节点信息</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    E item<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 每个链表存储了 first 和 last 指针</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first<span class="token punctuation">;</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span></code></pre></li><li><p>比较</p><blockquote><p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现</p></blockquote><ul><li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素</li><li>链表不支持随机访问，但插入删除只需要改变指针</li></ul></li></ul></li><li><p>LinkedHashMap</p><ul><li><p>存储结构</p><blockquote><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性</p><p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token comment" spellcheck="true">/** * The head (eldest) of the doubly linked list. */</span><span class="token keyword">transient</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * The tail (youngest) of the doubly linked list. */</span><span class="token keyword">transient</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用</span><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre></li><li><p>afterNodeAccess()</p><blockquote><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// move node to last</span>    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> last<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span>            <span class="token punctuation">(</span>LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>after <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> null<span class="token punctuation">)</span>            head <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">else</span>            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> null<span class="token punctuation">)</span>            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">else</span>            last <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> null<span class="token punctuation">)</span>            head <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>            last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        tail <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>afterNodeInsertion()</p><blockquote><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first</p><p>evict 只有在构建 Map 的时候才为 false，在这里为 true</p><p>removeEldestEntry() 默认为false，如果需要让它为 true，需要继承LinkedHashMap 并且覆盖这个方法的实现</p><p>实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// possibly remove eldest</span>    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        K key <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">;</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>LRU缓存</p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ENTRIES <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> MAX_ENTRIES<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>MAX_ENTRIES<span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LRUCache<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LRUCache</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>ConcurrentHashMap</p><ul><li><p>存储结构</p><blockquote><p>ConcurrentHashMap 和 HashMap 实现上类似</p><p>ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> V value<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Segment 继承自 ReentrantLock</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 2249069246763182397L<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_SCAN_RETRIES <span class="token operator">=</span>        Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">64</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">transient</span> <span class="token keyword">volatile</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 默认的并发级别为 16，也就是说默认创建 16 个 Segment</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CONCURRENCY_LEVEL <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span></code></pre></li><li><p>size操作</p><blockquote><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数</p><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来</p><p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的</p><p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3</p><p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * The number of elements. Accessed only either within locks * or among other volatile reads that maintain visibility. */</span><span class="token keyword">transient</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result. */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RETRIES_BEFORE_LOCK <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Try a few times to get accurate count. On failure due to</span>    <span class="token comment" spellcheck="true">// continuous async changes in table, resort to locking.</span>    <span class="token keyword">final</span> Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>segments<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> overflow<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true if size overflows 32 bits</span>    <span class="token keyword">long</span> sum<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// sum of modCounts</span>    <span class="token keyword">long</span> last <span class="token operator">=</span> 0L<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// previous sum</span>    <span class="token keyword">int</span> retries <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// first iteration isn't retry</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 超过尝试次数，则对每个 Segment 加锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>retries<span class="token operator">++</span> <span class="token operator">==</span> RETRIES_BEFORE_LOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>                    <span class="token function">ensureSegment</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// force creation</span>            <span class="token punctuation">}</span>            sum <span class="token operator">=</span> 0L<span class="token punctuation">;</span>            size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            overflow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> seg <span class="token operator">=</span> <span class="token function">segmentAt</span><span class="token punctuation">(</span>segments<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>seg <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    sum <span class="token operator">+=</span> seg<span class="token punctuation">.</span>modCount<span class="token punctuation">;</span>                    <span class="token keyword">int</span> c <span class="token operator">=</span> seg<span class="token punctuation">.</span>count<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>size <span class="token operator">+=</span> c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                        overflow <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 连续两次得到的结果一致，则认为这个结果是正确的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> last<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            last <span class="token operator">=</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retries <span class="token operator">></span> RETRIES_BEFORE_LOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>                <span class="token function">segmentAt</span><span class="token punctuation">(</span>segments<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> overflow <span class="token operator">?</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>1.8改进</p><ul><li>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等</li><li>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized</li><li>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树</li></ul></li></ul></li><li><p>Vector</p><ul><li><p>同步</p><blockquote><p>实现与 ArrayList 类似，但是使用了 synchronized 进行同步</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">ensureCapacityHelper</span><span class="token punctuation">(</span>elementCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>elementCount<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> elementCount<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>扩容</p><blockquote><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement</p><p>如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">int</span> capacityIncrement<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                           initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>capacityIncrement <span class="token operator">=</span> capacityIncrement<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>capacityIncrement <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span>                                     capacityIncrement <span class="token operator">:</span> oldCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>比较</p><ul><li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制</li><li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍</li></ul></li><li><p>替代方案</p><blockquote><p>使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList</p><p>使用 concurrent 并发包下的 CopyOnWriteArrayList 类</p></blockquote><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> synList <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><p>CopyOnWriteArrayList</p><ul><li><p>读写分离</p><blockquote><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失</p><p>写操作结束之后需要把原始数组指向新的复制数组</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setArray</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    array <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span><span class="token keyword">private</span> E <span class="token function">get</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>应用场景</p><blockquote><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景</p><p>不适合内存敏感以及对实时性要求很高的场景</p></blockquote></li><li><p>缺陷</p><ul><li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右</li><li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中</li></ul></li></ul></li><li><p>WeakHashMap</p><ul><li><p>存储结构</p><blockquote><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收</p><p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span></code></pre></li><li><p>ConcurrentCache</p><blockquote><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能</p></blockquote></li><li><p>ConcurrentCache采取的是分代缓存</p><ul><li>经常使用的对象放入eden中，eden使用ConcurrentHashMap实现，不用担心会被回收（伊甸园）</li><li>不常用的对象放入longterm，longterm使用WeakHashMap实现，这些老对象会被垃圾收集器回收</li><li>当调用get()方法时，会先从eden区获取，如果没有找到的话再到longterm获取，当从longterm获取到就把对象放入eden中，从而保证经常被访问的节点不容易被回收</li><li>当调用put()方法时，如果eden的大小超过了size，那么就将eden中的所有对象都放入longterm中，利用虚拟机回收掉一部分不经常使用的对象</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentCache</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> eden<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> longterm<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcurrentCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>eden <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>longterm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>K k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        V v <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            v <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>longterm<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> v<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>K k<span class="token punctuation">,</span> V v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>longterm<span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul></li></ul></li></ol><h3 id="1-3-IO"><a href="#1-3-IO" class="headerlink" title="1.3 IO"></a>1.3 IO</h3><h4 id="1-3-1-基础"><a href="#1-3-1-基础" class="headerlink" title="1.3.1 基础"></a>1.3.1 基础</h4><ul><li><p>磁盘操作：File</p><blockquote><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容</p></blockquote></li><li><p>字节操作：InputStream 和 OutputStream</p><ul><li><p>装饰者模式</p><blockquote><p>Java I/O 使用了装饰者模式来实现</p></blockquote></li><li><p>InputStream 是抽象组件</p></li><li><p>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作</p></li><li><p>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能</p><ul><li>例如 BufferedInputStream 为 FileInputStream 提供缓存的功能</li></ul></li><li><p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型</span>FileInputStream fileInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>BufferedInputStream bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>fileInputStream<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>字符操作：Reader 和 Writer</p><ul><li><p>编码与解码</p><blockquote><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符</p><p>如果编码和解码过程使用不同的编码方式那么就出现了乱码</p></blockquote></li><li><p>常见编码方式</p><ul><li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节</li><li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节</li><li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节</li></ul></li><li><p>java内存编码</p><blockquote><p>UTF-16be 中的 be 指的是 Big Endian，也就是大端</p><p>UTF-16le中的le 指的是 Little Endian，也就是小端</p><p>Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码</p><p>char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储</p></blockquote></li><li><p>String的编码方式</p><blockquote><p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String</p></blockquote><pre class=" language-java"><code class="language-java">String str1 <span class="token operator">=</span> <span class="token string">"中文"</span><span class="token punctuation">;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>Reader与Writer</p><blockquote><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符</p><p>在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法</p></blockquote><ul><li>InputStreamReader 实现从字节流解码成字符流</li><li>OutputStreamWriter 实现字符流编码成为字节流</li></ul></li></ul></li><li><p>对象操作：Serializable</p><blockquote><p>序列化就是将一个对象转换成字节序列，方便存储和传输</p><p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态</p></blockquote><ul><li><p>序列化：ObjectOutputStream.writeObject()</p></li><li><p>反序列化：ObjectInputStream.readObject()</p></li><li><p>Serializable</p><blockquote><p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常</p></blockquote></li><li><p>transient</p><blockquote><p>transient 关键字可以使一些属性不会被序列化</p><p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span></code></pre></li></ul></li><li><p>网络操作：Socket</p><ul><li><p>InetAddress：用于表示网络上的硬件资源，即 IP 地址</p><blockquote><p>没有公有的构造函数，只能通过静态方法来创建实例</p></blockquote></li><li><p>URL：统一资源定位符</p><blockquote><p>可以直接从 URL 中读取字节流数据</p></blockquote></li><li><p>Sockets：使用 TCP 协议实现网络通信</p><ul><li><p>ServerSocket：服务器端类</p></li><li><p>Socket：客户端类</p></li><li><p>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出</p></li><li><p>通信示意</p><p><img src="/2018/07/13/0-javabase/githubblog\source_posts\notes\001.Sockets通信.png" alt="Sockets通信"></p></li></ul></li><li><p>Datagram：使用 UDP 协议实现网络通信</p><ul><li>DatagramSocket：通信类</li><li>DatagramPacket：数据包类</li></ul></li></ul></li><li><p>新的输入/输出：NIO</p><blockquote><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O</p></blockquote><ul><li><p>流与块</p><blockquote><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据</p></blockquote><ul><li>面向流的 I/O 一次处理一个字节数据<ul><li>优点<ul><li>一个输入流产生一个字节数据，一个输出流消费一个字节数据</li><li>为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分</li></ul></li><li>缺点<ul><li>面向流的 I/O 通常相当慢</li></ul></li></ul></li><li>面向块的 I/O 一次处理一个数据块<ul><li>优点<ul><li>按块处理数据比按流处理数据要快得多</li></ul></li><li>缺点<ul><li>面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性</li></ul></li></ul></li></ul></li><li><p>通道与缓冲区</p><blockquote><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据</p><p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写</p></blockquote><ul><li><p>类型</p><ul><li>FileChannel：从文件中读写数据</li><li>DatagramChannel：通过UDP读写网络中数据</li><li>SocketChannel：通过TCP读写网络中数据</li><li>ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel</li></ul></li><li><p>缓冲区</p><blockquote><p>发送给一个通道的所有数据都必须首先放到缓冲区中</p><p>从通道中读取的任何数据都要先读到缓冲区中</p><p>不会直接对通道进行读写数据，而是要先经过缓冲区</p><p><font color="red">缓冲区实质上是一个数组，但它不仅仅是一个数组</font></p><p>缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程</p></blockquote></li><li><p>类型</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul></li></ul></li><li><p>缓冲区状态变量</p><ul><li>capacity：最大容量</li><li>position：当前已经读写的字节数</li><li>limit：还可以读写的字节数</li><li>状态变量的改变过程举例<ul><li>新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8，capacity 变量不会改变</li><li>从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变</li><li>在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0</li><li>从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4</li><li>最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置</li></ul></li></ul></li><li><p>选择器</p><blockquote><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用</p></blockquote><ul><li>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件</li><li>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行</li><li>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能</li><li>只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义</li></ul></li><li><p>内存映射文件</p><blockquote><p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多</p><p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件</p><p>修改数据与将数据保存到磁盘是没有分开的</p></blockquote></li><li><p>NIO与普通I/O的区别</p><ul><li>NIO 是非阻塞的</li><li>NIO 面向块，I/O 面向流</li></ul></li></ul></li></ul><h4 id="1-3-2-基础操作"><a href="#1-3-2-基础操作" class="headerlink" title="1.3.2 基础操作"></a>1.3.2 基础操作</h4><ol><li><p>磁盘操作</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 递归地列出一个目录下所有文件</span><span class="token comment" spellcheck="true">// 从 Java7 开始，可以使用 Paths 和 Files 代替 File</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">listAllFiles</span><span class="token punctuation">(</span>File dir<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dir <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>dir<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dir<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dir<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>File file <span class="token operator">:</span> dir<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">listAllFiles</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>字节操作</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 文件复制</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">copyFile</span><span class="token punctuation">(</span>String src<span class="token punctuation">,</span> String dist<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    FileInputStream in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    FileOutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>dist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">20</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// read() 最多读取 buffer.length 个字节</span>    <span class="token comment" spellcheck="true">// 返回的是实际读取的个数</span>    <span class="token comment" spellcheck="true">// 返回 -1 的时候表示读到 eof，即文件尾</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cnt <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>字符操作</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 逐行输出文本文件的内容</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">readFileContent</span><span class="token punctuation">(</span>String filePath<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    FileReader fileReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>    BufferedReader bufferedReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>fileReader<span class="token punctuation">)</span><span class="token punctuation">;</span>    String line<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> bufferedReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span>    <span class="token comment" spellcheck="true">// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法</span>    <span class="token comment" spellcheck="true">// 因此只要一个 close() 调用即可</span>    bufferedReader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>序列化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>    A a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String objectFile <span class="token operator">=</span> <span class="token string">"file/a1"</span><span class="token punctuation">;</span>    ObjectOutputStream objectOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>objectFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>    objectOutputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ObjectInputStream objectInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>objectFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    A a2 <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span> objectInputStream<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    objectInputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">private</span> String y<span class="token punctuation">;</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> String y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"x = "</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">"  "</span> <span class="token operator">+</span> <span class="token string">"y = "</span> <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>InetAddress</p><pre class=" language-java"><code class="language-java">InetAddress<span class="token punctuation">.</span><span class="token function">getByName</span><span class="token punctuation">(</span>String host<span class="token punctuation">)</span><span class="token punctuation">;</span>InetAddress<span class="token punctuation">.</span><span class="token function">getByAddress</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>URL</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    URL url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"http://www.baidu.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 字节流 */</span>    InputStream is <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">openStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 字符流 */</span>    InputStreamReader isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 提供缓存功能 */</span>    BufferedReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>isr<span class="token punctuation">)</span><span class="token punctuation">;</span>    String line<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>文件NIO实例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fastCopy</span><span class="token punctuation">(</span>String src<span class="token punctuation">,</span> String dist<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 获得源文件的输入字节流 */</span>    FileInputStream fin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 获取输入字节流的文件通道 */</span>    FileChannel fcin <span class="token operator">=</span> fin<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 获取目标文件的输出字节流 */</span>    FileOutputStream fout <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>dist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 获取输出字节流的文件通道 */</span>    FileChannel fcout <span class="token operator">=</span> fout<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 为缓冲区分配 1024 个字节 */</span>    ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 从输入通道中读取数据到缓冲区中 */</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> fcin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* read() 返回 -1 表示 EOF */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/* 切换读写 */</span>        buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 把缓冲区的内容写入输出文件中 */</span>        fcout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 清空缓冲区 */</span>        buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>选择器使用</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. 创建选择器</span>Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 2. 将通道注册到选择器上</span>ServerSocketChannel ssChannel <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ssChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ssChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰</span><span class="token comment" spellcheck="true">// 在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类</span><span class="token comment" spellcheck="true">// SelectionKey.OP_CONNECT</span><span class="token comment" spellcheck="true">// SelectionKey.OP_ACCEPT</span><span class="token comment" spellcheck="true">// SelectionKey.OP_READ</span><span class="token comment" spellcheck="true">// SelectionKey.OP_WRITE</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_READ <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_WRITE <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_CONNECT <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_ACCEPT <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 每个事件可以被当成一个位域，从而组成事件集整数</span><span class="token keyword">int</span> interestSet <span class="token operator">=</span> SelectionKey<span class="token punctuation">.</span>OP_READ <span class="token operator">|</span> SelectionKey<span class="token punctuation">.</span>OP_WRITE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 3. 监听事件</span><span class="token keyword">int</span> num <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 4. 获取到达的事件</span>Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keyIterator <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    SelectionKey key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span>    keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 5. 事件循环 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keyIterator <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        SelectionKey key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// ...</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// ...</span>        <span class="token punctuation">}</span>        keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>套接字NIO实例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NIOServer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ServerSocketChannel ssChannel <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ssChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ssChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span>        ServerSocket serverSocket <span class="token operator">=</span> ssChannel<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        InetSocketAddress address <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        serverSocket<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keyIterator <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                SelectionKey key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    ServerSocketChannel ssChannel1 <span class="token operator">=</span> <span class="token punctuation">(</span>ServerSocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 服务器会为每个新连接创建一个 SocketChannel</span>                    SocketChannel sChannel <span class="token operator">=</span> ssChannel1<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    sChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 这个新连接主要用于从客户端读取数据</span>                    sChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    SocketChannel sChannel <span class="token operator">=</span> <span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">readDataFromSocketChannel</span><span class="token punctuation">(</span>sChannel<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    sChannel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String <span class="token function">readDataFromSocketChannel</span><span class="token punctuation">(</span>SocketChannel sChannel<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuilder data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> sChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> limit <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>limit<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> limit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dst<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            data<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>            buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NIOClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        Socket socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        OutputStream out <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="1-4-并发-amp-多线程"><a href="#1-4-并发-amp-多线程" class="headerlink" title="1.4 并发&amp;多线程"></a>1.4 并发&amp;多线程</h3><h4 id="1-4-1-使用线程"><a href="#1-4-1-使用线程" class="headerlink" title="1.4.1 使用线程"></a>1.4.1 使用线程</h4><ol><li><p>实现线程的三种方式</p><ul><li>实现 Runnable 接口</li><li>实现 Callable 接口</li><li>继承 Thread 类</li></ul><blockquote><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用</p><p>可以理解为任务是通过线程驱动从而执行的</p></blockquote></li><li><p>实现 Runnable 接口</p><blockquote><p>需要实现接口中的 run() 方法</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    MyRunnable instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>实现 Callable 接口</p><blockquote><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>    MyCallable mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>mc<span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ft<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ft<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>继承 Thread 类</p><blockquote><p>需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    MyThread mt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mt<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>实现接口 VS 继承 Thread</p><blockquote><p>实现接口会更好一些</p></blockquote><ul><li>Java 不支持多重继承，但是可以实现多个接口</li><li>类可能只要求可执行就行，继承整个 Thread 类开销过大</li></ul></li></ol><h4 id="1-4-2-基础线程机制"><a href="#1-4-2-基础线程机制" class="headerlink" title="1.4.2 基础线程机制"></a>1.4.2 基础线程机制</h4><ol><li><p>Executor</p><blockquote><p>管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期</p><p>这里的异步是指多个任务的执行互不干扰，不需要进行同步操作</p></blockquote><ul><li><p>类型</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>CachedThreadPool</td><td>一个任务创建一个线程</td></tr><tr><td>FixedThreadPool</td><td>所有任务只能使用固定大小的线程</td></tr><tr><td>SingleThreadExecutor</td><td>相当于大小为 1 的 FixedThreadPool</td></tr></tbody></table></li><li><p>示例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>Daemon</p><blockquote><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程</p><p>main() 属于非守护线程</p><p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>sleep()</p><blockquote><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒</p><p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理</p><p>线程中抛出的其它异常也同样需要在本地进行处理</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>yield()</p><blockquote><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行</p><p>该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="1-4-3-中断"><a href="#1-4-3-中断" class="headerlink" title="1.4.3 中断"></a>1.4.3 中断</h4><ol><li><p>概述</p><blockquote><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束</p></blockquote></li><li><p>InterruptedException</p><blockquote><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException</p><p>从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterruptExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread1<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Main run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>interrupted()</p><blockquote><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束</p><p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true</p><p>因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterruptExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread2</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// ..</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread2<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>Executor 的中断操作</p><blockquote><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 Lambda 创建线程，相当于创建了一个匿名内部线程</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Main run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?> 对象，通过调用该对象的 cancel(true) 方法就可以中断线程</span>Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> future <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ..</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>future<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="1-4-4-互斥同步"><a href="#1-4-4-互斥同步" class="headerlink" title="1.4.4 互斥同步"></a>1.4.4 互斥同步</h4><ol><li><p>概述</p><blockquote><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock</p></blockquote></li><li><p>synchronized</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. 同一个代码块</span><span class="token comment" spellcheck="true">// 只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    SynchronizedExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e1<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e1<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步，从输出结果可以看出，两个线程交叉执行</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    SynchronizedExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SynchronizedExample e2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e1<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e2<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 2. 同步一个方法</span><span class="token comment" spellcheck="true">// 和同步代码块一样，作用于同一个对象</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 3. 同步一个类</span><span class="token comment" spellcheck="true">// 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SynchronizedExample<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SynchronizedExample<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    SynchronizedExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SynchronizedExample e2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e1<span class="token punctuation">.</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e2<span class="token punctuation">.</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 4. 同步一个静态方法</span><span class="token comment" spellcheck="true">// 作用于整个类</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre></li><li><p>ReentrantLock</p><blockquote><p>java.util.concurrent（J.U.C）包中的锁</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 确保释放锁，从而避免发生死锁。</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LockExample lockExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LockExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> lockExample<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> lockExample<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>比较</p><table><thead><tr><th>项目</th><th>实现</th><th>性能</th><th>等待可中断</th><th>公平锁</th><th>锁绑定多个条件</th></tr></thead><tbody><tr><td>synchronized</td><td>JVM 实现</td><td>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，大致相同</td><td>synchronized 不能中断</td><td>synchronized 中的锁是非公平的</td><td></td></tr><tr><td>ReentrantLock</td><td>JDK 实现</td><td>大致相同</td><td>ReentrantLock 可中断</td><td>eentrantLock 默认情况下也是非公平的，但是也可以是公平</td><td>一个 ReentrantLock 可以同时绑定多个 Condition 对象</td></tr></tbody></table><p>解释</p><ul><li><p>等待可中断</p><blockquote><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情</p></blockquote></li><li><p>公平锁</p><blockquote><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</p></blockquote></li></ul></li><li><p>使用选择</p><blockquote><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized</p><p>是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持</p><p>并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放</p></blockquote></li></ol><h4 id="1-4-5-线程之间的协作"><a href="#1-4-5-线程之间的协作" class="headerlink" title="1.4.5 线程之间的协作"></a>1.4.5 线程之间的协作</h4><ol><li><p>概述</p><blockquote><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调</p></blockquote></li><li><p>join()</p><blockquote><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JoinExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> A a<span class="token punctuation">;</span>        <span class="token function">B</span><span class="token punctuation">(</span>A a<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        A a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        B b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    JoinExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JoinExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    example<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>wait() notify() notifyAll()</p><blockquote><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程</p><p>都属于 Object 的一部分，而不属于 Thread</p><p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException</p><p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁</p><p>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法</p><p>wait() 会释放锁，sleep() 不会</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WaitNotifyExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    WaitNotifyExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WaitNotifyExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>await() signal() signalAll()</p><blockquote><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程</p><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 Lock 来获取一个 Condition 对象</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AwaitSignalExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Condition condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    AwaitSignalExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AwaitSignalExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="1-4-6-线程状态"><a href="#1-4-6-线程状态" class="headerlink" title="1.4.6 线程状态"></a>1.4.6 线程状态</h4><ol><li><p>概述</p><blockquote><p>一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态</p></blockquote></li><li><p>新建（NEW）</p><blockquote><p>创建后尚未启动</p></blockquote></li><li><p>可运行（RUNABLE）</p><blockquote><p>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度</p></blockquote></li><li><p>阻塞（BLOCKED）</p><blockquote><p>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock</p></blockquote></li><li><p>无限期等待（WAITING）</p><blockquote><p>等待其它线程显式地唤醒</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock</p><p>而等待是主动的，通过调用 Object.wait() 等方法进入</p></blockquote><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></li><li><p>限期等待（TIMED_WAITING）</p><blockquote><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒</p><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述</p><p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态</p></blockquote><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></li><li><p>死亡（TERMINATED）</p><blockquote><p>可以是线程结束任务之后自己结束，或者产生了异常而结束</p></blockquote></li></ol><h4 id="1-4-7-J-U-C-AQS"><a href="#1-4-7-J-U-C-AQS" class="headerlink" title="1.4.7 J.U.C - AQS"></a>1.4.7 J.U.C - AQS</h4><ol><li><p>概述</p><blockquote><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心</p></blockquote></li><li><p>CountDownLatch</p><blockquote><p>用来控制一个或者多个线程等待多个线程</p><p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountdownLatchExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> totalThread <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>totalThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> totalThread<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"run.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>CyclicBarrier</p><blockquote><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的</p><p>线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障</p><p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">,</span> Runnable barrierAction<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parties <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parties <span class="token operator">=</span> parties<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> parties<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>barrierCommand <span class="token operator">=</span> barrierAction<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>parties<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> totalThread <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        CyclicBarrier cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span>totalThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> totalThread<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"before.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> BrokenBarrierException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"after.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>Semaphore</p><blockquote><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> clientCount <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> totalRequestCount <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span>clientCount<span class="token punctuation">)</span><span class="token punctuation">;</span>        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> totalRequestCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>semaphore<span class="token punctuation">.</span><span class="token function">availablePermits</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="1-4-8-J-U-C-其它组件"><a href="#1-4-8-J-U-C-其它组件" class="headerlink" title="1.4.8 J.U.C - 其它组件"></a>1.4.8 J.U.C - 其它组件</h4><ol><li><p>FutureTask</p><blockquote><p>Callable 可以有返回值，返回值通过 Future<V> 进行封装</V></p><p>FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future<V> 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值</V></p><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景</p><p>当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">RunnableFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RunnableFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Runnable</span><span class="token punctuation">,</span> Future<span class="token operator">&lt;</span>V<span class="token operator">></span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureTaskExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    result <span class="token operator">+=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread computeThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        computeThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread otherThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"other task is running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        otherThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>BlockingQueue</p><blockquote><p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置</p></blockquote><ul><li>FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li><li>优先级队列 ：PriorityBlockingQueue</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 BlockingQueue 实现生产者消费者问题</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProducerConsumer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"product"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"produce.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                String product <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"consume.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Producer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Consumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Producer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>ForkJoin</p><blockquote><p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForkJoinExample</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threshold <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> first<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> last<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ForkJoinExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>last <span class="token operator">=</span> last<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Integer <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first <span class="token operator">&lt;=</span> threshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 任务足够小则直接计算</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> first<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> last<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">+=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 拆分成小任务</span>            <span class="token keyword">int</span> middle <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            ForkJoinExample leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinExample</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>            ForkJoinExample rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinExample</span><span class="token punctuation">(</span>middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span>            leftTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            rightTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result <span class="token operator">=</span> leftTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> rightTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>    ForkJoinExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinExample</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ForkJoinPool forkJoinPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Future result <span class="token operator">=</span> forkJoinPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>example<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForkJoinPool</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span><span class="token comment" spellcheck="true">// ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率</span><span class="token comment" spellcheck="true">// 每个线程都维护了一个双端队列，用来存储需要执行的任务</span><span class="token comment" spellcheck="true">// 工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行</span><span class="token comment" spellcheck="true">// 窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争</span></code></pre></li></ol><h4 id="1-4-9-线程不安全示例"><a href="#1-4-9-线程不安全示例" class="headerlink" title="1.4.9 线程不安全示例"></a>1.4.9 线程不安全示例</h4><ul><li><p>概述</p><blockquote><p>多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致</p></blockquote></li><li><p>示例</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadUnsafeExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    ThreadUnsafeExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadUnsafeExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            example<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h4 id="1-4-10-Java-内存模型"><a href="#1-4-10-Java-内存模型" class="headerlink" title="1.4.10 Java 内存模型"></a>1.4.10 Java 内存模型</h4><ol><li><p>概述</p><blockquote><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果</p></blockquote></li><li><p>主内存与工作内存</p><blockquote><p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p><p>加入高速缓存带来了一个新的问题：缓存一致性</p><p>如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题</p><p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝</p><p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成</p></blockquote></li><li><p>内存间交互操作</p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>read</td><td>把一个变量的值从主内存传输到工作内存中</td></tr><tr><td>load</td><td>在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</td></tr><tr><td>use</td><td>把工作内存中一个变量的值传递给执行引擎</td></tr><tr><td>assign</td><td>把一个从执行引擎接收到的值赋给工作内存的变量</td></tr><tr><td>store</td><td>把工作内存的一个变量的值传送到主内存中</td></tr><tr><td>write</td><td>在 store 之后执行，把 store 得到的值放入主内存的变量中</td></tr><tr><td>lock</td><td>作用于主内存的变量</td></tr><tr><td>unlock</td><td></td></tr></tbody></table></li><li><p>内存模型三大特性</p><ol><li><p>原子性</p><blockquote><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性</p><p>但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性</p><p>AtomicInteger 能保证多个线程修改的原子性</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> AtomicInteger cnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cnt<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    AtomicExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只修改这条语句</span>    <span class="token keyword">final</span> CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            example<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicSynchronizedExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    AtomicSynchronizedExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicSynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            example<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>可见性</p><blockquote><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的</p><p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性</p></blockquote><p>实现可见性</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li><li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li></ul></li><li><p>有序性</p><blockquote><p>在本线程内观察，所有操作都是有序的</p><p>在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序</p><p>在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性</p><p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前</p><p>通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码</p></blockquote></li></ol></li><li><p>先行发生原则</p><blockquote><p>JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成</p></blockquote><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td>单一线程原则</td><td>在一个线程内，在程序前面的操作先行发生于后面的操作</td></tr><tr><td>管程锁定规则</td><td>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</td></tr><tr><td>volatile 变量规则</td><td>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作</td></tr><tr><td>线程启动规则</td><td>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作</td></tr><tr><td>线程加入规则</td><td>Thread 对象的结束先行发生于 join() 方法返回</td></tr><tr><td>线程中断规则</td><td>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生</td></tr><tr><td>对象终结规则</td><td>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始</td></tr><tr><td>传递性</td><td>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C</td></tr></tbody></table></li></ol><h4 id="1-4-11-线程安全"><a href="#1-4-11-线程安全" class="headerlink" title="1.4.11 线程安全"></a>1.4.11 线程安全</h4><ol><li><p>概述</p><blockquote><p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为</p></blockquote></li><li><p>不可变</p><blockquote><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施</p><p>只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态</p><p>多线程环境下，应当尽量使对象成为不可变，来满足线程安全</p></blockquote><p>类型</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImmutableExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> unmodifiableMap <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        unmodifiableMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常</span><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>互斥同步</p><blockquote><p>synchronized 和 ReentrantLock</p></blockquote></li><li><p>非阻塞同步</p><blockquote><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题</p><p>无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作</p><p>基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）</p><p>这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p></blockquote><ul><li><p>CAS</p><blockquote><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成</p><p>硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）</p><p>CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B</p><p>当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p></blockquote></li><li><p>AtomicInteger</p><blockquote><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 以下代码使用了 AtomicInteger 执行了自增的操作</span><span class="token keyword">private</span> AtomicInteger cnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cnt<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() </span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> var5<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> var5<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</span></code></pre></li><li><p>ABA</p><blockquote><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过</p><p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性</p><p>大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效</p></blockquote></li></ul></li><li><p>无同步方案</p><blockquote><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性</p></blockquote><ol><li><p>栈封闭</p><blockquote><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackClosedExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add100</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StackClosedExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackClosedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">add100</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">add100</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>线程本地存储（Thread Local Storage）</p><blockquote><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。<br>其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadLocal threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            threadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            threadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 为了理解 ThreadLocal，先看以下代码</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalExample1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadLocal threadLocal1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadLocal threadLocal2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            threadLocal1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            threadLocal2<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            threadLocal1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            threadLocal2<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象</span><span class="token comment" spellcheck="true">/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */</span>ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap threadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal->value 键值对插入到该 Map 中</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// get() 方法类似</span><span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadLocalMap<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            T result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争<br>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险</p></blockquote></li><li><p>可重入代码（Reentrant Code）</p><blockquote><p>也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等</p></blockquote></li></ol></li></ol><h4 id="1-4-12-锁优化"><a href="#1-4-12-锁优化" class="headerlink" title="1.4.12 锁优化"></a>1.4.12 锁优化</h4><ol><li><p>概述</p><blockquote><p>主要是指 JVM 对 synchronized 的优化</p></blockquote></li><li><p>自旋锁</p><blockquote><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免</p><p>在许多应用中，共享数据的锁定状态只会持续很短的一段时间</p><p>自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景</p><p>自适应的自旋锁，自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定</p></blockquote></li><li><p>锁消除</p><blockquote><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除</p><p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对于一些看起来没有加锁的代码，其实隐式的加了很多锁</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">concatString</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> String s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> s1 <span class="token operator">+</span> s2 <span class="token operator">+</span> s3<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作</span><span class="token comment" spellcheck="true">// 每个 append() 方法中都有一个同步块</span><span class="token comment" spellcheck="true">// 虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部</span><span class="token comment" spellcheck="true">// 也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">concatString</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> String s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>锁粗化</p><blockquote><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗</p><p>对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了</p></blockquote></li><li><p>轻量级锁</p><blockquote><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）</p><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销</p></blockquote></li><li><p>偏向锁</p><blockquote><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要</p></blockquote></li></ol><h4 id="1-4-13-小结"><a href="#1-4-13-小结" class="headerlink" title="1.4.13 小结"></a>1.4.13 小结</h4><ul><li>给线程起个有意义的名字，这样可以方便找 Bug。</li><li>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</li><li>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</li><li>使用 BlockingQueue 实现生产者消费者问题。</li><li>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</li><li>使用本地变量和不可变类来保证线程安全。</li><li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li></ul><h3 id="1-5-虚拟机"><a href="#1-5-虚拟机" class="headerlink" title="1.5 虚拟机"></a>1.5 虚拟机</h3><h4 id="1-5-1-运行时数据区域"><a href="#1-5-1-运行时数据区域" class="headerlink" title="1.5.1 运行时数据区域"></a>1.5.1 运行时数据区域</h4><ol><li><p>程序计数器</p><blockquote><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）</p></blockquote></li><li><p>Java 虚拟机栈</p><blockquote><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M</span>java <span class="token operator">-</span>Xss2M HackTheJava<span class="token comment" spellcheck="true">// 该区域可能抛出以下异常：</span>    <span class="token comment" spellcheck="true">// 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</span>    <span class="token comment" spellcheck="true">// 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</span></code></pre></li><li><p>本地方法栈</p><blockquote><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务</p></blockquote></li><li><p>堆</p><blockquote><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）</p><p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法，分为新生代和老年代</p><p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值</span>java <span class="token operator">-</span>Xms1M <span class="token operator">-</span>Xmx2M HackTheJava</code></pre></li><li><p>方法区</p><blockquote><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p><p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常</p><p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现</p><p>HotSpot 虚拟机把它当成永久代来进行垃圾回收</p><p>很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常</p><p>为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中</p><p><font color="red">方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式</font></p></blockquote></li><li><p>运行时常量池</p><blockquote><p>运行时常量池是方法区的一部分</p><p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域</p><p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()</p></blockquote></li><li><p>直接内存</p><blockquote><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作</p><p>这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据</p></blockquote></li></ol><h4 id="1-5-2-垃圾收集"><a href="#1-5-2-垃圾收集" class="headerlink" title="1.5.2 垃圾收集"></a>1.5.2 垃圾收集</h4><ol><li><p>概述</p><blockquote><p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收</p></blockquote></li><li><p>判断一个对象是否可被回收</p><ol><li><p>引用记数法</p><blockquote><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1</p><p>引用计数为 0 的对象可被回收</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Object instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Test b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span>instance <span class="token operator">=</span> b<span class="token punctuation">;</span>        b<span class="token punctuation">.</span>instance <span class="token operator">=</span> a<span class="token punctuation">;</span>        a <span class="token operator">=</span> null<span class="token punctuation">;</span>        b <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收</span></code></pre></li><li><p>可达性分析算法</p><blockquote><p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收</p></blockquote><ul><li>GC Roots 一般包含以下内容<ul><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈中 JNI 中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul></li></ul></li><li><p>方法区的回收</p><blockquote><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高</p><p>主要是对常量池的回收和对类的卸载</p><p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能</p></blockquote></li><li><p>类卸载条件</p><ul><li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法</li></ul></li><li><p>finalize()</p><blockquote><p>类似 C++ 的析构函数，用于关闭外部资源</p><p>但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用</p><p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救</p><p>自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法</p></blockquote></li></ol></li><li><p>引用类型</p><blockquote><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有</p></blockquote><ul><li><p>强引用</p><blockquote><p>被强引用关联的对象不会被回收</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 new 一个新对象的方式来创建强引用</span>Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>软引用</p><blockquote><p>被软引用关联的对象只有在内存不够的情况下才会被回</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 SoftReference 类来创建软引用</span>Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SoftReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 使对象只被软引用关联</span></code></pre></li><li><p>弱引用</p><blockquote><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 WeakReference 类来创建弱引用</span>Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>WeakReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> wf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre></li><li><p>虚引用</p><blockquote><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象</p><p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 PhantomReference 来创建虚引</span>Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PhantomReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre></li></ul></li><li><p>垃圾收集算法</p><ol><li><p>标记-清除</p><blockquote><p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记</p><p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块</p><p>回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块</p><p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表</p></blockquote><ul><li>不足<ul><li>标记和清除过程效率都不高</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存</li></ul></li></ul></li><li><p>标记-整理</p><blockquote><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p></blockquote><ul><li>优点:<ul><li>不会产生内存碎片</li></ul></li><li>不足:<ul><li>需要移动大量对象，处理效率比较低</li></ul></li></ul></li><li><p>复制</p><blockquote><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理</p><p>主要不足是只使用了内存的一半</p><p>在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor</p><p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%</p></blockquote></li><li><p>分代收集</p><blockquote><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法</p></blockquote><ul><li>一般将堆分为新生代和老年代<ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li></ul></li></ul></li></ol></li><li><p>垃圾收集器</p><ol><li><p>概述</p><ol><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ol></li><li><p>Serial 收集器</p><blockquote><p>Serial 翻译为串行，也就是说它以串行的方式执行</p><p>单线程的收集器，只会使用一个线程进行垃圾收集工作</p><p>优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率</p></blockquote></li><li><p>ParNew 收集器</p><blockquote><p>是 Serial 收集器的多线程版本</p><p>是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用</p></blockquote></li><li><p>Parallel Scavenge 收集器</p><blockquote><p>与 ParNew 一样是多线程收集器</p><p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器</p><p>这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降</p><p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p></blockquote></li><li><p>Serial Old 收集器</p><blockquote><p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul></blockquote></li><li><p>Parallel Old 收集器</p><blockquote><p>是 Parallel Scavenge 收集器的老年代版本</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器</p></blockquote></li><li><p>CMS 收集器</p><blockquote><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法</p></blockquote><ul><li>分为以下四个流程：<ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul></li><li>具有以下缺点：<ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul></li></ul></li><li><p>G1 收集器</p><blockquote><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收</p><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离</p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p></blockquote><ul><li>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：<ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul></li><li>具备如下特点：<ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒</li></ul></li></ul></li></ol></li></ol><h4 id="1-5-3-内存分配与回收策略"><a href="#1-5-3-内存分配与回收策略" class="headerlink" title="1.5.3 内存分配与回收策略"></a>1.5.3 内存分配与回收策略</h4><ol><li><p>Minor GC 和 Full GC</p><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul></li><li><p>内存分配策略</p><ol><li><p>对象优先在Eden分配</p><blockquote><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC</p></blockquote></li><li><p>大对象直接进入老年代</p><blockquote><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对</p><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制</p></blockquote></li><li><p>长期存活的对象进入老年代</p><blockquote><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中</p><p>-XX:MaxTenuringThreshold 用来定义年龄的阈值</p></blockquote></li><li><p>动态对象年龄判定</p><blockquote><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄</p></blockquote></li><li><p>空间分配担保</p><blockquote><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC</p></blockquote></li></ol></li><li><p>Full GC 的触发条件</p><blockquote><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件</p></blockquote><ul><li><p>调用 System.gc()</p><blockquote><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p></blockquote></li><li><p>老年代空间不足</p><blockquote><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p></blockquote></li><li><p>空间分配担保失败</p><blockquote><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC</p></blockquote></li><li><p>JDK 1.7 及以前的永久代空间不足</p><blockquote><p>JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC</p></blockquote></li><li><p>Concurrent Mode Failure</p><blockquote><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC</p></blockquote></li></ul></li></ol><h4 id="1-5-4-类加载机制"><a href="#1-5-4-类加载机制" class="headerlink" title="1.5.4 类加载机制"></a>1.5.4 类加载机制</h4><ol><li><p>概述</p><blockquote><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存</p></blockquote></li><li><p>类的生命周期</p><ul><li>加载（Loading）</li><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）</li><li>初始化（Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ul></li><li><p>类加载过程</p><blockquote><p>包含了加载、验证、准备、解析和初始化这 5 个阶段</p></blockquote><ul><li><p>加载（Loading）</p><blockquote><p>加载是类加载的一个阶段，注意不要混淆</p></blockquote><ul><li>加载过程完成以下三件事：<ul><li>通过类的完全限定名称获取定义该类的二进制字节流。</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li></ul></li><li>其中二进制字节流可以从以下方式中获取：<ul><li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li><li>从网络中获取，最典型的应用是 Applet。</li><li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li><li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li></ul></li></ul></li><li><p>验证（Verification）</p><blockquote><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p></blockquote></li><li><p>准备（Preparation）</p><blockquote><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存</p><p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre></li><li><p>解析（Resolution）</p><blockquote><p>将常量池的符号引用替换为直接引用的过程</p><p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定</p></blockquote></li><li><p>初始化（Initialization）</p><blockquote><p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p><p><clinit>() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问</clinit></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 给变量赋值可以正常编译通过</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这句编译器会提示“非法向前引用”</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 由于父类的 &lt;clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        A <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> B <span class="token operator">=</span> A<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Sub<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 2</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 虚拟机会保证一个类的 &lt;clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit>() 方法完毕。如果在一个类的 &lt;clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽</span></code></pre></li></ul></li><li><p>类初始化时机</p><ol><li><p>主动引用</p><blockquote><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）</p></blockquote><ul><li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</li></ul></li><li><p>被动引用</p><blockquote><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 通过子类引用父类的静态字段，不会导致子类初始化</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// value 字段在 SuperClass 中定义</span><span class="token comment" spellcheck="true">// 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法</span>SuperClass<span class="token punctuation">[</span><span class="token punctuation">]</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ConstClass<span class="token punctuation">.</span>HELLOWORLD<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>类与类加载器</p><blockquote><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间</p><p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true</p></blockquote></li><li><p>类加载器分类</p><ul><li>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；</li><li>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</li></ul><p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p><ul><li>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</JRE_HOME></li><li>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</JAVA_HOME></li><li>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</li></ul></li><li><p>双亲委派模型</p><blockquote><p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器</p><p>双亲委派模型（Parents Delegation Model）要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）</p></blockquote><ul><li><p>工作过程</p><blockquote><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载</p></blockquote></li><li><p>好处</p><blockquote><p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一</p></blockquote></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// The parent class loader for delegation</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ClassLoader parent<span class="token punctuation">;</span>    <span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// First, check if the class has already been loaded</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// ClassNotFoundException thrown if class not found</span>                    <span class="token comment" spellcheck="true">// from the non-null parent class loader</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// If still not found, then invoke findClass in order</span>                    <span class="token comment" spellcheck="true">// to find the class.</span>                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>自定义类加载器实现</p><blockquote><p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p><p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileSystemClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String rootDir<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">FileSystemClassLoader</span><span class="token punctuation">(</span>String rootDir<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>rootDir <span class="token operator">=</span> rootDir<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classData <span class="token operator">=</span> <span class="token function">getClassData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>classData <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> classData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> classData<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getClassData</span><span class="token punctuation">(</span>String className<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String path <span class="token operator">=</span> <span class="token function">classNameToPath</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            InputStream ins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>            ByteArrayOutputStream baos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> bufferSize <span class="token operator">=</span> <span class="token number">4096</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>bufferSize<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> bytesNumRead<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytesNumRead <span class="token operator">=</span> ins<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                baos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytesNumRead<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> baos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> String <span class="token function">classNameToPath</span><span class="token punctuation">(</span>String className<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> rootDir <span class="token operator">+</span> File<span class="token punctuation">.</span>separatorChar                <span class="token operator">+</span> className<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span> File<span class="token punctuation">.</span>separatorChar<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2. 数据库"></a>2. 数据库</h2><h3 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h3><h4 id="2-1-1-事务"><a href="#2-1-1-事务" class="headerlink" title="2.1.1 事务"></a>2.1.1 事务</h4><ol><li><p>概念</p><blockquote><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚</p></blockquote></li><li><p>ACID</p><ol><li><p>原子性</p><blockquote><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚</p><p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可</p></blockquote></li><li><p>一致性</p><blockquote><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的</p></blockquote></li><li><p>隔离性</p><blockquote><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的</p></blockquote></li><li><p>持久性</p><blockquote><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失</p><p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性</p><p>与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改</p></blockquote></li><li><p>小结</p><ol><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况。</li></ol></li></ol></li><li><p>AUTOCOMMIT</p><blockquote><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交</p></blockquote></li></ol><h4 id="2-1-2-并发一致性问题"><a href="#2-1-2-并发一致性问题" class="headerlink" title="2.1.2 并发一致性问题"></a>2.1.2 并发一致性问题</h4><ol><li><p>概述</p><blockquote><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题</p></blockquote></li><li><p>丢失修改</p><blockquote><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换</p></blockquote></li><li><p>读脏数据</p><blockquote><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据</p></blockquote></li><li><p>不可重复读</p><blockquote><p>不可重复读指在一个事务内多次读取同一数据集合</p></blockquote></li><li><p>幻影读</p><blockquote><p>幻读本质上也属于不可重复读的情况</p></blockquote></li><li><p>小结</p><blockquote><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题</p></blockquote></li></ol><h4 id="2-1-3-封锁"><a href="#2-1-3-封锁" class="headerlink" title="2.1.3 封锁"></a>2.1.3 封锁</h4><ol><li><p>封锁粒度</p><blockquote><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p></blockquote></li><li><p>封锁类型</p><ol><li><p>读写锁</p><ul><li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul></li><li><p>规定</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li></ul></li><li><p>意向锁</p><blockquote><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁</p></blockquote><ul><li>规定<ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul></li></ul></li></ol></li><li><p>封锁协议</p><ol><li><p>一级封锁协议</p><blockquote><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖</p></blockquote></li><li><p>二级封锁协议</p><blockquote><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p></blockquote></li><li><p>三级封锁协议</p><blockquote><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p></blockquote></li><li><p>两段锁协议</p><blockquote><p>加锁和解锁分为两个阶段进行</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">lock</span><span class="token operator">-</span>x<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">lock</span><span class="token operator">-</span>s<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">lock</span><span class="token operator">-</span>s<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>unlock<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>unlock<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>unlock<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- 但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</span><span class="token keyword">lock</span><span class="token operator">-</span>x<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>unlock<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">lock</span><span class="token operator">-</span>s<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>unlock<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">lock</span><span class="token operator">-</span>s<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>unlock<span class="token punctuation">(</span>C<span class="token punctuation">)</span></code></pre></li></ol></li><li><p>MySQL 隐式与显式锁定</p><blockquote><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- InnoDB 也可以使用特定的语句进行显示锁定</span><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">In</span> <span class="token keyword">SHARE MODE</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="2-1-4-隔离级别"><a href="#2-1-4-隔离级别" class="headerlink" title="2.1.4 隔离级别"></a>2.1.4 隔离级别</h4><ol><li><p>未提交读（READ UNCOMMITTED）</p><blockquote><p>事务中的修改，即使没有提交，对其它事务也是可见的</p></blockquote></li><li><p>提交读（READ COMMITTED）</p><blockquote><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的</p></blockquote></li><li><p>可重复读（REPEATABLE READ）</p><blockquote><p>保证在同一个事务中多次读取同一数据的结果是一样的</p></blockquote></li><li><p>可串行化（SERIALIZABLE）</p><blockquote><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p></blockquote></li></ol><h4 id="2-1-5-多版本并发控制"><a href="#2-1-5-多版本并发控制" class="headerlink" title="2.1.5 多版本并发控制"></a>2.1.5 多版本并发控制</h4><ol><li><p>基本思想</p><blockquote><p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照</p><p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读</p></blockquote></li><li><p>版本号</p><blockquote><p>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。<br>事务版本号 TRX_ID ：事务开始时的系统版本号。</p></blockquote></li><li><p>Undo 日志</p><blockquote><p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作</span>INSERT INTO <span class="token function">t</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token function">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>UPDATE t SET x<span class="token operator">=</span><span class="token string">"b"</span> WHERE id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>UPDATE t SET x<span class="token operator">=</span><span class="token string">"c"</span> WHERE id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></code></pre></li><li><p>ReadView</p><blockquote><p>MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, …}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX</p></blockquote><p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p><ul><li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</li><li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li><li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：<ul><li>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li><li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li></ul></li></ul><p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断</p></li><li><p>快照读与当前读</p><ol><li><p>快照读</p><p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span></code></pre></li><li><p>当前读</p><p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span class="token keyword">DELETE</span><span class="token punctuation">;</span></code></pre><p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> ? <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> ? <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></code></pre></li></ol></li></ol><h4 id="2-1-6-Next-Key-Locks"><a href="#2-1-6-Next-Key-Locks" class="headerlink" title="2.1.6 Next-Key Locks"></a>2.1.6 Next-Key Locks</h4><ol><li><p>概述</p><blockquote><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p><p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p></blockquote></li><li><p>Record Locks</p><blockquote><p>锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p></blockquote></li><li><p>Gap Locks</p><blockquote><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token number">c</span> <span class="token keyword">FROM</span> t <span class="token keyword">WHERE</span> <span class="token number">c</span> <span class="token operator">BETWEEN</span> <span class="token number">10</span> <span class="token operator">and</span> <span class="token number">20</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></code></pre></li><li><p>Next-Key Locks</p><blockquote><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token punctuation">(</span><span class="token operator">-</span>∞<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token operator">+</span>∞<span class="token punctuation">)</span></code></pre></li></ol><h4 id="2-1-7-关系数据库设计理论"><a href="#2-1-7-关系数据库设计理论" class="headerlink" title="2.1.7 关系数据库设计理论"></a>2.1.7 关系数据库设计理论</h4><ol><li><p>函数依赖</p><blockquote><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖</p></blockquote></li><li><p>异常</p><blockquote><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息</p></blockquote><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>95</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li><li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul></li><li><p>范式</p><blockquote><p>范式理论是为了解决以上提到四种异常。</p><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p></blockquote><ul><li><p>第一范式 (1NF)</p><blockquote><p>属性不可分</p></blockquote></li><li><p>第二范式 (2NF)</p><blockquote><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p></blockquote></li><li><p>分解前</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>95</td></tr></tbody></table><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据</p></li><li><p>分解后</p><p>关系-1</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><table><thead><tr><th>Sno</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>课程-2</td><td>95</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt; Grade</li></ul></li><li><p>第三范式 (3NF)</p><blockquote><p>非主属性不传递函数依赖于键码。</p></blockquote><p>上面的 关系-1 中存在以下传递函数依赖：</p><ul><li>Sno -&gt; Sdept -&gt; Mname</li></ul><p>可以进行以下分解：</p><p>关系-11</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td></tr></tbody></table><p>关系-12</p><table><thead><tr><th>Sdept</th><th>Mname</th></tr></thead><tbody><tr><td>学院-1</td><td>院长-1</td></tr><tr><td>学院-2</td><td>院长-2</td></tr></tbody></table></li></ul></li></ol><h4 id="2-1-8-ER-图"><a href="#2-1-8-ER-图" class="headerlink" title="2.1.8 ER 图"></a>2.1.8 ER 图</h4><ol><li><p>实体的三种联系</p><blockquote><p>包含一对一，一对多，多对多三种</p></blockquote><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li></ul></li><li><p>表示出现多次的关系</p><ul><li>一个实体在联系出现几次，就要用几条线连接</li><li>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系</li></ul></li><li><p>联系的多向性</p><blockquote><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系</p></blockquote></li><li><p>表示子类</p><blockquote><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上</p></blockquote></li></ol><h3 id="2-2-语法"><a href="#2-2-语法" class="headerlink" title="2.2 语法"></a>2.2 语法</h3><h4 id="2-2-1-基础"><a href="#2-2-1-基础" class="headerlink" title="2.2.1 基础"></a>2.2.1 基础</h4><ol><li><p>概述</p><blockquote><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式</p><p>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）</p><p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL</p><p>各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等</p><p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置</p></blockquote></li><li><p>注释</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">## 注释</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 注释</span><span class="token comment" spellcheck="true">/* 注释1   注释2 */</span></code></pre></li><li><p>创建与使用</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> test<span class="token punctuation">;</span><span class="token keyword">USE</span> test<span class="token punctuation">;</span></code></pre></li></ol><h4 id="2-2-2-表的基础操作"><a href="#2-2-2-表的基础操作" class="headerlink" title="2.2.2 表的基础操作"></a>2.2.2 表的基础操作</h4><ol><li><p>创建表</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mytable <span class="token punctuation">(</span>  <span class="token comment" spellcheck="true">-- int 类型，不为空，自增</span>  id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">-- int 类型，不可为空，默认值为 1，不为空</span>  col1 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">-- 变长字符串类型，最长为 45 个字符，可以为空</span>  col2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">-- 日期类型，可为空</span>  col3 <span class="token keyword">DATE</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">-- 设置主键为 id</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>修改表</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 添加列</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> mytable<span class="token keyword">ADD</span> col CHAR<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 删除列</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> mytable<span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> col<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 删除表</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">;</span></code></pre></li><li><p>插入</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 普通插入</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> mytable<span class="token punctuation">(</span>col1<span class="token punctuation">,</span> col2<span class="token punctuation">)</span><span class="token keyword">VALUES</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 插入检索出来的数据</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> mytable1<span class="token punctuation">(</span>col1<span class="token punctuation">,</span> col2<span class="token punctuation">)</span><span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2<span class="token keyword">FROM</span> mytable2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 将一个表的内容插入到一个新表</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> newtable <span class="token keyword">AS</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span></code></pre></li><li><p>更新</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> mytable<span class="token keyword">SET</span> col <span class="token operator">=</span> val<span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre></li><li><p>删除</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- TRUNCATE TABLE 可以清空表，也就是删除所有行</span><span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏;可以先用 SELECT 语句进行测试，防止错误删除</span></code></pre></li><li><p>查询</p><ol><li><p>DISTINCT</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 相同值只会出现一次;它作用于所有列，也就是说所有列的值都相同才算相同</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> col1<span class="token punctuation">,</span> col2<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span></code></pre></li><li><p>LIMIT</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</span><span class="token comment" spellcheck="true">-- 返回前 5 行</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">LIMIT</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 返回第 3 ~ 5 行</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">LIMIT</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>排序</p><ul><li>ASC ：升序（默认）</li><li>DESC ：降序</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 可以按多个列进行排序，并且为每个列指定不同的排序方式</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col1 <span class="token keyword">DESC</span><span class="token punctuation">,</span> col2 <span class="token keyword">ASC</span><span class="token punctuation">;</span></code></pre></li><li><p>过滤</p><blockquote><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽</p><p>因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> col <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span></code></pre><ul><li><p>下表显示了 WHERE 子句可用的操作符</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;&gt; !=</td><td>不等于</td></tr><tr><td>&lt;= !&gt;</td><td>小于等于</td></tr><tr><td>&gt;= !&lt;</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在两个值之间</td></tr><tr><td>IS NULL</td><td>为 NULL 值</td></tr></tbody></table></li><li><p>注意</p><ul><li>应该注意到，NULL 与 0、空字符串都不同。</li><li><strong>AND 和 OR</strong> 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</li><li><strong>IN</strong> 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</li><li><strong>NOT</strong> 操作符用于否定一个条件。</li></ul></li></ul></li></ol><h4 id="2-2-3-表的高级操作"><a href="#2-2-3-表的高级操作" class="headerlink" title="2.2.3 表的高级操作"></a>2.2.3 表的高级操作</h4><ol><li><p>通配符</p><blockquote><p>通配符也是用在过滤语句中，但它只能用于文本字段</p><p>不要滥用通配符，通配符位于开头处匹配会非常慢</p></blockquote><ul><li><p>类型</p><ul><li><strong>%</strong> 匹配 &gt;=0 个任意字符；</li><li><strong>_</strong> 匹配 ==1 个任意字符；</li><li><strong>[ ]</strong> 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</li></ul></li><li><p>示例</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 使用 Like 来进行通配符匹配</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> col <span class="token operator">LIKE</span> <span class="token string">'[^AB]%'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 不以 A 和 B 开头的任意文本</span></code></pre></li></ul></li><li><p>计算字段</p><blockquote><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式</span><span class="token keyword">SELECT</span> col1 <span class="token operator">*</span> col2 <span class="token keyword">AS</span> alias<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- CONCAT() 用于连接两个字段；许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格</span><span class="token keyword">SELECT</span> CONCAT<span class="token punctuation">(</span>TRIM<span class="token punctuation">(</span>col1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> TRIM<span class="token punctuation">(</span>col2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> concat_col<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span></code></pre></li><li><p>函数</p><ol><li><p>概述</p><blockquote><p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数</p></blockquote></li><li><p>汇总</p><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值</td></tr><tr><td>COUNT()</td><td>返回某列的行数</td></tr><tr><td>MAX()</td><td>返回某列的最大值</td></tr><tr><td>MIN()</td><td>返回某列的最小值</td></tr><tr><td>SUM()</td><td>返回某列值之和</td></tr></tbody></table><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- AVG() 会忽略 NULL 行。</span><span class="token comment" spellcheck="true">-- 使用 DISTINCT 可以汇总不同的值。</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> col1<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_col<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span></code></pre></li><li><p>文本处理</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>LEFT()</td><td>左边的字符</td></tr><tr><td>RIGHT()</td><td>右边的字符</td></tr><tr><td>LOWER()</td><td>转换为小写字符</td></tr><tr><td>UPPER()</td><td>转换为大写字符</td></tr><tr><td>LTRIM()</td><td>去除左边的空格</td></tr><tr><td>RTRIM()</td><td>去除右边的空格</td></tr><tr><td>LENGTH()</td><td>长度</td></tr><tr><td>SOUNDEX()</td><td>转换为语音值</td></tr></tbody></table><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> SOUNDEX<span class="token punctuation">(</span>col1<span class="token punctuation">)</span> <span class="token operator">=</span> SOUNDEX<span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span></code></pre></li><li><p>日期和时间处理</p><ul><li>日期格式：YYYY-MM-DD</li><li>时间格式：HH:<zero-width space>MM:SS</zero-width></li></ul><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>ADDDATE()</td><td>增加一个日期（天、周等）</td></tr><tr><td>ADDTIME()</td><td>增加一个时间（时、分等）</td></tr><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>DATE()</td><td>返回日期时间的日期部分</td></tr><tr><td>DATEDIFF()</td><td>计算两个日期之差</td></tr><tr><td>DATE_ADD()</td><td>高度灵活的日期运算函数</td></tr><tr><td>DATE_FORMAT()</td><td>返回一个格式化的日期或时间串</td></tr><tr><td>DAY()</td><td>返回一个日期的天数部分</td></tr><tr><td>DAYOFWEEK()</td><td>对于一个日期，返回对应的星期几</td></tr><tr><td>HOUR()</td><td>返回一个时间的小时部分</td></tr><tr><td>MINUTE()</td><td>返回一个时间的分钟部分</td></tr><tr><td>MONTH()</td><td>返回一个日期的月份部分</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>SECOND()</td><td>返回一个时间的秒部分</td></tr><tr><td>TIME()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>YEAR()</td><td>返回一个日期的年份部分</td></tr></tbody></table><pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>数值处理</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SIN()</td><td>正弦</td></tr><tr><td>COS()</td><td>余弦</td></tr><tr><td>TAN()</td><td>正切</td></tr><tr><td>ABS()</td><td>绝对值</td></tr><tr><td>SQRT()</td><td>平方根</td></tr><tr><td>MOD()</td><td>余数</td></tr><tr><td>EXP()</td><td>指数</td></tr><tr><td>PI()</td><td>圆周率</td></tr><tr><td>RAND()</td><td>随机数</td></tr></tbody></table></li></ol></li><li><p>分组</p><blockquote><p>把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</span><span class="token keyword">SELECT</span> col<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num<span class="token keyword">FROM</span> mytable<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> col<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</span><span class="token keyword">SELECT</span> col<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num<span class="token keyword">FROM</span> mytable<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> col<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> num<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</span><span class="token keyword">SELECT</span> col<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num<span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> col <span class="token operator">></span> <span class="token number">2</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> col<span class="token keyword">HAVING</span> num <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre><p>分组规定</p><ul><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型</li></ul></li><li><p>子查询</p><blockquote><p>子查询中只能返回一个字段的数据</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 可以将子查询的结果作为 WHRER 语句的过滤条件：</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable1<span class="token keyword">WHERE</span> col1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> col2               <span class="token keyword">FROM</span> mytable2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次</span><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>                   <span class="token keyword">FROM</span> Orders                   <span class="token keyword">WHERE</span> Orders<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> Customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">)</span>                   <span class="token keyword">AS</span> orders_num<span class="token keyword">FROM</span> Customers<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> cust_name<span class="token punctuation">;</span></code></pre></li><li><p>连接</p><ol><li><p>概述</p><blockquote><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE</p><p>连接可以替换子查询，并且比子查询的效率一般会更快</p><p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表</p></blockquote></li><li><p>内连接</p><blockquote><p>内连接又称等值连接，使用 INNER JOIN 关键字</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> A<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token keyword">FROM</span> tablea <span class="token keyword">AS</span> A <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> tableb <span class="token keyword">AS</span> B<span class="token keyword">ON</span> A<span class="token punctuation">.</span><span class="token keyword">key</span> <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token keyword">key</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</span><span class="token keyword">SELECT</span> A<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token keyword">FROM</span> tablea <span class="token keyword">AS</span> A<span class="token punctuation">,</span> tableb <span class="token keyword">AS</span> B<span class="token keyword">WHERE</span> A<span class="token punctuation">.</span><span class="token keyword">key</span> <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token keyword">key</span><span class="token punctuation">;</span></code></pre></li><li><p>自连接</p><blockquote><p>自连接可以看成内连接的一种，只是连接的表是自身而已</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</span><span class="token comment" spellcheck="true">-- 子查询版本</span><span class="token keyword">SELECT</span> name<span class="token keyword">FROM</span> employee<span class="token keyword">WHERE</span> department <span class="token operator">=</span> <span class="token punctuation">(</span>      <span class="token keyword">SELECT</span> department      <span class="token keyword">FROM</span> employee      <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">"Jim"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 自连接版本</span><span class="token keyword">SELECT</span> <span class="token number">e1</span><span class="token punctuation">.</span>name<span class="token keyword">FROM</span> employee <span class="token keyword">AS</span> <span class="token number">e1</span> <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> employee <span class="token keyword">AS</span> <span class="token number">e2</span><span class="token keyword">ON</span> <span class="token number">e1</span><span class="token punctuation">.</span>department <span class="token operator">=</span> <span class="token number">e2</span><span class="token punctuation">.</span>department      <span class="token operator">AND</span> <span class="token number">e2</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Jim"</span><span class="token punctuation">;</span></code></pre></li><li><p>自然连接</p><blockquote><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个</p><p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> A<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token keyword">FROM</span> tablea <span class="token keyword">AS</span> A <span class="token keyword">NATURAL</span> <span class="token keyword">JOIN</span> tableb <span class="token keyword">AS</span> B<span class="token punctuation">;</span></code></pre></li><li><p>外连接</p><blockquote><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 检索所有顾客的订单信息，包括还没有订单信息的顾客</span><span class="token keyword">SELECT</span> Customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span> Customer<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> Orders<span class="token punctuation">.</span>order_id<span class="token keyword">FROM</span> Customers <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> Orders<span class="token keyword">ON</span> Customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> Orders<span class="token punctuation">.</span>cust_id<span class="token punctuation">;</span></code></pre><p>customers 表：</p><table><thead><tr><th>cust_id</th><th>cust_name</th></tr></thead><tbody><tr><td>1</td><td>a</td></tr><tr><td>2</td><td>b</td></tr><tr><td>3</td><td>c</td></tr></tbody></table><p>orders 表：</p><table><thead><tr><th>order_id</th><th>cust_id</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td></tr><tr><td>3</td><td>3</td></tr><tr><td>4</td><td>3</td></tr></tbody></table><p>结果：</p><table><thead><tr><th>cust_id</th><th>cust_name</th><th>order_id</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>1</td></tr><tr><td>1</td><td>a</td><td>2</td></tr><tr><td>3</td><td>c</td><td>3</td></tr><tr><td>3</td><td>c</td><td>4</td></tr><tr><td>2</td><td>b</td><td>Null</td></tr></tbody></table></li></ol></li><li><p>组合查询</p><blockquote><p>使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行</p><p>每个查询必须包含相同的列、表达式和聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p><p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> col<span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> col <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">UNION</span><span class="token keyword">SELECT</span> col<span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> col <span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="2-2-4-其他"><a href="#2-2-4-其他" class="headerlink" title="2.2.4 其他"></a>2.2.4 其他</h4><ol><li><p>视图</p><blockquote><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p><p>对视图的操作和对普通表的操作一样。</p></blockquote><p>优势</p><ul><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示</li></ul><p>示例</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> myview <span class="token keyword">AS</span><span class="token keyword">SELECT</span> Concat<span class="token punctuation">(</span>col1<span class="token punctuation">,</span> col2<span class="token punctuation">)</span> <span class="token keyword">AS</span> concat_col<span class="token punctuation">,</span> col3<span class="token operator">*</span>col4 <span class="token keyword">AS</span> compute_col<span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> col5 <span class="token operator">=</span> val<span class="token punctuation">;</span></code></pre></li><li><p>存储过程</p><blockquote><p>存储过程可以看成是对一系列 SQL 操作的批处理</p><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误</p><p>包含 in、out 和 inout 三种参数。</p><p>给变量赋值都需要用 select into 语句。</p><p>每次只能给一个变量赋值，不支持集合的操作。</p></blockquote><p>优势</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>示例</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">delimiter</span> <span class="token comment" spellcheck="true">//</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> myprocedure<span class="token punctuation">(</span> <span class="token keyword">out</span> ret <span class="token keyword">int</span> <span class="token punctuation">)</span>    <span class="token keyword">begin</span>        <span class="token keyword">declare</span> y <span class="token keyword">int</span><span class="token punctuation">;</span>        <span class="token keyword">select</span> <span class="token function">sum</span><span class="token punctuation">(</span>col1<span class="token punctuation">)</span>        <span class="token keyword">from</span> mytable        <span class="token keyword">into</span> y<span class="token punctuation">;</span>        <span class="token keyword">select</span> y<span class="token operator">*</span>y <span class="token keyword">into</span> ret<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token comment" spellcheck="true">//</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token keyword">call</span> myprocedure<span class="token punctuation">(</span><span class="token variable">@ret</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token variable">@ret</span><span class="token punctuation">;</span></code></pre></li><li><p>游标</p><blockquote><p>在存储过程中使用游标可以对一个结果集进行移动遍历</p><p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改</p></blockquote><p>步骤</p><ul><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ul><p>示例</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">delimiter</span> <span class="token comment" spellcheck="true">//</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> myprocedure<span class="token punctuation">(</span><span class="token keyword">out</span> ret <span class="token keyword">int</span><span class="token punctuation">)</span>    <span class="token keyword">begin</span>        <span class="token keyword">declare</span> done <span class="token keyword">boolean</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">declare</span> mycursor <span class="token keyword">cursor</span> <span class="token keyword">for</span>        <span class="token keyword">select</span> col1 <span class="token keyword">from</span> mytable<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true"># 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1</span>        <span class="token keyword">declare</span> <span class="token keyword">continue</span> <span class="token keyword">handler</span> <span class="token keyword">for</span> sqlstate <span class="token string">'02000'</span> <span class="token keyword">set</span> done <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">open</span> mycursor<span class="token punctuation">;</span>        repeat            <span class="token keyword">fetch</span> mycursor <span class="token keyword">into</span> ret<span class="token punctuation">;</span>            <span class="token keyword">select</span> ret<span class="token punctuation">;</span>        until done <span class="token keyword">end</span> repeat<span class="token punctuation">;</span>        <span class="token keyword">close</span> mycursor<span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token comment" spellcheck="true">//</span> <span class="token keyword">delimiter</span> <span class="token punctuation">;</span></code></pre></li><li><p>触发器</p><blockquote><p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDAT</p><p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字</p><p>BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中</p><p>INSERT 触发器包含一个名为 NEW 的虚拟表</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</span><span class="token comment" spellcheck="true">-- UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</span><span class="token comment" spellcheck="true">-- MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</span><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> mytrigger <span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> mytable<span class="token keyword">FOR EACH ROW</span> <span class="token keyword">SELECT</span> NEW<span class="token punctuation">.</span>col <span class="token keyword">into</span> <span class="token variable">@result</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token variable">@result</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 获取结果</span></code></pre></li><li><p>事务管理</p><ul><li><p>概述</p><blockquote><p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句</p><p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交</p><p>出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交</p><p>设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的</p><p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点</p></blockquote></li><li><p>术语</p><ul><li>事务（transaction）指一组 SQL 语句；</li><li>回退（rollback）指撤销指定 SQL 语句的过程；</li><li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）</li></ul></li><li><p>示例</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token comment" spellcheck="true">// ...</span><span class="token keyword">SAVEPOINT</span> delete1<span class="token comment" spellcheck="true">// ...</span><span class="token keyword">ROLLBACK</span> <span class="token keyword">TO</span> delete1<span class="token comment" spellcheck="true">// ...</span><span class="token keyword">COMMIT</span></code></pre></li></ul></li><li><p>字符集</p><ul><li><p>术语</p><ul><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ul></li><li><p>示例</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 除了给表指定字符集和校对外，也可以给列指定</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">(</span>col <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER SET</span> latin <span class="token keyword">COLLATE</span> latin1_general_ci <span class="token punctuation">)</span><span class="token keyword">DEFAULT</span> <span class="token keyword">CHARACTER SET</span> hebrew <span class="token keyword">COLLATE</span> hebrew_general_ci<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 可以在排序、分组时指定校对</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> mytable<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col <span class="token keyword">COLLATE</span> latin1_general_ci<span class="token punctuation">;</span></code></pre></li></ul></li><li><p>权限管理</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- MySQL 的账户信息保存在 mysql 这个数据库中</span><span class="token keyword">USE</span> mysql<span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token keyword">user</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 创建账户</span><span class="token comment" spellcheck="true">-- 新创建的账户没有任何权限</span><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> myuser IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'mypassword'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 修改账户名</span><span class="token keyword">RENAME</span> <span class="token keyword">USER</span> myuser <span class="token keyword">TO</span> newuser<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 删除账户</span><span class="token keyword">DROP</span> <span class="token keyword">USER</span> myuser<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 查看权限</span><span class="token keyword">SHOW</span> GRANTS <span class="token keyword">FOR</span> myuser<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 授予权限</span><span class="token comment" spellcheck="true">-- 账户用 username@host 的形式定义，username@% 使用的是默认主机名</span><span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span><span class="token punctuation">,</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> mydatabase<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> myuser<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 删除权限</span><span class="token comment" spellcheck="true">-- GRANT 和 REVOKE 可在几个层次上控制访问权限：</span>    <span class="token comment" spellcheck="true">-- 整个服务器，使用 GRANT ALL 和 REVOKE ALL；</span>    <span class="token comment" spellcheck="true">-- 整个数据库，使用 ON database.*；</span>    <span class="token comment" spellcheck="true">-- 特定的表，使用 ON database.table；</span>    <span class="token comment" spellcheck="true">-- 特定的列；</span>    <span class="token comment" spellcheck="true">-- 特定的存储过程。</span><span class="token keyword">REVOKE</span> <span class="token keyword">SELECT</span><span class="token punctuation">,</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> mydatabase<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> myuser<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 更改密码</span><span class="token comment" spellcheck="true">-- 必须使用 Password() 函数进行加密。</span><span class="token keyword">SET</span> PASSWROD <span class="token keyword">FOR</span> myuser <span class="token operator">=</span> Password<span class="token punctuation">(</span><span class="token string">'new_password'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><h3 id="2-3-练习"><a href="#2-3-练习" class="headerlink" title="2.3 练习"></a>2.3 练习</h3><ol><li><p>Big Countries(595)</p><ol><li><p>题述</p><table><thead><tr><th>name</th><th>continent</th><th>area</th><th>population</th><th>gdp</th></tr></thead><tbody><tr><td>Afghanistan</td><td>Asia</td><td>652230</td><td>25500100</td><td>20343000</td></tr><tr><td>Albania</td><td>Europe</td><td>28748</td><td>2831741</td><td>12960000</td></tr><tr><td>Algeria</td><td>Africa</td><td>2381741</td><td>37100000</td><td>188681000</td></tr><tr><td>Andorra</td><td>Europe</td><td>468</td><td>78115</td><td>3712000</td></tr><tr><td>Angola</td><td>Africa</td><td>1246700</td><td>20609294</td><td>100990000</td></tr></tbody></table><p>查找面积超过 3,000,000 或者人口数超过 25,000,000 的国家</p><table><thead><tr><th>name</th><th>population</th><th>area</th></tr></thead><tbody><tr><td>Afghanistan</td><td>25500100</td><td>652230</td></tr><tr><td>Algeria</td><td>37100000</td><td>2381741</td></tr></tbody></table></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span>    population<span class="token punctuation">,</span>    area<span class="token keyword">FROM</span>    World<span class="token keyword">WHERE</span>    area <span class="token operator">></span> <span class="token number">3000000</span>    <span class="token operator">OR</span> population <span class="token operator">></span> <span class="token number">25000000</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- SQL Schema 用于在本地环境下创建表结构并导入数据，从而方便在本地环境调试</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> World<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> World <span class="token punctuation">(</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> continent <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> area <span class="token keyword">INT</span><span class="token punctuation">,</span> population <span class="token keyword">INT</span><span class="token punctuation">,</span> gdp <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> World <span class="token punctuation">(</span> NAME<span class="token punctuation">,</span> continent<span class="token punctuation">,</span> area<span class="token punctuation">,</span> population<span class="token punctuation">,</span> gdp <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token string">'Afghanistan'</span><span class="token punctuation">,</span> <span class="token string">'Asia'</span><span class="token punctuation">,</span> <span class="token string">'652230'</span><span class="token punctuation">,</span> <span class="token string">'25500100'</span><span class="token punctuation">,</span> <span class="token string">'203430000'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'Albania'</span><span class="token punctuation">,</span> <span class="token string">'Europe'</span><span class="token punctuation">,</span> <span class="token string">'28748'</span><span class="token punctuation">,</span> <span class="token string">'2831741'</span><span class="token punctuation">,</span> <span class="token string">'129600000'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'Algeria'</span><span class="token punctuation">,</span> <span class="token string">'Africa'</span><span class="token punctuation">,</span> <span class="token string">'2381741'</span><span class="token punctuation">,</span> <span class="token string">'37100000'</span><span class="token punctuation">,</span> <span class="token string">'1886810000'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'Andorra'</span><span class="token punctuation">,</span> <span class="token string">'Europe'</span><span class="token punctuation">,</span> <span class="token string">'468'</span><span class="token punctuation">,</span> <span class="token string">'78115'</span><span class="token punctuation">,</span> <span class="token string">'37120000'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'Angola'</span><span class="token punctuation">,</span> <span class="token string">'Africa'</span><span class="token punctuation">,</span> <span class="token string">'1246700'</span><span class="token punctuation">,</span> <span class="token string">'20609294'</span><span class="token punctuation">,</span> <span class="token string">'1009900000'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>Swap Salary(627)</p><ol><li><p>题述</p><table><thead><tr><th>id</th><th>name</th><th>sex</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>m</td><td>2500</td></tr><tr><td>2</td><td>B</td><td>f</td><td>1500</td></tr><tr><td>3</td><td>C</td><td>m</td><td>5500</td></tr><tr><td>4</td><td>D</td><td>f</td><td>500</td></tr></tbody></table><p>只用一个 SQL 查询，将 sex 字段反转</p><table><thead><tr><th>id</th><th>name</th><th>sex</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>f</td><td>2500</td></tr><tr><td>2</td><td>B</td><td>m</td><td>1500</td></tr><tr><td>3</td><td>C</td><td>f</td><td>5500</td></tr><tr><td>4</td><td>D</td><td>m</td><td>500</td></tr></tbody></table></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 两个相等的数异或的结果为 0，而 0 与任何一个数异或的结果为这个数。</span><span class="token comment" spellcheck="true">-- sex 字段只有两个取值：'f' 和 'm'，并且有以下规律：</span>    <span class="token comment" spellcheck="true">-- 'f' ^ ('m' ^ 'f') = 'm' ^ ('f' ^ 'f') = 'm'</span>    <span class="token comment" spellcheck="true">-- 'm' ^ ('m' ^ 'f') = 'f' ^ ('m' ^ 'm') = 'f'</span><span class="token comment" spellcheck="true">-- 因此将 sex 字段和 'm' ^ 'f' 进行异或操作，最后就能反转 sex 字段</span><span class="token keyword">UPDATE</span> salary<span class="token keyword">SET</span> sex <span class="token operator">=</span> CHAR <span class="token punctuation">(</span> ASCII<span class="token punctuation">(</span>sex<span class="token punctuation">)</span> <span class="token operator">^</span> ASCII<span class="token punctuation">(</span> <span class="token string">'m'</span> <span class="token punctuation">)</span> <span class="token operator">^</span> ASCII<span class="token punctuation">(</span> <span class="token string">'f'</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- SQL Schema</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> salary<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> salary <span class="token punctuation">(</span> id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> sex CHAR <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> salary <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> salary <span class="token punctuation">(</span> id<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> sex<span class="token punctuation">,</span> salary <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token string">'2500'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'1500'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token string">'5500'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'500'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>Not Boring Movies(620)</p><ol><li><p>题述</p><table><thead><tr><th>id</th><th>movie</th><th>description</th><th>rating</th></tr></thead><tbody><tr><td>1</td><td>War</td><td>great 3D</td><td>8.9</td></tr><tr><td>2</td><td>Science</td><td>fiction</td><td>8.5</td></tr><tr><td>3</td><td>irish</td><td>boring</td><td>6.2</td></tr><tr><td>4</td><td>Ice song</td><td>Fantacy</td><td>8.6</td></tr><tr><td>5</td><td>House card</td><td>Interesting</td><td>9.1</td></tr></tbody></table><p>查找 id 为奇数，并且 description 不是 boring 的电影，按 rating 降序</p><table><thead><tr><th>id</th><th>movie</th><th>description</th><th>rating</th></tr></thead><tbody><tr><td>5</td><td>House card</td><td>Interesting</td><td>9.1</td></tr><tr><td>1</td><td>War</td><td>great 3D</td><td>8.9</td></tr></tbody></table></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    <span class="token operator">*</span><span class="token keyword">FROM</span>    cinema<span class="token keyword">WHERE</span>    id <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>    <span class="token operator">AND</span> description <span class="token operator">!=</span> <span class="token string">'boring'</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span>    rating <span class="token keyword">DESC</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- SQL Schema</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> cinema<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> cinema <span class="token punctuation">(</span> id <span class="token keyword">INT</span><span class="token punctuation">,</span> movie <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> description <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> rating <span class="token keyword">FLOAT</span> <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> cinema <span class="token punctuation">(</span> id<span class="token punctuation">,</span> movie<span class="token punctuation">,</span> description<span class="token punctuation">,</span> rating <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'War'</span><span class="token punctuation">,</span> <span class="token string">'great 3D'</span><span class="token punctuation">,</span> <span class="token number">8.9</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Science'</span><span class="token punctuation">,</span> <span class="token string">'fiction'</span><span class="token punctuation">,</span> <span class="token number">8.5</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'irish'</span><span class="token punctuation">,</span> <span class="token string">'boring'</span><span class="token punctuation">,</span> <span class="token number">6.2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'Ice song'</span><span class="token punctuation">,</span> <span class="token string">'Fantacy'</span><span class="token punctuation">,</span> <span class="token number">8.6</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'House card'</span><span class="token punctuation">,</span> <span class="token string">'Interesting'</span><span class="token punctuation">,</span> <span class="token number">9.1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>Classes More Than 5 Students(596)</p><ol><li><p>题述</p><table><thead><tr><th>student</th><th>class</th></tr></thead><tbody><tr><td>A</td><td>Math</td></tr><tr><td>B</td><td>English</td></tr><tr><td>C</td><td>Math</td></tr><tr><td>D</td><td>Biology</td></tr><tr><td>E</td><td>Math</td></tr><tr><td>F</td><td>Computer</td></tr><tr><td>G</td><td>Math</td></tr><tr><td>H</td><td>Math</td></tr><tr><td>I</td><td>Math</td></tr></tbody></table><p>查找有五名及以上 student 的 class</p><table><thead><tr><th>class</th></tr></thead><tbody><tr><td>Math</td></tr></tbody></table></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 对 class 列进行分组之后，再使用 count 汇总函数统计每个分组的记录个数，之后使用 HAVING 进行筛选。HAVING 针对分组进行筛选，而 WHERE 针对每个记录（行）进行筛选</span><span class="token keyword">SELECT</span>    class<span class="token keyword">FROM</span>    courses<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>    class<span class="token keyword">HAVING</span>    <span class="token function">count</span><span class="token punctuation">(</span> <span class="token keyword">DISTINCT</span> student <span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- SQL Schema</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> courses<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> courses <span class="token punctuation">(</span> student <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> class <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> courses <span class="token punctuation">(</span> student<span class="token punctuation">,</span> class <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'English'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'Biology'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'F'</span><span class="token punctuation">,</span> <span class="token string">'Computer'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'G'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'H'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'I'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>Duplicate Emails(182)</p><ol><li><p>题述</p><table><thead><tr><th>Id</th><th>Email</th></tr></thead><tbody><tr><td>1</td><td><a href="mailto:&#97;&#64;&#x62;&#46;&#x63;&#111;&#x6d;">&#97;&#64;&#x62;&#46;&#x63;&#111;&#x6d;</a></td></tr><tr><td>2</td><td><a href="mailto:&#99;&#x40;&#100;&#46;&#99;&#x6f;&#x6d;">&#99;&#x40;&#100;&#46;&#99;&#x6f;&#x6d;</a></td></tr><tr><td>3</td><td><a href="mailto:&#97;&#x40;&#98;&#x2e;&#99;&#111;&#109;">&#97;&#x40;&#98;&#x2e;&#99;&#111;&#109;</a></td></tr></tbody></table><p>查找重复的邮件地址</p><table><thead><tr><th>Email</th></tr></thead><tbody><tr><td><a href="mailto:&#97;&#x40;&#98;&#x2e;&#x63;&#111;&#109;">&#97;&#x40;&#98;&#x2e;&#x63;&#111;&#109;</a></td></tr></tbody></table></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 对 Email 进行分组，如果并使用 COUNT 进行计数统计，结果大于等于 2 的表示 Email 重复</span><span class="token keyword">SELECT</span>    Email<span class="token keyword">FROM</span>    Person<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>    Email<span class="token keyword">HAVING</span>    <span class="token function">COUNT</span><span class="token punctuation">(</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- SQL Schema</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Person<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Person <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> Email <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Person <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> Email <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'a@b.com'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'c@d.com'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'a@b.com'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>Delete Duplicate Emails(196)</p><ol><li><p>题述</p><table><thead><tr><th>Id</th><th>Email</th></tr></thead><tbody><tr><td>1</td><td><a href="mailto:&#x6a;&#111;&#104;&#110;&#64;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;">&#x6a;&#111;&#104;&#110;&#64;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;</a></td></tr><tr><td>2</td><td><a href="mailto:&#98;&#111;&#98;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#109;">&#98;&#111;&#98;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#109;</a></td></tr><tr><td>3</td><td><a href="mailto:&#106;&#x6f;&#104;&#110;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#x6d;">&#106;&#x6f;&#104;&#110;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#x6d;</a></td></tr></tbody></table><p>删除重复的邮件地址</p><table><thead><tr><th>Id</th><th>Email</th></tr></thead><tbody><tr><td>1</td><td><a href="mailto:&#106;&#111;&#x68;&#x6e;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#x6d;">&#106;&#111;&#x68;&#x6e;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#x6d;</a></td></tr><tr><td>2</td><td><a href="mailto:&#x62;&#x6f;&#98;&#64;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d;">&#x62;&#x6f;&#98;&#64;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d;</a></td></tr></tbody></table></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 只保留相同 Email 中 Id 最小的那一个，然后删除其它的</span><span class="token comment" spellcheck="true">-- 连接查询</span><span class="token keyword">DELETE</span> p1<span class="token keyword">FROM</span>    Person p1<span class="token punctuation">,</span>    Person p2<span class="token keyword">WHERE</span>    p1<span class="token punctuation">.</span>Email <span class="token operator">=</span> p2<span class="token punctuation">.</span>Email    <span class="token operator">AND</span> p1<span class="token punctuation">.</span>Id <span class="token operator">></span> p2<span class="token punctuation">.</span>Id<span class="token comment" spellcheck="true">-- 子查询</span><span class="token keyword">DELETE</span><span class="token keyword">FROM</span>    Person<span class="token keyword">WHERE</span>    id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span>        <span class="token keyword">SELECT</span> id         <span class="token keyword">FROM</span> <span class="token punctuation">(</span>             <span class="token keyword">SELECT</span> <span class="token function">min</span><span class="token punctuation">(</span> id <span class="token punctuation">)</span> <span class="token keyword">AS</span> id             <span class="token keyword">FROM</span> Person            <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> email        <span class="token punctuation">)</span> <span class="token keyword">AS</span> m    <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 额外嵌套了一个 SELECT 语句，如果不这么做，会出现错误：You can't specify target table 'Person' for update in FROM clause</span></code></pre></li></ol></li><li><p>Combine Two Tables(175)</p><ol><li><p>题述</p><p>Person 表</p><table><thead><tr><th>Column Name</th><th>Type</th></tr></thead><tbody><tr><td>PersonId</td><td>int</td></tr><tr><td>FirstName</td><td>varchar</td></tr><tr><td>LastName</td><td>varchar</td></tr></tbody></table><p>Address 表</p><table><thead><tr><th>Column Name</th><th>Type</th></tr></thead><tbody><tr><td>AddressId</td><td>int</td></tr><tr><td>PersonId</td><td>int</td></tr><tr><td>City</td><td>varchar</td></tr><tr><td>State</td><td>varchar</td></tr></tbody></table></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 查找 FirstName, LastName, City, State 数据，而不管一个用户有没有填地址信息</span><span class="token comment" spellcheck="true">-- 涉及到 Person 和 Address 两个表，在对这两个表执行连接操作时，因为要保留 Person 表中的信息，即使在 Address 表中没有关联的信息也要保留。此时可以用左外连接，将 Person 表放在 LEFT JOIN 的左边</span><span class="token keyword">SELECT</span>    FirstName<span class="token punctuation">,</span>    LastName<span class="token punctuation">,</span>    City<span class="token punctuation">,</span>    State<span class="token keyword">FROM</span>    Person P    <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Address A    <span class="token keyword">ON</span> P<span class="token punctuation">.</span>PersonId <span class="token operator">=</span> A<span class="token punctuation">.</span>PersonId<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- SQL Schema</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Person<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Person <span class="token punctuation">(</span> PersonId <span class="token keyword">INT</span><span class="token punctuation">,</span> FirstName <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> LastName <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Address<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Address <span class="token punctuation">(</span> AddressId <span class="token keyword">INT</span><span class="token punctuation">,</span> PersonId <span class="token keyword">INT</span><span class="token punctuation">,</span> City <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> State <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Person <span class="token punctuation">(</span> PersonId<span class="token punctuation">,</span> LastName<span class="token punctuation">,</span> FirstName <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Wang'</span><span class="token punctuation">,</span> <span class="token string">'Allen'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Address <span class="token punctuation">(</span> AddressId<span class="token punctuation">,</span> PersonId<span class="token punctuation">,</span> City<span class="token punctuation">,</span> State <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'New York City'</span><span class="token punctuation">,</span> <span class="token string">'New York'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>Employees Earning More Than Their Managers(181)</p><ol><li><p>题述</p><table><thead><tr><th>Id</th><th>Name</th><th>Salary</th><th>ManagerId</th></tr></thead><tbody><tr><td>1</td><td>Joe</td><td>70000</td><td>3</td></tr><tr><td>2</td><td>Henry</td><td>80000</td><td>4</td></tr><tr><td>3</td><td>Sam</td><td>60000</td><td>NULL</td></tr><tr><td>4</td><td>Max</td><td>90000</td><td>NULL</td></tr></tbody></table></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 查找薪资大于其经理薪资的员工信息</span><span class="token keyword">SELECT</span>    E1<span class="token punctuation">.</span>NAME <span class="token keyword">AS</span> Employee<span class="token keyword">FROM</span>    Employee E1    <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Employee E2    <span class="token keyword">ON</span> E1<span class="token punctuation">.</span>ManagerId <span class="token operator">=</span> E2<span class="token punctuation">.</span>Id    <span class="token operator">AND</span> E1<span class="token punctuation">.</span>Salary <span class="token operator">></span> E2<span class="token punctuation">.</span>Salary<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- SQL Schema</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Employee<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Employee <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> Salary <span class="token keyword">INT</span><span class="token punctuation">,</span> ManagerId <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Employee <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> Salary<span class="token punctuation">,</span> ManagerId <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Joe'</span><span class="token punctuation">,</span> <span class="token number">70000</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Henry'</span><span class="token punctuation">,</span> <span class="token number">80000</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Sam'</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'Max'</span><span class="token punctuation">,</span> <span class="token number">90000</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>Customers Who Never Order(183)</p><ol><li><p>题述</p><p>Customers 表</p><table><thead><tr><th>Id</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>Joe</td></tr><tr><td>2</td><td>Henry</td></tr><tr><td>3</td><td>Sam</td></tr><tr><td>4</td><td>Max</td></tr></tbody></table><p>Orders 表</p><table><thead><tr><th>Id</th><th>CustomerId</th></tr></thead><tbody><tr><td>1</td><td>3</td></tr><tr><td>2</td><td>1</td></tr></tbody></table><p>查找没有订单的顾客信息</p><table><thead><tr><th>Customers</th></tr></thead><tbody><tr><td>Henry</td></tr><tr><td>Max</td></tr></tbody></table></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 左外链接</span><span class="token keyword">SELECT</span>    C<span class="token punctuation">.</span>Name <span class="token keyword">AS</span> Customers<span class="token keyword">FROM</span>    Customers C    <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Orders O    <span class="token keyword">ON</span> C<span class="token punctuation">.</span>Id <span class="token operator">=</span> O<span class="token punctuation">.</span>CustomerId<span class="token keyword">WHERE</span>    O<span class="token punctuation">.</span>CustomerId <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 子查询</span><span class="token keyword">SELECT</span>    Name <span class="token keyword">AS</span> Customers<span class="token keyword">FROM</span>    Customers<span class="token keyword">WHERE</span>    Id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span>         <span class="token keyword">SELECT</span> CustomerId         <span class="token keyword">FROM</span> Orders     <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- SQL Schema</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Customers<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Customers <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Orders<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Orders <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> CustomerId <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Customers <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> NAME <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Joe'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Henry'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Sam'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'Max'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Orders <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> CustomerId <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>Department Highest Salary(184)</p><ol><li><p>题述</p><p>Employee 表</p><table><thead><tr><th>Id</th><th>Name</th><th>Salary</th><th>DepartmentId</th></tr></thead><tbody><tr><td>1</td><td>Joe</td><td>70000</td><td>1</td></tr><tr><td>2</td><td>Henry</td><td>80000</td><td>2</td></tr><tr><td>3</td><td>Sam</td><td>60000</td><td>2</td></tr><tr><td>4</td><td>Max</td><td>90000</td><td>1</td></tr></tbody></table><p>Department 表</p><table><thead><tr><th>Id</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>IT</td></tr><tr><td>2</td><td>Sales</td></tr></tbody></table><p>查找一个 Department 中收入最高者的信息</p><table><thead><tr><th>Department</th><th>Salary</th><th>Salary</th></tr></thead><tbody><tr><td>IT</td><td>Max</td><td>90000</td></tr><tr><td>Sales</td><td>Henry</td><td>80000</td></tr></tbody></table></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 创建一个临时表，包含了部门员工的最大薪资。可以对部门进行分组，然后使用 MAX() 汇总函数取得最大薪资</span><span class="token comment" spellcheck="true">-- 之后使用连接找到一个部门中薪资等于临时表中最大薪资的员工</span><span class="token keyword">SELECT</span>    D<span class="token punctuation">.</span>NAME Department<span class="token punctuation">,</span>    E<span class="token punctuation">.</span>NAME Employee<span class="token punctuation">,</span>    E<span class="token punctuation">.</span>Salary<span class="token keyword">FROM</span>    Employee E<span class="token punctuation">,</span>    Department D<span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> DepartmentId<span class="token punctuation">,</span> <span class="token function">MAX</span><span class="token punctuation">(</span> Salary <span class="token punctuation">)</span> Salary      <span class="token keyword">FROM</span> Employee      <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> DepartmentId <span class="token punctuation">)</span> M<span class="token keyword">WHERE</span>    E<span class="token punctuation">.</span>DepartmentId <span class="token operator">=</span> D<span class="token punctuation">.</span>Id    <span class="token operator">AND</span> E<span class="token punctuation">.</span>DepartmentId <span class="token operator">=</span> M<span class="token punctuation">.</span>DepartmentId    <span class="token operator">AND</span> E<span class="token punctuation">.</span>Salary <span class="token operator">=</span> M<span class="token punctuation">.</span>Salary<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- SQL Schema</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> Employee<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Employee <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> Salary <span class="token keyword">INT</span><span class="token punctuation">,</span> DepartmentId <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> Department<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Department <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Employee <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> Salary<span class="token punctuation">,</span> DepartmentId <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Joe'</span><span class="token punctuation">,</span> <span class="token number">70000</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Henry'</span><span class="token punctuation">,</span> <span class="token number">80000</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Sam'</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'Max'</span><span class="token punctuation">,</span> <span class="token number">90000</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Department <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> NAME <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'IT'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Sales'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>Second Highest Salary(176)</p><ol><li><p>题述</p><table><thead><tr><th>Id</th><th>Salary</th></tr></thead><tbody><tr><td>1</td><td>100</td></tr><tr><td>2</td><td>200</td></tr><tr><td>3</td><td>300</td></tr></tbody></table><p>查找工资第二高的员工</p><table><thead><tr><th>SecondHighestSalary</th></tr></thead><tbody><tr><td>200</td></tr></tbody></table></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 没有找到返回 null 而不是不返回数据</span><span class="token comment" spellcheck="true">-- 为了在没有查找到数据时返回 null，需要在查询结果外面再套一层 SELECT</span><span class="token keyword">SELECT</span>    <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> Salary      <span class="token keyword">FROM</span> Employee      <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Salary <span class="token keyword">DESC</span>      <span class="token keyword">LIMIT</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span> SecondHighestSalary<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- SQL Schema</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Employee<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Employee <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> Salary <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Employee <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> Salary <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">200</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">300</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>Nth Highest Salary(177)</p><ol><li><p>题述</p><blockquote><p>查找工资第 N 高的员工</p></blockquote></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> getNthHighestSalary <span class="token punctuation">(</span> N <span class="token keyword">INT</span> <span class="token punctuation">)</span> <span class="token keyword">RETURNS</span> <span class="token keyword">INT</span> <span class="token keyword">BEGIN</span><span class="token keyword">SET</span> N <span class="token operator">=</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">RETURN</span> <span class="token punctuation">(</span>     <span class="token keyword">SELECT</span> <span class="token punctuation">(</span>         <span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> Salary         <span class="token keyword">FROM</span> Employee         <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Salary <span class="token keyword">DESC</span>         <span class="token keyword">LIMIT</span> N<span class="token punctuation">,</span> <span class="token number">1</span>     <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">END</span></code></pre></li></ol></li><li><p>Rank Scores(178)</p><ol><li><p>题述</p><p>得分表</p><table><thead><tr><th>Id</th><th>Score</th></tr></thead><tbody><tr><td>1</td><td>3.50</td></tr><tr><td>2</td><td>3.65</td></tr><tr><td>3</td><td>4.00</td></tr><tr><td>4</td><td>3.85</td></tr><tr><td>5</td><td>4.00</td></tr><tr><td>6</td><td>3.65</td></tr></tbody></table><p>将得分排序，并统计排名</p><table><thead><tr><th>Score</th><th>Rank</th></tr></thead><tbody><tr><td>4.00</td><td>1</td></tr><tr><td>4.00</td><td>1</td></tr><tr><td>3.85</td><td>2</td></tr><tr><td>3.65</td><td>3</td></tr><tr><td>3.65</td><td>3</td></tr><tr><td>3.50</td><td>4</td></tr></tbody></table><p>要统计某个 score 的排名，只要统计大于等于该 score 的 score 数量</p><table><thead><tr><th>Id</th><th>score</th><th>大于等于该 score 的 score 数量</th><th>排名</th></tr></thead><tbody><tr><td>1</td><td>4.1</td><td>3</td><td>3</td></tr><tr><td>2</td><td>4.2</td><td>2</td><td>2</td></tr><tr><td>3</td><td>4.3</td><td>1</td><td>1</td></tr></tbody></table></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 使用连接操作找到某个 score 对应的大于等于其值的记录</span><span class="token keyword">SELECT</span>    <span class="token operator">*</span><span class="token keyword">FROM</span>    Scores S1    <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Scores S2    <span class="token keyword">ON</span> S1<span class="token punctuation">.</span>score <span class="token operator">&lt;=</span> S2<span class="token punctuation">.</span>score<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>    S1<span class="token punctuation">.</span>score <span class="token keyword">DESC</span><span class="token punctuation">,</span> S1<span class="token punctuation">.</span>Id<span class="token punctuation">;</span></code></pre><table><thead><tr><th>S1.Id</th><th>S1.score</th><th>S2.Id</th><th>S2.score</th></tr></thead><tbody><tr><td>3</td><td>4.3</td><td>3</td><td>4.3</td></tr><tr><td>2</td><td>4.2</td><td>2</td><td>4.2</td></tr><tr><td>2</td><td>4.2</td><td>3</td><td>4.3</td></tr><tr><td>1</td><td>4.1</td><td>1</td><td>4.1</td></tr><tr><td>1</td><td>4.1</td><td>2</td><td>4.2</td></tr><tr><td>1</td><td>4.1</td><td>3</td><td>4.3</td></tr></tbody></table><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 可以看到每个 S1.score 都有对应好几条记录，我们再进行分组，并统计每个分组的数量作为 'Rank</span><span class="token keyword">SELECT</span>    S1<span class="token punctuation">.</span>score <span class="token string">'Score'</span><span class="token punctuation">,</span>    <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token string">'Rank'</span><span class="token keyword">FROM</span>    Scores S1    <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Scores S2    <span class="token keyword">ON</span> S1<span class="token punctuation">.</span>score <span class="token operator">&lt;=</span> S2<span class="token punctuation">.</span>score<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>    S1<span class="token punctuation">.</span>id<span class="token punctuation">,</span> S1<span class="token punctuation">.</span>score<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>    S1<span class="token punctuation">.</span>score <span class="token keyword">DESC</span><span class="token punctuation">,</span> S1<span class="token punctuation">.</span>Id<span class="token punctuation">;</span></code></pre><table><thead><tr><th>score</th><th>Rank</th></tr></thead><tbody><tr><td>4.3</td><td>1</td></tr><tr><td>4.2</td><td>2</td></tr><tr><td>4.1</td><td>3</td></tr></tbody></table><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 我们想要的结果是，把分数相同的放在同一个排名，并且相同分数只占一个位置，例如上面的分数，Id=2 和 Id=3 的记录都有相同的分数，并且最高，他们并列第一。而 Id=1 的记录应该排第二名，而不是第三名。所以在进行 COUNT 计数统计时，我们需要使用 COUNT( DISTINCT S2.score ) 从而只统计一次相同的分数</span><span class="token keyword">SELECT</span>    S1<span class="token punctuation">.</span>score <span class="token string">'Score'</span><span class="token punctuation">,</span>    <span class="token function">COUNT</span><span class="token punctuation">(</span> <span class="token keyword">DISTINCT</span> S2<span class="token punctuation">.</span>score <span class="token punctuation">)</span> <span class="token string">'Rank'</span><span class="token keyword">FROM</span>    Scores S1    <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Scores S2    <span class="token keyword">ON</span> S1<span class="token punctuation">.</span>score <span class="token operator">&lt;=</span> S2<span class="token punctuation">.</span>score<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>    S1<span class="token punctuation">.</span>id<span class="token punctuation">,</span> S1<span class="token punctuation">.</span>score<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>    S1<span class="token punctuation">.</span>score <span class="token keyword">DESC</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- SQL Schema</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Scores<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Scores <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> Score <span class="token keyword">DECIMAL</span> <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Scores <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> Score <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4.1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4.1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4.2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4.2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4.3</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4.3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>Consecutive Numbers(180)</p><ol><li><p>题述</p><p>数字表</p><table><thead><tr><th>Id</th><th>Num</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td></tr><tr><td>3</td><td>1</td></tr><tr><td>4</td><td>2</td></tr><tr><td>5</td><td>1</td></tr><tr><td>6</td><td>2</td></tr><tr><td>7</td><td>2</td></tr></tbody></table><p>查找连续出现三次的数字</p><table><thead><tr><th>ConsecutiveNums</th></tr></thead><tbody><tr><td>1</td></tr></tbody></table></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    <span class="token keyword">DISTINCT</span> L1<span class="token punctuation">.</span>num ConsecutiveNums<span class="token keyword">FROM</span>    Logs L1<span class="token punctuation">,</span>    Logs L2<span class="token punctuation">,</span>    Logs L3<span class="token keyword">WHERE</span> L1<span class="token punctuation">.</span>id <span class="token operator">=</span> l2<span class="token punctuation">.</span>id <span class="token operator">-</span> <span class="token number">1</span>    <span class="token operator">AND</span> L2<span class="token punctuation">.</span>id <span class="token operator">=</span> L3<span class="token punctuation">.</span>id <span class="token operator">-</span> <span class="token number">1</span>    <span class="token operator">AND</span> L1<span class="token punctuation">.</span>num <span class="token operator">=</span> L2<span class="token punctuation">.</span>num    <span class="token operator">AND</span> l2<span class="token punctuation">.</span>num <span class="token operator">=</span> l3<span class="token punctuation">.</span>num<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- SQL Schema</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> LOGS<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> LOGS <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> Num <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> LOGS <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> Num <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>Exchange Seats(626)</p><ol><li><p>题述</p><p>seat 表存储着座位对应的学生</p><table><thead><tr><th>id</th><th>student</th></tr></thead><tbody><tr><td>1</td><td>Abbot</td></tr><tr><td>2</td><td>Doris</td></tr><tr><td>3</td><td>Emerson</td></tr><tr><td>4</td><td>Green</td></tr><tr><td>5</td><td>Jeames</td></tr></tbody></table><p>要求交换相邻座位的两个学生，如果最后一个座位是奇数，那么不交换这个座位上的学生</p><table><thead><tr><th>id</th><th>student</th></tr></thead><tbody><tr><td>1</td><td>Doris</td></tr><tr><td>2</td><td>Abbot</td></tr><tr><td>3</td><td>Green</td></tr><tr><td>4</td><td>Emerson</td></tr><tr><td>5</td><td>Jeames</td></tr></tbody></table></li><li><p>实现</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 使用多个 union</span><span class="token comment" spellcheck="true">-- 处理偶数 id，让 id 减 1</span><span class="token comment" spellcheck="true">-- 例如 2,4,6,... 变成 1,3,5,...</span><span class="token keyword">SELECT</span>    s1<span class="token punctuation">.</span>id <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">AS</span> id<span class="token punctuation">,</span>    s1<span class="token punctuation">.</span>student<span class="token keyword">FROM</span>    seat s1<span class="token keyword">WHERE</span>    s1<span class="token punctuation">.</span>id MOD <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">UNION</span><span class="token comment" spellcheck="true">-- 处理奇数 id，让 id 加 1。但是如果最大的 id 为奇数，则不做处理</span><span class="token comment" spellcheck="true">-- 例如 1,3,5,... 变成 2,4,6,...</span><span class="token keyword">SELECT</span>    s2<span class="token punctuation">.</span>id <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">AS</span> id<span class="token punctuation">,</span>    s2<span class="token punctuation">.</span>student<span class="token keyword">FROM</span>    seat s2<span class="token keyword">WHERE</span>    s2<span class="token punctuation">.</span>id MOD <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>    <span class="token operator">AND</span> s2<span class="token punctuation">.</span>id <span class="token operator">!=</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token function">max</span><span class="token punctuation">(</span> s3<span class="token punctuation">.</span>id <span class="token punctuation">)</span> <span class="token keyword">FROM</span> seat s3 <span class="token punctuation">)</span> <span class="token keyword">UNION</span><span class="token comment" spellcheck="true">-- 如果最大的 id 为奇数，单独取出这个数</span><span class="token keyword">SELECT</span>    s4<span class="token punctuation">.</span>id <span class="token keyword">AS</span> id<span class="token punctuation">,</span>    s4<span class="token punctuation">.</span>student<span class="token keyword">FROM</span>    seat s4<span class="token keyword">WHERE</span>    s4<span class="token punctuation">.</span>id MOD <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>    <span class="token operator">AND</span> s4<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token function">max</span><span class="token punctuation">(</span> s5<span class="token punctuation">.</span>id <span class="token punctuation">)</span> <span class="token keyword">FROM</span> seat s5 <span class="token punctuation">)</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span>    id<span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> seat<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> seat <span class="token punctuation">(</span> id <span class="token keyword">INT</span><span class="token punctuation">,</span> student <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> seat <span class="token punctuation">(</span> id<span class="token punctuation">,</span> student <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'Abbot'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'Doris'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'Emerson'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'Green'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'Jeames'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li></ol><h3 id="2-4-MySQL"><a href="#2-4-MySQL" class="headerlink" title="2.4 MySQL"></a>2.4 MySQL</h3><h4 id="2-4-1-索引"><a href="#2-4-1-索引" class="headerlink" title="2.4.1 索引"></a>2.4.1 索引</h4><ol><li><p>B+ Tree 原理</p><ol><li><p>数据结构</p><blockquote><p>B Tree 指的是 Balance Tree，也就是平衡树</p><p>平衡树是一颗查找树，并且所有叶子节点位于同一层。</p><p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1</p></blockquote></li><li><p>操作</p><ul><li>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找</li><li>直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data</li><li>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</li></ul></li><li><p>与红黑树的比较</p><blockquote><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能</p></blockquote><ul><li><p>B+ 树有更低的树高</p><blockquote><p>平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度</p><p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多</p></blockquote></li><li><p>磁盘访问原理</p><blockquote><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据</p><p>数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p><p>如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间</p><p>B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p></blockquote></li><li><p>磁盘预读特性</p><blockquote><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读</p><p>预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快</p><p>并且可以利用预读特性，相邻的节点也能够被预先载入</p></blockquote></li></ul></li></ol></li><li><p>MySQL 索引</p><blockquote><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现</p></blockquote><ul><li><p>B+Tree 索引</p><blockquote><p>大多数 MySQL 存储引擎的默认索引类型</p><p>不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多</p><p>除了用于查找，还可以用于排序和分组，可以指定多个列作为索引列，多个索引列共同组成键</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找，如果不是按照索引列的顺序进行查找，则无法使用索引</p><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引</p><p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引，因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引</p><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找</p></blockquote></li><li><p>哈希索引</p><blockquote><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性</p><p>无法用于排序与分组，只支持精确查找，无法用于部分查找和范围查找</p><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找</p></blockquote></li><li><p>全文索引</p><blockquote><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等<br>查找条件使用 MATCH AGAINST，而不是普通的 WHERE<br>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射<br>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引</p></blockquote></li><li><p>空间数据索引</p><blockquote><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储</p><p>空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询<br>必须使用 GIS 相关的函数来维护数据</p></blockquote></li></ul></li><li><p>索引优化</p><ol><li><p>独立的列</p><blockquote><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 例如下面的查询不能使用 actor_id 列的索引</span><span class="token keyword">SELECT</span> actor_id <span class="token keyword">FROM</span> sakila<span class="token punctuation">.</span>actor <span class="token keyword">WHERE</span> actor_id <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></code></pre></li><li><p>多列索引</p><blockquote><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引</span><span class="token keyword">SELECT</span> film_id<span class="token punctuation">,</span> actor_ id <span class="token keyword">FROM</span> sakila<span class="token punctuation">.</span>film_actor<span class="token keyword">WHERE</span> actor_id <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">AND</span> film_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre></li><li><p>索引列的顺序</p><blockquote><p>让选择性最强的索引列放在前面</p><p>索引的选择性是指：不重复的索引值和记录总数的比值</p><p>最大值为 1，此时每个记录都有唯一的索引与其对应</p><p>选择性越高，每个记录的区分度越高，查询效率也越高</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> staff_id<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> staff_id_selectivity<span class="token punctuation">,</span><span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> customer_id<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> customer_id_selectivity<span class="token punctuation">,</span><span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">FROM</span> payment<span class="token punctuation">;</span>   staff_id_selectivity: <span class="token number">0.0001</span>customer_id_selectivity: <span class="token number">0.0373</span>               <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>: <span class="token number">16049</span></code></pre></li><li><p>前缀索引</p><blockquote><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符</p><p>前缀长度的选取需要根据索引选择性来确定</p></blockquote></li><li><p>覆盖索引</p><blockquote><p>索引包含所有需要查询的字段的值</p></blockquote><p>优势</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引</li></ul></li></ol></li><li><p>索引的优点</p><ul><li>大大减少了服务器需要扫描的数据行数</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）</li></ul></li><li><p>索引的使用条件</p><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效</li><li>对于中到大型的表，索引就非常有效</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术</li></ul></li></ol><h4 id="2-4-2-查询性能优化"><a href="#2-4-2-查询性能优化" class="headerlink" title="2.4.2 查询性能优化"></a>2.4.2 查询性能优化</h4><ol><li><p>使用 Explain 进行分析</p><blockquote><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句</p></blockquote><p>重要字段</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul></li><li><p>优化数据访问</p><ol><li><p>减少请求的数据量</p><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul></li><li><p>减少服务器扫描的行数</p><blockquote><p>最有效的方式是使用索引来覆盖查询</p></blockquote></li></ol></li><li><p>重构查询方式</p><ol><li><p>切分大于查询</p><blockquote><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> messages <span class="token keyword">WHERE</span> <span class="token keyword">create</span> <span class="token operator">&lt;</span> DATE_SUB<span class="token punctuation">(</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> INTERVAL <span class="token number">3</span> MONTH<span class="token punctuation">)</span><span class="token punctuation">;</span>rows_affected <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">do</span> {    rows_affected <span class="token operator">=</span> do_query<span class="token punctuation">(</span>    <span class="token string">"DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"</span><span class="token punctuation">)</span>} <span class="token keyword">while</span> rows_affected <span class="token operator">></span> <span class="token number">0</span></code></pre></li><li><p>分解大于连接查询</p><blockquote><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联</p></blockquote><p>优势</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询</li><li>减少锁竞争</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tag<span class="token keyword">JOIN</span> tag_post <span class="token keyword">ON</span> tag_post<span class="token punctuation">.</span>tag_id<span class="token operator">=</span>tag<span class="token punctuation">.</span>id<span class="token keyword">JOIN</span> post <span class="token keyword">ON</span> tag_post<span class="token punctuation">.</span>post_id<span class="token operator">=</span>post<span class="token punctuation">.</span>id<span class="token keyword">WHERE</span> tag<span class="token punctuation">.</span>tag<span class="token operator">=</span><span class="token string">'mysql'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tag <span class="token keyword">WHERE</span> tag<span class="token operator">=</span><span class="token string">'mysql'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tag_post <span class="token keyword">WHERE</span> tag_id<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> post <span class="token keyword">WHERE</span> post<span class="token punctuation">.</span>id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span><span class="token number">456</span><span class="token punctuation">,</span><span class="token number">567</span><span class="token punctuation">,</span><span class="token number">9098</span><span class="token punctuation">,</span><span class="token number">8904</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li></ol><h4 id="2-4-3-存储引擎"><a href="#2-4-3-存储引擎" class="headerlink" title="2.4.3 存储引擎"></a>2.4.3 存储引擎</h4><ol><li><p>InnoDB</p><blockquote><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎</p><p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读</p><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p></blockquote></li><li><p>MyISAM</p><blockquote><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它</p><p>提供了大量的特性，包括压缩表、空间数据索引等</p><p>不支持事务</p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘</p><p>这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作</p></blockquote></li><li><p>比较</p><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td>事务</td><td>InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句</td></tr><tr><td>并发</td><td>MyISAM 只支持表级锁，而 InnoDB 还支持行级锁</td></tr><tr><td>外键</td><td>InnoDB 支持外键</td></tr><tr><td>备份</td><td>InnoDB 支持在线热备份</td></tr><tr><td>崩溃恢复</td><td>MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢</td></tr><tr><td>其他</td><td>MyISAM 支持压缩表和空间数据索引</td></tr></tbody></table></li></ol><h4 id="2-4-5-数据类型"><a href="#2-4-5-数据类型" class="headerlink" title="2.4.5 数据类型"></a>2.4.5 数据类型</h4><ol><li><p>整型</p><blockquote><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p><p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p></blockquote></li><li><p>浮点数</p><blockquote><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价</p><p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分</p></blockquote></li><li><p>字符串</p><blockquote><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的</p><p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内</p><p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格</p></blockquote></li><li><p>时间和日期</p><blockquote><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP</p></blockquote><ol><li><p>DATETIME</p><blockquote><p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间</p><p>它与时区无关</p></blockquote></li><li><p>TIMESTAMP</p><blockquote><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年</p><p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的</p><p>尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高</p></blockquote></li></ol></li></ol><h4 id="2-4-5-切分"><a href="#2-4-5-切分" class="headerlink" title="2.4.5 切分"></a>2.4.5 切分</h4><ol><li><p>水平切分</p><blockquote><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力</p></blockquote></li><li><p>垂直切分</p><blockquote><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等</p></blockquote></li><li><p>Sharding 策略</p><ul><li>哈希取模：hash(key) % N</li><li>范围：可以是 ID 范围也可以是时间范围</li><li>映射表：使用单独的一个数据库来存储映射关系</li></ul></li><li><p>Sharding 存在的问题</p><ul><li><p>事务问题</p><blockquote><p>使用分布式事务来解决，比如 XA 接口</p></blockquote></li><li><p>连接</p><blockquote><p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接</p></blockquote></li><li><p>ID唯一性</p><ul><li>使用全局唯一 ID（GUID）</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li></ul></li></ul></li></ol><h4 id="2-4-6-复制"><a href="#2-4-6-复制" class="headerlink" title="2.4.6 复制"></a>2.4.6 复制</h4><ol><li><p>主从复制</p><blockquote><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程</p></blockquote><ul><li>解释<ul><li>binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中</li><li>I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）</li><li>SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）</li></ul></li></ul></li><li><p>读写分离</p><blockquote><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作</p><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器</p></blockquote><p>原因</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销</li><li>增加冗余，提高可用性</li></ul></li></ol><h3 id="2-5-Redis"><a href="#2-5-Redis" class="headerlink" title="2.5 Redis"></a>2.5 Redis</h3><h4 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1 概述"></a>2.5.1 概述</h4><blockquote><p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射</p><p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合</p><p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能</p></blockquote><h4 id="2-5-2-数据类型"><a href="#2-5-2-数据类型" class="headerlink" title="2.5.2 数据类型"></a>2.5.2 数据类型</h4><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作<br> 对整数和浮点数执行自增或者自减操作</td></tr><tr><td>LIST</td><td>列表</td><td>从两端压入或者弹出元素 <br> 对单个或者多个元素进行修剪，<br> 只保留一个范围内的元素</td></tr><tr><td>SET</td><td>无序集合</td><td>添加、获取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合里面随机获取元素</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对<br> 获取所有键值对<br> 检查某个键是否存在</td></tr><tr><td>ZSET</td><td>有序集合</td><td>添加、获取、删除元素<br> 根据分值范围或者成员来获取元素<br> 计算一个键的排名</td></tr></tbody></table><ol><li><p>STRING</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">></span> <span class="token keyword">set</span> hello worldOK<span class="token operator">></span> get hello<span class="token string">"world"</span><span class="token operator">></span> del hello<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">></span> get hello<span class="token punctuation">(</span>nil<span class="token punctuation">)</span></code></pre></li><li><p>LIST</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">></span> rpush list<span class="token operator">-</span><span class="token keyword">key</span> item<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">></span> rpush list<span class="token operator">-</span><span class="token keyword">key</span> item2<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">2</span><span class="token operator">></span> rpush list<span class="token operator">-</span><span class="token keyword">key</span> item<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">3</span><span class="token operator">></span> lrange list<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token number">1</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"item"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"item2"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"item"</span><span class="token operator">></span> lindex list<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">1</span><span class="token string">"item2"</span><span class="token operator">></span> lpop list<span class="token operator">-</span><span class="token keyword">key</span><span class="token string">"item"</span><span class="token operator">></span> lrange list<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token number">1</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"item2"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"item"</span></code></pre></li><li><p>SET</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">></span> sadd <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">></span> sadd <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item2<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">></span> sadd <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item3<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">></span> sadd <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token operator">></span> smembers <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"item"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"item2"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"item3"</span><span class="token operator">></span> sismember <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item4<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token operator">></span> sismember <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">></span> srem <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item2<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">></span> srem <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span> item2<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token operator">></span> smembers <span class="token keyword">set</span><span class="token operator">-</span><span class="token keyword">key</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"item"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"item3"</span></code></pre></li><li><p>HASH</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">></span> hset <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span> sub<span class="token operator">-</span>key1 value1<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">></span> hset <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span> sub<span class="token operator">-</span>key2 value2<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">></span> hset <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span> sub<span class="token operator">-</span>key1 value1<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token operator">></span> hgetall <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"sub-key1"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"value1"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"sub-key2"</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"value2"</span><span class="token operator">></span> hdel <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span> sub<span class="token operator">-</span>key2<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">></span> hdel <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span> sub<span class="token operator">-</span>key2<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token operator">></span> hget <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span> sub<span class="token operator">-</span>key1<span class="token string">"value1"</span><span class="token operator">></span> hgetall <span class="token keyword">hash</span><span class="token operator">-</span><span class="token keyword">key</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"sub-key1"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"value1"</span></code></pre></li><li><p>ZSET</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">></span> zadd zset<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">728</span> member1<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">></span> zadd zset<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">982</span> member0<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">></span> zadd zset<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">982</span> member0<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token operator">></span> zrange zset<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token number">1</span> withscores<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"member1"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"728"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"member0"</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"982"</span><span class="token operator">></span> zrangebyscore zset<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">0</span> <span class="token number">800</span> withscores<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"member1"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"728"</span><span class="token operator">></span> zrem zset<span class="token operator">-</span><span class="token keyword">key</span> member1<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">></span> zrem zset<span class="token operator">-</span><span class="token keyword">key</span> member1<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token operator">></span> zrange zset<span class="token operator">-</span><span class="token keyword">key</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token number">1</span> withscores<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"member0"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"982"</span></code></pre></li></ol><h4 id="2-5-3-数据结构"><a href="#2-5-3-数据结构" class="headerlink" title="2.5.3 数据结构"></a>2.5.3 数据结构</h4><ol><li><p>字典</p><blockquote><p>dictht 是一个散列表结构，使用拉链法解决哈希冲突</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* This is our hash table structure. Every dictionary has two of this as we * implement incremental rehashing, for the old to the new table. */</span>typedef struct dictht {    dictEntry <span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">table</span><span class="token punctuation">;</span>    unsigned long size<span class="token punctuation">;</span>    unsigned long sizemask<span class="token punctuation">;</span>    unsigned long used<span class="token punctuation">;</span>} dictht<span class="token punctuation">;</span>typedef struct dictEntry {    void <span class="token operator">*</span><span class="token keyword">key</span><span class="token punctuation">;</span>    <span class="token keyword">union</span> {        void <span class="token operator">*</span>val<span class="token punctuation">;</span>        uint64_t u64<span class="token punctuation">;</span>        int64_t s64<span class="token punctuation">;</span>        <span class="token keyword">double</span> <span class="token number">d</span><span class="token punctuation">;</span>    } v<span class="token punctuation">;</span>    struct dictEntry <span class="token operator">*</span><span class="token keyword">next</span><span class="token punctuation">;</span>} dictEntry<span class="token punctuation">;</span></code></pre><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</span>typedef struct dict {    dictType <span class="token operator">*</span><span class="token keyword">type</span><span class="token punctuation">;</span>    void <span class="token operator">*</span>privdata<span class="token punctuation">;</span>    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    long rehashidx<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* rehashing not in progress if rehashidx == -1 */</span>    unsigned long iterators<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* number of iterators currently running */</span>} dict<span class="token punctuation">;</span></code></pre><p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</p><p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p><p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</p><p>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/* Performs N steps of incremental rehashing. Returns 1 if there are still * keys to move from the old to the new hash table, otherwise 0 is returned. * * Note that a rehashing step consists in moving a bucket (that may have more * than one key as we use chaining) from the old to the new hash table, however * since part of the hash table may be composed of empty spaces, it is not * guaranteed that this function will rehash even a single bucket, since it * will visit at max N*10 empty buckets in total, otherwise the amount of * work it does would be unbound and the function may block for a long time. */</span><span class="token keyword">int</span> dictRehash<span class="token punctuation">(</span>dict <span class="token operator">*</span><span class="token number">d</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> {    <span class="token keyword">int</span> empty_visits <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Max number of empty buckets to visit. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dictIsRehashing<span class="token punctuation">(</span><span class="token number">d</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token comment" spellcheck="true">-- &amp;&amp; d->ht[0].used != 0) {</span>        dictEntry <span class="token operator">*</span><span class="token number">de</span><span class="token punctuation">,</span> <span class="token operator">*</span>nextde<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Note that rehashidx can't overflow as we are sure there are more         * elements because ht[0].used != 0 */</span>        assert<span class="token punctuation">(</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">></span> <span class="token punctuation">(</span>unsigned long<span class="token punctuation">)</span> <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>rehashidx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">table</span><span class="token punctuation">[</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>rehashidx<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">=</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span> {            <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>rehashidx<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment" spellcheck="true">--empty_visits == 0) return 1;</span>        }        <span class="token number">de</span> <span class="token operator">=</span> <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">table</span><span class="token punctuation">[</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>rehashidx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Move all the keys in this bucket from the old to the new hash HT */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">de</span><span class="token punctuation">)</span> {            uint64_t h<span class="token punctuation">;</span>            nextde <span class="token operator">=</span> <span class="token number">de</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">next</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* Get the index in the new hash table */</span>            h <span class="token operator">=</span> dictHashKey<span class="token punctuation">(</span><span class="token number">d</span><span class="token punctuation">,</span> <span class="token number">de</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">key</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sizemask<span class="token punctuation">;</span>            <span class="token number">de</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">next</span> <span class="token operator">=</span> <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">table</span><span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">table</span><span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">de</span><span class="token punctuation">;</span>            <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used<span class="token comment" spellcheck="true">--;</span>            <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>            <span class="token number">de</span> <span class="token operator">=</span> nextde<span class="token punctuation">;</span>        }        <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">table</span><span class="token punctuation">[</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>rehashidx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>        <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>rehashidx<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>    }    <span class="token comment" spellcheck="true">/* Check if we already rehashed the whole table... */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">=</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> {        zfree<span class="token punctuation">(</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">table</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        _dictReset<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token number">d</span><span class="token operator">-</span><span class="token operator">></span>rehashidx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    }    <span class="token comment" spellcheck="true">/* More to rehash... */</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>}</code></pre></li><li><p>跳跃表</p><blockquote><p>是有序集合的底层实现之一。</p><p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。</p><p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。</p></blockquote><p>优势</p><ul><li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li><li>更容易实现；</li><li>支持无锁操作。</li></ul></li></ol><h4 id="2-5-4-使用场景"><a href="#2-5-4-使用场景" class="headerlink" title="2.5.4 使用场景"></a>2.5.4 使用场景</h4><ol><li><p>计数器</p><blockquote><p>可以对 String 进行自增自减运算，从而实现计数器功能。</p><p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p></blockquote></li><li><p>缓存</p><blockquote><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率</p></blockquote></li><li><p>查找表</p><blockquote><p>例如 DNS 记录就很适合使用 Redis 进行存储</p><p>查找表和缓存类似，也是利用了 Redis 快速的查找特性</p><p>但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p></blockquote></li><li><p>消息队列</p><blockquote><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p><p>不过最好使用 Kafka、RabbitMQ 等消息中间件</p></blockquote></li><li><p>会话缓存</p><blockquote><p>可以使用 Redis 来统一存储多台应用服务器的会话信息</p><p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性</p></blockquote></li><li><p>分布式锁实现</p><blockquote><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步</p><p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现</p></blockquote></li><li><p>其它</p><blockquote><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能</p><p>ZSet 可以实现有序性操作，从而实现排行榜等功能</p></blockquote></li></ol><h4 id="2-5-5-Redis-与-Memcached"><a href="#2-5-5-Redis-与-Memcached" class="headerlink" title="2.5.5 Redis 与 Memcached"></a>2.5.5 Redis 与 Memcached</h4><ol><li><p>都是非关系型内存键值数据库</p></li><li><p>数据类型</p><blockquote><p>Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题</p></blockquote></li><li><p>数据持久化</p><blockquote><p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化</p></blockquote></li><li><p>分布式</p><blockquote><p>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点</p><p>Redis Cluster 实现了分布式的支持</p></blockquote></li><li><p>内存管理机制</p><ul><li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中</li><li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了</li></ul></li></ol><h4 id="2-5-6-键的过期时间"><a href="#2-5-6-键的过期时间" class="headerlink" title="2.5.6 键的过期时间"></a>2.5.6 键的过期时间</h4><blockquote><p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键</p><p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间</p></blockquote><h4 id="2-5-7-数据淘汰策略"><a href="#2-5-7-数据淘汰策略" class="headerlink" title="2.5.7 数据淘汰策略"></a>2.5.7 数据淘汰策略</h4><blockquote><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略</p></blockquote><ul><li><p>6 种淘汰策略</p><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td>volatile-lru</td><td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>volatile-ttl</td><td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td>volatile-random</td><td>从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td>allkeys-lru</td><td>从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>allkeys-random</td><td>从所有数据集中任意选择数据进行淘汰</td></tr><tr><td>noeviction</td><td>禁止驱逐数据</td></tr></tbody></table></li></ul><blockquote><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key</p><p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰</p><p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰</p></blockquote><h4 id="2-5-8-持久化"><a href="#2-5-8-持久化" class="headerlink" title="2.5.8 持久化"></a>2.5.8 持久化</h4><ol><li><p>概述</p><blockquote><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上</p></blockquote></li><li><p>RDB 持久化</p><ul><li>将某个时间点的所有数据都存放到硬盘上</li><li>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本</li><li>如果系统发生故障，将会丢失最后一次创建快照之后的数据</li><li>如果数据量很大，保存快照的时间会很长。</li></ul></li><li><p>AOF 持久化</p><blockquote><p>将写命令添加到 AOF 文件（Append Only File）的末尾</p><p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘</p></blockquote><ul><li><p>同步选项</p><table><thead><tr><th>选项</th><th>同步频率</th></tr></thead><tbody><tr><td>always</td><td>每个写命令都同步</td></tr><tr><td>everysec</td><td>每秒同步一次</td></tr><tr><td>no</td><td>让操作系统来决定何时同步</td></tr></tbody></table></li><li><p>解释</p><ul><li>always 选项会严重减低服务器的性能</li><li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响</li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量</li></ul></li></ul></li></ol><h4 id="2-5-9-事务"><a href="#2-5-9-事务" class="headerlink" title="2.5.9 事务"></a>2.5.9 事务</h4><blockquote><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求</p><p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能</p><p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来</p></blockquote><h4 id="2-5-10-事件"><a href="#2-5-10-事件" class="headerlink" title="2.5.10 事件"></a>2.5.10 事件</h4><ol><li><p>概述</p><blockquote><p>Redis 服务器是一个事件驱动程序</p></blockquote></li><li><p>文件事件</p><blockquote><p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象</p><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器</p></blockquote></li><li><p>时间事件</p><blockquote><p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象</p><p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器</p></blockquote><ul><li>分类<ul><li>定时事件：是让一段程序在指定的时间之内执行一次</li><li>周期性事件：是让一段程序每隔指定时间就执行一次</li></ul></li></ul></li><li><p>事件的调度与执行</p><blockquote><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 事件调度与执行由 aeProcessEvents 函数负责，伪代码如下</span><span class="token number">def</span> aeProcessEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>:    <span class="token comment" spellcheck="true">-- 获取到达时间离当前时间最接近的时间事件</span>    time_event <span class="token operator">=</span> aeSearchNearestTimer<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 计算最接近的时间事件距离到达还有多少毫秒</span>    remaind_ms <span class="token operator">=</span> time_event<span class="token punctuation">.</span><span class="token keyword">when</span> <span class="token operator">-</span> unix_ts_now<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span>    <span class="token keyword">if</span> remaind_ms <span class="token operator">&lt;</span> <span class="token number">0</span>:        remaind_ms <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true">-- 根据 remaind_ms 的值，创建 timeval</span>    timeval <span class="token operator">=</span> create_timeval_with_ms<span class="token punctuation">(</span>remaind_ms<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span>    aeApiPoll<span class="token punctuation">(</span>timeval<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 处理所有已产生的文件事件</span>    procesFileEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 处理所有已到达的时间事件</span>    processTimeEvents<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- 将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下</span><span class="token number">def</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span>:    <span class="token comment" spellcheck="true">-- 初始化服务器</span>    init_server<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 一直处理事件，直到服务器关闭为止</span>    <span class="token keyword">while</span> server_is_not_shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span>:        aeProcessEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 服务器关闭，执行清理操作</span>    clean_server<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li></ol><h4 id="2-5-11-复制"><a href="#2-5-11-复制" class="headerlink" title="2.5.11 复制"></a>2.5.11 复制</h4><ol><li><p>概述</p><blockquote><p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器</p><p>一个从服务器只能有一个主服务器，并且不支持主主复制</p></blockquote></li><li><p>连接过程</p><ol><li>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li><li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li><li>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li></ol></li><li><p>主从链</p><blockquote><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器</p></blockquote></li></ol><h4 id="2-5-12-Sentinel"><a href="#2-5-12-Sentinel" class="headerlink" title="2.5.12 Sentinel"></a>2.5.12 Sentinel</h4><blockquote><p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器</p></blockquote><h4 id="2-5-13-分片"><a href="#2-5-13-分片" class="headerlink" title="2.5.13 分片"></a>2.5.13 分片</h4><blockquote><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升</p><p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中</p></blockquote><ul><li>最简单的方式是范围分片，例如用户 id 从 0<del>1000 的存储到实例 R0 中，用户 id 从 1001</del>2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li><li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li></ul><p>三种分片方式</p><ul><li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li><li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li><li>服务器分片：Redis Cluster。</li></ul><h4 id="2-5-14-一个简单的论坛系统分析"><a href="#2-5-14-一个简单的论坛系统分析" class="headerlink" title="2.5.14 一个简单的论坛系统分析"></a>2.5.14 一个简单的论坛系统分析</h4><ol><li><p>基础功能</p><ol><li>可以发布文章；</li><li>可以对文章进行点赞；</li><li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示。</li></ol></li><li><p>文章信息</p><blockquote><p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p><p>Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔</p></blockquote></li><li><p>点赞功能</p><blockquote><p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。</p><p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定</p></blockquote></li><li><p>对文章进行排序</p><blockquote><p>为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合</p></blockquote></li></ol><h3 id="2-6-Oracle"><a href="#2-6-Oracle" class="headerlink" title="2.6 Oracle"></a>2.6 Oracle</h3><h2 id="3-系统设计"><a href="#3-系统设计" class="headerlink" title="3. 系统设计"></a>3. 系统设计</h2><h3 id="3-1-基础"><a href="#3-1-基础" class="headerlink" title="3.1 基础"></a>3.1 基础</h3><ol><li><p>性能</p><ol><li><p>性能指标</p><ol><li><p>响应时间</p><blockquote><p>指某个请求从发出到接 收到响应消耗的时间。<br>在对响应时间进行测试时，通常采用重复请求的方式，然后计算平均响应时间。</p></blockquote></li><li><p>吞吐量</p><blockquote><p> 指系统在单位时间内可以处理的请求数量，通常使用每秒的请求数来衡量。</p></blockquote></li><li><p>并发用户数</p><blockquote><p>指系统能同时处理的并发用 户请求数量。<br>在没有并发存在的系统中，请求被顺序执行，此时响应时间为吞吐量的倒数。例如系统支持的吞吐量为 100 req/s，那么平均响应时间应该为 0.01s。<br>使用 IO 多路复用等方式，系统在等待一个 IO 操作完成的这段时间内不需要被阻塞，可以去处理其它请求。通过将这个等待时间利用起来，使得 CPU 利用率大大提高。<br>并发用户数不是越高越好，因为如果并发用户数太高，系统来不及处理这么多的请求，会使得过多的请求需要等待，那么响应时间就会大大提高。</p></blockquote><p>目前的大型系统都支持多线程来处理并发请求，多线程能够提高吞吐量以及缩短响应时间，主要有两个原因：</p><ul><li>多 CPU</li><li>IO 等待时间</li></ul></li></ol></li><li><p>性能优化</p><ol><li><p>集群</p><blockquote><p>将多台服务器组成集群，使用负载均衡将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低。</p></blockquote></li><li><p>缓存<br> 缓存能够提高性能的原因如下：</p><ul><li>缓存数据通常位于内存等介质中，这种介质对于读操作特别快</li><li>缓存数据可以位于靠近用户的地理位置上</li><li>可以将计算结果进行缓存，从而避免重复计算</li></ul></li><li><p>异步</p><blockquote><p>某些流程可以 将操作转换为消息，将消息发送到消息队列之后立即返回，之后这个操作会被异步处理。</p></blockquote></li></ol></li></ol></li><li><p>伸缩性</p><blockquote><p>指不断向集群中添加服务器来缓解不断上升的用户并发访问压力和不断增长的数据存储需求</p></blockquote><ul><li><p>伸缩性与性能</p><blockquote><p>如果系统存在性能问题，那么单个用户的请求总是很慢的；<br>如果系统存在伸缩性问题，那么单个用户的请求可能会很快，但是在并发数很高的情况下系统会很慢。</p></blockquote></li><li><p>实现伸缩性</p><blockquote><p>应用服务器只要不具有状态 ，那么就可以很容易地通过负载均衡器向集群中添加新的服务器。<br>关系型数据库的伸缩性通过 Sharding 来实现，将数据按一定的规则分布到不同的节点上，从而解决单台存储服务器的存储空间限制。<br>对于非关系型数据库，它们天生就是为海量数据而诞生，对伸缩性的支持特别好。</p></blockquote></li></ul></li><li><p>扩展性</p><blockquote><p>指的是添加新功能时对现有系统的其它应用无影响，这就要求不同应用具备低耦合的特点</p></blockquote><p>扩展方式</p><ul><li>使用消息队列进行解耦，应用之间通过消息传递进行通信；</li><li>使用分布式服务将业务和可复用的服务分离开来，业务使用分布式服务框架调用可复用的服务。新增的产品可以通过调用可复用的服务来实现业务逻辑，对其它产品没有影响。</li></ul></li><li><p>可用性</p><ol><li><p>冗余</p><blockquote><p>保证高可用的 主要手段是使用冗余，当某个服务器故障时就请求其它服务器。</p><p>应用服务器的冗余比较容易实现，只要保证应用服务器不具有状态，那么某个应用服务器故障时，负载均衡器将该应用服务器原先的用户请求转发到另一个应用服务器上，不会对用户有任何影响。</p><p>存储服务器的冗余需要使用主从复制来实现，当主服务器故障时，需要提升从服务器为主服务器，这个过程称为切换。</p></blockquote></li><li><p>监控</p><blockquote><p>对 CPU、内存、磁盘、网络等系统负载信息进行监控，当某个信息达到一定阈值时通知运维人员，从而在系统发生故障之前及时发现问题。</p></blockquote></li><li><p>服务降级</p><blockquote><p>服务降级是系统为了应 对大量的请求，主动关闭部分功能，从而保证核心功能可用。</p></blockquote></li></ol></li><li><p>安全性</p><blockquote><p>要求系统在应对各种攻击手段时能够有可靠的应对措施</p></blockquote></li></ol><h3 id="3-2-分布式"><a href="#3-2-分布式" class="headerlink" title="3.2 分布式"></a>3.2 分布式</h3><h4 id="3-2-1-分布式锁"><a href="#3-2-1-分布式锁" class="headerlink" title="3.2.1 分布式锁"></a>3.2.1 分布式锁</h4><ol><li><p>概述</p><blockquote><p>在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁</p></blockquote><ul><li>阻塞锁通常使用互斥量来实现<ul><li>互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态</li><li>互斥量为 1 表示未锁定状态</li></ul></li></ul></li><li><p>数据库的唯一索引</p><blockquote><p>获得锁时向表中插入一条记录，释放锁时删除这条记录</p><p>唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态</p></blockquote><p>存在问题</p><ul><li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁；</li><li>只能是非阻塞锁，插入失败直接就报错了，无法重试；</li><li>不可重入，已经获得锁的进程也必须重新获取锁</li></ul></li><li><p>Redis 的 SETNX 指令</p><blockquote><p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p><p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p><p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p></blockquote></li><li><p>Redis 的 RedLock 算法</p><blockquote><p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用</p></blockquote><ul><li>尝试从 N 个互相独立 Redis 实例获取锁；</li><li>计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；</li><li>如果获取锁失败，就到每个实例上释放锁。</li></ul></li><li><p>Zookeeper 的有序节点</p><ol><li><p>Zookeeper抽象模型</p><blockquote><p>Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1</p></blockquote></li><li><p>节点模型</p><ul><li>永久节点：不会因为会话结束或者超时而消失；</li><li>临时节点：如果会话结束或者超时就会消失；</li><li>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推</li></ul></li><li><p>监听器</p><blockquote><p>为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息</p></blockquote></li><li><p>分布式锁实现</p><ul><li>创建一个锁目录 /lock；</li><li>当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；</li><li>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；</li><li>执行业务代码，完成后，删除对应的子节点</li></ul></li><li><p>会话超时</p><blockquote><p>如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题</p></blockquote></li><li><p>羊群效应</p><blockquote><p>一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应，一只羊动起来，其它羊也会一哄而上），而我们只希望它的后一个子节点收到通知</p></blockquote></li></ol></li></ol><h4 id="3-2-2-分布式事务"><a href="#3-2-2-分布式事务" class="headerlink" title="3.2.2 分布式事务"></a>3.2.2 分布式事务</h4><ol><li><p>概述</p><blockquote><p>指事务的操作位于不同的节点上，需要保证事务的 ACID 特性</p></blockquote><p>分布式锁和分布式事务区别</p><ul><li>锁问题的关键在于进程操作的互斥关系，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。</li><li>而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。</li></ul></li><li><p>2PC</p><blockquote><p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务</p></blockquote><ol><li><p>运行过程</p><ol><li><p>准备阶段</p><blockquote><p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行</p></blockquote></li><li><p>提交阶段</p><blockquote><p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p><p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p></blockquote></li></ol></li><li><p>存在问题</p><ol><li><p>同步阻塞</p><blockquote><p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作</p></blockquote></li><li><p>单点问题</p><blockquote><p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完成其它操作</p></blockquote></li><li><p>数据不一致</p><blockquote><p>在提交阶段，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致</p></blockquote></li><li><p>太过保守</p><blockquote><p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制</p></blockquote></li></ol></li></ol></li><li><p>本地消息表</p><blockquote><p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性</p></blockquote><ol><li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li><li>之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li><li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作.</li></ol></li></ol><h4 id="3-2-3-CAP"><a href="#3-2-3-CAP" class="headerlink" title="3.2.3 CAP"></a>3.2.3 CAP</h4><ol><li><p>概述</p><blockquote><p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项</p></blockquote></li><li><p>一致性</p><blockquote><p>一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p><p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p></blockquote></li><li><p>可用性</p><blockquote><p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p><p>在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p></blockquote></li><li><p>分区容忍性</p><blockquote><p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p><p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p></blockquote></li><li><p>权衡</p><blockquote><p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。</p><p>可用性和一致性往往是冲突的，很难使它们同时满足</p></blockquote><p>多个节点之间进行数据同步</p><ul><li>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性</li><li>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致</li></ul></li></ol><h4 id="3-2-4-BASE"><a href="#3-2-4-BASE" class="headerlink" title="3.2.4 BASE"></a>3.2.4 BASE</h4><ol><li><p>概述</p><blockquote><p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p><p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p></blockquote></li><li><p>基本可用</p><blockquote><p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p><p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面</p></blockquote></li><li><p>软状态</p><blockquote><p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。</p></blockquote></li><li><p>最终一致性</p><blockquote><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p><p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p><p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p></blockquote></li></ol><h4 id="3-2-5-Paxos"><a href="#3-2-5-Paxos" class="headerlink" title="3.2.5 Paxos"></a>3.2.5 Paxos</h4><ol><li><p>基础</p><blockquote><p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值</p></blockquote><p>主要有三类节点</p><ul><li>提议者（Proposer）：提议一个值；</li><li>接受者（Acceptor）：对每个提议进行投票；</li><li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li></ul></li><li><p>执行过程</p><blockquote><p>规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值</p></blockquote><ol><li><p>Prepare 阶段</p><blockquote><p>当 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n1, v1]，并且之前还未接收过 Prepare 请求，那么发送一个 Prepare 响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议</p><p>如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 &gt; n2，那么就丢弃该提议请求；否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议</p></blockquote></li><li><p>Accept 阶段</p><blockquote><p>当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时，就可以发送 Accept 请求</p></blockquote></li><li><p>Learn 阶段</p><blockquote><p>Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来</p></blockquote></li></ol></li><li><p>约束条件</p><ol><li><p>正确性</p><blockquote><p>指只有一个提议值会生效。</p><p>因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。</p></blockquote></li><li><p>可终止性</p><blockquote><p>指最后总会有一个提议生效。</p><p>Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。</p></blockquote></li></ol></li></ol><h4 id="3-2-6-Raft"><a href="#3-2-6-Raft" class="headerlink" title="3.2.6 Raft"></a>3.2.6 Raft</h4><ol><li><p>概述</p><blockquote><p>Raft 也是分布式一致性协议，主要是用来竞选主节点</p></blockquote></li><li><p>单个 Candidate 的竞选</p><blockquote><p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段</p></blockquote></li><li><p>多个 Candidate 竞选</p><blockquote><p>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Node B 和 Node D 都获得两票，需要重新开始投票</p><p>由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低</p></blockquote></li><li><p>数据同步</p><blockquote><p>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中</p><p>Leader 会把修改复制到所有 Follower</p><p>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交</p><p>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致</p></blockquote></li></ol><h3 id="3-3-集群"><a href="#3-3-集群" class="headerlink" title="3.3 集群"></a>3.3 集群</h3><h4 id="3-3-1-负载均衡"><a href="#3-3-1-负载均衡" class="headerlink" title="3.3.1 负载均衡"></a>3.3.1 负载均衡</h4><ol><li><p>概述</p><blockquote><p>集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点</p><p>负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上</p></blockquote><p>负载均衡器可以用来实现高可用以及伸缩性</p><ul><li>高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用；</li><li>伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点</li></ul><p>负载均衡器运行过程</p><ol><li>根据负载均衡算法得到转发的节点；</li><li>进行转发。</li></ol></li><li><p>负载均衡算法</p><ol><li><p>轮询（Round Robin）</p><blockquote><p>轮询算法把每个请求轮流发送到每个服务器上</p><p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载</p></blockquote></li><li><p>加权轮询（Weighted Round Robbin）</p><blockquote><p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值</p></blockquote></li><li><p>最少连接（least Connections）</p><blockquote><p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡</p><p>最少连接算法就是将请求发送给当前最少连接数的服务器上</p></blockquote></li><li><p>加权最少连接（Weighted Least Connection）</p><blockquote><p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数</p></blockquote></li><li><p>随机算法（Random）</p><blockquote><p>把请求随机发送到服务器上。</p><p>和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p></blockquote></li><li><p>源地址哈希法 (IP Hash)</p><blockquote><p>源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。</p><p>可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）</p></blockquote></li></ol></li><li><p>转发实现</p><ol><li><p>HTTP 重定向</p><blockquote><p>HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求</p><p>该负载均衡转发的缺点比较明显，实际场景中很少使用它</p></blockquote><ul><li>缺点<ul><li>需要两次请求，因此访问延迟比较高；</li><li>HTTP 负载均衡器处理能力有限，会限制集群的规模。</li></ul></li></ul></li><li><p>DNS 域名解析</p><blockquote><p>在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址</p><p>大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址</p></blockquote><ul><li><p>优点</p><blockquote><p>DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址</p></blockquote></li><li><p>缺点</p><blockquote><p>由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效</p></blockquote></li></ul></li><li><p>反向代理服务器</p><blockquote><p>反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器</p><p>在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址</p></blockquote><p>优点：</p><ul><li>与其它功能集成在一起，部署简单。</li></ul><p>缺点：</p><ul><li>所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。</li></ul></li><li><p>网络层</p><blockquote><p>在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。</p><p>源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现</p></blockquote><p>优点：</p><ul><li>在内核进程中进行处理，性能比较高。</li></ul><p>缺点：</p><ul><li>和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。</li></ul></li><li><p>链路层</p><blockquote><p>在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。</p><p>通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。</p><p>这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。</p><p>这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）</p></blockquote></li></ol></li></ol><h4 id="3-3-2-集群下的-Session-管理"><a href="#3-3-2-集群下的-Session-管理" class="headerlink" title="3.3.2 集群下的 Session 管理"></a>3.3.2 集群下的 Session 管理</h4><ol><li><p>概述</p><blockquote><p>一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作</p></blockquote></li><li><p>Sticky Session</p><blockquote><p>需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中</p></blockquote><p>缺点：</p><ul><li>当服务器宕机时，将丢失该服务器上的所有 Session。</li></ul></li><li><p>Session Replication</p><blockquote><p>在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求</p></blockquote><p>缺点：</p><ul><li>占用过多内存；</li><li>同步过程占用网络带宽以及服务器处理器时间。</li></ul></li><li><p>Session Server</p><blockquote><p>使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库</p></blockquote><p>优点：</p><ul><li>为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。</li></ul><p>缺点：</p><ul><li>需要去实现存取 Session 的代码。</li></ul></li></ol><h3 id="3-4-缓存"><a href="#3-4-缓存" class="headerlink" title="3.4 缓存"></a>3.4 缓存</h3><ol><li><p>缓存特征</p><ol><li><p>命中率</p><blockquote><p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。<br>缓存命中率越高，缓存的利用率也就越高。</p></blockquote></li><li><p>最大空间</p><blockquote><p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。<br>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p></blockquote></li><li><p>淘汰策略</p><ul><li>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</li><li>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</li><li>LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。</li></ul></li></ol></li><li><p>缓存位置</p><ol><li><p>浏览器</p><blockquote><p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p></blockquote></li><li><p>ISP</p><blockquote><p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p></blockquote></li><li><p>反向代理</p><blockquote><p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p></blockquote></li><li><p>本地缓存</p><blockquote><p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p></blockquote></li><li><p>分布式缓存</p><blockquote><p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。<br>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p></blockquote></li><li><p>数据库缓存</p><blockquote><p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p></blockquote></li><li><p>Java 内部的缓存</p><blockquote><p>Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。</p></blockquote></li><li><p>CPU 多级缓存</p><blockquote><p>CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。</p></blockquote></li></ol></li><li><p>CDN</p><blockquote><p>内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户</p></blockquote><p>优点</p><ul><li>更快地将数据分发给用户；</li><li>通过部署多台服务器，从而提高系统整体的带宽性能；</li><li>多台服务器可以看成是一种冗余机制，从而具有高可用性。</li></ul></li><li><p>缓存问题</p><ol><li><p>缓存穿透</p><blockquote><p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p></blockquote><p>解决方案：</p><ul><li>对这些不存在的数据缓存一个空数据；</li><li>对这类请求进行过滤。</li></ul></li><li><p>缓存雪崩</p><blockquote><p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。<br>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p></blockquote><p>解决方案：</p><ul><li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li><li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li><li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li></ul></li><li><p>缓存一致性</p><blockquote><p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p><p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p></blockquote><p>解决方案：</p><ul><li>在数据更新的同时立即去更新缓存；</li><li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li></ul></li><li><p>缓存 “无底洞” 现象</p><blockquote><p>指的是为了满足业务要求添加了大量缓存节点，但是性 能不但没有好转反而下降了的现象。<br>产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。</p></blockquote><p>解决方案：</p><ul><li>优化批量数据操作命令；</li><li>减少网络通信次数；</li><li>降低接入成本，使用长连接 / 连接池，NIO 等。</li></ul></li></ol></li><li><p>数据分布</p><ol><li><p>哈希分布</p><blockquote><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p><p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移</p></blockquote></li><li><p>顺序分布</p><blockquote><p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上</p></blockquote><p>顺序分布相比于哈希分布的主要优点</p><ul><li>能保持数据原有的顺序；</li><li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大</li></ul></li></ol></li><li><p>一致性哈希</p><blockquote><p>Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题</p></blockquote><ol><li><p>基本原理</p><blockquote><p>将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上</p><p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点</p></blockquote></li><li><p>虚拟节点</p><blockquote><p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。</p><p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。</p><p>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀</p></blockquote></li></ol></li><li><p>LRU</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：</span><span class="token comment" spellcheck="true">// 访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。</span><span class="token comment" spellcheck="true">// 为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRU</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Iterable</span><span class="token operator">&lt;</span>K<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Node head<span class="token punctuation">;</span>    <span class="token keyword">private</span> Node tail<span class="token punctuation">;</span>    <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> Node<span class="token operator">></span> map<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> maxSize<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        Node pre<span class="token punctuation">;</span>        Node next<span class="token punctuation">;</span>        K k<span class="token punctuation">;</span>        V v<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>K k<span class="token punctuation">,</span> V v<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>k <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>v <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre></li></ol><pre><code>   public LRU(int maxSize) &#123;       this.maxSize = maxSize;       this.map = new HashMap&lt;&gt;(maxSize * 4 / 3);       head = new Node(null, null);       tail = new Node(null, null);       head.next = tail;       tail.pre = head;   &#125;   public V get(K key) &#123;       if (!map.containsKey(key)) &#123;           return null;       &#125;       Node node = map.get(key);       unlink(node);       appendHead(node);       return node.v;   &#125;   public void put(K key, V value) &#123;       if (map.containsKey(key)) &#123;           Node node = map.get(key);           unlink(node);       &#125;       Node node = new Node(key, value);       map.put(key, node);       appendHead(node);       if (map.size() &gt; maxSize) &#123;           Node toRemove = removeTail();           map.remove(toRemove.k);       &#125;   &#125;   private void unlink(Node node) &#123;       Node pre = node.pre;       Node next = node.next;       pre.next = next;       next.pre = pre;       node.pre = null;       node.next = null;   &#125;   private void appendHead(Node node) &#123;       Node next = head.next;       node.next = next;       next.pre = node;       node.pre = head;       head.next = node;   &#125;   private Node removeTail() &#123;       Node node = tail.pre;       Node pre = node.pre;       tail.pre = pre;       pre.next = tail;       node.pre = null;       node.next = null;       return node;   &#125;   @Override   public Iterator&lt;K&gt; iterator() &#123;       return new Iterator&lt;K&gt;() &#123;           private Node cur = head.next;           @Override           public boolean hasNext() &#123;               return cur != tail;           &#125;           @Override           public K next() &#123;               Node node = cur;               cur = cur.next;               return node.k;           &#125;       &#125;;   &#125;</code></pre><p>   }</p><pre><code>### 3.5 消息队列#### 3.5.1 消息模型1. 点对点&gt; 消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次2. 发布/订阅&gt; 消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费3. 发布与订阅模式和观察者模式有以下不同* 观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信* 观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回#### 3.5.2 使用场景1. 异步处理&gt; 发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理2. 流量削锋&gt; 在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。&gt;&gt; 可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。3. 应用解耦&gt; 如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。&gt;&gt; 通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用#### 3.5.3 可靠性1. 发送端的可靠性&gt; 发送端完成操作后一定能将消息成功发送到消息队列中。&gt;&gt; 实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传2. 接收端的可靠性&gt; 接收端能够从消息队列成功消费一次消息实现方式* 保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。* 保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。### 3.6 攻击防御1. 跨站脚本攻击&gt; 跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript危害* 窃取用户的 Cookie* 伪造虚假的输入表单骗取个人信息* 显示伪造的文章或者图片防御* 设置 Cookie 为 HttpOnly  &gt; 设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息* 过滤特殊字符  &gt; 例如将 `&lt;` 转义为 `&amp;lt;`，将 `&gt;` 转义为 `&amp;gt;`，从而避免 HTML 和 Jascript 代码的运行。  &gt;  &gt; 富文本编辑器允许用户输入 HTML 代码，就不能简单地将 `&lt;` 等字符进行过滤了，极大地提高了 XSS 攻击的可能性。  &gt;  &gt; 富文本编辑器通常采用 XSS filter 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。2. 跨站请求伪造&gt; 跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。&gt;&gt; XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任&gt;&gt; 攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作防御* 检查 Referer 首部字段  &gt; Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。  &gt;  &gt; 这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能* 添加校验 Token  &gt; 在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数* 输入验证码  &gt; 因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作3. SQL 注入攻击&gt; 服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成防御* 使用参数化查询  &gt; Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生* 单引号转换  &gt; 将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能4. 拒绝服务攻击&gt; 拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问&gt;&gt; 分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击## 4. 工具### 4.1 Git1. 集中式与分布式&gt; Git 属于分布式版本控制系统，而 SVN 属于集中式&gt;&gt; 集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑上就有一份完整的代码&gt;&gt; 集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了&gt;&gt; 集中式版本控制需要连网才能工作，如果网速过慢，那么提交一个文件会慢的无法让人忍受。而分布式版本控制不需要连网就能工作&gt;&gt; 分布式版本控制新建分支、合并分支操作速度非常快，而集中式版本控制新建一个分支相当于复制一份完整代码2. 中心服务器&gt; 中心服务器用来交换每个用户的修改，没有中心服务器也能工作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改&gt;&gt; Github 就是一个中心服务器3. 工作流&gt; 新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库&gt;&gt; Git 的版本库有一个称为 Stage 的暂存区以及最后的 History 版本库，History 存储所有分支信息，使用一个 HEAD 指针指向当前分支操作* git add files 把文件的修改添加到暂存区* git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了* git reset -- files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files* git checkout -- files 使用暂存区的修改覆盖工作目录，用来撤销本地修改可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中* git commit -a 直接把所有文件的修改添加到暂存区然后执行提交* git checkout HEAD -- files 取出最后一次修改，可以用来进行回滚操作4. 分支实现&gt; 使用指针将每个提交连接成一条时间线，HEAD 指针指向当前分支指针&gt;&gt; 新建分支是新建一个指针指向时间线的最后一个节点，并让 HEAD 指针指向新分支，表示新分支成为当前分支&gt;&gt; 每次提交只会让当前分支指针向前移动，而其它分支指针不会移动&gt;&gt; 合并分支也只需要改变指针即可5. 冲突&gt; 当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突&gt;&gt; Git 会使用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ，\=\=\===== ，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突```shell&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</code></pre><ol start="6"><li><p>Fast forward</p><blockquote><p>“快进式合并”（fast-farward merge），会直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息</p><p>可以在合并时加上 –no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit</p></blockquote><pre class=" language-shell"><code class="language-shell">$ git merge --no-ff -m "merge with no-ff" dev</code></pre></li><li><p>储藏（Stashing）</p><blockquote><p>在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也能看到新的修改。这是因为所有分支都共用一个工作区的缘故</p><p>可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的所有修改都会被存到栈中，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了</p></blockquote><pre class=" language-shell"><code class="language-shell">$ git stashSaved working directory and index state \ "WIP on master: 049d078 added the index file"HEAD is now at 049d078 added the index file (To restore them type "git stash apply")</code></pre><blockquote><p>该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master 上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分支并切换到 bug 分支之前就需要使用 git stash 将 dev 分支的未提交修改储藏起来</p></blockquote></li><li><p>SSH 传输设置</p><blockquote><p>Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密</p><p>如果工作区下没有 .ssh 目录，或者该目录下没有 id_rsa 和 id_rsa.pub 这两个文件，可以通过以下命令来创建 SSH Key</p><p>然后把公钥 id_rsa.pub 的内容复制到 Github “Account settings” 的 SSH Keys 中</p></blockquote><pre class=" language-shell"><code class="language-shell">$ ssh-keygen -t rsa -C "youremail@example.com"</code></pre></li><li><p>.gitignore 文件</p><ul><li>操作系统自动生成的文件，比如缩略图；</li><li>编译生成的中间文件，比如 Java 编译产生的 .class 文件；</li><li>自己的敏感信息，比如存放口令的配置文件。</li></ul></li><li><p>Git 命令一览</p><p><img src="https://camo.githubusercontent.com/c91a2b2afab81bacf79151369d88d29d6c71ee65641fcc452e51d8ad95af906e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37613239616363652d663234332d343931342d396630302d6632393838633532383431322e6a7067" alt="img"></p></li></ol><h3 id="4-2-Docker"><a href="#4-2-Docker" class="headerlink" title="4.2 Docker"></a>4.2 Docker</h3><ol><li><p>解决的问题</p><blockquote><p>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。</p><p>Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。</p></blockquote></li><li><p>与虚拟机的比较</p><blockquote><p>虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现</p></blockquote><p>启动速度</p><ul><li>启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢；</li><li>而启动 Docker 相当于启动宿主操作系统上的一个进程。</li></ul><p>占用资源</p><ul><li>虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU 资源，一台机器只能开启几十个的虚拟机。</li><li>而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。</li></ul></li><li><p>优势</p><blockquote><p>启动速度快以及占用资源少之外</p></blockquote><ul><li><p>更容易迁移</p><blockquote><p>提供一致性的运行环境。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行</p></blockquote></li><li><p>更容易维护</p><blockquote><p>使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易</p></blockquote></li><li><p>更容易扩展</p><blockquote><p>可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。</p></blockquote></li></ul></li><li><p>使用场景</p><ul><li><p>持续集成</p><blockquote><p>持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。<br>Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。</p></blockquote></li><li><p>提供可伸缩的云服务</p><blockquote><p>根据应用的负载情况，可以很容易地增加或者减少 Docker。</p></blockquote></li><li><p>搭建微服务架构</p><blockquote><p>Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。</p></blockquote></li></ul></li><li><p>镜像与容器</p><blockquote><p>镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。</p><p>镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。</p><p>构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。</p></blockquote></li></ol><h3 id="4-3-构建工具"><a href="#4-3-构建工具" class="headerlink" title="4.3 构建工具"></a>4.3 构建工具</h3><ol><li><p>构建工具的作用</p><blockquote><p>构建一个项目通常包含了依赖管理、测试、编译、打包、发布等流程，构建工具可以自动化进行这些操作，从而为我们减少这些繁琐的工作。</p><p>其中构建工具提供的依赖管理能够可以自动处理依赖关系。例如一个项目需要用到依赖 A，A 又依赖于 B，那么构建工具就能帮我们导入 B，而不需要我们手动去寻找并导入。</p><p>在 Java 项目中，打包流程通常是将项目打包成 Jar 包。在没有构建工具的情况下，我们需要使用命令行工具或者 IDE 手动打包。而发布流程通常是将 Jar 包上传到服务器上</p></blockquote></li><li><p>Java 主流构建工具</p><ul><li>Ant 具有编译、测试和打包功能，其后出现的 Maven 在 Ant 的功能基础上又新增了依赖管理功能，而最新的 Gradle 又在 Maven 的功能基础上新增了对 Groovy 语言的支持</li><li>Gradle 和 Maven 的区别是，它使用 Groovy 这种特定领域语言（DSL）来管理构建脚本，而不再使用 XML 这种标记性语言。因为项目如果庞大的话，XML 很容易就变得臃肿</li></ul></li><li><p>Maven</p><blockquote><p>提供了项目对象模型（POM）文件来管理项目的构建</p></blockquote><ul><li><p>仓库</p><blockquote><p>仓库的搜索顺序为：本地仓库、中央仓库、远程仓库</p></blockquote><ul><li>本地仓库用来存储项目的依赖库；</li><li>中央仓库是下载依赖库的默认位置；</li><li>远程仓库，因为并非所有的依赖库都在中央仓库，或者中央仓库访问速度很慢，远程仓库是中央仓库的补充</li></ul></li><li><p>POM文件</p><blockquote><p>POM 代表项目对象模型，它是一个 XML 文件，保存在项目根目录的 pom.xml 文件中</p><p>[groupId, artifactId, version, packaging, classifier] 称为一个项目的坐标，其中 groupId、artifactId、version 必须定义，packaging 可选（默认为 Jar），classifier 不能直接定义的，需要结合插件使用</p></blockquote><ul><li>说明<ul><li>groupId：项目组 Id，必须全球唯一；</li><li>artifactId：项目 Id，即项目名；</li><li>version：项目版本；</li><li>packaging：项目打包方式。</li></ul></li></ul></li><li><p>依赖原则</p><ul><li><p>依赖路径最短优先原则</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 由于 X(2.0) 路径最短，所以使用 X(2.0)</span>A <span class="token operator">-</span><span class="token operator">></span> B <span class="token operator">-</span><span class="token operator">></span> C <span class="token operator">-</span><span class="token operator">></span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span>A <span class="token operator">-</span><span class="token operator">></span> D <span class="token operator">-</span><span class="token operator">></span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span></code></pre></li><li><p>声明顺序优先原则</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 在 POM 中最先声明的优先，上面的两个依赖如果先声明 B，那么最后使用 X(1.0)</span>A <span class="token operator">-</span><span class="token operator">></span> B <span class="token operator">-</span><span class="token operator">></span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span>A <span class="token operator">-</span><span class="token operator">></span> C <span class="token operator">-</span><span class="token operator">></span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span></code></pre></li><li><p>覆写优先原则</p><blockquote><p>子 POM 内声明的依赖优先于父 POM 中声明的依赖</p></blockquote></li></ul></li><li><p>解决依赖冲突</p><blockquote><p>找到 Maven 加载的 Jar 包版本，使用 <code>mvn dependency:tree</code> 查看依赖树，根据依赖原则来调整依赖在 POM 文件的声明顺序</p></blockquote></li></ul></li></ol><h3 id="4-4-正则"><a href="#4-4-正则" class="headerlink" title="4.4 正则"></a>4.4 正则</h3><ol><li><p>概述</p><blockquote><p>正则表达式用于文本内容的查找和替换。</p><p>正则表达式内置于其它语言或者软件产品中，它本身不是一种语言或者软件</p></blockquote></li><li><p>匹配单个字符</p><blockquote><p><strong>.</strong> 可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；</p><p><strong>.</strong> 是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。</p><p>正则表达式一般是区分大小写的，但也有些实现不区分。</p></blockquote></li><li><p>匹配一组字符</p><blockquote><p><strong>[ ]</strong> 定义一个字符集合；</p><p>0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。</p><p><strong>-</strong> 只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；</p><p><strong>^</strong> 在 [ ] 中是取非操作。</p></blockquote><ul><li><p>应用</p><blockquote><p>匹配以 abc 为开头，并且最后一个字母不为数字的字符串</p></blockquote></li><li><p>正则</p><pre><code>abc[^0-9]</code></pre></li></ul></li><li><p>使用元字符</p><ul><li><p>匹配空白字符</p><blockquote><p>\r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n。</p><p>\r\n\r\n 可以匹配 Windows 下的空白行，因为它匹配两个连续的行尾标签，而这正是两条记录之间的空白行</p></blockquote><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>[\b]</td><td>回退（删除）一个字符</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr></tbody></table></li><li><p>匹配特定的字符</p><ul><li><p>数字元字符</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>\d</td><td>数字字符，等价于 [0-9]</td></tr><tr><td>\D</td><td>非数字字符，等价于 [^0-9]</td></tr></tbody></table></li><li><p>字母数字元字符</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>\w</td><td>大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]</td></tr><tr><td>\W</td><td>对 \w 取非</td></tr></tbody></table></li><li><p>空白字符元字符</p><blockquote><p>\x 匹配十六进制字符，\0 匹配八进制，例如 \xA 对应值为 10 的 ASCII 字符 ，即 \n</p></blockquote><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>\s</td><td>任何一个空白字符，等价于 [\f\n\r\t\v]</td></tr><tr><td>\S</td><td>对 \s 取非</td></tr></tbody></table></li></ul></li></ul></li><li><p>重复匹配</p><blockquote><p>和 + 都是贪婪型元字符，会匹配尽可能多的内容。在后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m,n}? </p><p>[\w.] 匹配的是字母数字或者 . ，在其后面加上 + ，表示匹配多次。在字符集合 [ ] 里，. 不是元字符；</p></blockquote><ul><li><strong>+</strong> 匹配 1 个或者多个字符</li><li>* 匹配 0 个或者多个字符</li><li><strong>?</strong> 匹配 0 个或者 1 个字符</li></ul><ul><li><p>应用</p><blockquote><p>匹配邮箱地址</p></blockquote></li><li><p>正则</p><pre><code>[\w.]+@\w+\.\w+</code></pre></li></ul></li><li><p>位置匹配</p><ol><li><p>单词边界</p><blockquote><p><strong>\b</strong> 可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；<strong>\B</strong> 匹配一个不是单词边界的位置。</p><p>\b 只匹配位置，不匹配字符，因此 \babc\b 匹配出来的结果为 3 个字符。</p></blockquote></li><li><p>字符串边界</p><blockquote><p><strong>^</strong> 匹配整个字符串的开头，**$** 匹配结尾。</p><p>^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。</p><p>分行匹配模式（multiline）下，换行被当做字符串的边界。</p></blockquote></li></ol><ul><li><p>应用</p><blockquote><p>匹配代码中以 // 开始的注释行</p></blockquote></li><li><p>正则</p><pre><code>^\s*\/\/.*$</code></pre></li></ul></li><li><p>使用子表达式</p><blockquote><p>使用 <strong>( )</strong> 定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。</p><p>子表达式可以嵌套，但是嵌套层次过深会变得很难理解。</p></blockquote><ul><li><p>应用</p><blockquote><p>匹配 IP 地址</p></blockquote></li><li><p>正则</p><pre><code>((25[0-5]|(2[0-4]\d)|(1\d&#123;2&#125;)|([1-9]\d)|(\d))\.)&#123;3&#125;(25[0-5]|(2[0-4]\d)|(1\d&#123;2&#125;)|([1-9]\d)|(\d))</code></pre></li></ul></li><li><p>回溯引用</p><blockquote><p>回溯引用使用 <strong>\n</strong> 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc</p></blockquote><ul><li><p>应用</p><blockquote><p>匹配 HTML 中合法的标题元素</p></blockquote></li><li><p>正则</p><pre class=" language-html"><code class="language-html">\1 将回溯引用子表达式 (h[1-6]) 匹配的内容，也就是说必须和子表达式匹配的内容一<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>(h[1-6])</span><span class="token punctuation">></span></span>\w*?&lt;\/\1></code></pre></li></ul></li><li><p>替换</p><blockquote><p>需要用到两个正则表达式</p></blockquote><ul><li><p>应用</p><blockquote><p>修改电话号码格式</p></blockquote></li><li><p>正则</p><pre><code>(\d&#123;3&#125;)(-)(\d&#123;3&#125;)(-)(\d&#123;4&#125;)</code></pre></li><li><p>大小写转换</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>\l</td><td>把下个字符转换为小写</td></tr><tr><td>\u</td><td>把下个字符转换为大写</td></tr><tr><td>\L</td><td>把\L 和\E 之间的字符全部转换为小写</td></tr><tr><td>\U</td><td>把\U 和\E 之间的字符全部转换为大写</td></tr><tr><td>\E</td><td>结束\L 或者\U</td></tr></tbody></table></li></ul></li><li><p>前后查找</p><blockquote><p>前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。</p><p>向前查找使用 <strong>?=</strong> 定义，它规定了尾部匹配的内容，这个匹配的内容在 ?= 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 ?&lt;= 定义（注: JavaScript 不支持向后匹配，Java 对其支持也不完善）</p></blockquote><ul><li><p>应用</p><blockquote><p>查找出邮件地址 @ 字符前面的部分</p></blockquote></li><li><p>正则</p><pre><code>\w+(?=@)</code></pre></li></ul></li><li><p>嵌入条件</p><blockquote><p>回溯引用条件：条件为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容</p><p>前后查找条件：条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中</p></blockquote><ul><li><p>应用</p><blockquote><p>回溯引用条件：子表达式 (() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 ) 匹配，也就是匹配右括号</p><p>前后查找条件：?(?=-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \d{5} ，才继续匹配 -\d{4}</p></blockquote></li><li><p>正则</p><pre><code>(\()?abc(?(1)\))\d&#123;5&#125;(?(?=-)-\d&#123;4&#125;)</code></pre></li></ul></li></ol><h2 id="5-网络"><a href="#5-网络" class="headerlink" title="5. 网络"></a>5. 网络</h2><h3 id="5-1-基础"><a href="#5-1-基础" class="headerlink" title="5.1 基础"></a>5.1 基础</h3><h4 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1 概述"></a>5.1.1 概述</h4><ol><li>网络的网络</li><li>ISP</li><li>主机之间的通信方式</li><li>电路交换与分组交换<ol><li>电路交换</li><li>分组交换</li></ol></li><li>时延<ol><li>排队时延</li><li>处理时延</li><li>传输时延</li><li>传播时延</li></ol></li><li>计算机网络体系结构<ol><li>五层协议</li><li>OSI</li><li>TCP/IP</li><li>数据在各层之间的传递过程</li></ol></li></ol><h4 id="5-1-2-物理层"><a href="#5-1-2-物理层" class="headerlink" title="5.1.2 物理层"></a>5.1.2 物理层</h4><ol><li>通信方式</li><li>带通调制</li></ol><h4 id="5-1-3-链路层"><a href="#5-1-3-链路层" class="headerlink" title="5.1.3 链路层"></a>5.1.3 链路层</h4><ol><li>基本问题<ol><li>封装成帧</li><li>透明传输</li><li>差错检测</li></ol></li><li>信道分类<ol><li>广播信道</li><li>点对点信道</li></ol></li><li>信道复用技术<ol><li>频分复用</li><li>时分复用</li><li>统计时分复用</li><li>波分复用</li><li>码分复用</li></ol></li><li>CSMA/CD 协议</li><li>PPP 协议</li><li>MAC 地址</li><li>局域网</li><li>以太网</li><li>交换机</li><li>虚拟局域网</li></ol><h4 id="5-1-4-网络层"><a href="#5-1-4-网络层" class="headerlink" title="5.1.4 网络层"></a>5.1.4 网络层</h4><ol><li>概述</li><li>IP 数据报格式</li><li>IP 地址编址方式<ol><li>分类</li><li>子网划分</li><li>无分类</li></ol></li><li>地址解析协议 ARP</li><li>网际控制报文协议 ICMP<ol><li>Ping</li><li>Traceroute</li></ol></li><li>虚拟专用网 VPN</li><li>网络地址转换 NAT</li><li>路由器的结构</li><li>路由器分组转发流程</li><li>路由选择协议<ol><li>内部网关协议 RIP</li><li>内部网关协议 OSPF</li><li>外部网关协议 BGP</li></ol></li></ol><h4 id="5-1-5-传输层"><a href="#5-1-5-传输层" class="headerlink" title="5.1.5 传输层"></a>5.1.5 传输层</h4><ol><li>UDP 和 TCP 的特点</li><li>UDP 首部格式</li><li>TCP 首部格式</li><li>TCP 的三次握手</li><li>TCP 的四次挥手</li><li>TCP 可靠传输</li><li>TCP 滑动窗口</li><li>TCP 流量控制</li><li>TCP 拥塞控制<ol><li>慢开始与拥塞避免</li><li>快重传与快恢复</li></ol></li></ol><h4 id="5-1-6-应用层"><a href="#5-1-6-应用层" class="headerlink" title="5.1.6 应用层"></a>5.1.6 应用层</h4><ol><li>域名系统</li><li>文件传送协议</li><li>动态主机配置协议</li><li>远程登录协议</li><li>电子邮件协议<ol><li>SMTP</li><li>POP3</li><li>IMAP</li></ol></li><li>常用端口</li><li>Web 页面请求过程<ol><li>DHCP 配置主机信息</li><li>ARP 解析 MAC 地址</li><li>DNS 解析域名</li><li>HTTP 请求页面</li></ol></li></ol><h3 id="5-2-HTTP"><a href="#5-2-HTTP" class="headerlink" title="5.2 HTTP"></a>5.2 HTTP</h3><h4 id="5-2-1-基础概念"><a href="#5-2-1-基础概念" class="headerlink" title="5.2.1 基础概念"></a>5.2.1 基础概念</h4><ol><li>请求和响应报文</li><li>URL</li></ol><h4 id="5-2-2-方法"><a href="#5-2-2-方法" class="headerlink" title="5.2.2 方法"></a>5.2.2 方法</h4><ol><li>GET</li><li>HEAD</li><li>POST</li><li>PUT</li><li>PATCH</li><li>DELETE</li><li>OPTIONS</li><li>CONNECT</li><li>TRACE</li></ol><h4 id="5-2-3-HTTP-状态码"><a href="#5-2-3-HTTP-状态码" class="headerlink" title="5.2.3 HTTP 状态码"></a>5.2.3 HTTP 状态码</h4><ol><li>1XX 信息</li><li>2XX 成功</li><li>3XX 重定向</li><li>4XX 客户端错误</li><li>5XX 服务器错误</li></ol><h4 id="5-2-4-HTTP-首部"><a href="#5-2-4-HTTP-首部" class="headerlink" title="5.2.4 HTTP 首部"></a>5.2.4 HTTP 首部</h4><ol><li>通用首部字段</li><li>请求首部字段</li><li>响应首部字段</li><li>实体首部字段</li></ol><h4 id="5-2-5-具体应用"><a href="#5-2-5-具体应用" class="headerlink" title="5.2.5 具体应用"></a>5.2.5 具体应用</h4><ol><li>连接管理</li><li>Cookie</li><li>缓存</li><li>内容协商</li><li>内容编码</li><li>范围请求</li><li>分块传输编码</li><li>多部分对象集合</li><li>虚拟主机</li><li>通信数据转发</li></ol><h4 id="5-2-6-HTTPS"><a href="#5-2-6-HTTPS" class="headerlink" title="5.2.6 HTTPS"></a>5.2.6 HTTPS</h4><ol><li>加密</li><li>认证</li><li>完整性保护</li><li>HTTPS 的缺点</li></ol><h4 id="5-2-7-HTTP-2-0"><a href="#5-2-7-HTTP-2-0" class="headerlink" title="5.2.7 HTTP/2.0"></a>5.2.7 HTTP/2.0</h4><ol><li>HTTP/1.x 缺陷</li><li>二进制分帧层</li><li>服务端推送</li><li>首部压缩</li></ol><h4 id="5-2-8-HTTP-1-1-新特性"><a href="#5-2-8-HTTP-1-1-新特性" class="headerlink" title="5.2.8 HTTP/1.1 新特性"></a>5.2.8 HTTP/1.1 新特性</h4><h4 id="5-2-9-GET-和-POST-比较"><a href="#5-2-9-GET-和-POST-比较" class="headerlink" title="5.2.9 GET 和 POST 比较"></a>5.2.9 GET 和 POST 比较</h4><ol><li>作用</li><li>参数</li><li>安全</li><li>幂等性</li><li>可缓存</li><li>XMLHttpRequest</li></ol><h3 id="5-3-Socket"><a href="#5-3-Socket" class="headerlink" title="5.3 Socket"></a>5.3 Socket</h3><h4 id="5-3-1-I-O-模型"><a href="#5-3-1-I-O-模型" class="headerlink" title="5.3.1 I/O 模型"></a>5.3.1 I/O 模型</h4><ol><li>阻塞式 I/O</li><li>非阻塞式 I/O</li><li>I/O 复用</li><li>信号驱动 I/O</li><li>异步 I/O</li><li>五大 I/O 模型比较</li></ol><h4 id="5-3-2-I-O-复用"><a href="#5-3-2-I-O-复用" class="headerlink" title="5.3.2 I/O 复用"></a>5.3.2 I/O 复用</h4><ol><li>select</li><li>poll</li><li>比较</li><li>epoll</li><li>工作模式</li><li>应用场景</li></ol><h2 id="6-操作系统"><a href="#6-操作系统" class="headerlink" title="6. 操作系统"></a>6. 操作系统</h2><h3 id="6-1-基础"><a href="#6-1-基础" class="headerlink" title="6.1 基础"></a>6.1 基础</h3><ol><li>基本特征<ol><li>并发</li><li>共享</li><li>虚拟</li><li>异步</li></ol></li><li>基本功能<ol><li>进程管理</li><li>内存管理</li><li>文件管理</li><li>设备管理</li></ol></li><li>系统调用</li><li>宏内核和微内核<ol><li>宏内核</li><li>微内核</li></ol></li><li>中断分类<ol><li>外中断</li><li>异常</li><li>陷入</li></ol></li></ol><h3 id="6-2-进程管理"><a href="#6-2-进程管理" class="headerlink" title="6.2 进程管理"></a>6.2 进程管理</h3><ol><li>进程与线程<ol><li>进程</li><li>线程</li><li>区别</li></ol></li><li>进程状态的切换</li><li>进程调度算法<ol><li>批处理系统</li><li>交互式系统</li><li>实时系统</li></ol></li><li>进程同步<ol><li>临界区</li><li>同步与互斥</li><li>信号量</li><li>管程</li></ol></li><li>经典同步问题<ol><li>哲学家进餐问题</li><li>读者-写者问题</li></ol></li><li>进程通信<ol><li>管道</li><li>FIFO</li><li>消息队列</li><li>信号量</li><li>共享存储</li><li>套接字</li></ol></li></ol><h3 id="6-3-内存管理"><a href="#6-3-内存管理" class="headerlink" title="6.3 内存管理"></a>6.3 内存管理</h3><ol><li>虚拟内存</li><li>分页系统地址映射</li><li>页面置换算法<ol><li>最佳</li><li>最近最久未使用</li><li>最近未使用</li><li>先进先出</li><li>第二次机会算法</li><li>时钟</li></ol></li><li>分段</li><li>段页式</li><li>分页与分段的比较</li></ol><h3 id="6-4-死锁"><a href="#6-4-死锁" class="headerlink" title="6.4 死锁"></a>6.4 死锁</h3><ol><li>必要条件</li><li>处理方法</li><li>鸵鸟策略</li><li>死锁检测与死锁恢复<ol><li>每种类型一个资源的死锁检测</li><li>每种类型多个资源的死锁检测</li><li>死锁恢复</li></ol></li><li>死锁预防<ol><li>破坏互斥条件</li><li>破坏占有和等待条件</li><li>破坏不可抢占条件</li><li>破坏环路等待</li></ol></li><li>死锁避免<ol><li>安全状态</li><li>单个资源的银行家算法</li><li>多个资源的银行家算法</li></ol></li></ol><h3 id="6-5-设备管理"><a href="#6-5-设备管理" class="headerlink" title="6.5 设备管理"></a>6.5 设备管理</h3><ol><li>磁盘结构</li><li>磁盘调度算法<ol><li>先来先服务</li><li>最短寻道时间优先</li><li>电梯算法</li></ol></li></ol><h3 id="6-6-链接"><a href="#6-6-链接" class="headerlink" title="6.6 链接"></a>6.6 链接</h3><ol><li>编译系统</li><li>静态链接</li><li>目标文件</li><li>动态链接</li></ol><h3 id="6-7-Linux"><a href="#6-7-Linux" class="headerlink" title="6.7 Linux"></a>6.7 Linux</h3><h4 id="6-7-1-常用操作以及概念"><a href="#6-7-1-常用操作以及概念" class="headerlink" title="6.7.1 常用操作以及概念"></a>6.7.1 常用操作以及概念</h4><ol><li>快捷键</li><li>求助</li><li>关机</li><li>PATH</li><li>sudo</li><li>包管理工具</li><li>发行版</li><li>VIM 三个模式</li><li>GNU</li><li>开源协议</li></ol><h4 id="6-7-2-磁盘"><a href="#6-7-2-磁盘" class="headerlink" title="6.7.2 磁盘"></a>6.7.2 磁盘</h4><ol><li>磁盘接口</li><li>磁盘的文件名</li></ol><h4 id="6-7-3-分区"><a href="#6-7-3-分区" class="headerlink" title="6.7.3 分区"></a>6.7.3 分区</h4><ol><li>分区表</li><li>开机检测程序</li></ol><h4 id="6-7-4-文件系统"><a href="#6-7-4-文件系统" class="headerlink" title="6.7.4 文件系统"></a>6.7.4 文件系统</h4><ol><li>分区与文件系统</li><li>组成</li><li>文件读取</li><li>磁盘碎片</li><li>block</li><li>inode</li><li>目录</li><li>日志</li><li>挂载</li><li>目录配置</li></ol><h4 id="6-7-5-文件"><a href="#6-7-5-文件" class="headerlink" title="6.7.5 文件"></a>6.7.5 文件</h4><ol><li>文件属性</li><li>文件与目录的基本操作</li><li>修改权限</li><li>默认权限</li><li>目录的权限</li><li>链接</li><li>获取文件内容</li><li>指令与文件搜索</li></ol><h4 id="6-7-6-压缩与打包"><a href="#6-7-6-压缩与打包" class="headerlink" title="6.7.6 压缩与打包"></a>6.7.6 压缩与打包</h4><ol><li>压缩文件名</li><li>压缩指令</li><li>打包</li></ol><h4 id="6-7-7-Bash"><a href="#6-7-7-Bash" class="headerlink" title="6.7.7 Bash"></a>6.7.7 Bash</h4><ol><li>特性</li><li>变量操作</li><li>指令搜索顺序</li><li>数据流重定向</li></ol><h4 id="6-7-8-管道指令"><a href="#6-7-8-管道指令" class="headerlink" title="6.7.8 管道指令"></a>6.7.8 管道指令</h4><ol><li>提取指令</li><li>排序指令</li><li>双向输出重定向</li><li>字符转换指令</li><li>分区指令</li></ol><h4 id="6-7-9-正则表达式"><a href="#6-7-9-正则表达式" class="headerlink" title="6.7.9 正则表达式"></a>6.7.9 正则表达式</h4><ol><li>grep</li><li>printf</li><li>awk</li></ol><h4 id="6-7-10-进程管理"><a href="#6-7-10-进程管理" class="headerlink" title="6.7.10 进程管理"></a>6.7.10 进程管理</h4><ol><li>查看进程</li><li>进程状态</li><li>SIGCHLD</li><li>wait()</li><li>waitpid()</li><li>孤儿进程</li><li>僵尸进程</li></ol><h2 id="7-编码规范"><a href="#7-编码规范" class="headerlink" title="7. 编码规范"></a>7. 编码规范</h2><h3 id="7-1-泛化规范"><a href="#7-1-泛化规范" class="headerlink" title="7.1 泛化规范"></a>7.1 泛化规范</h3><h3 id="7-2-阿里特约"><a href="#7-2-阿里特约" class="headerlink" title="7.2 阿里特约"></a>7.2 阿里特约</h3>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
