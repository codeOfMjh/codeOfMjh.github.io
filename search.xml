<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2020/10/31/java/"/>
      <url>2020/10/31/java/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面试"><a href="#Java面试" class="headerlink" title="Java面试"></a>Java面试</h1><p>[TOC]</p><h2 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1. Java基础"></a>1. Java基础</h2><ol><li><p>抽象类和接口的区别</p><ol><li>抽象类只能单继承，而接口可以多实现</li><li>接口的方法都是public修饰，而抽象类允许私有方法</li><li>jdk8以前接口只能有抽象方法，而抽象类可以有普通和静态方法</li></ol></li><li><p>==和equals的区别</p><ol><li>==是值比较</li><li>equals是比较对象内容是否相同</li><li>在比较自定义类是否相同需要重写equals方法，不然是值比较</li></ol></li><li><p>String</p><ol><li>由final修饰的不可改变的量</li><li>StingBuffer：多线程环境下拼接效率高，有同步锁，所以线程安全</li><li>StringBuilder：单线程环境下拼接效率高，没有同步锁，所以效率最高</li><li>new字符串时首先会在常量池中找，没有就创建两个对象，一个在堆中，一个在常量池中；有就只在堆中创建一个对象</li></ol></li><li><p>final/finaly/finalize区别</p><ol><li>final修饰的量不可改变，修饰的方法不能重写，修饰的类不能被继承</li><li>finaly是异常捕获用于兜底的操作，一般用于释放资源</li><li>finalize是垃圾回收时，被回收对象调用执行的方法</li></ol></li><li><p>Servlet生命周期</p><ol><li>初始化阶段，调用init方法</li><li>响应请求阶段，处理请求</li><li>终止销毁</li></ol></li><li><p>IO</p><ol><li>Block-IO<ol><li>字节流<ol><li>InputStream</li><li>OutputStream</li></ol></li><li>字符流<ol><li>Reader</li><li>Writer</li></ol></li><li>交互方式：同步阻塞式</li></ol></li><li>MonBlock-IO<ol><li>多路复用式的同步非阻塞式IO</li><li>组成<ol><li>Channels<ol><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ol></li><li>Buffers<ol><li>ByteBuffer</li></ol></li><li>Selectors</li></ol></li><li>select，poll，epoll</li></ol></li><li>Asynchronous IO<ol><li>基于事件和回调机制的IO</li><li>基于回调：实现CompletionHandler接口，调用时触发回调函数</li><li>返回Future：通过isDone方法检查是否准备好，通过get方法等待返回数据</li></ol></li><li>Netty</li></ol></li><li><p>异常</p><ol><li>Error：程序无法处理的系统错误，编译器不做检查</li><li>Exception：程序可以处理的异常，捕获后可能恢复<ol><li>!RuntimeException：编译期异常，在编译时必须处理的异常</li><li>RuntimeException：运行时异常</li></ol></li><li>抛出异常：创建异常对象交给运行时系统处理</li><li>捕获异常：寻找合适的异常处理器处理异常，否则终止运行</li><li>finally优于catch块中的return执行，如果finally和catch都有return，则catch中的return会覆盖掉finally中的return值</li><li>异常处理规则<ol><li>具体明确：抛出的异常应能通过异常类名和message准说明异常的类型和异常产生的原因</li><li>提早抛出：尽可能早的发现并抛出异常，便于精确定位问题</li><li>延迟捕获：异常的捕获和处理尽可能的延迟，让掌握更多信息的作用域来处理异常</li></ol></li><li>异常梳理设计原则<ol><li>创建一个异常类继承自RuntimeException异常来统一处理</li><li>其余异常统一转为AppException</li><li>在catch后，抛出自定义异常的子类，并提供足以定位的信息</li><li>由前端接收AppException做统一处理</li></ol></li><li>异常处理消耗性能的地方<ol><li>try-catch块影响JVM优化</li><li>异常对象实例需要保存栈快照等信息，开销较大</li></ol></li></ol></li></ol><h2 id="2-Java集合-容器"><a href="#2-Java集合-容器" class="headerlink" title="2. Java集合(容器)"></a>2. Java集合(容器)</h2><ol><li>List:<ol><li>特点<ol><li>有序可重复</li><li>可以通过索引值来操作元素</li></ol></li><li>实现类<ol><li>ArrayList<ol><li>底层是数组，利用数组的下标进行元素访问</li><li>初始大小为10 ，扩容为原来的0.5倍，扩容是基于数组的复制，比较耗费内存</li><li>查询快，增删慢</li></ol></li><li>LinkedList<ol><li>底层是双向链表，链表存储指向前后节点的引用和元素</li><li>增删快，查询慢</li></ol></li></ol></li></ol></li><li>Map<ol><li>特点<br>1. </li><li>实现类<ol><li>HashMap<ol><li>底层原理<ol><li>1.8之前底层是数组+链表，1.8之后是数组+链表+红黑树</li><li>链表的出现就是解决Hash值相同，由HashCode值决定存放的位置</li><li>链表转为红黑树—当数组长度大于64且链表长度大于8时会将链表转为红黑树</li><li>初始值为16，当负载因子达到0.75时，就会扩容为原来的2倍</li><li>一般用于单线程环境</li></ol></li><li>put流程<ol><li>如果HashMap未被初始化，则先进行初始化</li><li>对key求hash值，然后通过hashcode方法计算下标值</li><li>如果没有hash碰撞，直接放入桶中</li><li>如果有hash碰撞，以链表的方式链接到后面</li><li>如果链表的长度超过8时，就把链表转为红黑树</li><li>如果链表的长度小于6时，就把红黑树转为链表</li><li>如果节点满了，则进行扩容，扩容为原来的2倍后进行重排</li></ol></li><li>减少hash碰撞<ol><li>扰动函数：使元素分布均匀，减少碰撞几率</li><li>使用final对象，这些对象已经重写equals和hashcode方法</li></ol></li><li>扩容<ol><li>基础容量为16，负载因子达到0.75时扩容为原来的2倍</li><li>多线程环境下，调整大小会存在条件竞争，容易造成死锁</li><li>rehashing是比较耗时的过程</li></ol></li><li>解决线程不安全<ol><li>调用Collections的synchronizedMap为HashMap实例对象加锁</li><li>synchronizedMap方法为hashMap实例对象加synchronized锁，锁是mutex互斥锁</li></ol></li></ol></li><li>LinkedHashMap</li><li>TreeMap</li><li>HashTable：线程安全，有同步锁</li></ol></li></ol></li><li>Queue</li><li>Set<ol><li>特点<ol><li>无序，不可重复，但TreeSet有序</li></ol></li><li>实现类<ol><li>HashSet：底层是HashMap，由Hashcode和equals方法保证元素唯一性</li><li>TreeSet：底层是TreeMap，元素有序<ol><li>自然排序：让所属对象的方法实现comparable接口的无参构造</li><li>比较器排序：comparator带参构造</li></ol></li><li>LinkedHashSet</li></ol></li></ol></li><li>JUC<ol><li>CAS是JUC的基础</li><li>AQS是JUC的locks包的基础</li><li>包的分类<ol><li>线程执行器executor</li><li>锁locks</li><li>原子变量atomic</li><li>并发工具类tools<ol><li>闭锁CountDownLatch：让主线程等待一组事件发生后继续执行</li><li>栅栏CyclicBarrier：阻塞当前线程，等待其他线程</li><li>信号量Semaphore：控制某个资源可被同时访问的线程个数</li><li>交换器Exchanger：两个线程达到同步点后，相互交换数据</li></ol></li><li>并发集合Collections<ol><li>BlockingQueue：提供可阻塞的入队和出队操作(都是线程安全的)<ol><li>主要用于生产者-消费者模式：将任务的生产和消费进行隔离</li><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：一个由链表结构组成的有/无界阻塞队列</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li><li>DealyQueue：一个使用优先级队列实现的无界阻塞队列</li><li>SynchronousQueue：一个不存储元素的阻塞队列</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li><li>ConcurrentHashMap<ol><li>JDK8以前：使用更细粒度的锁，由一个Segment数组和多个HashEntry组成，实现了锁分离，即每个元素的锁是不一样的</li><li>JDK8之后：使用CAS++synchronized使锁更细化</li><li>存在于JUC包下，不允许存储null键值</li><li>put逻辑<ol><li>判断Node[]数组是否初始化，没有就先初始化</li><li>通过hash定位数组的索引坐标，是否有node节点，如果没有则使用CAS进行添加(链表的头结点)，添加失败则进入下次循环</li><li>检查内部正在扩容，就帮助它一块扩容</li><li>如果f!=null，则使用synchronized锁住元素(锁是链表/红黑树的头元素)<ol><li>如果Node(链表结构)则执行链表的添加操作</li><li>如果Node(树结构)则执行树的添加操作</li></ol></li><li>判断链表的长度是否达到临界值8(可修改的默认值)，达到8就将链表转为红黑树</li></ol></li><li>锁<ol><li>首先使用无锁操作CAS插入头节点，失败就循环重试</li><li>若已有头节点，则尝试获取头节点的同步锁，再进行操作</li></ol></li><li>Size方法和MappingCount方法异同</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol><h2 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3. 多线程"></a>3. 多线程</h2><ol><li>进程和线程<ol><li>进程<ol><li>是资源分配时的最小单元(独占一块内存，相互之间互不干扰)</li><li>可以看做是独立应用，线程只是进程的不同执行路径</li></ol></li><li>线程<ol><li>是CPU调度的最小单元(共享进程的内存资源，可以更细粒度的控制任务)</li></ol></li><li>进程和线程的关系<ol><li>运行一个程序会产生一个进程，进程至少包含一个线程</li><li>每个进程对应一个JVM实例，多线程共享JVM里的堆</li><li>Java采用单线程编程模型，程序会自动创建主线程</li><li>主线程可以创建子线程，在子线程之后完成执行</li></ol></li></ol></li><li>start和run方法<ol><li>start用于启动线程，而run用于运行线程</li><li>start方法会创建子线程并启动，而run方法是线程的一个普通方法调用</li></ol></li><li>实现线程<ol><li>继承Thread类，而Thread类底层也是实现了Runnable接口</li><li>直接实现Runnable接口，重写run方法</li><li>实现Callable接口，重写call方法</li><li>处理线程的返回值<ol><li>主线程等待法</li><li>使用线程的join方法用以阻塞等待子线程处理完毕</li><li>实现Callable接口，获取call方法的返回值</li><li>通过线程池来获取返回值</li></ol></li></ol></li><li>线程状态<ol><li>新建：创建后还没有启动的线程</li><li>运行：包含正在运行和等待运行的线程</li><li>无限等待：不会被分配CPU执行，需要显示被唤醒</li><li>限期等待：在一定时间后会由系统自动唤醒</li><li>阻塞：等待获取排他锁</li><li>结束：已终止线程的状态，执行结束</li></ol></li><li>等待线程和唤醒线程<ol><li>等待线程<ol><li>wait<ol><li>是Object类中的方法</li><li>只能在synchronized方法或synchronized块中使用</li><li>不仅释放CPU，而且会释放已经占有的同步资源锁</li></ol></li><li>sleep<ol><li>是线程类特有的方法</li><li>可以在任何地方调用</li><li>只会让出cpu，不会导致锁行为的改变</li></ol></li></ol></li><li>唤醒线程<ol><li>池<ol><li>锁池EntryList：等待获取锁的池</li><li>等待池WaitSet：等待线程的池</li></ol></li><li>notify<ol><li>只会随机选取一个处于等待池中的线程进入锁池中去竞争获取锁</li></ol></li><li>notifyAll<ol><li>会让所有处于等待池中的线程全部进入锁池去竞争获取锁</li></ol></li></ol></li><li>函数<ol><li>yield<ol><li>告知线程调度器当前(调用者)线程愿意让出CPU的暗示，但是线程调度器会忽略这个暗示</li><li>不会影响锁的行为(不会使当前线程让出已经占用的锁)</li></ol></li><li>interrupt<ol><li>停止线程：stop方法，suspend方法，resume方法</li><li>调用interrupt如果线程处于阻塞状态，那么线程立即退出阻塞状态，抛出InterruptedException异常</li><li>调用interrupt如果线程处于正常运行，那么会将其中断标志位设置为true，被中断标识的线程仍可以正常运行</li><li>需要被调用interrupt的线程配合中断</li></ol></li></ol></li><li>锁—解决多线程操作共享数据带来的数据不安全<ol><li>互斥锁<ol><li>互斥性：在同一时刻只允许一个线程持有某个对象锁</li><li>可见性：确保在锁被释放前，对共享变量的修改是对后面线程是可见的</li></ol></li><li>同步锁<ol><li>获取对象锁<ol><li>同步代码块，锁 是this</li><li>同步非静态方法，锁是当前对象的实例对象</li></ol></li><li>获取类锁<ol><li>同步代码块，锁是类的字节码文件</li><li>同步静态方法，锁是当前对象的类对象</li></ol></li><li>原理<ol><li>基于Java对象头和Monitor实现</li><li>对象在内存中的布局<ol><li>对象头：Mark Word和Class Metadata Address组成<ol><li>Mark Word：存储对象的运行时数据，默认存储对象的HashCode，分代年龄，锁类型，锁标志位等</li><li>Class Metadata Address：是指针，指向对象的类元数据</li></ol></li><li>Monitor<ol><li>每个Java对象自身存在的内部锁—java对象可以作为锁的原因</li><li>重入：一个线程试图获取自己持有对象锁的临界资源时</li><li>阻塞：一个线程试图获取由其他线程持有的对象锁的临界资源时</li></ol></li><li>实例数据</li><li>对齐填充</li></ol></li><li>早期的synchronized锁<ol><li>属于重量级锁，依赖于Mutex Lock实现</li><li>线程之间的切换需要从用户态转到核心态，开销大</li></ol></li><li>自旋锁：通过让线程忙于循环等待锁的释放，不让出CPU的执行权；若锁被其他线程长时间占用，则会带来许多性能上的开销</li><li>自适应自旋锁：自旋的次数由前一次在同一个锁上自旋的时间以及锁的拥有者状态来决定</li><li>锁消除：JIT在编译时，对运行上下文进行扫描，消除不可能存在竞争的锁</li><li>状态<ol><li>无锁</li><li>偏向锁：减少同一线程获取锁的代价，不适用于锁竞争比较激烈的情况</li><li>轻量级锁</li><li>重量级锁</li><li>锁升级：无锁—偏向锁—轻量级锁—重量级锁</li></ol></li></ol></li></ol></li><li>ReentranLock(重入锁)<ol><li>位于Java.util.concurrent.locks包下</li><li>和CountDownLatch，FutureTask，Semaphore一样基于AQS实现<ol><li>AQS：AbstractQueueSynchronizer</li></ol></li><li>实现比synchronized更细粒度的控制，如fairness(公平锁)<ol><li>公平锁：获取锁的顺序按先后调用lock方法的顺序</li><li>非公平锁：抢占机制，优先度高的抢到的几率大</li></ol></li><li>调用lock方法后，必须调用unlock释放锁</li><li>区分synchronized锁<ol><li>synchronized是关键字，而ReentranLock是类</li><li>ReentranLock可以对锁的等待时间进行设置，避免死锁</li><li>ReentranLock可以获取各种锁的信息，可以灵活的实现多路通知</li><li>synchronized操作的是Mark Word，lock锁操作的是Unsafe类的park方法</li></ol></li></ol></li><li>JMM—Java Memory Model<ol><li>主内存<ol><li>存储Java实例对象</li><li>包括成员变量，类信息，常量，静态变量等</li><li>属于数据共享区域，多线程并发操作时会引发线程安全问题</li></ol></li><li>工作内存<ol><li>存储的是当前方法的所有本地变量信息，本地变量对其他线程不可见</li><li>字节码行号指示器，Native方法信息</li><li>属于线程私有数据区域，不存在线程安全问题</li></ol></li><li>区分Java内存划分<ol><li>JMM描述的是一组规则，围绕原子性，有序性，可见性展开</li><li>同Java内存相似，都存在共享区和私有区</li><li>方法里的基本数据类型和本地变量直接存储在工作内存的栈帧结构中</li><li>引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中</li><li>成员变量：static变量，类信息均会存储在主内存中</li></ol></li><li>指令重排序<ol><li>在单线程情况下不能改变程序运行的结果</li><li>存在数据依赖关系的不允许重排序</li><li>无法通过Happens-before原则推导出来的，才能进行指令重排序<ol><li>A操作的结果需要对B操作可见，则A和B存在happens-before关系</li><li>happens-before的原则<ol><li>程序次序规则：一个线程内，按照代码顺序，先写的代码先执行</li><li>锁定规则：一个unLock操作优先后面对同一个锁的lock操作</li><li>Volatile变量规则：一个变量的写操作优先于后面对这个变量的读操作</li><li>传递规则：如果A操作优于B操作，B操作优于C操作，那么A操作优于C操作</li><li>线程启动规则：Thread对象的start方法优先执行在该线程的每一个动作之前</li><li>线程中断规则：对线程interrupt方法的调用优于被中断线程的代码检测到中断事件前发生</li><li>线程终结规则：线程中所有的操作都优于线程终止检测事件</li><li>对象终结规则：一个对象的初始化完成优于其finalize方法执行</li></ol></li></ol></li></ol></li><li>Volatile<ol><li>JVM提供轻量级同步机制</li><li>由Volatile修饰的共享变量对所有线程总是可见的</li><li>禁止指令的重排序优化<ol><li>内存屏障<ol><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性</li></ol></li><li>通过插入内存屏障指令来禁止在内存屏障前后的指令执行重排序优化</li><li>强制刷出CPU的缓存数据，因此在cpu上的任何线程都能读取到这些数据的最新版本</li></ol></li><li>可见性分析<ol><li>定义一个Volatile变量时，JMM会把该线程对应的工作内存中的共享变量刷新到主内存中</li><li>读取一个Volatile变量时，JMM会把该线程对应的工作内存置为无效</li></ol></li></ol></li><li>Volatile和synchronized的区别<ol><li>Volatile本质是告知JVM当前变量在寄存器(工作内存)中的值不确定需要从主内存中读取，synchronized只是锁定当前变量</li><li>Volatile仅用于变量级别，synchronized可以用在变量，方法，类上</li><li>Volatile不会造成线程阻塞，synchronized会造成线程阻塞</li><li>Volatile标记的变量不会被编译器优化，synchronized标记的变量会被编译器优化</li></ol></li></ol></li><li>CAS(乐观所锁)—一种高效实现线程安全性的方法<ol><li>支持原子更新操作，适用于计数器，序列发生器等场景</li><li>属于乐观锁机制，号称lock-free</li><li>CAS操作失败 后开发者决定是否继续尝试，还是执行别的操作</li><li>包含三个操作数：内存位置，预期原值和新值</li><li>缺点<ol><li>若循环时间长，则开销大</li><li>只能保证一个共享变量的原子操作</li><li>ABA问题—一个变量A改变到B未被检测出来，导致两次读取的值都是A—通过AtomicStampedReference类改变</li></ol></li></ol></li></ol></li><li>线程池<ol><li>Executor接口<ol><li>Executor：运行新任务的简单接口，将任务提交和任务执行细节解耦</li><li>ExecutorService：具备管理执行器和任务生命周期的方法，提交任务 机制更完善</li><li>SchduledExecutorService：支持Future和定时任务</li></ol></li><li>5种不同场景的线程池创建<ol><li>newFixedThreadPool(int nThread)：指定工作线程数量的线程池</li><li>newCachedThreadPool()：短时间处理大量工作任务的线程池</li><li>newSingleThreadExecutor()：创建唯一的工作线程来执行任务，如果该线程一结束，会有另一个线程取代它</li><li>newSingleThreadScheduledExecutor()和newScheduledThreadExecutor(int corePoolSize)：定时或者周期性的工作调度线程池，两个的区别在于单一工作线程还是多线程</li><li>newWorkStealingPool()：内部构建ForkJoinPool，利用working-stealing算法，并行的执行任务，不保证处理顺序<ol><li>Fork/Join框架<ol><li>把大任务分割为有限的小任务执行，把每个小 任务的执行结果汇总得到大任务结果的框架</li></ol></li><li>work-stealing算法：某个线程从其他队列里窃取任务来执行</li></ol></li><li>确定线程池的大小<ol><li>CPU密集型：线程数=核数+1</li><li>IO密集型：线程数=核数*（1+平均等待时间/平均工作时间）</li></ol></li></ol></li><li>优势<ol><li>降低资源的消耗</li><li>提高线程的可管理性</li></ol></li><li>ThreadPoolExecutor构造函数<ol><li>corePoolSize：核心线程数量</li><li>maximunPoolSize：线程不够用时，最多可创建的线程数</li><li>workQueue：任务等待队列</li><li>keepAliveTime：抢占顺序不一定</li><li>ThreadFactory：创建新线程</li><li>Handler：线程池的饱和策略<ol><li>AbortPolicy：直接抛出异常，默认策略</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务，并执行当前任务</li><li>DiscardOldPolicy：丢弃队列中最靠前的任务，并执行当前任务</li><li>DiscardPolicy：直接丢弃任务</li><li>通过实现RejectedExecutorHandler接口来自定义Handler</li></ol></li></ol></li><li>executor流程<ol><li>如果线程数少于corePoolSize，则直接创建新线程来执行任务，即使线程池中其他线程是空闲的</li><li>如果线程池中的线程数量大于等于corePoolSize而小于maximumPoolSize，只有当workQueue满时才去创建新线程处理任务</li><li>如果corePoolSize和maximumPoolSize值相同，则创建的线程池大小固定的，这是如果有新任务，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取出任务并执行</li><li>如果运行的线程数大于等于maximumPoolSize，这时如果workQueue已满，则通过Handler所指定的策略来处理任务</li></ol></li><li>线程池的状态<ol><li>Runing：能够接受新任务提交，也可以处理阻塞队列中的任务</li><li>Shutdown：不在接受新提交的任务，但可以处理存量任务</li><li>Stop：不在接受新提交的任务，也不处理存量任务</li><li>Tidying：所有任务都已终止</li><li>Terminated：terminated方法执行后进入该状态(仅作标识)</li></ol></li></ol></li></ol></li></ol><h2 id="4-JVM"><a href="#4-JVM" class="headerlink" title="4. JVM"></a>4. JVM</h2><ol><li><p>Java跨平台原理</p><ul><li>基于不同平台的JVM实现，即在不同平台安装对应的JDK就能运行Java程序</li></ul></li><li><p>Java反射</p><ul><li>动态获取任意类，对象的属性和方法</li><li>这种在运行状态中动态获取信息以及调用对象方法的特性称为Java的反射机制</li><li>API：getDeclaredMethod(getMethod)：接收方法名，方法名对应的字节码对象</li><li>本质：把Java类中的方法和属性映射为Java对象</li></ul></li><li><p>类加载机制</p><ul><li>虚拟机将class文件加载进内存的行为</li><li>加载流程<ul><li>通过ClassLoader加载class字节码文件，生成class对象</li><li>检查class的正确性和安全性</li><li>为变量分配内存空间和设置初始值</li><li>JVM常量池中的符号引用转为直接引用</li><li>执行类变量赋值和静态代码块</li></ul></li><li>双亲委派机制<ul><li>一个类收到类加载请求时，会将请求委派给父类，如果父类不能加载才由子类去完成加载</li><li>避免同样的字节码文件被加载多次</li></ul></li><li>四种类加载器<ul><li>启动类加载器：用于加载Java的核心类库</li><li>扩展类加载器：用于加载Java的扩展库</li><li>系统类加载器：根据Java的类路径来加载Java类</li><li>用户自定义类加载器：通过继承Classloader类的方式实现</li></ul></li><li>LoaderClass和forName<ul><li>在运行时都能知道该类的属性和方法</li></ul></li></ul></li><li><p>内存结构 </p><ol><li>线程私有<ol><li>虚拟机栈，本地方法栈，程序计数器<ol><li>虚拟机栈<ol><li>Java方法执行的基础</li><li>包含多个栈帧(栈帧用于存储局部变量表，操作数栈，动态链接，方法出口)</li></ol></li><li>本地方法栈<ol><li>和虚拟机栈类似，主要用于标注native方法</li></ol></li><li>程序计数器<ol><li>当前线程所执行的字节码行号指示器(逻辑指示器)</li><li>改变计数器的值来选取下一条所需执行的字节码指令</li><li>和线程是一对一关系(即线程有)</li><li>对Java方法计数，如果是native方法则计数器值undefined</li></ol></li></ol></li></ol></li><li>线程共享<ol><li>堆<ol><li>对象实例的分配区域</li><li>GC管理的主要区域</li><li>JDK7以后常量池存在于堆中，方便GC(之前存在于永久代中，浪费内存)</li></ol></li><li>元空间(MetaSpace)和永久代(PermGen)—是方法区的实现<ol><li>都是用来存储class的相关信息</li><li>元空间使用的本地内存，而永久代使用的是JVM内存，所以元空间替代了永久代</li><li>字符串常量池存在于永久代中，容易出现性能问题和内存溢出</li><li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li><li>永久代为GC带来不必要的复杂性</li></ol></li><li>堆和栈的区别<ol><li>联系：引用对象，数组时，栈里定义变量保存在堆中的地址</li><li>管理方式：栈可以自动释放，堆需要GC</li><li>空间：栈比堆小</li><li>碎片：栈内存产生的碎片远小于堆</li><li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li><li>效率：栈的效率比堆高</li></ol></li></ol></li></ol></li><li><p>GC机制</p><ol><li>没有被其他对象引用时，就判定为垃圾</li><li>垃圾判定算法<ol><li>引用计数法<ol><li>通过判断对象的引用数量来决定对象是否可以被回收</li><li>为每个对象创建一个引用计数器，被引用的计数器值+1，完成引用后计数器值-1</li><li>当引用计数器值为0时，就认定该对象为垃圾</li><li>优点：执行效率高，程序执行受影响小</li><li>缺点：无法检测出循环引用的情况，导致内存泄漏(子类和父类之间循环引用，计数器值就没有为0的情况)</li></ol></li><li>可达性分析算法—基于图论<ol><li>判断对象的引用链是否可达，不可达就认定为垃圾</li><li>GC Root对象<ol><li>虚拟机栈中引用的对象(栈帧中的本地变量表)</li><li>方法区中常量引用的对象</li><li>方法区中静态属性引用的对象</li><li>本地方法栈中JNI(native方法)引用的对象</li><li>活跃线程引用的对象</li></ol></li></ol></li></ol></li><li>垃圾回收算法<ol><li>标记-清除算法<ol><li>标记：从跟集合进行扫描，对存活的对象进行标记</li><li>清除：对堆内存从到尾进行线程遍历，回收不可达的对象</li><li>缺点：产生碎片块多</li></ol></li><li>复制算法<ol><li>分为对象面和空闲面</li><li>对象在对象面上创建</li><li>将存活的对象从对象面复制到空闲面</li><li>将对象面的所有对象从内存中清除</li><li>优点<ol><li>解决碎片化问题</li><li>顺序分配内存，简单高效</li><li>适用于对象存活率低的场景(如年轻代)</li></ol></li></ol></li><li>标记-整理算法<ol><li>标记：从跟集合进行扫描，对存活的对象进行标记</li><li>整理：移动所有存活的对象，且按照内存地址依次排序，然后将末端内存地址以后的内存全部回收</li></ol></li><li>分代收集算法<ol><li>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法，提高了JVM的回收效率</li><li>JDK8以前分为年轻代，老年代，永久代；JDK8开始取消永久代</li><li>Minor GC发生在年轻代中的收集动作，采用的是复制算法<ol><li>尽可能快速的收集哪些生命周期短的对象</li><li>主要分为Eden区和两个Survivor区(包含一个from区和to区)[Eden:from:to=8:1:1]</li><li>每次触发GC后存活的对象年龄值+1，默认是15岁后进入老年代</li></ol></li><li>Full GC<ol><li>经历一定次数(默认是15次)的Minor GC后依然存活的对象开始进入老年代</li><li>Survivor区存放不下的大对象直接进入老年代</li><li>发生在老年代的收集动作，存放生命周期较长的对象；采用标记-清除算法和标记-整理算法</li><li>触发Full GC<ol><li>老年代和永久代空间不足</li><li>CMS GC时出现promotion failed，concurrent mode failure</li><li>Minor GC升级老年代的平均大小大于老年代的剩余空间</li><li>调用System.gc()方法—只是提醒虚拟机需要在这里进行回收，具体的回收操作由虚拟机自己决定</li><li>通过RMI来进行RPC或管理JDK引用，默认每1小时进行一次Full GC</li></ol></li></ol></li></ol></li><li>调优参数<ol><li>-XX:SurvivorRatio：设置Eden和Survivor的比值，默认是8:1</li><li>-XX:NewRatio：设置老年代和年轻代内存大小的比例</li><li>-XX:MaxTenuringThreshold：对象从年轻代升级为老年代需要出发Minor GC的次数</li></ol></li><li>Stop_the_World<ol><li>JVM由于要执行GC而停止了应用程序的执行</li><li>任何一种GC都会发生</li><li>通过避免减少Stop_the_World的发生时间来提高程序性能</li></ol></li><li>Safepoint(安全点)<ol><li>触发GC的快照点</li><li>分析过程中对象引用关系不会产生变化的点</li><li>Safepoint可能点：方法调用，循环跳转，异常跳转等</li><li>要确保安全点数量适中</li></ol></li></ol></li><li>垃圾收集器<ol><li>新生代垃圾收集器<ol><li>Serial收集器<ol><li>单线程收集，进行垃圾收集时，必须暂停所有的工作线程</li><li>简单高效，Client模式下默认的年轻代收集器</li></ol></li><li>ParNew收集器<ol><li>多线程收集器，其余和Serial相同</li><li>单线程执行效率不如Serial，在多核环境下才有优势</li></ol></li><li>Parallel Scavenge收集器<ol><li>更关注系统的吞吐量</li><li>在多核执行才有优势，Server模式下默认的年轻代收集器</li></ol></li></ol></li><li>老年代垃圾收集器<ol><li>Serial Old收集器<ol><li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li><li>简单高效，Client模式下默认的老年代收集器</li></ol></li><li>Parallel Old收集器<ol><li>多线程，吞吐量优先</li></ol></li><li>CMS收集器<ol><li>初始标记：Stop_the_World</li><li>并发标记：并发追溯标记，程序不会停顿</li><li>并发预清理：查找执行文件并发标记阶段从年轻代晋升老年代的对象</li><li>重新标记：暂停虚拟机，扫描CMS堆中的剩余对象</li><li>并发清理：清理垃圾对象，程序不会停顿</li><li>并发重置：重置CMS收集器的数据结构</li></ol></li><li>Garbage First收集器<ol><li>并发和并行</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li><li>将Java堆内存划分为多个大小相等的Region</li></ol></li><li>finalize方法</li><li>Java中的强引用，软引用，弱引用，虚引用<ol><li>强引用<ol><li>最普遍的引用，抛出OutMemoryError终止程序也不会回收具有强引用的对象</li><li>通过将对象置为null来弱化其引用，使其被回收</li></ol></li><li>软引用<ol><li>对象处于有用但非必须的状态</li><li>只有当空间不足时，GC会回收该引用对象的内存</li><li>用来实现高速缓存</li></ol></li><li>弱引用<ol><li>非必须引用对象，比软引用更弱一些</li><li>GC触发时会被回收</li><li>被回收的几率不大，因为GC线程的优先级比较低</li><li>适用于偶尔使用的对象</li></ol></li><li>虚引用<ol><li>不会决定对象的生命周期</li><li>任何时候都可能会被GC</li><li>用于跟踪垃圾回收器的回收活动，起到哨兵作用</li><li>必须和引用队列联合使用</li></ol></li><li>引用队列<ol><li>没有实际的存储结构，存储逻辑依赖于内部节点之间的关系来表达</li><li>存储关联被GC的软引用，弱引用，以及虚引用</li></ol></li><li>JVM调优<ol><li>调优参数含义<ol><li>-Xss：表示每个虚拟机栈(堆栈)的大小</li><li>-Xms：堆的初始值</li><li>-Xmx：堆能达到的最大值(一般情况下将-Xms和-Xmx值设置相同，避免扩容时的内存抖动而影响程序运行时的稳定性)</li></ol></li><li>内存分配策略<ol><li>静态存储：编译时确定每个数据目标在运行时的存储空间</li><li>栈式存储：数据区在编译时未知，运行时模块入口前确定</li><li>堆式存储：编译时或运行时模块入口都无法确定，动态分配</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li><li><p>内存溢出</p><blockquote><p>程序在申请内存的时候，没有足够的内存供其使用</p></blockquote><ul><li>死循环</li><li>递归</li><li>大对象太多，Java中的大对象是可以直接进入老年代的</li></ul></li><li></li></ol><h2 id="5-MySQL"><a href="#5-MySQL" class="headerlink" title="5. MySQL"></a>5. MySQL</h2><ol><li><p>关系型数据库</p><ul><li>数据库模块<ul><li>存储模块—OS文件系统(将数据持久化存储到硬盘，磁盘中)</li><li>程序实例—用逻辑结构来映射物理结构<ul><li>存储管理</li><li>缓存机制</li><li>sql解析模块</li><li>日志管理</li><li>权限划分</li><li>容灾机制</li><li>索引管理</li><li>锁管理</li></ul></li></ul></li></ul></li><li><p>索引</p><ul><li>作用：提高查询效率</li><li>实例：主键，唯一键(id)，让数据具备一定区分性的字段等可以作为索引</li><li>数据结构<ul><li>生成索引建立二叉树进行二分查找</li><li>生成索引建立B树结构进行查找</li><li>生成索引建立B+树结构进行查找</li><li>生成索引，建立hash结构进行查找</li></ul></li></ul></li><li><p>树结构介绍</p><ul><li>二叉查找树<ul><li>查询效率：O(logn)</li><li>左子树：左子树节点值均小于根节点值</li><li>右子树：右子树节点值均大于根节点值</li><li>注意：二叉树在有限次增删改之后会变成线性结构，此时查询效率为O(n)</li><li>解决：利用树的旋转特性，将二叉树转为平衡二叉树，这样查询效率会维持在O(logn)</li><li>平衡二叉树：大数据量情况下，由于每个节点只能有两个叶子节点，大大增加了树的层级和存储空间；会浪费大量的磁盘IO</li></ul></li><li>B树<ul><li>一种多路平衡查找树，每个节点最多有M个子节点，称为M阶B树，但至少有两个子节点</li><li>查询效率O(logn)</li></ul></li><li>B+树<ul><li>每个叶子节点的指针数和关键字数相同，同阶的B+树比B树能存储更多的关键字</li><li>优势<ul><li>磁盘读写代价更低</li><li>查询效率更为稳定</li><li>更有利于数据库的扫描(B+树只需遍历所有的叶子节点就能对全部的关键字进行扫描)</li></ul></li></ul></li><li>Hash索引<ul><li>根据Hash函数计算一次便能找到所需元素</li><li>仅仅满足=，in等等值查询，不能使用范围查询</li><li>不能进行排序操作，因为经过Hash运算后的值和运算前的键值对应，而查找是Hash索引对应的值，不能匹配到</li><li>不能避免全表 扫描</li></ul></li><li>BitMap<ul><li>仅Oracle支持</li><li>锁的粒度较大，新增和修改操作时，在同一位图的数据操作都会被阻塞</li></ul></li></ul></li><li><p>密集索引和稀疏索引</p><ul><li>密集索引：每个搜索码值都对应一个索引值</li><li>稀疏索引：只为索引码的某些值建立索引项</li></ul></li><li><p>InnoDB</p><ul><li>若一个主键被定义，则该主键则作为密集索引</li><li>若无主键定义，则该表第一个唯一非空索引值作为密集索引</li><li>若无以上，innodb内部会生成一个隐藏主键(密集索引)</li><li>数据和索引是存储在一起的，MyIsAM数据和索引是分开的</li></ul></li><li><p>优化步骤</p><ol><li>根据慢查询日志定位慢查询sql<ol><li>变量<ol><li>慢查询日志：slow_query_log</li><li>慢查询文件路径：slow_query_log_file</li><li>慢查询时间：long_query_time</li><li>开启慢查询日志：set global slow_query_log = on;</li></ol></li><li>状态<ol><li>slow_queries：慢查询数量</li></ol></li></ol></li><li>使用explain等工具分析 sql<ol><li>type：查找数据行的方式，index(索引)&gt;all(全表扫描)</li><li>extra：Using filesort和Using temporary意味着不走索引，应该进行优化</li></ol></li><li>修改sql或者尽量让sql走索引<ol><li>修改sql走索引</li><li>为查询字段添加索引</li></ol></li></ol></li><li><p>原则</p><ul><li> 最左前缀匹配原则，mysql会一直向右匹配，直到范围限定，如果范围之间有索引，则只有第一个条件会走索引，其他不会走索引</li><li> =和in查询无需考虑索引顺序</li></ul></li></ol><p>索引相当于目录在书中的地位，内容远远多于目录时才适合建立。</p><ol><li><p>锁</p><ul><li><p>MyIsAM和InnoDB锁的区别</p><ul><li>MyIsAM默认使用表级锁，不支持行级锁</li><li>InnoDB默认使用行级锁，也支持表级锁</li></ul></li><li><p>排他锁和共享锁的区别</p><table><thead><tr><th></th><th>排他锁</th><th>共享锁</th></tr></thead><tbody><tr><td>排他锁</td><td>冲突</td><td>冲突</td></tr><tr><td>共享锁</td><td>冲突</td><td>兼容</td></tr></tbody></table></li><li><p>乐观锁和悲观锁</p></li><li><p>MyIsAM和InnoDB使用场景</p><ul><li>MyIsAM<ul><li>频繁的执行全表count语句</li><li>对数据进行增删频率不高，查询频率非常高</li><li>没有事务</li></ul></li><li>InnoDB<ul><li>数据增删改查的频率都非常频繁</li><li>可靠性要求比较高，要求支持事务</li></ul></li></ul></li><li><p>当前读和快照读</p></li><li><p>RC，RR级别下的InnoDB非阻塞读实现</p><ul><li>RR避免幻读，加行锁+Gap锁(gap锁用于非唯一索引和不走索引时)</li></ul></li></ul></li><li><p>事务的四大特性</p><ul><li>ACID</li><li>原子性，一致性，隔离性，持久性</li><li>隔离级别<ul><li>读已提交(RC)—解决脏读：一个事物读到另一个事务未提交的数据</li><li>可重复读(RR)—解决不重复读：一个数据前后两次读到的数据不一致</li><li>串行化—解决幻读：一个事物读到自己未提交的事务</li></ul></li></ul></li><li><p>锁的分类</p><ol><li>读锁又称为共享锁</li><li>写锁又称为排他锁</li><li>共享锁和排他锁，只有两个事务都是共享锁时不冲突</li><li>排他锁：增删改操作</li><li>共享锁：查询操作</li><li>悲观锁：在数据处理过程中将数据锁定，排他锁就是悲观锁的体现；为数据处理的安全性提供保证，同时也增加了产生死锁的机会</li><li>乐观锁：认为一般不会发生冲突，只有在更新数据时才会进行检测，如果冲突就返回错误信息(时间戳或数据版本)</li></ol></li><li><p>RC</p><ol><li>Oracle默认的提交方式</li><li>实现快照读(非阻塞读)<ol><li>数据行必须有DB_TRX_ID，DB_ROLL_PTR，DB_ROW_ID字段</li><li>undo日志</li><li>read view</li></ol></li></ol></li><li><p>RR</p><ol><li>MySQL默认的提交方式</li><li>行锁+gap锁</li><li>gap锁<ol><li>精确查找的时候，所有记录都有对应不会加gap锁</li><li>where条件部分命中，会加gap锁</li><li>用于非唯一索引或不走索引的当前读中</li></ol></li></ol></li><li><p>关键语法</p><ul><li>Group by<ul><li>Select语句中的列名必须为分组用到的列或列函数</li><li>只能是针对同一张表的字段进行分组</li></ul></li><li>having<ul><li>通常和Group By一起使用，where过滤行，having过滤组</li><li>如果省略了where，having的作用和where相同</li></ul></li></ul></li></ol><h2 id="6-Redis"><a href="#6-Redis" class="headerlink" title="6. Redis"></a>6. Redis</h2><ul><li><p>缓存中间件</p><ul><li><p>Memcache：代码层次类似于Hash</p><ul><li>支持简单的数据类型</li><li>不支持数据持久化存储和主从复制，以及分片</li></ul></li><li><p>Redis</p><ul><li>数据类型丰富</li><li>支持数据磁盘持久化和主从复制，以及分片</li><li>每秒100000+QPS，QPS即每秒内查询次数</li></ul></li></ul></li><li><p>为什么Redis速度快</p><ul><li>完全基于内存，没有磁盘IO操作，执行效率高</li><li>数据结构简单，对数据操作也简单</li><li>采用单线程也能处理高并发，多核也可以启动多实例</li><li>使用多了IO复用模型，即非阻塞式IO，采用多路复用函数</li></ul></li></ul><ol><li>数据类型<ul><li>String：基本数据类型，二进制安全</li><li>Hash：String组成的字典，适合存储对象</li><li>List：列表，按照String元素插入顺序排序</li><li>Set：String元素组成的无序集合，通过Hash表现，不允许重复</li><li>Sorted Set：通过分数类为集合中的成员进行从小到大的排序</li><li>HyperLogLog：用于支持存储地理位置信息</li></ul></li><li>大数据查询固定前缀的key<ul><li>使用scan count match key*</li></ul></li><li>分布式锁<ul><li>面临问题<ul><li>互斥性</li><li>安全性</li><li>死锁</li><li>容错</li></ul></li><li>解决<ul><li>使用set方法设置键的过期时间并给键添加一个随机字符，避免键集中过期时造成的卡顿</li></ul></li></ul></li><li>异步队列<ul><li>使用List做为队列，RPush产生消息，LPop消费消息<ul><li>缺点：没有等待队列有值就进行消费</li><li>解决<ol><li>通过应用层引入Sleep机制调用LPop重新消费</li><li>阻塞直到队列有消息或者超时；缺点：只能提供一个消费者消费</li><li>主题订阅模式；缺点：无法保证消息可达性</li></ol></li></ul></li></ul></li><li>持久化方式<ul><li>RDB<ul><li>保存某个时间点的全部数据快照方式，文件小，恢复快，数据丢失风险大</li><li>触发<ul><li>redis.conf文件配置的save m n定时触发</li><li>主从复制，主节点自动触发</li><li>执行Debug Reload时</li><li>执行Shutdown时</li></ul></li></ul></li><li>AOF<ul><li>保存到写状态，文件可读，适合保存增量数据；数据丢失风险小，但文件呢体积较大，恢复时间较长</li></ul></li><li>解决：混合模式—RDB做镜像的全量持久化，而AOF做增量的持久化</li></ul></li><li>主从同步<ul><li>Pipeline：批量执行Redis指令，节省多次IO往返的时间</li><li>同步原理 <ul><li>从节点发送同步命令到主节点</li><li>主节点启动一个后台进程，将Redis中的数据快照保存到文件中</li><li>主节点将保存数据快照期间接收到的写命令缓存起来</li><li>主节点完成文件操作后，将该文件发送给从节点</li><li>使用新的AOF文件替换旧的AOF文件</li><li>主节点将这期间收集的增量命令发送给从节点</li></ul></li></ul></li><li>集群<ul><li>哨兵<ul><li>主从复制的基石，由哨兵们监控集群状态，主节点宕机后根据定义规则选举新的主节点，保证系统的运行</li></ul></li><li>流言协议：在杂乱无章中寻求一致；用于主从切换<ul><li>消息节点向其他节点随机发送消息，最终消息会趋于一致性</li></ul></li><li>原理<ul><li>分片：按照一定规则划分数据，分散存储在多个节点上</li><li>获取：一致性哈希算法，对2^32取模，将hash值空间组成虚拟环</li></ul></li></ul></li></ol><h2 id="7-MongoDB"><a href="#7-MongoDB" class="headerlink" title="7. MongoDB"></a>7. MongoDB</h2><h2 id="8-Mybatis"><a href="#8-Mybatis" class="headerlink" title="8. Mybatis"></a>8. Mybatis</h2><h2 id="9-Spring"><a href="#9-Spring" class="headerlink" title="9. Spring"></a>9. Spring</h2><ol><li>IOC<ol><li>控制反转IOC：Spring最核心的部分，主要是用来创建对象</li><li>依赖注入DI：把第层类作为参数传递给上层类，实现上层对下层的”控制”<ol><li>是IOC的一种特殊实现</li><li>Setter</li><li>Interface</li><li>Constructor</li><li>Annotation</li></ol></li><li>依赖查找DL：IOC的另一种实现</li><li>优势<ol><li>避免在各处使用new来创建类，并且可以做到统一维护</li><li>创建实例的时候不需要了解其中的细节</li></ol></li><li>功能<ol><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调方法</li></ol></li><li>核心接口<ol><li>BeanDefinition：主要用来描述Bean的定义</li><li>BeanDefinitionRegistry：提供向IOC容器注册BeanDefinition对象的方法</li><li>BeanFactory：Spring最核心的接口<ol><li>提供IOC的配置机制</li><li>包含Bean的各种定义，便于实例化Bean</li><li>建立Bean之间的依赖关系</li><li>Bean生命周期的控制</li></ol></li><li>ApplicationContext<ol><li>继承BeanFactory接口，能够管理和装配Bean</li></ol></li></ol></li></ol></li><li>AOP</li></ol><h2 id="10-SpringMVC"><a href="#10-SpringMVC" class="headerlink" title="10. SpringMVC"></a>10. SpringMVC</h2><h2 id="11-Dubbo-zookeeper"><a href="#11-Dubbo-zookeeper" class="headerlink" title="11. Dubbo+zookeeper"></a>11. Dubbo+zookeeper</h2><h2 id="12-SpringCloud"><a href="#12-SpringCloud" class="headerlink" title="12. SpringCloud"></a>12. SpringCloud</h2><h2 id="13-网络基础"><a href="#13-网络基础" class="headerlink" title="13. 网络基础"></a>13. 网络基础</h2><ol><li><p>OSI网络基础</p><ul><li><p>七层模型</p><ul><li>物理层：电子接口通信信道上的原始比特流传输</li><li>数据链路层：将原始比特流转为逻辑传输线路</li><li>网络层：控制子网的运行，分组传输，路由选择</li><li>传输层：保证会话层的数据段有效的到达网络层</li><li>会话层：建立和管理应用层的会话</li><li>表示层：</li></ul></li><li><p>TCP</p><ul><li><p>流程</p><ul><li>面向连接的，可靠的，基于字节流的传输层通信协议</li><li>将应用层的数据流分割为报文段并发送给目标节点的TCP层</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和来检验数据在传输过程中是否有误</li></ul></li><li><p>标识</p><ul><li>URG：紧急指针标志</li><li>ACK：确认序号标志</li><li>PSH：push标志</li><li>PST：重置连接标志</li><li>SYN：同步序号，用于建立连接过程</li><li>FIN：finish标志，用于释放连接</li></ul></li><li><p>三次握手</p><p><img src="E:\最新面试总结\assets\1595725222817.png" alt="1595725222817"></p><ul><li>说明<ul><li>建立连接时，客户端发送syn包到服务器，并进入syn_send状态，等待服务器确认。</li><li>服务器收到syn包，必须确认客户的syn包为接收值+1，同时自己也发送一个syn包，即syn+ack包，此时服务器进入syn_recv状态</li><li>客户端受到服务器的syn+ack包，向服务器发送确认包ack为接收服务的值+1，此时包发送完毕，客户端和服务器端进入restablished状态完成三次握手</li></ul></li></ul></li><li><p>四次挥手</p><p><img src="E:\最新面试总结\assets\1595726230144.png" alt="1595726230144"></p><ul><li>说明<ul><li>客户端发送fin字段来请求关闭连接到服务器，客户端进入fin_wait_1状态</li><li>服务器端接收到fin字段后，发送ack给客户端，确认序号为收到的序号+1，此时服务器进入close_wait状态</li><li>服务器发送fin字段，用来关闭服务器到客户端的数据传送，服务器进入last_ack状态</li><li>客户端收到fin后，进入time_wait状态，向服务器发送ack确认序号为收到序号+1，服务器进入closed状态，完成四次挥手</li></ul></li><li>服务器出现close_wait状态的原因<ul><li>服务器端未进行释放资源的操作</li><li>处理请求的线程配置不合理</li></ul></li></ul></li></ul></li><li><p>UDP</p><ul><li>特点<ul><li>面向非连接，不维护连接状态，支持同时向多个客户端传输相同的消息</li><li>数据包报头只有8个字节，额外开销小</li><li>吞吐量只受限于数据生成的速率，传输速率以及机器性能</li><li>尽最大努力交付，不保证交付的可靠性，不需要维持复杂的连接状态</li><li>面向报文，不对应用程序提交报文信息进行拆分合并</li></ul></li></ul></li><li><p>TCP和UDP对比</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>TCP</td><td>1. 面向连接<br />2. 传输可靠<br />3. 传输有序</td><td>1. 传输速度慢<br />2. 重量级传输协议</td></tr><tr><td>UDP</td><td>1. 传输速度高<br />2. 轻量级传输协议</td><td>1. 面向无连接<br />2. 不保证可靠性<br />3. 不保证有序性</td></tr></tbody></table></li><li><p>TCP的滑动窗口</p><blockquote><p>TCP使用滑动窗口做流量控制与乱序重排</p></blockquote><ul><li>保证TCP的可靠性</li><li>保证TCP的流控特性</li></ul></li></ul></li><li><p>HTTP</p><ul><li><p>特点</p><ul><li>支持客户和服务器模式</li><li>简单快速灵活</li><li>无连接，无状态</li></ul></li><li><p>步骤</p><ul><li>根据DNS解析的域名地址访问服务器</li><li>和服务器之间建立TCP连接(三次握手)</li><li>客户端发送HTTP请求到web服务器</li><li>服务器接收请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>浏览器释放连接(四次挥手)</li></ul></li><li><p>状态码</p><ul><li>200：请求成功</li><li>401：未授权</li><li>403：服务被拒绝</li><li>404：未找到资源</li><li>500：服务器端错误，代码异常</li><li>503：服务器当前不能处理请求，需要等待，常见于服务启动尚未被注册中心发现。</li></ul></li><li><p>get和post的区别</p><table><thead><tr><th></th><th>get</th><th>post</th></tr></thead><tbody><tr><td>HTTP报文</td><td>将请求信息放在URL地址栏中</td><td>放在报文主体中</td></tr><tr><td>数据库</td><td>符合幂等性和安全性</td><td>不符合</td></tr><tr><td>其他</td><td>可以被缓存，被存储</td><td>不可以被缓存存储</td></tr></tbody></table></li></ul><ul><li>cookie和session的区别<ul><li>cookie保存在客户端浏览器相对不安全，大小为4k限制 </li><li>session保存在服务器端相对安全，借助于cookie实现，无大小限制</li></ul></li></ul></li><li><p>HTTPS</p><ul><li>加密<ul><li>对称加密：加密和解密都使用同一个密钥</li><li>非对称加密：加密使用的密钥和解密使用的密钥不同</li><li>哈希算法：将任意长度值的信息转换为固定长度的汉字，算法不可逆，常见的是MD5</li><li>数字签名：证明某个消息或者文件是某人发出/认同的</li></ul></li><li>HTTPS流程<ul><li>浏览器将支持的加密算法信息发送给服务器</li><li>服务器选择一套浏览器支持的加密算法，以证书的形式发送给浏览器</li><li>浏览器验证证书的合法性，并结合证书公钥加密信息发送给服务器</li><li>服务器使用私钥解密信息，验证哈希，加密响应消息发送给浏览器</li><li>浏览器解密响应消息，并对消息验证真假，之后进行加密交互数据</li></ul></li></ul></li><li><p>HTTP和HTTPS区别</p><table><thead><tr><th></th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>证书</td><td>不需要CA证书</td><td>需要到CA申请证书</td></tr><tr><td>传输</td><td>明文传输</td><td>密文传输<br />使用HTTP+加密+认证+完整性保护</td></tr><tr><td>端口</td><td>使用80端口</td><td>使用443端口</td></tr></tbody></table></li><li><p>socket</p><blockquote><p>是TCP/IP协议的抽象，是操作系统对外开放的接口</p></blockquote></li><li><p>Linux</p><ol><li>查找指定文件：find path [options] params</li><li>查找符合条件的文本：grep [options] pattern file</li><li>对文件内容进行统计：awk [options] cmd file</li><li>批量替换文档内容：sed [options] ‘sed command’ filename</li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/10/31/hello-world/"/>
      <url>2020/10/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
