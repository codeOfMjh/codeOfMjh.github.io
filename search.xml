<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>7.examProject</title>
      <link href="2020/11/29/7-examproject/"/>
      <url>2020/11/29/7-examproject/</url>
      
        <content type="html"><![CDATA[<h1 id="慕课Java笔记"><a href="#慕课Java笔记" class="headerlink" title="慕课Java笔记"></a>慕课Java笔记</h1><ul><li><p>笔记架构图</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E7%AC%94%E8%AE%B0%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="笔记架构图"></p></li></ul><h2 id="1-单体项目开发部署"><a href="#1-单体项目开发部署" class="headerlink" title="1. 单体项目开发部署"></a>1. 单体项目开发部署</h2><h3 id="1-1-项目基础搭建"><a href="#1-1-项目基础搭建" class="headerlink" title="1.1 项目基础搭建"></a>1.1 项目基础搭建</h3><h4 id="1-1-1-大型互联网系统架构演变历程"><a href="#1-1-1-大型互联网系统架构演变历程" class="headerlink" title="1.1.1 大型互联网系统架构演变历程"></a>1.1.1 大型互联网系统架构演变历程</h4><h4 id="1-1-2-大型网站的九大特点"><a href="#1-1-2-大型网站的九大特点" class="headerlink" title="1.1.2 大型网站的九大特点"></a>1.1.2 大型网站的九大特点</h4><ol><li>高并发 </li><li>高可用 </li><li>大数据 </li><li>迭代周期短 </li><li>用户量庞大 </li><li>可持续发展 </li><li>安全级别高 </li><li>可弹性、可伸缩</li><li>吞吐量高，响应速度快</li></ol><h4 id="1-1-3-大型网站演变进程"><a href="#1-1-3-大型网站演变进程" class="headerlink" title="1.1.3 大型网站演变进程"></a>1.1.3 大型网站演变进程</h4><ol><li><p>基础形式</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E5%9F%BA%E7%A1%80%E5%BD%A2%E5%BC%8F.png" alt="基础形式"></p></li><li><p>进阶形式</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E8%BF%9B%E9%98%B6%E5%BD%A2%E5%BC%8F.png" alt="进阶形式"></p></li><li><p>单体架构</p><ol><li><p>特点：多个资源部署在同一台服务器上</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="单体架构"></p><ol><li>优点<ol><li>部署方便，开发周期短</li></ol></li><li>缺点<ol><li>容灾性低</li><li>并发数少</li></ol></li></ol></li></ol></li></ol><h4 id="1-1-4-负载均衡"><a href="#1-1-4-负载均衡" class="headerlink" title="1.1.4 负载均衡"></a>1.1.4 负载均衡</h4><ol><li><p>数据的主从分离架构</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84.png" alt="数据的主从分离架构"></p></li><li><p>基于主从复制模式的集群架构</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png" alt="主从复制模式的集群架构"></p></li><li><p>分布式文件系统和数据库</p><ol><li>文件服务器(集群—分布式)<pre><code>1. 特点：多个服务器之间联合存储文件数据</code></pre></li><li>数据库(集群—分布式)<ol><li>特点：多个服务器之间联合存储用户数据</li><li>要注意使用全局唯一的主键，分布式主键</li><li>工商银行建议数据量达到500万的时候进行分表，最差建议700-800万条进行分表操作</li></ol></li></ol></li></ol><h4 id="1-1-5-Java架构师需要具备的技术栈与能力"><a href="#1-1-5-Java架构师需要具备的技术栈与能力" class="headerlink" title="1.1.5 Java架构师需要具备的技术栈与能力"></a>1.1.5 Java架构师需要具备的技术栈与能力</h4><ol><li>前端技术<ol><li>H5，C3，JS，TS，小程序，React</li></ol></li><li>后端技术<ol><li>nginx代理服务器</li><li>微服务(模块服务集群)</li><li>消息队列</li><li>分布式文件系统</li><li>Redis缓存集群</li><li>海量数据搜索</li><li>日志收集</li></ol></li></ol><h4 id="1-1-6-项目演示与单体架构技术选型"><a href="#1-1-6-项目演示与单体架构技术选型" class="headerlink" title="1.1.6  项目演示与单体架构技术选型"></a>1.1.6  项目演示与单体架构技术选型</h4><ol><li>前端技术<ol><li>javascript，h5，css3，jquery，vue</li></ol></li><li>后端技术<ol><li>SpringMVC是框架，SpringBoot是工具</li><li>SpringBoot2.x实现单体架构设计与准备</li><li>SpringBoot是零配置(yml)，集成了Tomcat等多样化的中间件</li></ol></li></ol><h4 id="1-1-7-前后端分离开发模式与项目分层设计原则"><a href="#1-1-7-前后端分离开发模式与项目分层设计原则" class="headerlink" title="1.1.7  前后端分离开发模式与项目分层设计原则"></a>1.1.7  前后端分离开发模式与项目分层设计原则</h4><ol><li><p>MVVM模式</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/MVVM%E6%A8%A1%E5%BC%8F.png" alt="MVVM模式"></p></li><li><p>聚合工程构建与SpringBoot2.1.x结合</p><ol><li><p>Maven管理示意图</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/Maven%E7%AE%A1%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Maven管理示意图"></p><ol><li>聚合工程分为顶级项目(顶级工程，父工程)与子工程，两者之间为继承关系，子工程在maven里称之为模块，模块之间是平级的，可以相互依赖。</li><li>子模块可以使用顶级工程里所有的资源(依赖)，子模块之间如果要使用相互资源，必须构建依赖(构建关系)</li><li>一个顶级工程是可以由多个不同的子工程组合而成</li></ol></li></ol></li><li><p>基于PDMan工具为数据库建模</p><ol><li><p>注意设置为增量模式，全量模式为先删除数据后在新建表创建字段</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/PDMan%E5%B7%A5%E5%85%B7.png" alt="PDMan工具"></p></li></ol></li><li><p>数据库物理外键</p><ol><li>优点<ol><li>数据库的数据完整性</li><li>强调数据的强一致性</li></ol></li><li>缺点<ol><li>降低数据库性能</li><li>不能进行热更新</li><li>不方便分库分表</li></ol></li><li>小结：传统，小型项目物理外键可以存在；但大型项目必须弃用物理外键</li></ol></li></ol><h4 id="1-1-8-SpringBoot项目配置"><a href="#1-1-8-SpringBoot项目配置" class="headerlink" title="1.1.8  SpringBoot项目配置"></a>1.1.8  SpringBoot项目配置</h4><ol><li><p>引入SpringBoot的父级依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--表示项目是一个SpringBoot项目--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span></code></pre></li><li><p>配置项目配置环境</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--项目编码方式--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--JDK版本号--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span></code></pre></li><li><p>引入项目依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--SpringBoot启动插件--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--排除自带的依赖日志插件--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--SpringBoot的web模块，表明该项目是一个web项目--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--SpringBoot配置文件解析，默认解析yml格式的；这个依赖作用是解析其他格式(xml,properties)的配置文件--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-configuration-processor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre></li><li><p>SpringBoot的启动流程</p><ol><li>主线程main中调用SpringApplication的run()方法加载当前类的字节码文件</li><li>run()方法接收项目启动类的字节码文件返回一个SpringBoot上下文对象</li></ol></li></ol><h4 id="1-1-9-整合HikariCP与MyBatis"><a href="#1-1-9-整合HikariCP与MyBatis" class="headerlink" title="1.1.9 整合HikariCP与MyBatis"></a>1.1.9 整合HikariCP与MyBatis</h4><ol><li><p>引入依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--mysql驱动--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--mybatis--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>配置数据源信息</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">############################################################</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># 配置数据源信息</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">############################################################</span><span class="token attr-name">spring</span><span class="token punctuation">:</span><span class="token attr-name">datasource</span><span class="token punctuation">:</span>                           <span class="token attr-value"># 数据源的相关配置</span><span class="token attr-name">type</span><span class="token punctuation">:</span> <span class="token attr-value">com.zaxxer.hikari.HikariDataSource  # 数据源类型：HikariCP</span><span class="token attr-name">driver-class-name</span><span class="token punctuation">:</span> <span class="token attr-value">com.mysql.jdbc.Driver  # mysql驱动</span><span class="token attr-name">url</span><span class="token punctuation">:</span> <span class="token attr-value">jdbc:mysql://MySQL服务器地址:3306/foodie-shop-dev?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect</span><span class="token attr-name">username</span><span class="token punctuation">:</span> <span class="token attr-value">用户名</span><span class="token attr-name">password</span><span class="token punctuation">:</span> <span class="token attr-value">密码</span><span class="token attr-name">hikari</span><span class="token punctuation">:</span><span class="token attr-name">connection-timeout</span><span class="token punctuation">:</span> <span class="token attr-value">30000         # 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQ</span><span class="token attr-name">minimum-idle</span><span class="token punctuation">:</span> <span class="token attr-value">5                   # 最小连接数,没有默认值，等同于10;一般设置为5-10</span><span class="token attr-name">maximum-pool-size</span><span class="token punctuation">:</span> <span class="token attr-value">20             # 最大连接数,默认值是10;一般设置为20</span><span class="token comment" spellcheck="true"># 官方建议将最大值和最小值设置一致</span><span class="token attr-name">auto-commit</span><span class="token punctuation">:</span> <span class="token attr-value">true                 # 自动提交</span><span class="token attr-name">idle-timeout</span><span class="token punctuation">:</span> <span class="token attr-value">600000              # 连接超时的最大时长（毫秒），超时则被释放（retired），默认:10分钟</span><span class="token attr-name">pool-name</span><span class="token punctuation">:</span> <span class="token attr-value">DateSourceHikariCP     # 连接池名字</span><span class="token attr-name">max-lifetime</span><span class="token punctuation">:</span> <span class="token attr-value">1800000             # 连接的生命时长（毫秒），超时而且没被使用则被释放（retired），默认:30分钟</span><span class="token attr-name">connection-test-query</span><span class="token punctuation">:</span> <span class="token attr-value">SELECT 1   # 指定连接的时候的测试sql语句</span><span class="token comment" spellcheck="true">############################################################</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># mybatis 配置</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">############################################################</span><span class="token attr-name">mybatis</span><span class="token punctuation">:</span><span class="token attr-name">type-aliases-package</span><span class="token punctuation">:</span> <span class="token attr-value">com.mjh.mapper        # 所有POJO类所在包路径</span><span class="token attr-name">mapper-locations</span><span class="token punctuation">:</span> <span class="token attr-value">classpath:mapper/*.xml  # mapper映射文件，数据层的资源目录下文件</span></code></pre></li><li><p>MyBatis数据库逆向生成</p><ol><li><p>mybatis-generator-集成了myMapper插件(引入依赖)—pom文件中引入依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--通用Mapper逆向工具--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>tk.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mapper-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>在api模块中添加配置</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">############################################################</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># mybatis mapper 配置</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">############################################################</span><span class="token comment" spellcheck="true"># 通用 Mapper 配置</span><span class="token attr-name">mapper</span><span class="token punctuation">:</span><span class="token attr-name">  mappers</span><span class="token punctuation">:</span> <span class="token attr-value">com.mjh.my.mapper.MyMapper</span><span class="token attr-name">  not-empty</span><span class="token punctuation">:</span> <span class="token attr-value">false        #在进行数据库操作的时候，判断表达式</span><span class="token comment" spellcheck="true">                            #username != null,是否追加username != ''</span><span class="token attr-name">  identity</span><span class="token punctuation">:</span> <span class="token attr-value">MYSQL         #数据库方言</span></code></pre></li></ol></li></ol><h4 id="1-1-10-结合通用Mapper，编写Restful风格Api"><a href="#1-1-10-结合通用Mapper，编写Restful风格Api" class="headerlink" title="1.1.10 结合通用Mapper，编写Restful风格Api"></a>1.1.10 结合通用Mapper，编写Restful风格Api</h4><blockquote><p>是一种通信方式，用于信息传递；是一种无状态的。</p></blockquote><ol><li><p>设计规范</p><ol><li>get：查询资源</li><li>post：保存信息，更新资源</li><li>put：更新资源</li><li>delete：删除资源</li></ol></li><li><p>示例</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/Restful%E9%A3%8E%E6%A0%BC.png" alt="Restful风格"></p></li></ol><h4 id="1-1-11-事务传播详解"><a href="#1-1-11-事务传播详解" class="headerlink" title="1.1.11 事务传播详解"></a>1.1.11 事务传播详解</h4><ol><li>单机版事务传播(propagation)<ol><li>require：使用当前的事务，如果当前没有事务，则自己新建一个事物，子方法必须是运行在一个事物中的；如果当前存在事务，则加入这个事务，成为一个整体。</li><li>supports：如果当前有事务，则使用事务；如果当前没有事务，则不使用事务。</li><li>mandatory：该传播属性强制必须存在一个事物，如果不存在，就抛出异常。</li><li>requires_new：如果当前有事务，则挂起该事务，并且为自己创建一个新事物使用；如果当前没有事务，作用和require相同</li><li>not_supported：如果当前有事务，则把事务挂起，以一种不适用事务的方式去操作数据库</li><li>never：如果当前有事务存在，则抛出异常</li><li>nested：如果当前有事务，则开启事务(嵌套事务)，嵌套事务是独立提交或者回滚的；如果当前没有事务，作用和require相同；但是如果主事务提交，会携带子事务一起提交，如果主事务回滚，则子事务也一起回滚；但子事务异常，主事务可以回滚或不回滚。</li></ol></li><li>SpringBootApplication内置EnableTransactionManagement事务注解源码跟踪</li></ol><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/EnableTransactionManagement%E6%B3%A8%E8%A7%A3.png" alt="EnableTransactionManagement注解"></p><h4 id="1-1-12-用户注册-登录流程详解与功能开发"><a href="#1-1-12-用户注册-登录流程详解与功能开发" class="headerlink" title="1.1.12 用户注册/登录流程详解与功能开发"></a>1.1.12 用户注册/登录流程详解与功能开发</h4><ol><li><p>项目核心功能描述</p><ol><li>用户的注册与登录<ol><li>Cookie和Session</li></ol></li><li>分类设计与实现</li><li>首页商品推荐</li><li>商品的搜索和分页</li><li>商品的详情与评论渲染</li><li>购物车与订单</li><li>微信支付与支付宝支付</li><li>集成Swagger2 生成api文档</li></ol></li><li><p>用户的注册和登录</p><ol><li><p>注册流程</p><ol><li><p>一般流程图示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%A4%BA.png" alt="一般流程图示"></p></li><li><p>邮箱注册流程</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E9%82%AE%E7%AE%B1%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.png" alt="邮箱注册流程"></p></li><li><p>手机号注册登录</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E6%89%8B%E6%9C%BA%E5%8F%B7%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95.png" alt="手机号注册登录"></p></li></ol></li></ol></li><li><p>用户名校验模块</p><ol><li><p>数据访问层注意要点</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mjh.mapper.UsersMapper<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>BaseResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mjh.pojo.Users<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><ol><li>注意namespace的路径是数据访问层接口所在包路径</li><li>注意type类型是需要封装的实体类所在包路径</li><li>注意id是全局唯一的，在使用mybatis生成工具时候要注意修改id使得全局唯一</li></ol></li><li><p>业务逻辑层注意要点</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">public</span> UsersMapper usersMapper<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//校验用户名是否存在</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>SUPPORTS<span class="token punctuation">)</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">queryUsernameIsExist</span><span class="token punctuation">(</span>String username<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//1. 创建用户表在mybatis中的example实例对象</span>    Example userExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Example</span><span class="token punctuation">(</span>Users<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2. 创建实例对象的条件集合</span>    Example<span class="token punctuation">.</span>Criteria userExampleCriteria <span class="token operator">=</span> userExample<span class="token punctuation">.</span><span class="token function">createCriteria</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3. 选取对应方法进行操作</span>    userExampleCriteria<span class="token punctuation">.</span><span class="token function">andEqualTo</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//4. 调用数据层的通用Mapper方法</span>    Users user <span class="token operator">=</span> usersMapper<span class="token punctuation">.</span><span class="token function">selectOneByExample</span><span class="token punctuation">(</span>userExample<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//5. 返回查询状态</span>    <span class="token keyword">return</span> user <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ol><li>一定要对数据访问层进行注入</li><li>Example的使用</li></ol></li><li><p>表现层注意要点</p><ol><li>一定要对业务逻辑层进行注入</li><li>注意方法和类路径的<code>/</code>，以免访问出错</li><li>@RequestParam：表示该参数是一个请求类型的参数</li></ol></li><li><p>app启动类注意要点</p><ol><li><p>一定要添加MapperScan进行数据访问层包扫描</p><p>a. <code>@MapperScan(basePackages = &quot;com.mjh.mapper&quot;)</code></p></li></ol></li></ol></li></ol><h4 id="1-1-13-整合与优化Swagger2文档Api"><a href="#1-1-13-整合与优化Swagger2文档Api" class="headerlink" title="1.1.13 整合与优化Swagger2文档Api"></a>1.1.13 整合与优化Swagger2文档Api</h4><ol><li><p>父工程引入依赖坐标</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- swagger2 配置 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--官方UI依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--第三方UI依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.xiaoymin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>swagger-bootstrap-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>创建Swagger2核心配置类</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//表示该类是一个Spring的配置类</span><span class="token annotation punctuation">@Configuration</span><span class="token comment" spellcheck="true">//开启Swagger2配置</span><span class="token annotation punctuation">@EnableSwagger2</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Swagger2</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// http://localhost:8088/swagger-ui.html 官方API文档访问链接</span>    <span class="token comment" spellcheck="true">// http://localhost:8088/doc.html 第三方API文档访问链接</span>    <span class="token annotation punctuation">@Bean</span> <span class="token comment" spellcheck="true">// 表示是一个Spring的Bean实例</span>    <span class="token comment" spellcheck="true">//配置Swagger2核心配置，docket</span>    <span class="token keyword">public</span> Docket <span class="token function">createRestApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Docket</span><span class="token punctuation">(</span>DocumentationType<span class="token punctuation">.</span>SWAGGER_2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 用于指定api类型为Swagger2</span>            <span class="token punctuation">.</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 用于定义api文档汇总信息</span>            <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">apis</span><span class="token punctuation">(</span>RequestHandlerSelectors                  <span class="token punctuation">.</span><span class="token function">basePackage</span><span class="token punctuation">(</span><span class="token string">"com.mjh.controller"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 指定Controller所在包路径</span>            <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span>PathSelectors<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 所有Controller</span>            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ApiInfo <span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">"欢乐商城 平台接口API"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">contact</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Contact</span><span class="token punctuation">(</span><span class="token string">"mjh"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 文档页标题</span>                                 <span class="token string">"http://www.mjhcode.com"</span><span class="token punctuation">,</span>                                 <span class="token string">"mjh@aliyun.com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 联系人信息</span>            <span class="token punctuation">.</span><span class="token function">description</span><span class="token punctuation">(</span><span class="token string">"专为码农提供的api文档"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 详细信息</span>            <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token string">"1.0.1"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 文档版本号</span>            <span class="token punctuation">.</span><span class="token function">termsOfServiceUrl</span><span class="token punctuation">(</span><span class="token string">"http://www.mjhcode.com"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 网站网址</span>            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="1-1-14-API文档生成工具Swagger2"><a href="#1-1-14-API文档生成工具Swagger2" class="headerlink" title="1.1.14 API文档生成工具Swagger2"></a>1.1.14 API文档生成工具Swagger2</h4><table><thead><tr><th>注解</th><th>作用</th><th>常用属性</th></tr></thead><tbody><tr><td><code>@ApiIgnore</code></td><td>在使用Swagger2生成API文档时忽略该接口</td><td>无</td></tr><tr><td><code>@Api</code></td><td>用于生成api文档说明，一般作用于类上</td><td><code>value</code>和<code>tags</code></td></tr><tr><td><code>@ApiOperation</code></td><td>用于为当前方法生成API文档描述</td><td><code>value</code>，<code>notes</code>和<code>httpMethod</code></td></tr><tr><td><code>@ApiModel</code></td><td>为该类生成的API文档添加描述(一般用于实体类中)</td><td><code>value</code>和<code>description</code></td></tr><tr><td><code>@ApiModelProperty</code></td><td>用于当前属性生成API文档描述(一般用于实体类中)</td><td><code>value</code>，<code>name</code>，<code>example</code>和<code>required</code></td></tr></tbody></table><h4 id="1-1-15-设置跨域配置实现前后端联调"><a href="#1-1-15-设置跨域配置实现前后端联调" class="headerlink" title="1.1.15 设置跨域配置实现前后端联调"></a>1.1.15 设置跨域配置实现前后端联调</h4><ol><li><p>修改前端项目中js目录下的开发环境路径，修改接口服务地址路径为：<code>serviceUrl: &quot;http://localhost:8080&quot;</code></p></li><li><p>创建跨域资源访问配置类</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CorsConfig</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CorsConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 空参构造</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> CorsFilter <span class="token function">corsFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1. 添加cors配置信息</span>        CorsConfiguration configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorsConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        configuration<span class="token punctuation">.</span><span class="token function">addAllowedOrigin</span><span class="token punctuation">(</span><span class="token string">"允许跨域的IP地址:8080"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2. 设置是否发送cookie信息</span>        configuration<span class="token punctuation">.</span><span class="token function">setAllowCredentials</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3. 设置允许请求的方式</span>        configuration<span class="token punctuation">.</span><span class="token function">addAllowedMethod</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 4. 设置允许的header</span>        configuration<span class="token punctuation">.</span><span class="token function">addAllowedHeader</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 5. 为url添加映射路径</span>        UrlBasedCorsConfigurationSource source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UrlBasedCorsConfigurationSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        source<span class="token punctuation">.</span><span class="token function">registerCorsConfiguration</span><span class="token punctuation">(</span><span class="token string">"/**"</span><span class="token punctuation">,</span> configuration<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 6. 返回新的source</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CorsFilter</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="1-1-16-用户登录实现"><a href="#1-1-16-用户登录实现" class="headerlink" title="1.1.16 用户登录实现"></a>1.1.16 用户登录实现</h4><ol><li><p>编写service</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 用于登录</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>SUPPORTS<span class="token punctuation">)</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Users <span class="token function">queryUserForLogin</span><span class="token punctuation">(</span>String username<span class="token punctuation">,</span> String password<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//1. 创建用户表在mybatis中的example实例对象</span>    Example userExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Example</span><span class="token punctuation">(</span>Users<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2. 创建实例对象的条件集合</span>    Example<span class="token punctuation">.</span>Criteria userExampleCriteria <span class="token operator">=</span> userExample<span class="token punctuation">.</span><span class="token function">createCriteria</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3. 选取对应方法进行操作</span>    userExampleCriteria<span class="token punctuation">.</span><span class="token function">andEqualTo</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>    userExampleCriteria<span class="token punctuation">.</span><span class="token function">andEqualTo</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//4. 调用数据层的通用Mapper方法</span>    Users user <span class="token operator">=</span> usersMapper<span class="token punctuation">.</span><span class="token function">selectOneByExample</span><span class="token punctuation">(</span>userExample<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> user<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>编写Controller</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 用于为当前方法生成API文档注释</span><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"用户登录"</span><span class="token punctuation">,</span> notes <span class="token operator">=</span> <span class="token string">"用户登录"</span><span class="token punctuation">,</span> httpMethod <span class="token operator">=</span> <span class="token string">"POST"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/login"</span><span class="token punctuation">)</span><span class="token keyword">public</span> MJHJSONResult <span class="token function">login</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span><span class="token comment" spellcheck="true">/*将前端传递的json数据接收映射为Java类*/</span> UserBO userBO<span class="token punctuation">,</span>                           HttpServletRequest request<span class="token punctuation">,</span>                           HttpServletResponse response    <span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//1. 获取用户信息</span>        String username <span class="token operator">=</span> userBO<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String password <span class="token operator">=</span> userBO<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2. 用户名密码进行非空校验</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span> <span class="token operator">||</span> StringUtils<span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> MJHJSONResult<span class="token punctuation">.</span><span class="token function">errorMsg</span><span class="token punctuation">(</span><span class="token string">"用户名或密码不能为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//4. 对前端密码进行加密，因为数据库密码是密文形式，所以加密后进行比对</span>        String md5Password <span class="token operator">=</span> MD5Utils<span class="token punctuation">.</span><span class="token function">getMD5Str</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//5. 实现登录登录校验</span>        Users user <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">queryUserForLogin</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> md5Password<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//6. 进行返回值校验</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> MJHJSONResult<span class="token punctuation">.</span><span class="token function">errorMsg</span><span class="token punctuation">(</span><span class="token string">"用户不存在或者密码输入错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 7. 将用户关键信息置为null，以免cookie劫持；真实场景要进行加密</span>        user <span class="token operator">=</span> <span class="token function">setUserProperty</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 8. 将用户信息写入cookie中，用于数据回显</span>        CookieUtils<span class="token punctuation">.</span><span class="token function">setCookie</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">,</span> JsonUtils<span class="token punctuation">.</span><span class="token function">objectToJson</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> MJHJSONResult<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="1-1-17-Cookie和Session"><a href="#1-1-17-Cookie和Session" class="headerlink" title="1.1.17 Cookie和Session"></a>1.1.17 Cookie和Session</h4><ol><li>Cookie<ol><li>以键值对的形式存储信息在浏览器中，有大小限制，为4kb</li><li>不能进行跨域，在当前及其父级域名可以取值</li><li>可以设置有效期</li><li>可以设置path</li></ol></li><li>Session<ol><li>基于服务器内存的缓存(非持久化 )，能保存请求会话</li><li>每个session通过sessionid(即调试面板的JSessionid)来区分不同请求</li><li>session可以设置过期时间</li><li>session也可以是键值对形式存在的</li></ol></li></ol><h4 id="1-1-18-整合Log4j打印日志"><a href="#1-1-18-整合Log4j打印日志" class="headerlink" title="1.1.18 整合Log4j打印日志"></a>1.1.18 整合Log4j打印日志</h4><ol><li><p>基于SpringAOP实现</p></li><li><p>实现</p><ol><li><p>引入AOP依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--aspect实现的AOP依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-aop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>在API接口资源目录下添加日志配置文件</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">log4j.rootLogger</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG,stdout,file</span><span class="token attr-name">log4j.additivity.org.apache</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">log4j.appender.stdout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.ConsoleAppender</span><span class="token attr-name">log4j.appender.stdout.threshold</span><span class="token punctuation">=</span><span class="token attr-value">INFO</span><span class="token attr-name">log4j.appender.stdout.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.stdout.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">%-5p %c&amp;#123;1&amp;#125;:%L - %m%n</span><span class="token attr-name">log4j.appender.file</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.DailyRollingFileAppender</span><span class="token attr-name">log4j.appender.file.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.file.DatePattern</span><span class="token punctuation">=</span><span class="token attr-value">'.'yyyy-MM-dd-HH-mm</span><span class="token attr-name">log4j.appender.file.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">%d&amp;#123;yyyy-MM-dd HH:mm:ss&amp;#125; %-5p %c&amp;#123;1&amp;#125;:%L - %m%n</span><span class="token attr-name">log4j.appender.file.Threshold</span><span class="token punctuation">=</span><span class="token attr-value">INFO</span><span class="token attr-name">log4j.appender.file.append</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">log4j.appender.file.File</span><span class="token punctuation">=</span><span class="token attr-value">/workspaces/logs/foodie-api/mylog.log</span></code></pre></li></ol></li></ol><h4 id="1-1-19-通过日志监控Service执行时间"><a href="#1-1-19-通过日志监控Service执行时间" class="headerlink" title="1.1.19 通过日志监控Service执行时间"></a>1.1.19 通过日志监控Service执行时间</h4><ol><li><p>在启动引导类中新增切面类实现</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Aspect</span> <span class="token comment" spellcheck="true">// 声明为Spring的切面类</span><span class="token annotation punctuation">@Component</span> <span class="token comment" spellcheck="true">// 表示该类是一个Spring的组件类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceLogAspect</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 全局日志标签</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger Log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>ServiceLogAspect<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * AOP通知类型：     * 1. 前置通知：在方法调用之前执行     * 2. 后置通知：在方法**正常**调用之后执行     * 3. 环绕通知：在方法调用之前和之后都能执行     * 4. 异常通知：如果在方法调用过程中发生异常，则通知     * 5. 最终通知：在方法调用之后执行     * */</span>    <span class="token comment" spellcheck="true">/*     * @Description // 切面表达式     * 第一处 * 代表方法的返回类型， * 代表所有类型     * 第二处 包名代表AOP监控的类所在的包     * 第三处 .. 代表该包及其子包下的所有类及其方法     * 第四处 * 代表类名，*代表所有类     * 第五处 *(..) 代表类中的所有方法和任意参数；     *        *代表类中的所有方法，..代表方法中的任何参数     * @Param [joinPoint]     * @return java.lang.Object     **/</span>    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"execution(* com.mjh.service.impl..*.*(..))"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">recordTimeLog</span><span class="token punctuation">(</span>ProceedingJoinPoint joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"==== 开始执行 &amp;#123;&amp;#125;.&amp;#123;&amp;#125; ===="</span><span class="token punctuation">,</span> joinPoint<span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 方法开始执行的时间点</span>        <span class="token keyword">long</span> begin <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 开始执行目标方法</span>        Object result <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 方法结束执行的时间点</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行方法耗时</span>        <span class="token keyword">long</span> takeTime <span class="token operator">=</span> end <span class="token operator">-</span> begin<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 进行日志级别输出</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>takeTime <span class="token operator">></span> <span class="token number">3000</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"===== 执行结束，耗时：&amp;#123;&amp;#125; 毫秒 ===="</span><span class="token punctuation">,</span> takeTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>takeTime <span class="token operator">></span> <span class="token number">2000</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"===== 执行结束，耗时：&amp;#123;&amp;#125; 毫秒 ===="</span><span class="token punctuation">,</span> takeTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"===== 执行结束，耗时：&amp;#123;&amp;#125; 毫秒 ===="</span><span class="token punctuation">,</span> takeTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 返回方法对象</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="1-1-20-用户退出登录清空Cookie"><a href="#1-1-20-用户退出登录清空Cookie" class="headerlink" title="1.1.20 用户退出登录清空Cookie"></a>1.1.20 用户退出登录清空Cookie</h4><ol><li><p>在PortController的logout方法中添加移除Cookie的方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 退出登录</span><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"用户退出登录"</span><span class="token punctuation">,</span> notes <span class="token operator">=</span> <span class="token string">"用户退出登录"</span><span class="token punctuation">,</span> httpMethod <span class="token operator">=</span> <span class="token string">"POST"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/logout"</span><span class="token punctuation">)</span><span class="token keyword">public</span> MJHJSONResult <span class="token function">logout</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> String userId<span class="token punctuation">,</span>                            HttpServletRequest request<span class="token punctuation">,</span>                            HttpServletResponse response<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 清除用户信息的相关Cookie</span>    CookieUtils<span class="token punctuation">.</span><span class="token function">deleteCookie</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>response<span class="token punctuation">,</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// todo 用户退出登录需要清空购物车</span>    <span class="token comment" spellcheck="true">// todo 分布式会话中需要清除用户数据</span>    <span class="token keyword">return</span> MJHJSONResult<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="1-1-21-开启MyBatis日志Sql打印"><a href="#1-1-21-开启MyBatis日志Sql打印" class="headerlink" title="1.1.21 开启MyBatis日志Sql打印"></a>1.1.21 开启MyBatis日志Sql打印</h4><ol><li><p>在API接口资源目录下添加如下配置</p><pre class=" language-yml"><code class="language-yml">mybatis:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 开启控制台日志打印</code></pre></li></ol><h3 id="1-2-商品分类搜索购物车模块实现"><a href="#1-2-商品分类搜索购物车模块实现" class="headerlink" title="1.2 商品分类搜索购物车模块实现"></a>1.2 商品分类搜索购物车模块实现</h3><h4 id="1-2-1-电商首页轮播图功能开发"><a href="#1-2-1-电商首页轮播图功能开发" class="headerlink" title="1.2.1 电商首页轮播图功能开发"></a>1.2.1 电商首页轮播图功能开发</h4><ol><li><p>数据库表结构</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E8%BD%AE%E6%92%AD%E5%9B%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="轮播图表结构"></p><ol><li>sort字段代表轮播图顺序</li></ol></li><li><p>业务逻辑层书写</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 注入数据访问层</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> CarouselMapper carouselMapper<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 查询所有轮播图</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Carousel<span class="token operator">></span> <span class="token function">queryAllCarousel</span><span class="token punctuation">(</span>Integer isShow<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. 构造Carousel的查询对象</span>    Example example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Example</span><span class="token punctuation">(</span>Carousel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1.1 为轮播图排序;倒序排列</span>    example<span class="token punctuation">.</span><span class="token function">orderBy</span><span class="token punctuation">(</span><span class="token string">"sort"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 创建查询条件</span>    Example<span class="token punctuation">.</span>Criteria criteria <span class="token operator">=</span> example<span class="token punctuation">.</span><span class="token function">createCriteria</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3. 添加查询条件</span>    criteria<span class="token punctuation">.</span><span class="token function">andEqualTo</span><span class="token punctuation">(</span><span class="token string">"isShow"</span><span class="token punctuation">,</span> isShow<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 4. 执行查询</span>    List<span class="token operator">&lt;</span>Carousel<span class="token operator">></span> carouselList <span class="token operator">=</span> carouselMapper<span class="token punctuation">.</span><span class="token function">selectByExample</span><span class="token punctuation">(</span>example<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> carouselList<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>视图展示层书写</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span>  <span class="token comment" spellcheck="true">//首页展示相关</span><span class="token keyword">private</span> CarouselService carouselService<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 用于为当前方法生成API文档注释</span><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"轮播图查询"</span><span class="token punctuation">,</span> notes <span class="token operator">=</span> <span class="token string">"轮播图集合"</span><span class="token punctuation">,</span> httpMethod <span class="token operator">=</span> <span class="token string">"GET"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/carousel"</span><span class="token punctuation">)</span><span class="token keyword">public</span> MJHJSONResult <span class="token function">carousel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//1. 查询所有轮播图列表</span>    List<span class="token operator">&lt;</span>Carousel<span class="token operator">></span> carouselList <span class="token operator">=</span> carouselService<span class="token punctuation">.</span><span class="token function">queryAllCarousel</span><span class="token punctuation">(</span>YesOrNo<span class="token punctuation">.</span>YES<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2. 返回查询结果</span>    <span class="token keyword">return</span> MJHJSONResult<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>carouselList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="1-2-2-首页分类需求分析"><a href="#1-2-2-首页分类需求分析" class="headerlink" title="1.2.2 首页分类需求分析"></a>1.2.2 首页分类需求分析</h4><ol><li>第一次刷新主页查询根分类，渲染展示到首页。</li><li>鼠标移动到跟分类，则加载根分类对应的子分类及其内容；如果子分类已经存在就不需要加载(懒加载)。</li></ol><h5 id="1-2-2-1-分类实现-加载与渲染大分类"><a href="#1-2-2-1-分类实现-加载与渲染大分类" class="headerlink" title="1.2.2.1 分类实现 - 加载与渲染大分类"></a>1.2.2.1 分类实现 - 加载与渲染大分类</h5><ol><li><p>数据库表结构</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E5%88%86%E7%B1%BB%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="分类表结构"></p><ol><li>type字段为分类标识符</li></ol></li><li><p>业务逻辑层编写</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> CategoryMapper categoryMapper<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 查询所有一级分类</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>SUPPORTS<span class="token punctuation">)</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Category<span class="token operator">></span> <span class="token function">queryAllCategory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. 构造Category的查询对象</span>    Example example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Example</span><span class="token punctuation">(</span>Category<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 创建查询条件</span>    Example<span class="token punctuation">.</span>Criteria criteria <span class="token operator">=</span> example<span class="token punctuation">.</span><span class="token function">createCriteria</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3. 添加查询条件 // todo 补充categoryType枚举类</span>    <span class="token keyword">int</span> categoryType <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    criteria<span class="token punctuation">.</span><span class="token function">andEqualTo</span><span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">,</span> categoryType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 4. 执行查询</span>    List<span class="token operator">&lt;</span>Category<span class="token operator">></span> categoryList <span class="token operator">=</span> categoryMapper<span class="token punctuation">.</span><span class="token function">selectByExample</span><span class="token punctuation">(</span>example<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> categoryList<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>视图展示层编写</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span>  <span class="token comment" spellcheck="true">//分类列表相关</span><span class="token keyword">private</span> CategoryService categoryService<span class="token punctuation">;</span><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"获取商品分类(一级分类)"</span><span class="token punctuation">,</span> notes <span class="token operator">=</span> <span class="token string">"获取商品分类(一级分类)"</span><span class="token punctuation">,</span> httpMethod <span class="token operator">=</span> <span class="token string">"GET"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/cats"</span><span class="token punctuation">)</span><span class="token keyword">public</span> MJHJSONResult <span class="token function">category</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Category<span class="token operator">></span> categoryList <span class="token operator">=</span> categoryService<span class="token punctuation">.</span><span class="token function">queryAllCategory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> MJHJSONResult<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>categoryList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><h5 id="1-2-2-2-分类实现-自连接查询子分类"><a href="#1-2-2-2-分类实现-自连接查询子分类" class="headerlink" title="1.2.2.2 分类实现 - 自连接查询子分类"></a>1.2.2.2 分类实现 - 自连接查询子分类</h5><ol><li><p>sql编写</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 根据一级分类查询子分类</span><span class="token keyword">select</span>  <span class="token number">f</span><span class="token punctuation">.</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">as</span> id<span class="token punctuation">,</span>  <span class="token number">f</span><span class="token punctuation">.</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">as</span> name<span class="token punctuation">,</span>  <span class="token number">f</span><span class="token punctuation">.</span><span class="token punctuation">`</span><span class="token keyword">type</span><span class="token punctuation">`</span> <span class="token keyword">as</span> <span class="token keyword">type</span><span class="token punctuation">,</span>  <span class="token number">f</span><span class="token punctuation">.</span><span class="token punctuation">`</span>father_id<span class="token punctuation">`</span> <span class="token keyword">as</span> fatherId<span class="token punctuation">,</span>  <span class="token number">c</span><span class="token punctuation">.</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">as</span> subId<span class="token punctuation">,</span>  <span class="token number">c</span><span class="token punctuation">.</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">as</span> subName<span class="token punctuation">,</span>  <span class="token number">c</span><span class="token punctuation">.</span><span class="token punctuation">`</span><span class="token keyword">type</span><span class="token punctuation">`</span> <span class="token keyword">as</span> subType<span class="token punctuation">,</span>  <span class="token number">c</span><span class="token punctuation">.</span><span class="token punctuation">`</span>father_id<span class="token punctuation">`</span> <span class="token keyword">as</span> subFatherId<span class="token keyword">from</span>  category <span class="token number">f</span>  <span class="token keyword">left</span> <span class="token keyword">join</span> category <span class="token number">c</span>    <span class="token keyword">on</span> <span class="token number">f</span><span class="token punctuation">.</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span><span class="token punctuation">`</span>father_id<span class="token punctuation">`</span><span class="token keyword">where</span> <span class="token number">f</span><span class="token punctuation">.</span><span class="token punctuation">`</span>father_id<span class="token punctuation">`</span> <span class="token operator">=</span> <span class="token number">1</span></code></pre></li></ol><h5 id="1-2-2-3-分类实现-自定义Mapper实现懒加载子分类展示"><a href="#1-2-2-3-分类实现-自定义Mapper实现懒加载子分类展示" class="headerlink" title="1.2.2.3 分类实现 - 自定义Mapper实现懒加载子分类展示"></a>1.2.2.3 分类实现 - 自定义Mapper实现懒加载子分类展示</h5><ol><li><p>数据访问层编写</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--自定义Mapper文件编写--></span><span class="token comment" spellcheck="true">&lt;!--namespace是自定义Mapper的全路径类名--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mjh.mapper.CategoryMapperCustom<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--id属性值和sql中的resultMap值对应        type为查询结果封装类型        Collection为查询类型中的集合类型                --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CategoryVO<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mjh.pojo.vo.CategoryVO<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>type<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>type<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fatherId<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fatherId<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!--Collection 标签：用于定义关联的list集合类型            property：对应三级分类的list属性名和前端调用的参数名相同            ofType：集合的类型，三级分类的VO        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>subCatList<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mjh.pojo.vo.SubCategoryVO<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>subId<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>subId<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>subName<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>subName<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>subType<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>subType<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>subFatherId<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>subFatherId<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--id值和自定义Mapper的方法名相同--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getSubCatList<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CategoryVO<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select        f.`id` as id,        f.`name` as name,        f.`type` as type,        f.`father_id` as fatherId,        c.`id` as subId,        c.`name` as subName,        c.`type` as subType,        c.`father_id` as subFatherId        from        category f        left join        category c        on        f.`id` = c.`father_id`        where        f.`father_id` = #<span class="token entity" title="&#123;">&amp;#123;</span>rootCatId<span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><ol><li><p>注意</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E5%88%86%E7%B1%BB%E6%B3%A8%E6%84%8F.png" alt="分类注意"></p><p>cat是二级分类数组，subCatList必须和Java类的属性名保持一致，否则前端拿不到值</p></li></ol></li><li><p>业务逻辑层编写</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> CategoryMapperCustom categoryMapperCustom<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//查询二级分类及其子分类</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>SUPPORTS<span class="token punctuation">)</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>CategoryVO<span class="token operator">></span> <span class="token function">getSubCateList</span><span class="token punctuation">(</span>Integer rootCatId<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    List subCatList <span class="token operator">=</span> categoryMapperCustom<span class="token punctuation">.</span><span class="token function">getSubCatList</span><span class="token punctuation">(</span>rootCatId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> subCatList<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>视图展示层编写</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 用于为当前方法生成API文档注释</span><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"查询二级分类及其子分类"</span><span class="token punctuation">,</span> notes <span class="token operator">=</span> <span class="token string">"查询二级分类及其子分类"</span><span class="token punctuation">,</span> httpMethod <span class="token operator">=</span> <span class="token string">"GET"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/subCat/&amp;#123;rootCatId&amp;#125;"</span><span class="token punctuation">)</span><span class="token keyword">public</span> MJHJSONResult <span class="token function">getSubCateList</span><span class="token punctuation">(</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"rootCatId"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"一级分类Id"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> Integer rootCatId<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rootCatId <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> MJHJSONResult<span class="token punctuation">.</span><span class="token function">errorMsg</span><span class="token punctuation">(</span><span class="token string">"分类不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>CategoryVO<span class="token operator">></span> subCateList <span class="token operator">=</span> categoryService<span class="token punctuation">.</span><span class="token function">getSubCateList</span><span class="token punctuation">(</span>rootCatId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> MJHJSONResult<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>subCateList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="1-2-3-商品推荐-需求分析与Sql查询"><a href="#1-2-3-商品推荐-需求分析与Sql查询" class="headerlink" title="1.2.3 商品推荐 - 需求分析与Sql查询"></a>1.2.3 商品推荐 - 需求分析与Sql查询</h4><ol><li><p>sql编写</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>  <span class="token number">c</span><span class="token punctuation">.</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> rootCatId<span class="token punctuation">,</span>  <span class="token number">c</span><span class="token punctuation">.</span>name rootCatName<span class="token punctuation">,</span>  <span class="token number">c</span><span class="token punctuation">.</span><span class="token punctuation">`</span>slogan<span class="token punctuation">`</span> slogan<span class="token punctuation">,</span>  <span class="token number">c</span><span class="token punctuation">.</span><span class="token punctuation">`</span>cat_image<span class="token punctuation">`</span> catImage<span class="token punctuation">,</span>  <span class="token number">c</span><span class="token punctuation">.</span><span class="token punctuation">`</span>bg_color<span class="token punctuation">`</span> bgColor<span class="token punctuation">,</span>  i<span class="token punctuation">.</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> itemId<span class="token punctuation">,</span>  i<span class="token punctuation">.</span><span class="token punctuation">`</span>item_name<span class="token punctuation">`</span> itemName<span class="token punctuation">,</span>  ii<span class="token punctuation">.</span><span class="token punctuation">`</span>url<span class="token punctuation">`</span> itemUrl<span class="token punctuation">,</span>  i<span class="token punctuation">.</span><span class="token punctuation">`</span>created_time<span class="token punctuation">`</span> createTime<span class="token keyword">from</span>  category <span class="token number">c</span>  <span class="token keyword">left</span> <span class="token keyword">join</span> items i    <span class="token keyword">on</span> <span class="token number">c</span><span class="token punctuation">.</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token punctuation">`</span>root_cat_id<span class="token punctuation">`</span>  <span class="token keyword">left</span> <span class="token keyword">join</span> items_img ii    <span class="token keyword">on</span> i<span class="token punctuation">.</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token operator">=</span> ii<span class="token punctuation">.</span><span class="token punctuation">`</span>item_id<span class="token punctuation">`</span><span class="token keyword">where</span> <span class="token number">c</span><span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token operator">and</span> i<span class="token punctuation">.</span><span class="token punctuation">`</span>root_cat_id<span class="token punctuation">`</span> <span class="token operator">=</span> <span class="token number">7</span>  <span class="token operator">and</span> ii<span class="token punctuation">.</span><span class="token punctuation">`</span>is_main<span class="token punctuation">`</span><span class="token keyword">order</span> <span class="token keyword">by</span> i<span class="token punctuation">.</span><span class="token punctuation">`</span>created_time<span class="token punctuation">`</span> <span class="token keyword">desc</span><span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span></code></pre></li><li><p>减少表的关联查询，以优化性能</p></li></ol><h5 id="1-2-3-1-商品推荐实现与联调"><a href="#1-2-3-1-商品推荐实现与联调" class="headerlink" title="1.2.3.1 商品推荐实现与联调"></a>1.2.3.1 商品推荐实现与联调</h5><ol><li><p>映射注意点</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E5%95%86%E5%93%81%E6%8E%A8%E8%8D%90%E6%98%A0%E5%B0%84%E6%B3%A8%E6%84%8F%E7%82%B9.png" alt="商品推荐映射注意点"></p><p>封装类的属性值务必和前端调用的属性值保持一致，否则前端拿不到数据</p></li><li><p>两个封装类核心属性</p><pre class=" language-java"><code class="language-java">NewItemsVO <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">private</span> Integer rootCatId<span class="token punctuation">;</span><span class="token keyword">private</span> String rootCatName<span class="token punctuation">;</span><span class="token keyword">private</span> String slogan<span class="token punctuation">;</span><span class="token keyword">private</span> String catImage<span class="token punctuation">;</span><span class="token keyword">private</span> String bgColor<span class="token punctuation">;</span><span class="token keyword">private</span> List<span class="token operator">&lt;</span>SimpleItemVO<span class="token operator">></span> simpleItemList<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>SimpleItemVO <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">private</span> String itemId<span class="token punctuation">;</span><span class="token keyword">private</span> String itemName<span class="token punctuation">;</span><span class="token keyword">private</span> String itemUrl<span class="token punctuation">;</span><span class="token keyword">private</span> String createTime<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这些属性在这里怎么写，前端就必须data.[这里对应的属性名]</span></code></pre></li><li><p>业务逻辑层编写</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//根据一级分类Id查询6条最新商品数据</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>SUPPORTS<span class="token punctuation">)</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>NewItemsVO<span class="token operator">></span> <span class="token function">getSixNewItemsLazy</span><span class="token punctuation">(</span>Integer rootCatId<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"rootCatId"</span><span class="token punctuation">,</span> rootCatId<span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>NewItemsVO<span class="token operator">></span> newItemsLazy <span class="token operator">=</span> categoryMapperCustom<span class="token punctuation">.</span><span class="token function">getSixNewItemsLazy</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> newItemsLazy<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>视图展示层编写</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 用于为当前方法生成API文档注释</span><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"查询一级分类下的最新6条数据"</span><span class="token punctuation">,</span> notes <span class="token operator">=</span> <span class="token string">"查询一级分类下的最新6条数据"</span><span class="token punctuation">,</span> httpMethod <span class="token operator">=</span> <span class="token string">"GET"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/sixNewItems/&amp;#123;rootCatId&amp;#125;"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//注意前端请求的路径必须和这里一致</span><span class="token keyword">public</span> MJHJSONResult <span class="token function">getSixNewItemsLazy</span><span class="token punctuation">(</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"rootCatId"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"一级分类Id"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> Integer rootCatId<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rootCatId <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> MJHJSONResult<span class="token punctuation">.</span><span class="token function">errorMsg</span><span class="token punctuation">(</span><span class="token string">"分类不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>NewItemsVO<span class="token operator">></span> subCateList <span class="token operator">=</span> categoryService<span class="token punctuation">.</span><span class="token function">getSixNewItemsLazy</span><span class="token punctuation">(</span>rootCatId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> MJHJSONResult<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>subCateList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><h5 id="1-2-3-2-商品详情实现与联调"><a href="#1-2-3-2-商品详情实现与联调" class="headerlink" title="1.2.3.2 商品详情实现与联调"></a>1.2.3.2 商品详情实现与联调</h5><ol><li><p>需求分析</p><ol><li><p>商品规格展示</p></li><li><p>商品详情展示</p></li><li><p>点击商品进入详情展示页面只向后端发送一次请求</p></li><li><p>数据库表结构展示</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E7%9B%B8%E5%85%B3%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="商品详情相关表结构"></p></li></ol></li><li><p>注意要点</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85VO%E6%98%A0%E5%B0%84%E6%B3%A8%E6%84%8F.png" alt="商品详情VO映射注意"></p></li></ol><h4 id="1-2-4-商品评价-数据库设计"><a href="#1-2-4-商品评价-数据库设计" class="headerlink" title="1.2.4 商品评价 - 数据库设计"></a>1.2.4 商品评价 - 数据库设计</h4><h5 id="1-2-4-1-商品评价-评论分页实现"><a href="#1-2-4-1-商品评价-评论分页实现" class="headerlink" title="1.2.4.1 商品评价 - 评论分页实现"></a>1.2.4.1 商品评价 - 评论分页实现</h5><h4 id="1-2-5-商品评价-信息脱敏"><a href="#1-2-5-商品评价-信息脱敏" class="headerlink" title="1.2.5 商品评价 - 信息脱敏"></a>1.2.5 商品评价 - 信息脱敏</h4><h4 id="1-2-6-搜索商品-功能详述与Sql编写"><a href="#1-2-6-搜索商品-功能详述与Sql编写" class="headerlink" title="1.2.6 搜索商品 - 功能详述与Sql编写"></a>1.2.6 搜索商品 - 功能详述与Sql编写</h4><h5 id="1-2-6-1-搜索商品-商品搜索功能实现"><a href="#1-2-6-1-搜索商品-商品搜索功能实现" class="headerlink" title="1.2.6.1 搜索商品 - 商品搜索功能实现"></a>1.2.6.1 搜索商品 - 商品搜索功能实现</h5><h5 id="1-2-6-2-搜索商品-前端业务与分类搜索查询"><a href="#1-2-6-2-搜索商品-前端业务与分类搜索查询" class="headerlink" title="1.2.6.2 搜索商品 - 前端业务与分类搜索查询"></a>1.2.6.2 搜索商品 - 前端业务与分类搜索查询</h5><h5 id="1-2-6-3-搜索商品-分类搜索商品查询实现"><a href="#1-2-6-3-搜索商品-分类搜索商品查询实现" class="headerlink" title="1.2.6.3 搜索商品 - 分类搜索商品查询实现"></a>1.2.6.3 搜索商品 - 分类搜索商品查询实现</h5><h4 id="1-2-7-购物车-购物车存储形式"><a href="#1-2-7-购物车-购物车存储形式" class="headerlink" title="1.2.7 购物车 - 购物车存储形式"></a>1.2.7 购物车 - 购物车存储形式</h4><h5 id="1-2-7-1-购物车-未登录已登录加入购物车业务代码讲解"><a href="#1-2-7-1-购物车-未登录已登录加入购物车业务代码讲解" class="headerlink" title="1.2.7.1 购物车 - 未登录已登录加入购物车业务代码讲解"></a>1.2.7.1 购物车 - 未登录已登录加入购物车业务代码讲解</h5><h5 id="1-2-7-2-购物车-渲染-刷新-购物车"><a href="#1-2-7-2-购物车-渲染-刷新-购物车" class="headerlink" title="1.2.7.2 购物车 - 渲染(刷新)购物车"></a>1.2.7.2 购物车 - 渲染(刷新)购物车</h5><h5 id="1-2-7-3-购物车-删除商品业务讲解"><a href="#1-2-7-3-购物车-删除商品业务讲解" class="headerlink" title="1.2.7.3 购物车 - 删除商品业务讲解"></a>1.2.7.3 购物车 - 删除商品业务讲解</h5><h3 id="1-3-地址，订单，支付模块开发"><a href="#1-3-地址，订单，支付模块开发" class="headerlink" title="1.3 地址，订单，支付模块开发"></a>1.3 地址，订单，支付模块开发</h3><h4 id="1-3-1-收货地址-需求分析与表设计"><a href="#1-3-1-收货地址-需求分析与表设计" class="headerlink" title="1.3.1 收货地址 - 需求分析与表设计"></a>1.3.1 收货地址 - 需求分析与表设计</h4><h5 id="1-3-1-1-收货地址-增删改查功能开发"><a href="#1-3-1-1-收货地址-增删改查功能开发" class="headerlink" title="1.3.1.1 收货地址 - 增删改查功能开发"></a>1.3.1.1 收货地址 - 增删改查功能开发</h5><h5 id="1-3-1-2-收货地址-默认收货地址设置"><a href="#1-3-1-2-收货地址-默认收货地址设置" class="headerlink" title="1.3.1.2 收货地址 - 默认收货地址设置"></a>1.3.1.2 收货地址 - 默认收货地址设置</h5><h4 id="1-3-2-确认订单-订单流程梳理与订单状态"><a href="#1-3-2-确认订单-订单流程梳理与订单状态" class="headerlink" title="1.3.2 确认订单 - 订单流程梳理与订单状态"></a>1.3.2 确认订单 - 订单流程梳理与订单状态</h4><h5 id="1-3-2-1-确认订单-订单表设计"><a href="#1-3-2-1-确认订单-订单表设计" class="headerlink" title="1.3.2.1 确认订单 - 订单表设计"></a>1.3.2.1 确认订单 - 订单表设计</h5><h5 id="1-3-2-2-确认订单-聚合支付中心作用"><a href="#1-3-2-2-确认订单-聚合支付中心作用" class="headerlink" title="1.3.2.2 确认订单 - 聚合支付中心作用"></a>1.3.2.2 确认订单 - 聚合支付中心作用</h5><h5 id="1-3-2-3-确认订单-提交并且接受订单信息"><a href="#1-3-2-3-确认订单-提交并且接受订单信息" class="headerlink" title="1.3.2.3 确认订单 - 提交并且接受订单信息"></a>1.3.2.3 确认订单 - 提交并且接受订单信息</h5><h4 id="1-3-3-创建订单-填充新订单数据"><a href="#1-3-3-创建订单-填充新订单数据" class="headerlink" title="1.3.3 创建订单 - 填充新订单数据"></a>1.3.3 创建订单 - 填充新订单数据</h4><h5 id="1-3-3-1-创建订单-保存订单与子订单数据"><a href="#1-3-3-1-创建订单-保存订单与子订单数据" class="headerlink" title="1.3.3.1 创建订单 - 保存订单与子订单数据"></a>1.3.3.1 创建订单 - 保存订单与子订单数据</h5><h5 id="1-3-3-2-创建订单-扣除商品库存与订单状态保存"><a href="#1-3-3-2-创建订单-扣除商品库存与订单状态保存" class="headerlink" title="1.3.3.2 创建订单 - 扣除商品库存与订单状态保存"></a>1.3.3.2 创建订单 - 扣除商品库存与订单状态保存</h5><h5 id="1-3-3-3-创建订单-测试订单创建与回滚"><a href="#1-3-3-3-创建订单-测试订单创建与回滚" class="headerlink" title="1.3.3.3 创建订单 - 测试订单创建与回滚"></a>1.3.3.3 创建订单 - 测试订单创建与回滚</h5><h5 id="1-3-3-4-创建订单-创建订单后-前端的业务处理"><a href="#1-3-3-4-创建订单-创建订单后-前端的业务处理" class="headerlink" title="1.3.3.4 创建订单 - 创建订单后,前端的业务处理"></a>1.3.3.4 创建订单 - 创建订单后,前端的业务处理</h5><h4 id="1-3-4-微信支付-构建商户端支付成功的回调接口"><a href="#1-3-4-微信支付-构建商户端支付成功的回调接口" class="headerlink" title="1.3.4 微信支付 - 构建商户端支付成功的回调接口"></a>1.3.4 微信支付 - 构建商户端支付成功的回调接口</h4><h5 id="1-3-4-1-微信支付-生成支付二维码"><a href="#1-3-4-1-微信支付-生成支付二维码" class="headerlink" title="1.3.4.1 微信支付 - 生成支付二维码"></a>1.3.4.1 微信支付 - 生成支付二维码</h5><h5 id="1-3-4-2-微信支付-商户回调地址与内网穿透"><a href="#1-3-4-2-微信支付-商户回调地址与内网穿透" class="headerlink" title="1.3.4.2 微信支付 - 商户回调地址与内网穿透"></a>1.3.4.2 微信支付 - 商户回调地址与内网穿透</h5><h5 id="1-3-4-3-支付宝支付-异步通知与同步通知"><a href="#1-3-4-3-支付宝支付-异步通知与同步通知" class="headerlink" title="1.3.4.3 支付宝支付 - 异步通知与同步通知"></a>1.3.4.3 支付宝支付 - 异步通知与同步通知</h5><h4 id="1-3-5-定时任务-定时关闭超期未支付订单"><a href="#1-3-5-定时任务-定时关闭超期未支付订单" class="headerlink" title="1.3.5 定时任务 - 定时关闭超期未支付订单"></a>1.3.5 定时任务 - 定时关闭超期未支付订单</h4><h5 id="1-3-5-1-定时任务-定时任务弊端与优化方案"><a href="#1-3-5-1-定时任务-定时任务弊端与优化方案" class="headerlink" title="1.3.5.1 定时任务 - 定时任务弊端与优化方案"></a>1.3.5.1 定时任务 - 定时任务弊端与优化方案</h5><h3 id="1-4-用户中心，订单-评价管理开发"><a href="#1-4-用户中心，订单-评价管理开发" class="headerlink" title="1.4 用户中心，订单/评价管理开发"></a>1.4 用户中心，订单/评价管理开发</h3><h4 id="1-4-1-用户中心-查询，修改用户信息"><a href="#1-4-1-用户中心-查询，修改用户信息" class="headerlink" title="1.4.1 用户中心 - 查询，修改用户信息"></a>1.4.1 用户中心 - 查询，修改用户信息</h4><h5 id="1-4-1-1-用户中心-使用Hibernate验证用户信息"><a href="#1-4-1-1-用户中心-使用Hibernate验证用户信息" class="headerlink" title="1.4.1.1 用户中心 - 使用Hibernate验证用户信息"></a>1.4.1.1 用户中心 - 使用Hibernate验证用户信息</h5><h4 id="1-4-2-上传头像-定义文件保存位置"><a href="#1-4-2-上传头像-定义文件保存位置" class="headerlink" title="1.4.2 上传头像 - 定义文件保存位置"></a>1.4.2 上传头像 - 定义文件保存位置</h4><h5 id="1-4-2-1-上传头像-图片格式限制以防后门"><a href="#1-4-2-1-上传头像-图片格式限制以防后门" class="headerlink" title="1.4.2.1 上传头像 - 图片格式限制以防后门"></a>1.4.2.1 上传头像 - 图片格式限制以防后门</h5><h5 id="1-4-2-2-上传头像-大小限制，以及自定义捕获异常"><a href="#1-4-2-2-上传头像-大小限制，以及自定义捕获异常" class="headerlink" title="1.4.2.2 上传头像 - 大小限制，以及自定义捕获异常"></a>1.4.2.2 上传头像 - 大小限制，以及自定义捕获异常</h5><h4 id="1-4-3-订单管理-查询我的订单Sql"><a href="#1-4-3-订单管理-查询我的订单Sql" class="headerlink" title="1.4.3 订单管理 - 查询我的订单Sql"></a>1.4.3 订单管理 - 查询我的订单Sql</h4><h5 id="1-4-3-1-订单管理-嵌套查询分页Bug解决方案"><a href="#1-4-3-1-订单管理-嵌套查询分页Bug解决方案" class="headerlink" title="1.4.3.1 订单管理 - 嵌套查询分页Bug解决方案"></a>1.4.3.1 订单管理 - 嵌套查询分页Bug解决方案</h5><h5 id="1-4-3-2-订单管理-操作订单前的验证"><a href="#1-4-3-2-订单管理-操作订单前的验证" class="headerlink" title="1.4.3.2 订单管理 - 操作订单前的验证"></a>1.4.3.2 订单管理 - 操作订单前的验证</h5><h4 id="1-4-4-评价管理-评价需求分析"><a href="#1-4-4-评价管理-评价需求分析" class="headerlink" title="1.4.4 评价管理 - 评价需求分析"></a>1.4.4 评价管理 - 评价需求分析</h4><h5 id="1-4-4-1-评价管理-待评价商品列表开发"><a href="#1-4-4-1-评价管理-待评价商品列表开发" class="headerlink" title="1.4.4.1 评价管理 - 待评价商品列表开发"></a>1.4.4.1 评价管理 - 待评价商品列表开发</h5><h5 id="1-4-4-2-评价管理-评价商品功能开发"><a href="#1-4-4-2-评价管理-评价商品功能开发" class="headerlink" title="1.4.4.2 评价管理 - 评价商品功能开发"></a>1.4.4.2 评价管理 - 评价商品功能开发</h5><h4 id="1-4-5-中心首页-订单状态接口联调"><a href="#1-4-5-中心首页-订单状态接口联调" class="headerlink" title="1.4.5 中心首页 - 订单状态接口联调"></a>1.4.5 中心首页 - 订单状态接口联调</h4><h5 id="1-4-5-1-中心首页-订单动向接口联调"><a href="#1-4-5-1-中心首页-订单动向接口联调" class="headerlink" title="1.4.5.1 中心首页 - 订单动向接口联调"></a>1.4.5.1 中心首页 - 订单动向接口联调</h5><h3 id="1-5-项目上线部署"><a href="#1-5-项目上线部署" class="headerlink" title="1.5 项目上线部署"></a>1.5 项目上线部署</h3><h4 id="1-5-1-云服务器购买及安装配置-JDK-Tomcat-MariaDB"><a href="#1-5-1-云服务器购买及安装配置-JDK-Tomcat-MariaDB" class="headerlink" title="1.5.1 云服务器购买及安装配置(JDK/Tomcat/MariaDB)"></a>1.5.1 云服务器购买及安装配置(JDK/Tomcat/MariaDB)</h4><h4 id="1-5-2-SpringBoot多环境部署profile-开发环境-生产环境"><a href="#1-5-2-SpringBoot多环境部署profile-开发环境-生产环境" class="headerlink" title="1.5.2 SpringBoot多环境部署profile(开发环境/生产环境)"></a>1.5.2 SpringBoot多环境部署profile(开发环境/生产环境)</h4><h4 id="1-5-3-SpringBoot项目打成war并发布到云服务器"><a href="#1-5-3-SpringBoot项目打成war并发布到云服务器" class="headerlink" title="1.5.3 SpringBoot项目打成war并发布到云服务器"></a>1.5.3 SpringBoot项目打成war并发布到云服务器</h4><h4 id="1-5-4-前端项目发布"><a href="#1-5-4-前端项目发布" class="headerlink" title="1.5.4 前端项目发布"></a>1.5.4 前端项目发布</h4><h4 id="1-5-5-解决Cookie异常，测试订单支付流程"><a href="#1-5-5-解决Cookie异常，测试订单支付流程" class="headerlink" title="1.5.5 解决Cookie异常，测试订单支付流程"></a>1.5.5 解决Cookie异常，测试订单支付流程</h4><h2 id="2-集群式高可用"><a href="#2-集群式高可用" class="headerlink" title="2. 集群式高可用"></a>2. 集群式高可用</h2><h3 id="2-1-LVS-Nginx实现集群高可用"><a href="#2-1-LVS-Nginx实现集群高可用" class="headerlink" title="2.1 LVS+Nginx实现集群高可用"></a>2.1 LVS+Nginx实现集群高可用</h3><h4 id="2-1-1-在Nginx中解决跨域问题"><a href="#2-1-1-在Nginx中解决跨域问题" class="headerlink" title="2.1.1 在Nginx中解决跨域问题"></a>2.1.1 在Nginx中解决跨域问题</h4><h5 id="2-1-1-1在Nginx中配置静态资源防盗链"><a href="#2-1-1-1在Nginx中配置静态资源防盗链" class="headerlink" title="2.1. 1.1在Nginx中配置静态资源防盗链"></a>2.1. 1.1在Nginx中配置静态资源防盗链</h5><h4 id="2-1-2-Nginx模块化设计"><a href="#2-1-2-Nginx模块化设计" class="headerlink" title="2.1.2 Nginx模块化设计"></a>2.1.2 Nginx模块化设计</h4><h5 id="2-1-2-1-Nginx集群负载均衡"><a href="#2-1-2-1-Nginx集群负载均衡" class="headerlink" title="2.1.2.1 Nginx集群负载均衡"></a>2.1.2.1 Nginx集群负载均衡</h5><h4 id="2-1-3-使用Nginx搭建3台Tomcat集群"><a href="#2-1-3-使用Nginx搭建3台Tomcat集群" class="headerlink" title="2.1. 3 使用Nginx搭建3台Tomcat集群"></a>2.1. 3 使用Nginx搭建3台Tomcat集群</h4><h5 id="2-1-3-1-使用JMeter测试单节点与集群并发异常率"><a href="#2-1-3-1-使用JMeter测试单节点与集群并发异常率" class="headerlink" title="2.1. 3.1 使用JMeter测试单节点与集群并发异常率"></a>2.1. 3.1 使用JMeter测试单节点与集群并发异常率</h5><h5 id="2-1-3-2-使用-Keepalived提高吞吐量"><a href="#2-1-3-2-使用-Keepalived提高吞吐量" class="headerlink" title="2.1. 3.2 使用 Keepalived提高吞吐量"></a>2.1. 3.2 使用 Keepalived提高吞吐量</h5><h4 id="2-1-4-负载均衡原理剖析-ip-hash-url-hash-与-least-conn"><a href="#2-1-4-负载均衡原理剖析-ip-hash-url-hash-与-least-conn" class="headerlink" title="2.1.4 负载均衡原理剖析 - ip_hash - url hash 与 least_conn"></a>2.1.4 负载均衡原理剖析 - ip_hash - url hash 与 least_conn</h4><h4 id="2-1-5-一致性hash算法讲解"><a href="#2-1-5-一致性hash算法讲解" class="headerlink" title="2.1.5 一致性hash算法讲解"></a>2.1.5 一致性hash算法讲解</h4><h4 id="2-1-6-Nginx控制浏览器缓存"><a href="#2-1-6-Nginx控制浏览器缓存" class="headerlink" title="2.1.6 Nginx控制浏览器缓存"></a>2.1.6 Nginx控制浏览器缓存</h4><h5 id="2-1-6-1-Nginx反向代理缓存"><a href="#2-1-6-1-Nginx反向代理缓存" class="headerlink" title="2.1.6.1 Nginx反向代理缓存"></a>2.1.6.1 Nginx反向代理缓存</h5><h5 id="2-1-6-2-使用Nginx配置SSL证书提供HTTPS访问"><a href="#2-1-6-2-使用Nginx配置SSL证书提供HTTPS访问" class="headerlink" title="2.1.6.2 使用Nginx配置SSL证书提供HTTPS访问"></a>2.1.6.2 使用Nginx配置SSL证书提供HTTPS访问</h5><h5 id="2-1-6-3-Nginx单实例存在的问题与集群原理详解"><a href="#2-1-6-3-Nginx单实例存在的问题与集群原理详解" class="headerlink" title="2.1.6.3 Nginx单实例存在的问题与集群原理详解"></a>2.1.6.3 Nginx单实例存在的问题与集群原理详解</h5><h5 id="2-1-6-4-心跳机制与自动重启实现"><a href="#2-1-6-4-心跳机制与自动重启实现" class="headerlink" title="2.1.6.4 心跳机制与自动重启实现"></a>2.1.6.4 心跳机制与自动重启实现</h5><h4 id="2-1-7-动静分离的那些事儿"><a href="#2-1-7-动静分离的那些事儿" class="headerlink" title="2.1.7 动静分离的那些事儿"></a>2.1.7 动静分离的那些事儿</h4><h5 id="2-1-7-1-部署Nginx到云端-实现动静分离与虚拟主机"><a href="#2-1-7-1-部署Nginx到云端-实现动静分离与虚拟主机" class="headerlink" title="2.1.7.1 部署Nginx到云端 - 实现动静分离与虚拟主机"></a>2.1.7.1 部署Nginx到云端 - 实现动静分离与虚拟主机</h5><h5 id="2-1-7-2-部署Nginx到云端-测试与日志调试"><a href="#2-1-7-2-部署Nginx到云端-测试与日志调试" class="headerlink" title="2.1.7.2 部署Nginx到云端 - 测试与日志调试"></a>2.1.7.2 部署Nginx到云端 - 测试与日志调试</h5><h5 id="2-1-7-3-实现Keepalived高可用双机主备"><a href="#2-1-7-3-实现Keepalived高可用双机主备" class="headerlink" title="2.1.7.3 实现Keepalived高可用双机主备"></a>2.1.7.3 实现Keepalived高可用双机主备</h5><h5 id="2-1-7-4-实现Keepalived高可用双机热备"><a href="#2-1-7-4-实现Keepalived高可用双机热备" class="headerlink" title="2.1.7.4 实现Keepalived高可用双机热备"></a>2.1.7.4 实现Keepalived高可用双机热备</h5><h5 id="2-1-7-5-LVS-Keepalived-Nginx实现高可用集群—负载均衡"><a href="#2-1-7-5-LVS-Keepalived-Nginx实现高可用集群—负载均衡" class="headerlink" title="2.1.7.5 LVS+Keepalived+Nginx实现高可用集群—负载均衡"></a>2.1.7.5 LVS+Keepalived+Nginx实现高可用集群—负载均衡</h5><h3 id="2-2-主从复制高可用Redis集群"><a href="#2-2-主从复制高可用Redis集群" class="headerlink" title="2.2 主从复制高可用Redis集群"></a>2.2 主从复制高可用Redis集群</h3><h4 id="2-2-1-Redis架构与原理解析"><a href="#2-2-1-Redis架构与原理解析" class="headerlink" title="2.2.1 Redis架构与原理解析"></a>2.2.1 Redis架构与原理解析</h4><h4 id="2-2-2-在SpringBoot中整合Redis实现数据存取"><a href="#2-2-2-在SpringBoot中整合Redis实现数据存取" class="headerlink" title="2.2.2 在SpringBoot中整合Redis实现数据存取"></a>2.2.2 在SpringBoot中整合Redis实现数据存取</h4><h5 id="2-2-2-1-基于Redis优化首页轮播图和分类查询"><a href="#2-2-2-1-基于Redis优化首页轮播图和分类查询" class="headerlink" title="2.2.2.1 基于Redis优化首页轮播图和分类查询"></a>2.2.2.1 基于Redis优化首页轮播图和分类查询</h5><h5 id="2-2-2-2-在Redis中实现订阅功能"><a href="#2-2-2-2-在Redis中实现订阅功能" class="headerlink" title="2.2.2.2 在Redis中实现订阅功能"></a>2.2.2.2 在Redis中实现订阅功能</h5><h5 id="2-2-2-3-Redis中RDB-AOF持久化工作原理解析"><a href="#2-2-2-3-Redis中RDB-AOF持久化工作原理解析" class="headerlink" title="2.2.2.3 Redis中RDB,AOF持久化工作原理解析"></a>2.2.2.3 Redis中RDB,AOF持久化工作原理解析</h5><h5 id="2-2-2-4-Redis主从架构模式讲解"><a href="#2-2-2-4-Redis主从架构模式讲解" class="headerlink" title="2.2.2.4 Redis主从架构模式讲解"></a>2.2.2.4 Redis主从架构模式讲解</h5><h5 id="2-2-2-5-Redis主从复制-无磁盘化复制原理解析"><a href="#2-2-2-5-Redis主从复制-无磁盘化复制原理解析" class="headerlink" title="2.2.2.5 Redis主从复制,无磁盘化复制原理解析"></a>2.2.2.5 Redis主从复制,无磁盘化复制原理解析</h5><h5 id="2-2-2-6-过期的缓存Key处理方案"><a href="#2-2-2-6-过期的缓存Key处理方案" class="headerlink" title="2.2.2.6 过期的缓存Key处理方案"></a>2.2.2.6 过期的缓存Key处理方案</h5><h4 id="2-2-3-Redis哨兵机制与原理解析"><a href="#2-2-3-Redis哨兵机制与原理解析" class="headerlink" title="2.2.3 Redis哨兵机制与原理解析"></a>2.2.3 Redis哨兵机制与原理解析</h4><h5 id="2-2-3-1-Redis哨兵落地实现"><a href="#2-2-3-1-Redis哨兵落地实现" class="headerlink" title="2.2.3.1 Redis哨兵落地实现"></a>2.2.3.1 Redis哨兵落地实现</h5><h5 id="2-2-3-2-Redis集群解决方案设计"><a href="#2-2-3-2-Redis集群解决方案设计" class="headerlink" title="2.2.3.2 Redis集群解决方案设计"></a>2.2.3.2 Redis集群解决方案设计</h5><h5 id="2-2-3-3-Redis集群原理解析"><a href="#2-2-3-3-Redis集群原理解析" class="headerlink" title="2.2.3.3 Redis集群原理解析"></a>2.2.3.3 Redis集群原理解析</h5><h5 id="2-2-3-4-主从复制高可用Redis集群搭建"><a href="#2-2-3-4-主从复制高可用Redis集群搭建" class="headerlink" title="2.2.3.4 主从复制高可用Redis集群搭建"></a>2.2.3.4 主从复制高可用Redis集群搭建</h5><h5 id="2-2-3-5-SpringBoot集成Redis集群环境"><a href="#2-2-3-5-SpringBoot集成Redis集群环境" class="headerlink" title="2.2.3.5 SpringBoot集成Redis集群环境"></a>2.2.3.5 SpringBoot集成Redis集群环境</h5><h3 id="2-3-Redis缓存雪崩，穿透"><a href="#2-3-Redis缓存雪崩，穿透" class="headerlink" title="2.3 Redis缓存雪崩，穿透"></a>2.3 Redis缓存雪崩，穿透</h3><h4 id="2-3-1-缓存雪崩现象解析"><a href="#2-3-1-缓存雪崩现象解析" class="headerlink" title="2.3.1 缓存雪崩现象解析"></a>2.3.1 缓存雪崩现象解析</h4><h4 id="2-3-2-缓存雪崩的解决方案与落地"><a href="#2-3-2-缓存雪崩的解决方案与落地" class="headerlink" title="2.3.2 缓存雪崩的解决方案与落地"></a>2.3.2 缓存雪崩的解决方案与落地</h4><h4 id="2-3-3-缓存穿透的解决方案与落地"><a href="#2-3-3-缓存穿透的解决方案与落地" class="headerlink" title="2.3.3 缓存穿透的解决方案与落地"></a>2.3.3 缓存穿透的解决方案与落地</h4><h4 id="2-3-4-拔高-Redis批量查询的优化设计"><a href="#2-3-4-拔高-Redis批量查询的优化设计" class="headerlink" title="2.3.4 拔高-Redis批量查询的优化设计"></a>2.3.4 拔高-Redis批量查询的优化设计</h4><h2 id="3-分布式技术要点"><a href="#3-分布式技术要点" class="headerlink" title="3. 分布式技术要点"></a>3. 分布式技术要点</h2><h3 id="3-1-分布式会话与单点登录SSO"><a href="#3-1-分布式会话与单点登录SSO" class="headerlink" title="3.1 分布式会话与单点登录SSO"></a>3.1 分布式会话与单点登录SSO</h3><h4 id="3-1-1-有状态会话和无状态会话区别"><a href="#3-1-1-有状态会话和无状态会话区别" class="headerlink" title="3.1.1 有状态会话和无状态会话区别"></a>3.1.1 有状态会话和无状态会话区别</h4><h4 id="3-1-2-动静分离架构下的用户会话解决方案"><a href="#3-1-2-动静分离架构下的用户会话解决方案" class="headerlink" title="3.1.2 动静分离架构下的用户会话解决方案"></a>3.1.2 动静分离架构下的用户会话解决方案</h4><h5 id="3-1-2-1-集群与分布式系统中的用户会话解决方案"><a href="#3-1-2-1-集群与分布式系统中的用户会话解决方案" class="headerlink" title="3.1.2.1 集群与分布式系统中的用户会话解决方案"></a>3.1.2.1 集群与分布式系统中的用户会话解决方案</h5><h5 id="3-1-2-2-单个Tomcat会话和全局Redis会话关系"><a href="#3-1-2-2-单个Tomcat会话和全局Redis会话关系" class="headerlink" title="3.1.2.2 单个Tomcat会话和全局Redis会话关系"></a>3.1.2.2 单个Tomcat会话和全局Redis会话关系</h5><h5 id="3-1-2-3-通过Redis-Cookie来实现前后端分离与分布式会话"><a href="#3-1-2-3-通过Redis-Cookie来实现前后端分离与分布式会话" class="headerlink" title="3.1.2.3 通过Redis+Cookie来实现前后端分离与分布式会话"></a>3.1.2.3 通过Redis+Cookie来实现前后端分离与分布式会话</h5><h4 id="3-1-3-配置用户权限拦截器"><a href="#3-1-3-配置用户权限拦截器" class="headerlink" title="3.1.3 配置用户权限拦截器"></a>3.1.3 配置用户权限拦截器</h4><h5 id="3-1-3-1-单点登录的作用，为何使用SSO"><a href="#3-1-3-1-单点登录的作用，为何使用SSO" class="headerlink" title="3.1.3.1 单点登录的作用，为何使用SSO"></a>3.1.3.1 单点登录的作用，为何使用SSO</h5><h5 id="3-1-3-2-多系统跨域的用户会话问题"><a href="#3-1-3-2-多系统跨域的用户会话问题" class="headerlink" title="3.1.3.2 多系统跨域的用户会话问题"></a>3.1.3.2 多系统跨域的用户会话问题</h5><h5 id="3-1-3-3-常见的会话跨域形式（Session-共享）"><a href="#3-1-3-3-常见的会话跨域形式（Session-共享）" class="headerlink" title="3.1.3.3 常见的会话跨域形式（Session 共享）"></a>3.1.3.3 常见的会话跨域形式（Session 共享）</h5><h5 id="3-1-3-4-Cookie实现Session跨域与原理"><a href="#3-1-3-4-Cookie实现Session跨域与原理" class="headerlink" title="3.1.3.4 Cookie实现Session跨域与原理"></a>3.1.3.4 Cookie实现Session跨域与原理</h5><h5 id="3-1-3-5-spring-session实现与原理"><a href="#3-1-3-5-spring-session实现与原理" class="headerlink" title="3.1.3.5 spring-session实现与原理"></a>3.1.3.5 spring-session实现与原理</h5><h3 id="3-2-分布式搜索引擎—ES"><a href="#3-2-分布式搜索引擎—ES" class="headerlink" title="3.2 分布式搜索引擎—ES"></a>3.2 分布式搜索引擎—ES</h3><h4 id="3-2-1-ES架构与原理解析"><a href="#3-2-1-ES架构与原理解析" class="headerlink" title="3.2.1 ES架构与原理解析"></a>3.2.1 ES架构与原理解析</h4><h4 id="3-2-2-ES健康状况详解"><a href="#3-2-2-ES健康状况详解" class="headerlink" title="3.2.2 ES健康状况详解"></a>3.2.2 ES健康状况详解</h4><h5 id="3-2-2-1-dsl搜索-分词，分页，多关键字匹配，布尔查询"><a href="#3-2-2-1-dsl搜索-分词，分页，多关键字匹配，布尔查询" class="headerlink" title="3.2.2.1 dsl搜索(分词，分页，多关键字匹配，布尔查询)"></a>3.2.2.1 dsl搜索(分词，分页，多关键字匹配，布尔查询)</h5><h5 id="3-2-2-2-出现不合法搜索如何定位问题"><a href="#3-2-2-2-出现不合法搜索如何定位问题" class="headerlink" title="3.2.2.2 出现不合法搜索如何定位问题"></a>3.2.2.2 出现不合法搜索如何定位问题</h5><h4 id="3-2-3-ES集群原理，shard与replica"><a href="#3-2-3-ES集群原理，shard与replica" class="headerlink" title="3.2.3 ES集群原理，shard与replica"></a>3.2.3 ES集群原理，shard与replica</h4><h5 id="3-2-3-1-集成ES集群故障之节点宕机"><a href="#3-2-3-1-集成ES集群故障之节点宕机" class="headerlink" title="3.2.3.1 集成ES集群故障之节点宕机"></a>3.2.3.1 集成ES集群故障之节点宕机</h5><h5 id="3-2-3-2-集成ES集群故障之脑裂问题探讨"><a href="#3-2-3-2-集成ES集群故障之脑裂问题探讨" class="headerlink" title="3.2.3.2 集成ES集群故障之脑裂问题探讨"></a>3.2.3.2 集成ES集群故障之脑裂问题探讨</h5><h5 id="3-2-3-3-集群环境中（分布式）文档的存取原理"><a href="#3-2-3-3-集群环境中（分布式）文档的存取原理" class="headerlink" title="3.2.3.3 集群环境中（分布式）文档的存取原理"></a>3.2.3.3 集群环境中（分布式）文档的存取原理</h5><h4 id="3-2-4-MySql和ES进行数据同步的方案分析"><a href="#3-2-4-MySql和ES进行数据同步的方案分析" class="headerlink" title="3.2.4 MySql和ES进行数据同步的方案分析"></a>3.2.4 MySql和ES进行数据同步的方案分析</h4><h5 id="3-2-4-1-基于Logstash进行数据同步"><a href="#3-2-4-1-基于Logstash进行数据同步" class="headerlink" title="3.2.4.1 基于Logstash进行数据同步"></a>3.2.4.1 基于Logstash进行数据同步</h5><h5 id="3-2-4-2-基于ES实现商品搜索与分类搜索"><a href="#3-2-4-2-基于ES实现商品搜索与分类搜索" class="headerlink" title="3.2.4.2 基于ES实现商品搜索与分类搜索"></a>3.2.4.2 基于ES实现商品搜索与分类搜索</h5><h4 id="3-2-5-ES深度分页下会带来怎样的性能问题"><a href="#3-2-5-ES深度分页下会带来怎样的性能问题" class="headerlink" title="3.2.5 ES深度分页下会带来怎样的性能问题"></a>3.2.5 ES深度分页下会带来怎样的性能问题</h4><h5 id="3-2-5-1-大数据量下该如何使用Scoll滚动技术进行搜索"><a href="#3-2-5-1-大数据量下该如何使用Scoll滚动技术进行搜索" class="headerlink" title="3.2.5.1 大数据量下该如何使用Scoll滚动技术进行搜索"></a>3.2.5.1 大数据量下该如何使用Scoll滚动技术进行搜索</h5><h5 id="3-2-5-2-ES拓展-基于Geo的地理坐标搜索实现"><a href="#3-2-5-2-ES拓展-基于Geo的地理坐标搜索实现" class="headerlink" title="3.2.5.2 ES拓展 - 基于Geo的地理坐标搜索实现"></a>3.2.5.2 ES拓展 - 基于Geo的地理坐标搜索实现</h5><h5 id="3-2-5-3-ES拓展-社交案例，距离我几公里内的好友"><a href="#3-2-5-3-ES拓展-社交案例，距离我几公里内的好友" class="headerlink" title="3.2.5.3 ES拓展 - 社交案例，距离我几公里内的好友"></a>3.2.5.3 ES拓展 - 社交案例，距离我几公里内的好友</h5><h3 id="3-3-分布式文件系统—FastDFS-OSS-对象存储"><a href="#3-3-分布式文件系统—FastDFS-OSS-对象存储" class="headerlink" title="3.3 分布式文件系统—FastDFS+OSS(对象存储)"></a>3.3 分布式文件系统—FastDFS+OSS(对象存储)</h3><h4 id="3-3-1-以架构师角度分析目前文件上传所存在的问题"><a href="#3-3-1-以架构师角度分析目前文件上传所存在的问题" class="headerlink" title="3.3.1 以架构师角度分析目前文件上传所存在的问题"></a>3.3.1 以架构师角度分析目前文件上传所存在的问题</h4><h4 id="3-3-2-分布式文件系统技术选型：FastDFS-VS-阿里OSS"><a href="#3-3-2-分布式文件系统技术选型：FastDFS-VS-阿里OSS" class="headerlink" title="3.3.2 分布式文件系统技术选型：FastDFS VS 阿里OSS"></a>3.3.2 分布式文件系统技术选型：FastDFS VS 阿里OSS</h4><h5 id="3-3-2-1-FastDFS架构与原理解析"><a href="#3-3-2-1-FastDFS架构与原理解析" class="headerlink" title="3.3.2.1 FastDFS架构与原理解析"></a>3.3.2.1 FastDFS架构与原理解析</h5><h5 id="3-3-2-2-Nginx-FastDFS-实现文件服务器"><a href="#3-3-2-2-Nginx-FastDFS-实现文件服务器" class="headerlink" title="3.3.2.2 Nginx + FastDFS 实现文件服务器"></a>3.3.2.2 Nginx + FastDFS 实现文件服务器</h5><h5 id="3-3-2-3-FastDFS整合SpringBoot，修改项目中文件上传"><a href="#3-3-2-3-FastDFS整合SpringBoot，修改项目中文件上传" class="headerlink" title="3.3.2.3 FastDFS整合SpringBoot，修改项目中文件上传"></a>3.3.2.3 FastDFS整合SpringBoot，修改项目中文件上传</h5><h4 id="3-3-3-第三方图片存储解决方案"><a href="#3-3-3-第三方图片存储解决方案" class="headerlink" title="3.3.3 第三方图片存储解决方案"></a>3.3.3 第三方图片存储解决方案</h4><h5 id="3-3-3-1-阿里OSS存储与实现原理"><a href="#3-3-3-1-阿里OSS存储与实现原理" class="headerlink" title="3.3.3.1 阿里OSS存储与实现原理"></a>3.3.3.1 阿里OSS存储与实现原理</h5><h5 id="3-3-3-2-SpringBoot整合阿里OSS-SDK与API"><a href="#3-3-3-2-SpringBoot整合阿里OSS-SDK与API" class="headerlink" title="3.3.3.2 SpringBoot整合阿里OSS SDK与API"></a>3.3.3.2 SpringBoot整合阿里OSS SDK与API</h5><h5 id="3-3-3-3-实现图片上传到OSS中"><a href="#3-3-3-3-实现图片上传到OSS中" class="headerlink" title="3.3.3.3 实现图片上传到OSS中"></a>3.3.3.3 实现图片上传到OSS中</h5><h5 id="3-3-3-4-在生产环境中切换文件存储为FastDFS"><a href="#3-3-3-4-在生产环境中切换文件存储为FastDFS" class="headerlink" title="3.3.3.4 在生产环境中切换文件存储为FastDFS"></a>3.3.3.4 在生产环境中切换文件存储为FastDFS</h5><h3 id="3-4-分布式消息队列—RabbitMQ"><a href="#3-4-分布式消息队列—RabbitMQ" class="headerlink" title="3.4 分布式消息队列—RabbitMQ"></a>3.4 分布式消息队列—RabbitMQ</h3><h4 id="3-4-1-业界主流消息队列与技术选型"><a href="#3-4-1-业界主流消息队列与技术选型" class="headerlink" title="3.4.1 业界主流消息队列与技术选型"></a>3.4.1 业界主流消息队列与技术选型</h4><h4 id="3-4-2-ActiveMQ集群架构与原理解析"><a href="#3-4-2-ActiveMQ集群架构与原理解析" class="headerlink" title="3.4.2 ActiveMQ集群架构与原理解析"></a>3.4.2 ActiveMQ集群架构与原理解析</h4><h5 id="3-4-2-1-RabbitMQ集群架构与原理解析"><a href="#3-4-2-1-RabbitMQ集群架构与原理解析" class="headerlink" title="3.4.2.1 RabbitMQ集群架构与原理解析"></a>3.4.2.1 RabbitMQ集群架构与原理解析</h5><h5 id="3-4-2-2-RocketMQ集群架构与原理解析"><a href="#3-4-2-2-RocketMQ集群架构与原理解析" class="headerlink" title="3.4.2.2 RocketMQ集群架构与原理解析"></a>3.4.2.2 RocketMQ集群架构与原理解析</h5><h5 id="3-4-2-3-Kafka集群架构与原理解析"><a href="#3-4-2-3-Kafka集群架构与原理解析" class="headerlink" title="3.4.2.3 Kafka集群架构与原理解析"></a>3.4.2.3 Kafka集群架构与原理解析</h5><h4 id="3-4-3-RabbitMQ核心API与高级特性"><a href="#3-4-3-RabbitMQ核心API与高级特性" class="headerlink" title="3.4.3 RabbitMQ核心API与高级特性"></a>3.4.3 RabbitMQ核心API与高级特性</h4><h5 id="3-4-3-1-RabbitMQ与SpringBoot整合实战（生产端，消费端）"><a href="#3-4-3-1-RabbitMQ与SpringBoot整合实战（生产端，消费端）" class="headerlink" title="3.4.3.1 RabbitMQ与SpringBoot整合实战（生产端，消费端）"></a>3.4.3.1 RabbitMQ与SpringBoot整合实战（生产端，消费端）</h5><h5 id="3-4-3-2-RabbitMQ镜像队列集群构建"><a href="#3-4-3-2-RabbitMQ镜像队列集群构建" class="headerlink" title="3.4.3.2 RabbitMQ镜像队列集群构建"></a>3.4.3.2 RabbitMQ镜像队列集群构建</h5><h5 id="3-4-3-3-RabbitMQ消息可靠性投递机制实战"><a href="#3-4-3-3-RabbitMQ消息可靠性投递机制实战" class="headerlink" title="3.4.3.3 RabbitMQ消息可靠性投递机制实战"></a>3.4.3.3 RabbitMQ消息可靠性投递机制实战</h5><h4 id="3-4-4-作为架构师如何去进行高层次的抽象公共API封装-消息序列化"><a href="#3-4-4-作为架构师如何去进行高层次的抽象公共API封装-消息序列化" class="headerlink" title="3.4.4 作为架构师如何去进行高层次的抽象公共API封装,消息序列化"></a>3.4.4 作为架构师如何去进行高层次的抽象公共API封装,消息序列化</h4><h5 id="3-4-4-1-生产端SDK自动装配与架构接口定义"><a href="#3-4-4-1-生产端SDK自动装配与架构接口定义" class="headerlink" title="3.4.4.1 生产端SDK自动装配与架构接口定义"></a>3.4.4.1 生产端SDK自动装配与架构接口定义</h5><h5 id="3-4-4-2-生产端发送迅速异步消息"><a href="#3-4-4-2-生产端发送迅速异步消息" class="headerlink" title="3.4.4.2 生产端发送迅速异步消息"></a>3.4.4.2 生产端发送迅速异步消息</h5><h5 id="3-4-4-3-生产端RabbitTemplate池化封装"><a href="#3-4-4-3-生产端RabbitTemplate池化封装" class="headerlink" title="3.4.4.3 生产端RabbitTemplate池化封装"></a>3.4.4.3 生产端RabbitTemplate池化封装</h5><h5 id="3-4-4-4-生产端消息序列化反序列化转换封装"><a href="#3-4-4-4-生产端消息序列化反序列化转换封装" class="headerlink" title="3.4.4.4 生产端消息序列化反序列化转换封装"></a>3.4.4.4 生产端消息序列化反序列化转换封装</h5><h5 id="3-4-4-5-RabbitMQ基础组件封装-基础组件应用演练"><a href="#3-4-4-5-RabbitMQ基础组件封装-基础组件应用演练" class="headerlink" title="3.4.4.5 RabbitMQ基础组件封装-基础组件应用演练"></a>3.4.4.5 RabbitMQ基础组件封装-基础组件应用演练</h5><h4 id="3-4-5-分布式定时任务组件封装"><a href="#3-4-5-分布式定时任务组件封装" class="headerlink" title="3.4.5 分布式定时任务组件封装"></a>3.4.5 分布式定时任务组件封装</h4><h5 id="3-4-5-1-可靠性消息重试实现集成定时任务组件"><a href="#3-4-5-1-可靠性消息重试实现集成定时任务组件" class="headerlink" title="3.4.5.1 可靠性消息重试实现集成定时任务组件"></a>3.4.5.1 可靠性消息重试实现集成定时任务组件</h5><h5 id="3-4-5-2-批量，延迟消息应用与封装实现"><a href="#3-4-5-2-批量，延迟消息应用与封装实现" class="headerlink" title="3.4.5.2 批量，延迟消息应用与封装实现"></a>3.4.5.2 批量，延迟消息应用与封装实现</h5><h3 id="3-5-分布式消息队列—Kafka"><a href="#3-5-分布式消息队列—Kafka" class="headerlink" title="3.5 分布式消息队列—Kafka"></a>3.5 分布式消息队列—Kafka</h3><h4 id="3-5-1-Kafka核心API"><a href="#3-5-1-Kafka核心API" class="headerlink" title="3.5.1 Kafka核心API"></a>3.5.1 Kafka核心API</h4><h5 id="3-5-1-1-Kafka与SpringBoot整合实战"><a href="#3-5-1-1-Kafka与SpringBoot整合实战" class="headerlink" title="3.5.1.1 Kafka与SpringBoot整合实战"></a>3.5.1.1 Kafka与SpringBoot整合实战</h5><h4 id="3-5-2-Kafka高吞吐量-海量日志收集架构设计"><a href="#3-5-2-Kafka高吞吐量-海量日志收集架构设计" class="headerlink" title="3.5.2 Kafka高吞吐量-海量日志收集架构设计"></a>3.5.2 Kafka高吞吐量-海量日志收集架构设计</h4><h5 id="3-5-2-1-Kafka高吞吐量-日志输出-Log4j2）"><a href="#3-5-2-1-Kafka高吞吐量-日志输出-Log4j2）" class="headerlink" title="3.5.2.1 Kafka高吞吐量-日志输出(Log4j2）"></a>3.5.2.1 Kafka高吞吐量-日志输出(Log4j2）</h5><h5 id="3-5-2-2-Kafka高吞吐量-日志收集-FileBeat）"><a href="#3-5-2-2-Kafka高吞吐量-日志收集-FileBeat）" class="headerlink" title="3.5.2.2 Kafka高吞吐量-日志收集(FileBeat）"></a>3.5.2.2 Kafka高吞吐量-日志收集(FileBeat）</h5><h5 id="3-5-2-3-Kafka高吞吐量-日志过滤-Logstash"><a href="#3-5-2-3-Kafka高吞吐量-日志过滤-Logstash" class="headerlink" title="3.5.2.3 Kafka高吞吐量-日志过滤(Logstash)"></a>3.5.2.3 Kafka高吞吐量-日志过滤(Logstash)</h5><h5 id="3-5-2-4-Kafka高吞吐量-日志持久化-Elasticsearch"><a href="#3-5-2-4-Kafka高吞吐量-日志持久化-Elasticsearch" class="headerlink" title="3.5.2.4 Kafka高吞吐量-日志持久化(Elasticsearch)"></a>3.5.2.4 Kafka高吞吐量-日志持久化(Elasticsearch)</h5><h5 id="3-5-2-5-Kafka高吞吐量-日志可视化-Kibana"><a href="#3-5-2-5-Kafka高吞吐量-日志可视化-Kibana" class="headerlink" title="3.5.2.5 Kafka高吞吐量-日志可视化(Kibana)"></a>3.5.2.5 Kafka高吞吐量-日志可视化(Kibana)</h5><h4 id="3-5-3-Kafka监控告警watcher监控告警实战"><a href="#3-5-3-Kafka监控告警watcher监控告警实战" class="headerlink" title="3.5.3 Kafka监控告警watcher监控告警实战"></a>3.5.3 Kafka监控告警watcher监控告警实战</h4><h3 id="3-6-分布式锁"><a href="#3-6-分布式锁" class="headerlink" title="3.6 分布式锁"></a>3.6 分布式锁</h3><h4 id="3-6-1-如何使用锁解决电商项目产生的超卖问题？"><a href="#3-6-1-如何使用锁解决电商项目产生的超卖问题？" class="headerlink" title="3.6.1 如何使用锁解决电商项目产生的超卖问题？"></a>3.6.1 如何使用锁解决电商项目产生的超卖问题？</h4><h5 id="3-6-1-1-基于Synchronized锁解决超卖问题（最原始的锁）"><a href="#3-6-1-1-基于Synchronized锁解决超卖问题（最原始的锁）" class="headerlink" title="3.6.1.1 基于Synchronized锁解决超卖问题（最原始的锁）"></a>3.6.1.1 基于Synchronized锁解决超卖问题（最原始的锁）</h5><h5 id="3-6-1-2-基于ReentrantLock锁解决超卖问题（并发包中的锁）"><a href="#3-6-1-2-基于ReentrantLock锁解决超卖问题（并发包中的锁）" class="headerlink" title="3.6.1.2 基于ReentrantLock锁解决超卖问题（并发包中的锁）"></a>3.6.1.2 基于ReentrantLock锁解决超卖问题（并发包中的锁）</h5><h4 id="3-6-2-乐观锁与悲观锁，公平锁与非公平锁"><a href="#3-6-2-乐观锁与悲观锁，公平锁与非公平锁" class="headerlink" title="3.6.2 乐观锁与悲观锁，公平锁与非公平锁"></a>3.6.2 乐观锁与悲观锁，公平锁与非公平锁</h4><h5 id="3-6-2-1-单体应用锁局限性分析-amp-解决方案"><a href="#3-6-2-1-单体应用锁局限性分析-amp-解决方案" class="headerlink" title="3.6.2.1 单体应用锁局限性分析&amp;解决方案"></a>3.6.2.1 单体应用锁局限性分析&amp;解决方案</h5><h5 id="3-6-2-2-基于数据库的悲观锁实现分布式锁"><a href="#3-6-2-2-基于数据库的悲观锁实现分布式锁" class="headerlink" title="3.6.2.2 基于数据库的悲观锁实现分布式锁"></a>3.6.2.2 基于数据库的悲观锁实现分布式锁</h5><h5 id="3-6-2-3-基于Redis的setnx实现分布式锁"><a href="#3-6-2-3-基于Redis的setnx实现分布式锁" class="headerlink" title="3.6.2.3 基于Redis的setnx实现分布式锁"></a>3.6.2.3 基于Redis的setnx实现分布式锁</h5><h5 id="3-6-2-4-基于Zookeeper的瞬时节点实现分布式锁"><a href="#3-6-2-4-基于Zookeeper的瞬时节点实现分布式锁" class="headerlink" title="3.6.2.4 基于Zookeeper的瞬时节点实现分布式锁"></a>3.6.2.4 基于Zookeeper的瞬时节点实现分布式锁</h5><h5 id="3-6-2-5-基于Zookeeper的客户端Curator实现分布式锁"><a href="#3-6-2-5-基于Zookeeper的客户端Curator实现分布式锁" class="headerlink" title="3.6.2.5 基于Zookeeper的客户端Curator实现分布式锁"></a>3.6.2.5 基于Zookeeper的客户端Curator实现分布式锁</h5><h5 id="3-6-5-6-基于Redis的Java客户端Redisson实现分布式锁"><a href="#3-6-5-6-基于Redis的Java客户端Redisson实现分布式锁" class="headerlink" title="3.6.5.6 基于Redis的Java客户端Redisson实现分布式锁"></a>3.6.5.6 基于Redis的Java客户端Redisson实现分布式锁</h5><h4 id="3-6-3-如何在电商项目中引入Redisson分布式锁"><a href="#3-6-3-如何在电商项目中引入Redisson分布式锁" class="headerlink" title="3.6.3 如何在电商项目中引入Redisson分布式锁"></a>3.6.3 如何在电商项目中引入Redisson分布式锁</h4><h5 id="3-6-3-1-多种分布式锁技术实现方案，如何选择"><a href="#3-6-3-1-多种分布式锁技术实现方案，如何选择" class="headerlink" title="3.6.3.1 多种分布式锁技术实现方案，如何选择?"></a>3.6.3.1 多种分布式锁技术实现方案，如何选择?</h5><h3 id="3-7-读写分离，分库分表"><a href="#3-7-读写分离，分库分表" class="headerlink" title="3.7 读写分离，分库分表"></a>3.7 读写分离，分库分表</h3><h4 id="3-7-1-如何选择垂直切分、水平切分"><a href="#3-7-1-如何选择垂直切分、水平切分" class="headerlink" title="3.7.1 如何选择垂直切分、水平切分"></a>3.7.1 如何选择垂直切分、水平切分</h4><h4 id="3-7-2-MyCAT快速体验"><a href="#3-7-2-MyCAT快速体验" class="headerlink" title="3.7.2 MyCAT快速体验"></a>3.7.2 MyCAT快速体验</h4><h5 id="3-7-2-1-MyCAT用户配置"><a href="#3-7-2-1-MyCAT用户配置" class="headerlink" title="3.7.2.1 MyCAT用户配置"></a>3.7.2.1 MyCAT用户配置</h5><h5 id="3-7-2-2-MyCAT的schema配置实操"><a href="#3-7-2-2-MyCAT的schema配置实操" class="headerlink" title="3.7.2.2 MyCAT的schema配置实操"></a>3.7.2.2 MyCAT的schema配置实操</h5><h5 id="3-7-2-3-MySql主从配置"><a href="#3-7-2-3-MySql主从配置" class="headerlink" title="3.7.2.3 MySql主从配置"></a>3.7.2.3 MySql主从配置</h5><h4 id="3-7-3-MyCAT分片规则配置（枚举分片、取模）"><a href="#3-7-3-MyCAT分片规则配置（枚举分片、取模）" class="headerlink" title="3.7.3 MyCAT分片规则配置（枚举分片、取模）"></a>3.7.3 MyCAT分片规则配置（枚举分片、取模）</h4><h5 id="3-7-3-1-MyCAT全局表、子表"><a href="#3-7-3-1-MyCAT全局表、子表" class="headerlink" title="3.7.3.1 MyCAT全局表、子表"></a>3.7.3.1 MyCAT全局表、子表</h5><h5 id="3-7-3-2-MyCAT高可用架构原理解析"><a href="#3-7-3-2-MyCAT高可用架构原理解析" class="headerlink" title="3.7.3.2 MyCAT高可用架构原理解析"></a>3.7.3.2 MyCAT高可用架构原理解析</h5><h5 id="3-7-3-3-MyCAT高可用架构-反向代理-HAProxy"><a href="#3-7-3-3-MyCAT高可用架构-反向代理-HAProxy" class="headerlink" title="3.7.3.3 MyCAT高可用架构-反向代理(HAProxy)"></a>3.7.3.3 MyCAT高可用架构-反向代理(HAProxy)</h5><h4 id="3-7-4-Sharding-JDBC分片表-（Spring和SpringBoot）"><a href="#3-7-4-Sharding-JDBC分片表-（Spring和SpringBoot）" class="headerlink" title="3.7.4 Sharding-JDBC分片表 （Spring和SpringBoot）"></a>3.7.4 Sharding-JDBC分片表 （Spring和SpringBoot）</h4><h5 id="3-7-4-1-Sharding-JDBC全局表（Spring和SpringBoot）"><a href="#3-7-4-1-Sharding-JDBC全局表（Spring和SpringBoot）" class="headerlink" title="3.7.4.1 Sharding-JDBC全局表（Spring和SpringBoot）"></a>3.7.4.1 Sharding-JDBC全局表（Spring和SpringBoot）</h5><h5 id="3-7-4-2-Sharding-JDBC子表（Spring和SpringBoot）"><a href="#3-7-4-2-Sharding-JDBC子表（Spring和SpringBoot）" class="headerlink" title="3.7.4.2 Sharding-JDBC子表（Spring和SpringBoot）"></a>3.7.4.2 Sharding-JDBC子表（Spring和SpringBoot）</h5><h3 id="3-8-分布式全局ID，分布式事务和数据一致性"><a href="#3-8-分布式全局ID，分布式事务和数据一致性" class="headerlink" title="3.8 分布式全局ID，分布式事务和数据一致性"></a>3.8 分布式全局ID，分布式事务和数据一致性</h3><h4 id="3-8-1-分布式全局ID的多种解决方案"><a href="#3-8-1-分布式全局ID的多种解决方案" class="headerlink" title="3.8.1 分布式全局ID的多种解决方案"></a>3.8.1 分布式全局ID的多种解决方案</h4><h4 id="3-8-2-使用UUID作为分布式全局唯一主键ID"><a href="#3-8-2-使用UUID作为分布式全局唯一主键ID" class="headerlink" title="3.8.2 使用UUID作为分布式全局唯一主键ID"></a>3.8.2 使用UUID作为分布式全局唯一主键ID</h4><h5 id="3-8-2-1-基于MyCAT实现全局唯一主键ID（本地文件和数据库）"><a href="#3-8-2-1-基于MyCAT实现全局唯一主键ID（本地文件和数据库）" class="headerlink" title="3.8.2.1 基于MyCAT实现全局唯一主键ID（本地文件和数据库）"></a>3.8.2.1 基于MyCAT实现全局唯一主键ID（本地文件和数据库）</h5><h5 id="3-8-2-2-基于雪花算法实现全局唯一主键ID"><a href="#3-8-2-2-基于雪花算法实现全局唯一主键ID" class="headerlink" title="3.8.2.2 基于雪花算法实现全局唯一主键ID"></a>3.8.2.2 基于雪花算法实现全局唯一主键ID</h5><h4 id="3-8-3-分布式系统CAP、BASE原理和ACID原则"><a href="#3-8-3-分布式系统CAP、BASE原理和ACID原则" class="headerlink" title="3.8.3 分布式系统CAP、BASE原理和ACID原则"></a>3.8.3 分布式系统CAP、BASE原理和ACID原则</h4><h4 id="3-8-4-分布式事务问题解析"><a href="#3-8-4-分布式事务问题解析" class="headerlink" title="3.8.4 分布式事务问题解析"></a>3.8.4 分布式事务问题解析</h4><h5 id="3-8-4-1-基于XA协议的两阶段提交解决数据一致性问题"><a href="#3-8-4-1-基于XA协议的两阶段提交解决数据一致性问题" class="headerlink" title="3.8.4.1 基于XA协议的两阶段提交解决数据一致性问题"></a>3.8.4.1 基于XA协议的两阶段提交解决数据一致性问题</h5><h5 id="3-8-4-2-使用Atomikos做分布式事务"><a href="#3-8-4-2-使用Atomikos做分布式事务" class="headerlink" title="3.8.4.2 使用Atomikos做分布式事务"></a>3.8.4.2 使用Atomikos做分布式事务</h5><h5 id="3-8-4-3-MyCAT与Sharding-JDBC分布式事务"><a href="#3-8-4-3-MyCAT与Sharding-JDBC分布式事务" class="headerlink" title="3.8.4.3 MyCAT与Sharding-JDBC分布式事务"></a>3.8.4.3 MyCAT与Sharding-JDBC分布式事务</h5><h4 id="3-8-5-基于事务补偿机制解决数据一致性"><a href="#3-8-5-基于事务补偿机制解决数据一致性" class="headerlink" title="3.8.5 基于事务补偿机制解决数据一致性"></a>3.8.5 基于事务补偿机制解决数据一致性</h4><h5 id="3-8-5-1-基于本地消息表-定时任务解决数据一致性"><a href="#3-8-5-1-基于本地消息表-定时任务解决数据一致性" class="headerlink" title="3.8.5.1 基于本地消息表+定时任务解决数据一致性"></a>3.8.5.1 基于本地消息表+定时任务解决数据一致性</h5><h5 id="3-8-5-2-基于MQ生产消费模型解决数据一致性"><a href="#3-8-5-2-基于MQ生产消费模型解决数据一致性" class="headerlink" title="3.8.5.2 基于MQ生产消费模型解决数据一致性"></a>3.8.5.2 基于MQ生产消费模型解决数据一致性</h5><h3 id="3-9-分布式接口幂等性，分布式限流"><a href="#3-9-分布式接口幂等性，分布式限流" class="headerlink" title="3.9 分布式接口幂等性，分布式限流"></a>3.9 分布式接口幂等性，分布式限流</h3><h4 id="3-9-1-基于唯一索引解决delete操作的幂等性问题"><a href="#3-9-1-基于唯一索引解决delete操作的幂等性问题" class="headerlink" title="3.9.1 基于唯一索引解决delete操作的幂等性问题"></a>3.9.1 基于唯一索引解决delete操作的幂等性问题</h4><h5 id="3-9-1-1-基于乐观锁解决update的幂等性操作问题"><a href="#3-9-1-1-基于乐观锁解决update的幂等性操作问题" class="headerlink" title="3.9.1.1 基于乐观锁解决update的幂等性操作问题"></a>3.9.1.1 基于乐观锁解决update的幂等性操作问题</h5><h5 id="3-9-1-2-通过token机制解决insert的幂等操作问题"><a href="#3-9-1-2-通过token机制解决insert的幂等操作问题" class="headerlink" title="3.9.1.2 通过token机制解决insert的幂等操作问题"></a>3.9.1.2 通过token机制解决insert的幂等操作问题</h5><h4 id="3-9-2-分布式限流技术选型"><a href="#3-9-2-分布式限流技术选型" class="headerlink" title="3.9.2 分布式限流技术选型"></a>3.9.2 分布式限流技术选型</h4><h5 id="3-9-2-1-限流常用算法讲解"><a href="#3-9-2-1-限流常用算法讲解" class="headerlink" title="3.9.2.1 限流常用算法讲解"></a>3.9.2.1 限流常用算法讲解</h5><h5 id="3-9-2-2-基于Nginx的分布式限流-IP限制"><a href="#3-9-2-2-基于Nginx的分布式限流-IP限制" class="headerlink" title="3.9.2.2 基于Nginx的分布式限流 - IP限制"></a>3.9.2.2 基于Nginx的分布式限流 - IP限制</h5><h5 id="3-9-2-3-基于Nginx的分布式限流-连接数限制"><a href="#3-9-2-3-基于Nginx的分布式限流-连接数限制" class="headerlink" title="3.9.2.3 基于Nginx的分布式限流 - 连接数限制"></a>3.9.2.3 基于Nginx的分布式限流 - 连接数限制</h5><h5 id="3-9-2-4-基于Redis-Lua的分布式限流"><a href="#3-9-2-4-基于Redis-Lua的分布式限流" class="headerlink" title="3.9.2.4 基于Redis+Lua的分布式限流"></a>3.9.2.4 基于Redis+Lua的分布式限流</h5><h5 id="3-9-2-5-基于网关层实现分布式限流"><a href="#3-9-2-5-基于网关层实现分布式限流" class="headerlink" title="3.9.2.5 基于网关层实现分布式限流"></a>3.9.2.5 基于网关层实现分布式限流</h5><h5 id="3-9-2-6-分布式限流落地"><a href="#3-9-2-6-分布式限流落地" class="headerlink" title="3.9.2.6 分布式限流落地"></a>3.9.2.6 分布式限流落地</h5><h4 id="3-9-3-分布式限流要注意的问题"><a href="#3-9-3-分布式限流要注意的问题" class="headerlink" title="3.9.3 分布式限流要注意的问题"></a>3.9.3 分布式限流要注意的问题</h4><h2 id="4-基于SpringCloud改造微服务"><a href="#4-基于SpringCloud改造微服务" class="headerlink" title="4. 基于SpringCloud改造微服务"></a>4. 基于SpringCloud改造微服务</h2><h3 id="4-1-微服务基础，治理中心Eureka"><a href="#4-1-微服务基础，治理中心Eureka" class="headerlink" title="4.1 微服务基础，治理中心Eureka"></a>4.1 微服务基础，治理中心Eureka</h3><h4 id="4-1-1-微服务架构的利弊以及面临的挑战"><a href="#4-1-1-微服务架构的利弊以及面临的挑战" class="headerlink" title="4.1.1 微服务架构的利弊以及面临的挑战"></a>4.1.1 微服务架构的利弊以及面临的挑战</h4><h5 id="4-1-1-2-微服务的拆分规范，原则"><a href="#4-1-1-2-微服务的拆分规范，原则" class="headerlink" title="4.1.1.2 微服务的拆分规范，原则"></a>4.1.1.2 微服务的拆分规范，原则</h5><h4 id="4-1-2-阿里新零售业务商品中心的微服务化过程"><a href="#4-1-2-阿里新零售业务商品中心的微服务化过程" class="headerlink" title="4.1.2 阿里新零售业务商品中心的微服务化过程"></a>4.1.2 阿里新零售业务商品中心的微服务化过程</h4><h5 id="4-1-2-1-SpringCloud和微服务架构的关系"><a href="#4-1-2-1-SpringCloud和微服务架构的关系" class="headerlink" title="4.1.2.1 SpringCloud和微服务架构的关系"></a>4.1.2.1 SpringCloud和微服务架构的关系</h5><h5 id="4-1-2-2-SpringCloud整体架构"><a href="#4-1-2-2-SpringCloud整体架构" class="headerlink" title="4.1.2.2 SpringCloud整体架构"></a>4.1.2.2 SpringCloud整体架构</h5><h4 id="4-1-3-面对疯狂演进的版本，跟还是不跟？"><a href="#4-1-3-面对疯狂演进的版本，跟还是不跟？" class="headerlink" title="4.1.3 面对疯狂演进的版本，跟还是不跟？"></a>4.1.3 面对疯狂演进的版本，跟还是不跟？</h4><h5 id="4-1-3-1-电商系统微服务化的构想"><a href="#4-1-3-1-电商系统微服务化的构想" class="headerlink" title="4.1.3.1 电商系统微服务化的构想"></a>4.1.3.1 电商系统微服务化的构想</h5><h5 id="4-1-3-2-服务治理技术选型Eureka-VS-Consul-VS-Nacos"><a href="#4-1-3-2-服务治理技术选型Eureka-VS-Consul-VS-Nacos" class="headerlink" title="4.1.3.2 服务治理技术选型Eureka VS Consul VS Nacos"></a>4.1.3.2 服务治理技术选型Eureka VS Consul VS Nacos</h5><h5 id="4-1-3-3-如何看待Eureka2-0开源计划搁置对技术选型的影响"><a href="#4-1-3-3-如何看待Eureka2-0开源计划搁置对技术选型的影响" class="headerlink" title="4.1.3.3 如何看待Eureka2.0开源计划搁置对技术选型的影响"></a>4.1.3.3 如何看待Eureka2.0开源计划搁置对技术选型的影响</h5><h4 id="4-1-4-Eureka体系架构解析"><a href="#4-1-4-Eureka体系架构解析" class="headerlink" title="4.1.4 Eureka体系架构解析"></a>4.1.4 Eureka体系架构解析</h4><h5 id="4-1-4-1-创建服务注册中心"><a href="#4-1-4-1-创建服务注册中心" class="headerlink" title="4.1.4.1 创建服务注册中心"></a>4.1.4.1 创建服务注册中心</h5><h5 id="4-1-4-2-服务注册源码探秘"><a href="#4-1-4-2-服务注册源码探秘" class="headerlink" title="4.1.4.2 服务注册源码探秘"></a>4.1.4.2 服务注册源码探秘</h5><h5 id="4-1-4-3-服务发现，心跳监测与服务剔除，服务续约，服务自保，服务下线"><a href="#4-1-4-3-服务发现，心跳监测与服务剔除，服务续约，服务自保，服务下线" class="headerlink" title="4.1.4.3 服务发现，心跳监测与服务剔除，服务续约，服务自保，服务下线"></a>4.1.4.3 服务发现，心跳监测与服务剔除，服务续约，服务自保，服务下线</h5><h5 id="4-1-4-4-心跳检测和服务续约源码探秘"><a href="#4-1-4-4-心跳检测和服务续约源码探秘" class="headerlink" title="4.1.4.4 心跳检测和服务续约源码探秘"></a>4.1.4.4 心跳检测和服务续约源码探秘</h5><h5 id="4-1-4-5-启用心跳和健康度检查"><a href="#4-1-4-5-启用心跳和健康度检查" class="headerlink" title="4.1.4.5 启用心跳和健康度检查"></a>4.1.4.5 启用心跳和健康度检查</h5><h5 id="4-1-4-6-如何保证注册中心的高可用化，单中心宕机的思考"><a href="#4-1-4-6-如何保证注册中心的高可用化，单中心宕机的思考" class="headerlink" title="4.1.4.6 如何保证注册中心的高可用化，单中心宕机的思考"></a>4.1.4.6 如何保证注册中心的高可用化，单中心宕机的思考</h5><h5 id="4-1-4-7-双备份注册中心-架构心得"><a href="#4-1-4-7-双备份注册中心-架构心得" class="headerlink" title="4.1.4.7 双备份注册中心 + 架构心得"></a>4.1.4.7 双备份注册中心 + 架构心得</h5><h5 id="4-1-4-8-电商系统用户模块集成Eureka"><a href="#4-1-4-8-电商系统用户模块集成Eureka" class="headerlink" title="4.1.4.8 电商系统用户模块集成Eureka"></a>4.1.4.8 电商系统用户模块集成Eureka</h5><h3 id="4-2-负载均衡，服务通信与调用"><a href="#4-2-负载均衡，服务通信与调用" class="headerlink" title="4.2 负载均衡，服务通信与调用"></a>4.2 负载均衡，服务通信与调用</h3><h4 id="4-2-1-负载均衡技术选型（客户端-vs-服务器端）"><a href="#4-2-1-负载均衡技术选型（客户端-vs-服务器端）" class="headerlink" title="4.2.1 负载均衡技术选型（客户端 vs 服务器端）"></a>4.2.1 负载均衡技术选型（客户端 vs 服务器端）</h4><h4 id="4-2-2-Ribbon体系架构解析"><a href="#4-2-2-Ribbon体系架构解析" class="headerlink" title="4.2.2 Ribbon体系架构解析"></a>4.2.2 Ribbon体系架构解析</h4><h5 id="4-2-2-1-为服务消费者添加负载均衡功能"><a href="#4-2-2-1-为服务消费者添加负载均衡功能" class="headerlink" title="4.2.2.1 为服务消费者添加负载均衡功能"></a>4.2.2.1 为服务消费者添加负载均衡功能</h5><h5 id="4-2-2-2-懒加载与饥饿加载"><a href="#4-2-2-2-懒加载与饥饿加载" class="headerlink" title="4.2.2.2 懒加载与饥饿加载"></a>4.2.2.2 懒加载与饥饿加载</h5><h5 id="4-2-2-3-负载均衡策略详解"><a href="#4-2-2-3-负载均衡策略详解" class="headerlink" title="4.2.2.3 负载均衡策略详解"></a>4.2.2.3 负载均衡策略详解</h5><h5 id="4-2-2-4-探究负载均衡策略源码"><a href="#4-2-2-4-探究负载均衡策略源码" class="headerlink" title="4.2.2.4 探究负载均衡策略源码"></a>4.2.2.4 探究负载均衡策略源码</h5><h5 id="4-2-2-5-深入了解LoadBalanced注解的底层机制"><a href="#4-2-2-5-深入了解LoadBalanced注解的底层机制" class="headerlink" title="4.2.2.5 深入了解LoadBalanced注解的底层机制"></a>4.2.2.5 深入了解LoadBalanced注解的底层机制</h5><h4 id="4-2-3-没有银弹！如何针对具体业务采用合适的负载均衡策略"><a href="#4-2-3-没有银弹！如何针对具体业务采用合适的负载均衡策略" class="headerlink" title="4.2.3 没有银弹！如何针对具体业务采用合适的负载均衡策略"></a>4.2.3 没有银弹！如何针对具体业务采用合适的负载均衡策略</h4><h5 id="4-2-3-1-电商系统用户模块统集成Ribbon"><a href="#4-2-3-1-电商系统用户模块统集成Ribbon" class="headerlink" title="4.2.3.1 电商系统用户模块统集成Ribbon"></a>4.2.3.1 电商系统用户模块统集成Ribbon</h5><h5 id="4-2-3-2-Ribbon可扩展性的研究-irule机制"><a href="#4-2-3-2-Ribbon可扩展性的研究-irule机制" class="headerlink" title="4.2.3.2 Ribbon可扩展性的研究-irule机制"></a>4.2.3.2 Ribbon可扩展性的研究-irule机制</h5><h5 id="4-2-3-3-自定义轮询式负载均衡策略"><a href="#4-2-3-3-自定义轮询式负载均衡策略" class="headerlink" title="4.2.3.3 自定义轮询式负载均衡策略"></a>4.2.3.3 自定义轮询式负载均衡策略</h5><h4 id="4-2-4-Feign体系架构解析"><a href="#4-2-4-Feign体系架构解析" class="headerlink" title="4.2.4 Feign体系架构解析"></a>4.2.4 Feign体系架构解析</h4><h5 id="4-2-4-1-将Feign应用到服务消费者中"><a href="#4-2-4-1-将Feign应用到服务消费者中" class="headerlink" title="4.2.4.1 将Feign应用到服务消费者中"></a>4.2.4.1 将Feign应用到服务消费者中</h5><h5 id="4-2-4-2-深入了解EnableFeignClient注解的底层机制"><a href="#4-2-4-2-深入了解EnableFeignClient注解的底层机制" class="headerlink" title="4.2.4.2 深入了解EnableFeignClient注解的底层机制"></a>4.2.4.2 深入了解EnableFeignClient注解的底层机制</h5><h5 id="4-2-4-3-理想的Feign风格项目架构分享"><a href="#4-2-4-3-理想的Feign风格项目架构分享" class="headerlink" title="4.2.4.3 理想的Feign风格项目架构分享"></a>4.2.4.3 理想的Feign风格项目架构分享</h5><h4 id="4-2-5-配置重试和超时策略"><a href="#4-2-5-配置重试和超时策略" class="headerlink" title="4.2.5 配置重试和超时策略"></a>4.2.5 配置重试和超时策略</h4><h5 id="4-2-5-1-深入了解FeignContract协议解析过程"><a href="#4-2-5-1-深入了解FeignContract协议解析过程" class="headerlink" title="4.2.5.1 深入了解FeignContract协议解析过程"></a>4.2.5.1 深入了解FeignContract协议解析过程</h5><h5 id="4-2-5-2-电商系统用户模块统集成Feign"><a href="#4-2-5-2-电商系统用户模块统集成Feign" class="headerlink" title="4.2.5.2 电商系统用户模块统集成Feign"></a>4.2.5.2 电商系统用户模块统集成Feign</h5><h3 id="4-3-服务容错—Hystrix"><a href="#4-3-服务容错—Hystrix" class="headerlink" title="4.3 服务容错—Hystrix"></a>4.3 服务容错—Hystrix</h3><h4 id="4-3-1-服务容错的解决方案-降级和熔断"><a href="#4-3-1-服务容错的解决方案-降级和熔断" class="headerlink" title="4.3.1 服务容错的解决方案 (降级和熔断)"></a>4.3.1 服务容错的解决方案 (降级和熔断)</h4><h4 id="4-3-2-Hystrix体系架构解析（依赖隔离、服务降级、请求熔断）"><a href="#4-3-2-Hystrix体系架构解析（依赖隔离、服务降级、请求熔断）" class="headerlink" title="4.3.2 Hystrix体系架构解析（依赖隔离、服务降级、请求熔断）"></a>4.3.2 Hystrix体系架构解析（依赖隔离、服务降级、请求熔断）</h4><h5 id="4-3-2-1-服务降级原理及常用解决方案-FailFast-Timeout和Request-Cache"><a href="#4-3-2-1-服务降级原理及常用解决方案-FailFast-Timeout和Request-Cache" class="headerlink" title="4.3.2.1 服务降级原理及常用解决方案(FailFast, Timeout和Request Cache)"></a>4.3.2.1 服务降级原理及常用解决方案(FailFast, Timeout和Request Cache)</h5><h5 id="4-3-2-2-Feign-Hystrix实现Fallback降级"><a href="#4-3-2-2-Feign-Hystrix实现Fallback降级" class="headerlink" title="4.3.2.2 Feign+Hystrix实现Fallback降级"></a>4.3.2.2 Feign+Hystrix实现Fallback降级</h5><h5 id="4-3-2-3-Hystrix实现Request-Cache降级"><a href="#4-3-2-3-Hystrix实现Request-Cache降级" class="headerlink" title="4.3.2.3 Hystrix实现Request Cache降级"></a>4.3.2.3 Hystrix实现Request Cache降级</h5><h5 id="4-3-2-4-多级降级方案-自定义降级处理类，二次降级"><a href="#4-3-2-4-多级降级方案-自定义降级处理类，二次降级" class="headerlink" title="4.3.2.4 多级降级方案(自定义降级处理类，二次降级)"></a>4.3.2.4 多级降级方案(自定义降级处理类，二次降级)</h5><h5 id="4-3-2-5-超时降级-规避与Ribbon共同作用时的坑"><a href="#4-3-2-5-超时降级-规避与Ribbon共同作用时的坑" class="headerlink" title="4.3.2.5 超时降级 - 规避与Ribbon共同作用时的坑"></a>4.3.2.5 超时降级 - 规避与Ribbon共同作用时的坑</h5><h5 id="4-3-2-6-Hystrix框架降级方案的触发方式（源码品读）"><a href="#4-3-2-6-Hystrix框架降级方案的触发方式（源码品读）" class="headerlink" title="4.3.2.6 Hystrix框架降级方案的触发方式（源码品读）"></a>4.3.2.6 Hystrix框架降级方案的触发方式（源码品读）</h5><h4 id="4-3-3-熔断器以及工作原理"><a href="#4-3-3-熔断器以及工作原理" class="headerlink" title="4.3.3 熔断器以及工作原理"></a>4.3.3 熔断器以及工作原理</h4><h5 id="4-3-3-1-Feign集成Hystrix熔断器"><a href="#4-3-3-1-Feign集成Hystrix熔断器" class="headerlink" title="4.3.3.1 Feign集成Hystrix熔断器"></a>4.3.3.1 Feign集成Hystrix熔断器</h5><h5 id="4-3-3-2-Hystrix熔断器参数的作用（源码品读）"><a href="#4-3-3-2-Hystrix熔断器参数的作用（源码品读）" class="headerlink" title="4.3.3.2 Hystrix熔断器参数的作用（源码品读）"></a>4.3.3.2 Hystrix熔断器参数的作用（源码品读）</h5><h5 id="4-3-3-3-降级熔断的业务规划（规划主链路-业务与容灾策略）"><a href="#4-3-3-3-降级熔断的业务规划（规划主链路-业务与容灾策略）" class="headerlink" title="4.3.3.3 降级熔断的业务规划（规划主链路/业务与容灾策略）"></a>4.3.3.3 降级熔断的业务规划（规划主链路/业务与容灾策略）</h5><h5 id="4-3-3-4-线程隔离-核心方案以及工作原理"><a href="#4-3-3-4-线程隔离-核心方案以及工作原理" class="headerlink" title="4.3.3.4 线程隔离 - 核心方案以及工作原理"></a>4.3.3.4 线程隔离 - 核心方案以及工作原理</h5><h5 id="4-3-3-5-线程池-vs-信号量的优缺点比较"><a href="#4-3-3-5-线程池-vs-信号量的优缺点比较" class="headerlink" title="4.3.3.5 线程池 vs 信号量的优缺点比较"></a>4.3.3.5 线程池 vs 信号量的优缺点比较</h5><h5 id="4-3-3-6-聚合Hystrix监控信息-–-Turbine和Hystrix-Dashboard"><a href="#4-3-3-6-聚合Hystrix监控信息-–-Turbine和Hystrix-Dashboard" class="headerlink" title="4.3.3.6 聚合Hystrix监控信息 – Turbine和Hystrix Dashboard"></a>4.3.3.6 聚合Hystrix监控信息 – Turbine和Hystrix Dashboard</h5><h5 id="4-3-3-7-通过Turbine聚合Consumer信息"><a href="#4-3-3-7-通过Turbine聚合Consumer信息" class="headerlink" title="4.3.3.7 通过Turbine聚合Consumer信息"></a>4.3.3.7 通过Turbine聚合Consumer信息</h5><h5 id="4-3-3-8-电商系统用户模块集成Hystrix实现降级熔断"><a href="#4-3-3-8-电商系统用户模块集成Hystrix实现降级熔断" class="headerlink" title="4.3.3.8 电商系统用户模块集成Hystrix实现降级熔断"></a>4.3.3.8 电商系统用户模块集成Hystrix实现降级熔断</h5><h3 id="4-4-分布式配置中心—Config"><a href="#4-4-分布式配置中心—Config" class="headerlink" title="4.4 分布式配置中心—Config"></a>4.4 分布式配置中心—Config</h3><h4 id="4-4-1-配置中心在微服务中的应用"><a href="#4-4-1-配置中心在微服务中的应用" class="headerlink" title="4.4.1 配置中心在微服务中的应用"></a>4.4.1 配置中心在微服务中的应用</h4><h5 id="4-4-1-1-Config核心功能和体系架构"><a href="#4-4-1-1-Config核心功能和体系架构" class="headerlink" title="4.4.1.1 Config核心功能和体系架构"></a>4.4.1.1 Config核心功能和体系架构</h5><h4 id="4-4-2-了解直联式架构，搭建直连式的配置中心"><a href="#4-4-2-了解直联式架构，搭建直连式的配置中心" class="headerlink" title="4.4.2 了解直联式架构，搭建直连式的配置中心"></a>4.4.2 了解直联式架构，搭建直连式的配置中心</h4><h5 id="4-4-2-1-搭建配置中心Config-Server"><a href="#4-4-2-1-搭建配置中心Config-Server" class="headerlink" title="4.4.2.1 搭建配置中心Config-Server"></a>4.4.2.1 搭建配置中心Config-Server</h5><h5 id="4-4-2-2-搭建Client端直连配置中心"><a href="#4-4-2-2-搭建Client端直连配置中心" class="headerlink" title="4.4.2.2 搭建Client端直连配置中心"></a>4.4.2.2 搭建Client端直连配置中心</h5><h4 id="4-4-3-资源文件加载流程ResourceRepository源码分析"><a href="#4-4-3-资源文件加载流程ResourceRepository源码分析" class="headerlink" title="4.4.3 资源文件加载流程ResourceRepository源码分析"></a>4.4.3 资源文件加载流程ResourceRepository源码分析</h4><h5 id="4-4-3-1-如何在运行期动态刷新配置项"><a href="#4-4-3-1-如何在运行期动态刷新配置项" class="headerlink" title="4.4.3.1 如何在运行期动态刷新配置项"></a>4.4.3.1 如何在运行期动态刷新配置项</h5><h5 id="4-4-3-2-单中心宕机的思考，如何保证配置中心的高可用化"><a href="#4-4-3-2-单中心宕机的思考，如何保证配置中心的高可用化" class="headerlink" title="4.4.3.2 单中心宕机的思考，如何保证配置中心的高可用化"></a>4.4.3.2 单中心宕机的思考，如何保证配置中心的高可用化</h5><h4 id="4-4-4-借助Eureka实现高可用性配置中心"><a href="#4-4-4-借助Eureka实现高可用性配置中心" class="headerlink" title="4.4.4 借助Eureka实现高可用性配置中心"></a>4.4.4 借助Eureka实现高可用性配置中心</h4><h5 id="4-4-4-1-如何对大规模集群进行刷新？总线式架构展望"><a href="#4-4-4-1-如何对大规模集群进行刷新？总线式架构展望" class="headerlink" title="4.4.4.1 如何对大规模集群进行刷新？总线式架构展望"></a>4.4.4.1 如何对大规模集群进行刷新？总线式架构展望</h5><h5 id="4-4-4-2-对称性密钥进行加解密-保存私密信息"><a href="#4-4-4-2-对称性密钥进行加解密-保存私密信息" class="headerlink" title="4.4.4.2 对称性密钥进行加解密(保存私密信息)"></a>4.4.4.2 对称性密钥进行加解密(保存私密信息)</h5><h4 id="4-4-5-分布式配置中心的其他花式用法-环境配置项隔离-辅助服务降级-平滑灰度等"><a href="#4-4-5-分布式配置中心的其他花式用法-环境配置项隔离-辅助服务降级-平滑灰度等" class="headerlink" title="4.4.5 分布式配置中心的其他花式用法(环境配置项隔离/辅助服务降级/平滑灰度等)"></a>4.4.5 分布式配置中心的其他花式用法(环境配置项隔离/辅助服务降级/平滑灰度等)</h4><h5 id="4-4-5-1-电商系统用户注册功能集成SCC"><a href="#4-4-5-1-电商系统用户注册功能集成SCC" class="headerlink" title="4.4.5.1 电商系统用户注册功能集成SCC"></a>4.4.5.1 电商系统用户注册功能集成SCC</h5><h5 id="4-4-5-2-视野拓展-阿里系的分布式配置中心"><a href="#4-4-5-2-视野拓展-阿里系的分布式配置中心" class="headerlink" title="4.4.5.2 视野拓展-阿里系的分布式配置中心"></a>4.4.5.2 视野拓展-阿里系的分布式配置中心</h5><h5 id="4-4-5-3-视野拓展-配置中心在阿里新零售业务中的应用"><a href="#4-4-5-3-视野拓展-配置中心在阿里新零售业务中的应用" class="headerlink" title="4.4.5.3 视野拓展-配置中心在阿里新零售业务中的应用"></a>4.4.5.3 视野拓展-配置中心在阿里新零售业务中的应用</h5><h3 id="4-5-消息总线，服务网关"><a href="#4-5-消息总线，服务网关" class="headerlink" title="4.5 消息总线，服务网关"></a>4.5 消息总线，服务网关</h3><h4 id="4-5-1-Bus体系架构解析"><a href="#4-5-1-Bus体系架构解析" class="headerlink" title="4.5.1 Bus体系架构解析"></a>4.5.1 Bus体系架构解析</h4><h5 id="4-5-1-2-Bus的接入方式-RabbitMQ、Kafka"><a href="#4-5-1-2-Bus的接入方式-RabbitMQ、Kafka" class="headerlink" title="4.5.1.2 Bus的接入方式 (RabbitMQ、Kafka)"></a>4.5.1.2 Bus的接入方式 (RabbitMQ、Kafka)</h5><h4 id="4-5-2-配置中心改造为总线架构-RabbitMQ"><a href="#4-5-2-配置中心改造为总线架构-RabbitMQ" class="headerlink" title="4.5.2 配置中心改造为总线架构 - RabbitMQ"></a>4.5.2 配置中心改造为总线架构 - RabbitMQ</h4><h5 id="4-5-2-1-源码解析-bus-refresh底层机制"><a href="#4-5-2-1-源码解析-bus-refresh底层机制" class="headerlink" title="4.5.2.1 源码解析-bus-refresh底层机制"></a>4.5.2.1 源码解析-bus-refresh底层机制</h5><h5 id="4-5-2-2-如何实现自动推送？Git-WebHook"><a href="#4-5-2-2-如何实现自动推送？Git-WebHook" class="headerlink" title="4.5.2.2 如何实现自动推送？Git WebHook"></a>4.5.2.2 如何实现自动推送？Git WebHook</h5><h4 id="4-5-3-架构思考-消息总线如何助攻其他业务场景"><a href="#4-5-3-架构思考-消息总线如何助攻其他业务场景" class="headerlink" title="4.5.3 架构思考-消息总线如何助攻其他业务场景"></a>4.5.3 架构思考-消息总线如何助攻其他业务场景</h4><h5 id="4-5-3-1-网关组件选型Gateway-vs-Zuul"><a href="#4-5-3-1-网关组件选型Gateway-vs-Zuul" class="headerlink" title="4.5.3.1 网关组件选型Gateway vs Zuul"></a>4.5.3.1 网关组件选型Gateway vs Zuul</h5><h5 id="4-5-3-2-Gateway体系架构解析"><a href="#4-5-3-2-Gateway体系架构解析" class="headerlink" title="4.5.3.2 Gateway体系架构解析"></a>4.5.3.2 Gateway体系架构解析</h5><h5 id="4-5-3-3-Gateway路由功能详解（Route）"><a href="#4-5-3-3-Gateway路由功能详解（Route）" class="headerlink" title="4.5.3.3 Gateway路由功能详解（Route）"></a>4.5.3.3 Gateway路由功能详解（Route）</h5><h5 id="4-5-3-4-利用Path断言实现url映射"><a href="#4-5-3-4-利用Path断言实现url映射" class="headerlink" title="4.5.3.4 利用Path断言实现url映射"></a>4.5.3.4 利用Path断言实现url映射</h5><h5 id="4-5-3-5-利用After断言实现定时秒杀场景"><a href="#4-5-3-5-利用After断言实现定时秒杀场景" class="headerlink" title="4.5.3.5 利用After断言实现定时秒杀场景"></a>4.5.3.5 利用After断言实现定时秒杀场景</h5><h5 id="4-5-3-6-自定义过滤器实现接口计时功能"><a href="#4-5-3-6-自定义过滤器实现接口计时功能" class="headerlink" title="4.5.3.6 自定义过滤器实现接口计时功能"></a>4.5.3.6 自定义过滤器实现接口计时功能</h5><h4 id="4-5-4-Gateway过滤器机制源码解析"><a href="#4-5-4-Gateway过滤器机制源码解析" class="headerlink" title="4.5.4 Gateway过滤器机制源码解析"></a>4.5.4 Gateway过滤器机制源码解析</h4><h5 id="4-5-4-1-如何进行权限认证-分布式Session的替代方案有哪些"><a href="#4-5-4-1-如何进行权限认证-分布式Session的替代方案有哪些" class="headerlink" title="4.5.4.1 如何进行权限认证 - 分布式Session的替代方案有哪些"></a>4.5.4.1 如何进行权限认证 - 分布式Session的替代方案有哪些</h5><h5 id="4-5-4-2-基于JWT实现用户鉴权"><a href="#4-5-4-2-基于JWT实现用户鉴权" class="headerlink" title="4.5.4.2 基于JWT实现用户鉴权"></a>4.5.4.2 基于JWT实现用户鉴权</h5><h5 id="4-5-4-3-架构思考-如何借助网关层对服务端各类异常做统一处理"><a href="#4-5-4-3-架构思考-如何借助网关层对服务端各类异常做统一处理" class="headerlink" title="4.5.4.3 架构思考-如何借助网关层对服务端各类异常做统一处理"></a>4.5.4.3 架构思考-如何借助网关层对服务端各类异常做统一处理</h5><h5 id="4-5-4-4-拓展-网关层的其他妙用-限流"><a href="#4-5-4-4-拓展-网关层的其他妙用-限流" class="headerlink" title="4.5.4.4 拓展-网关层的其他妙用 - 限流"></a>4.5.4.4 拓展-网关层的其他妙用 - 限流</h5><h5 id="4-5-4-5-为电商系统添加服务网关"><a href="#4-5-4-5-为电商系统添加服务网关" class="headerlink" title="4.5.4.5 为电商系统添加服务网关"></a>4.5.4.5 为电商系统添加服务网关</h5><h3 id="4-6-服务调用追踪，消息驱动"><a href="#4-6-服务调用追踪，消息驱动" class="headerlink" title="4.6 服务调用追踪，消息驱动"></a>4.6 服务调用追踪，消息驱动</h3><h4 id="4-6-1-调用链追溯在微服务中的应用"><a href="#4-6-1-调用链追溯在微服务中的应用" class="headerlink" title="4.6.1 调用链追溯在微服务中的应用"></a>4.6.1 调用链追溯在微服务中的应用</h4><h5 id="4-6-1-1-Sleuth核心功能和体系架构解析"><a href="#4-6-1-1-Sleuth核心功能和体系架构解析" class="headerlink" title="4.6.1.1 Sleuth核心功能和体系架构解析"></a>4.6.1.1 Sleuth核心功能和体系架构解析</h5><h5 id="4-6-1-2-调用链路数据模型-Trace、Span、Annotation"><a href="#4-6-1-2-调用链路数据模型-Trace、Span、Annotation" class="headerlink" title="4.6.1.2 调用链路数据模型 (Trace、Span、Annotation)"></a>4.6.1.2 调用链路数据模型 (Trace、Span、Annotation)</h5><h5 id="4-6-1-3-整合Sleuth追踪调用链路"><a href="#4-6-1-3-整合Sleuth追踪调用链路" class="headerlink" title="4.6.1.3 整合Sleuth追踪调用链路"></a>4.6.1.3 整合Sleuth追踪调用链路</h5><h4 id="4-6-2-解码解析-RequestHeader追踪调用链路的原理"><a href="#4-6-2-解码解析-RequestHeader追踪调用链路的原理" class="headerlink" title="4.6.2 解码解析-RequestHeader追踪调用链路的原理"></a>4.6.2 解码解析-RequestHeader追踪调用链路的原理</h4><h5 id="4-6-2-1-Sleuth整合ELK实现日志检索"><a href="#4-6-2-1-Sleuth整合ELK实现日志检索" class="headerlink" title="4.6.2.1 Sleuth整合ELK实现日志检索"></a>4.6.2.1 Sleuth整合ELK实现日志检索</h5><h5 id="4-6-2-2-电商项目用户模块集成Sleuth-Zipkin"><a href="#4-6-2-2-电商项目用户模块集成Sleuth-Zipkin" class="headerlink" title="4.6.2.2 电商项目用户模块集成Sleuth + Zipkin"></a>4.6.2.2 电商项目用户模块集成Sleuth + Zipkin</h5><h5 id="4-6-2-3-拓展-阿里新零售业务中商品发布的削峰策略"><a href="#4-6-2-3-拓展-阿里新零售业务中商品发布的削峰策略" class="headerlink" title="4.6.2.3 拓展-阿里新零售业务中商品发布的削峰策略"></a>4.6.2.3 拓展-阿里新零售业务中商品发布的削峰策略</h5><h4 id="4-6-3-源码解析-探秘Stream-Binder作用机制"><a href="#4-6-3-源码解析-探秘Stream-Binder作用机制" class="headerlink" title="4.6.3 源码解析-探秘Stream Binder作用机制"></a>4.6.3 源码解析-探秘Stream Binder作用机制</h4><h5 id="4-6-3-1-基于发布订阅实现广播功能"><a href="#4-6-3-1-基于发布订阅实现广播功能" class="headerlink" title="4.6.3.1 基于发布订阅实现广播功能"></a>4.6.3.1 基于发布订阅实现广播功能</h5><h5 id="4-6-3-2-阿里新零售业务利用发布订阅实现商品信息刷新"><a href="#4-6-3-2-阿里新零售业务利用发布订阅实现商品信息刷新" class="headerlink" title="4.6.3.2 阿里新零售业务利用发布订阅实现商品信息刷新"></a>4.6.3.2 阿里新零售业务利用发布订阅实现商品信息刷新</h5><h5 id="4-6-3-3-Stream中的消费组和消费分区机制"><a href="#4-6-3-3-Stream中的消费组和消费分区机制" class="headerlink" title="4.6.3.3 Stream中的消费组和消费分区机制"></a>4.6.3.3 Stream中的消费组和消费分区机制</h5><h5 id="4-6-3-4-基于消费组实现轮询单播功能"><a href="#4-6-3-4-基于消费组实现轮询单播功能" class="headerlink" title="4.6.3.4 基于消费组实现轮询单播功能"></a>4.6.3.4 基于消费组实现轮询单播功能</h5><h5 id="4-6-3-5-Stream-MQ插件实现延迟消息、equeue操作"><a href="#4-6-3-5-Stream-MQ插件实现延迟消息、equeue操作" class="headerlink" title="4.6.3.5 Stream + MQ插件实现延迟消息、equeue操作"></a>4.6.3.5 Stream + MQ插件实现延迟消息、equeue操作</h5><h4 id="4-6-4-架构思考-异常情况导致消息无法被消费怎么办？"><a href="#4-6-4-架构思考-异常情况导致消息无法被消费怎么办？" class="headerlink" title="4.6.4 架构思考-异常情况导致消息无法被消费怎么办？"></a>4.6.4 架构思考-异常情况导致消息无法被消费怎么办？</h4><h5 id="4-6-4-1-借助死信队列实现异常处理"><a href="#4-6-4-1-借助死信队列实现异常处理" class="headerlink" title="4.6.4.1 借助死信队列实现异常处理"></a>4.6.4.1 借助死信队列实现异常处理</h5><h5 id="4-6-4-2-定制自定义异常逻辑"><a href="#4-6-4-2-定制自定义异常逻辑" class="headerlink" title="4.6.4.2 定制自定义异常逻辑"></a>4.6.4.2 定制自定义异常逻辑</h5><h5 id="4-6-4-3-电商项目引入Stream-MQ"><a href="#4-6-4-3-电商项目引入Stream-MQ" class="headerlink" title="4.6.4.3 电商项目引入Stream + MQ"></a>4.6.4.3 电商项目引入Stream + MQ</h5><h3 id="4-7-微服务下Sentinel流量防控哨兵"><a href="#4-7-微服务下Sentinel流量防控哨兵" class="headerlink" title="4.7 微服务下Sentinel流量防控哨兵"></a>4.7 微服务下Sentinel流量防控哨兵</h3><h4 id="4-7-1-Sentinel哨兵全景分析"><a href="#4-7-1-Sentinel哨兵全景分析" class="headerlink" title="4.7.1 Sentinel哨兵全景分析"></a>4.7.1 Sentinel哨兵全景分析</h4><h5 id="4-7-1-2-Sentinel哨兵核心API详解"><a href="#4-7-1-2-Sentinel哨兵核心API详解" class="headerlink" title="4.7.1.2 Sentinel哨兵核心API详解"></a>4.7.1.2 Sentinel哨兵核心API详解</h5><h5 id="4-7-1-3-源码解析-Sentinel哨兵核心主流程分析"><a href="#4-7-1-3-源码解析-Sentinel哨兵核心主流程分析" class="headerlink" title="4.7.1.3 源码解析-Sentinel哨兵核心主流程分析"></a>4.7.1.3 源码解析-Sentinel哨兵核心主流程分析</h5><h4 id="4-7-2-Sentinel哨兵SpringAOP注解方式应用"><a href="#4-7-2-Sentinel哨兵SpringAOP注解方式应用" class="headerlink" title="4.7.2 Sentinel哨兵SpringAOP注解方式应用"></a>4.7.2 Sentinel哨兵SpringAOP注解方式应用</h4><h5 id="4-7-2-1-Sentinel哨兵与主流框架的适配使用"><a href="#4-7-2-1-Sentinel哨兵与主流框架的适配使用" class="headerlink" title="4.7.2.1 Sentinel哨兵与主流框架的适配使用"></a>4.7.2.1 Sentinel哨兵与主流框架的适配使用</h5><h5 id="4-7-2-2-Sentinel哨兵集群流控策与替代方案分享"><a href="#4-7-2-2-Sentinel哨兵集群流控策与替代方案分享" class="headerlink" title="4.7.2.2 Sentinel哨兵集群流控策与替代方案分享"></a>4.7.2.2 Sentinel哨兵集群流控策与替代方案分享</h5><h5 id="4-7-2-3-Sentinel哨兵集成Apollo-携程的开源配置中心"><a href="#4-7-2-3-Sentinel哨兵集成Apollo-携程的开源配置中心" class="headerlink" title="4.7.2.3 Sentinel哨兵集成Apollo(携程的开源配置中心)"></a>4.7.2.3 Sentinel哨兵集成Apollo(携程的开源配置中心)</h5><h4 id="4-7-3-Apollo持久化规则扩展思路详解"><a href="#4-7-3-Apollo持久化规则扩展思路详解" class="headerlink" title="4.7.3 Apollo持久化规则扩展思路详解"></a>4.7.3 Apollo持久化规则扩展思路详解</h4><h5 id="4-7-3-1-Apollo配置文件解析与ApolloOpenApiClient创建"><a href="#4-7-3-1-Apollo配置文件解析与ApolloOpenApiClient创建" class="headerlink" title="4.7.3.1 Apollo配置文件解析与ApolloOpenApiClient创建"></a>4.7.3.1 Apollo配置文件解析与ApolloOpenApiClient创建</h5><h5 id="4-7-3-2-Apollo-sentinel-dashboard扩展实现"><a href="#4-7-3-2-Apollo-sentinel-dashboard扩展实现" class="headerlink" title="4.7.3.2 Apollo sentinel-dashboard扩展实现"></a>4.7.3.2 Apollo sentinel-dashboard扩展实现</h5><h5 id="4-7-3-3-Apollo-客户端集成sentinel-dashboard"><a href="#4-7-3-3-Apollo-客户端集成sentinel-dashboard" class="headerlink" title="4.7.3.3 Apollo 客户端集成sentinel-dashboard"></a>4.7.3.3 Apollo 客户端集成sentinel-dashboard</h5><h3 id="4-8-微服务治理之Dubbo"><a href="#4-8-微服务治理之Dubbo" class="headerlink" title="4.8 微服务治理之Dubbo"></a>4.8 微服务治理之Dubbo</h3><h4 id="4-8-1-RPC-VS-HTTP"><a href="#4-8-1-RPC-VS-HTTP" class="headerlink" title="4.8.1 RPC VS HTTP"></a>4.8.1 RPC VS HTTP</h4><h4 id="4-8-2-Dubbo架构设计解析"><a href="#4-8-2-Dubbo架构设计解析" class="headerlink" title="4.8.2 Dubbo架构设计解析"></a>4.8.2 Dubbo架构设计解析</h4><h5 id="4-8-2-1-Dubbo核心功能讲解"><a href="#4-8-2-1-Dubbo核心功能讲解" class="headerlink" title="4.8.2.1 Dubbo核心功能讲解"></a>4.8.2.1 Dubbo核心功能讲解</h5><h5 id="4-8-2-2-构建Dubbo注册中心和Service-Provider"><a href="#4-8-2-2-构建Dubbo注册中心和Service-Provider" class="headerlink" title="4.8.2.2 构建Dubbo注册中心和Service Provider"></a>4.8.2.2 构建Dubbo注册中心和Service Provider</h5><h4 id="4-8-3-RPC协议解析流程"><a href="#4-8-3-RPC协议解析流程" class="headerlink" title="4.8.3 RPC协议解析流程"></a>4.8.3 RPC协议解析流程</h4><h5 id="4-8-3-1-构建服务消费者"><a href="#4-8-3-1-构建服务消费者" class="headerlink" title="4.8.3.1 构建服务消费者"></a>4.8.3.1 构建服务消费者</h5><h5 id="4-8-3-2-容错策略，负载均衡"><a href="#4-8-3-2-容错策略，负载均衡" class="headerlink" title="4.8.3.2 容错策略，负载均衡"></a>4.8.3.2 容错策略，负载均衡</h5><h5 id="4-8-3-3-基于Dubbo-Admin的服务治理"><a href="#4-8-3-3-基于Dubbo-Admin的服务治理" class="headerlink" title="4.8.3.3 基于Dubbo-Admin的服务治理"></a>4.8.3.3 基于Dubbo-Admin的服务治理</h5><h5 id="4-8-3-4-源码解析-Dubbo调用链路解析"><a href="#4-8-3-4-源码解析-Dubbo调用链路解析" class="headerlink" title="4.8.3.4 源码解析-Dubbo调用链路解析"></a>4.8.3.4 源码解析-Dubbo调用链路解析</h5><h4 id="4-8-4-拓展-阿里系王牌中间件-HSF"><a href="#4-8-4-拓展-阿里系王牌中间件-HSF" class="headerlink" title="4.8.4 拓展-阿里系王牌中间件 - HSF"></a>4.8.4 拓展-阿里系王牌中间件 - HSF</h4><h2 id="5-容器化—docker-amp-K8S"><a href="#5-容器化—docker-amp-K8S" class="headerlink" title="5. 容器化—docker&amp;K8S"></a>5. 容器化—docker&amp;K8S</h2><h3 id="5-1-服务容器化—docker"><a href="#5-1-服务容器化—docker" class="headerlink" title="5.1 服务容器化—docker"></a>5.1 服务容器化—docker</h3><h4 id="5-1-1-服务容器化优势和助力"><a href="#5-1-1-服务容器化优势和助力" class="headerlink" title="5.1.1 服务容器化优势和助力"></a>5.1.1 服务容器化优势和助力</h4><h5 id="5-1-1-1-服务容器化技术演进之路"><a href="#5-1-1-1-服务容器化技术演进之路" class="headerlink" title="5.1.1.1 服务容器化技术演进之路"></a>5.1.1.1 服务容器化技术演进之路</h5><h5 id="5-1-1-2-容器技术选型Docker-VS-Cloud-Foundry"><a href="#5-1-1-2-容器技术选型Docker-VS-Cloud-Foundry" class="headerlink" title="5.1.1.2 容器技术选型Docker VS Cloud Foundry"></a>5.1.1.2 容器技术选型Docker VS Cloud Foundry</h5><h4 id="5-1-2-Docker快速搭建，Docker整体架构解析"><a href="#5-1-2-Docker快速搭建，Docker整体架构解析" class="headerlink" title="5.1.2 Docker快速搭建，Docker整体架构解析"></a>5.1.2 Docker快速搭建，Docker整体架构解析</h4><h5 id="5-1-2-1-容器生命周期管理"><a href="#5-1-2-1-容器生命周期管理" class="headerlink" title="5.1.2.1 容器生命周期管理"></a>5.1.2.1 容器生命周期管理</h5><h5 id="5-1-2-3-Dockerfile实战：如何站在巨人的肩膀上，实现快速部署"><a href="#5-1-2-3-Dockerfile实战：如何站在巨人的肩膀上，实现快速部署" class="headerlink" title="5.1.2.3 Dockerfile实战：如何站在巨人的肩膀上，实现快速部署"></a>5.1.2.3 Dockerfile实战：如何站在巨人的肩膀上，实现快速部署</h5><h4 id="5-1-3-如何实现容器间的网络访问和通信管理"><a href="#5-1-3-如何实现容器间的网络访问和通信管理" class="headerlink" title="5.1.3 如何实现容器间的网络访问和通信管理"></a>5.1.3 如何实现容器间的网络访问和通信管理</h4><h5 id="5-1-3-1-选择最适合你的容器镜像仓库"><a href="#5-1-3-1-选择最适合你的容器镜像仓库" class="headerlink" title="5.1.3.1 选择最适合你的容器镜像仓库"></a>5.1.3.1 选择最适合你的容器镜像仓库</h5><h5 id="5-1-3-2-Docker生态圈：选型和优化"><a href="#5-1-3-2-Docker生态圈：选型和优化" class="headerlink" title="5.1.3.2 Docker生态圈：选型和优化"></a>5.1.3.2 Docker生态圈：选型和优化</h5><h5 id="5-1-3-3-Docker落地实战，部署微服务"><a href="#5-1-3-3-Docker落地实战，部署微服务" class="headerlink" title="5.1.3.3 Docker落地实战，部署微服务"></a>5.1.3.3 Docker落地实战，部署微服务</h5><h3 id="5-2-容器部署Cloud-Foundry"><a href="#5-2-容器部署Cloud-Foundry" class="headerlink" title="5.2 容器部署Cloud Foundry"></a>5.2 容器部署Cloud Foundry</h3><h4 id="5-2-1-Cloud-Foundry整体架构解析"><a href="#5-2-1-Cloud-Foundry整体架构解析" class="headerlink" title="5.2.1 Cloud Foundry整体架构解析"></a>5.2.1 Cloud Foundry整体架构解析</h4><h4 id="5-2-2-Cloud-Foundry环境搭建"><a href="#5-2-2-Cloud-Foundry环境搭建" class="headerlink" title="5.2.2 Cloud Foundry环境搭建"></a>5.2.2 Cloud Foundry环境搭建</h4><h5 id="5-2-2-1-Cloud-Foundry常用命令实战，实现容器生命周期管理"><a href="#5-2-2-1-Cloud-Foundry常用命令实战，实现容器生命周期管理" class="headerlink" title="5.2.2.1 Cloud Foundry常用命令实战，实现容器生命周期管理"></a>5.2.2.1 Cloud Foundry常用命令实战，实现容器生命周期管理</h5><h5 id="5-2-2-2-Cloud-Foundry网络管理-路由和访问控制"><a href="#5-2-2-2-Cloud-Foundry网络管理-路由和访问控制" class="headerlink" title="5.2.2.2 Cloud Foundry网络管理(路由和访问控制)"></a>5.2.2.2 Cloud Foundry网络管理(路由和访问控制)</h5><h5 id="5-2-2-3-基于Cloud-Foundry网络特性实现业务蓝绿发布"><a href="#5-2-2-3-基于Cloud-Foundry网络特性实现业务蓝绿发布" class="headerlink" title="5.2.2.3 基于Cloud Foundry网络特性实现业务蓝绿发布"></a>5.2.2.3 基于Cloud Foundry网络特性实现业务蓝绿发布</h5><h4 id="5-2-3-Cloud-Foundry数据服务管理-关系型数据库-缓存-配置管理"><a href="#5-2-3-Cloud-Foundry数据服务管理-关系型数据库-缓存-配置管理" class="headerlink" title="5.2.3 Cloud Foundry数据服务管理(关系型数据库/缓存/配置管理)"></a>5.2.3 Cloud Foundry数据服务管理(关系型数据库/缓存/配置管理)</h4><h5 id="5-2-3-1-如何实现数据持久层的高可用和业务连续性-架构思考"><a href="#5-2-3-1-如何实现数据持久层的高可用和业务连续性-架构思考" class="headerlink" title="5.2.3.1 如何实现数据持久层的高可用和业务连续性(架构思考)"></a>5.2.3.1 如何实现数据持久层的高可用和业务连续性(架构思考)</h5><h5 id="5-2-3-2-Cloud-Foundry容器应用和PaaS平台双重管理-Ops-amp-Aps-Manager"><a href="#5-2-3-2-Cloud-Foundry容器应用和PaaS平台双重管理-Ops-amp-Aps-Manager" class="headerlink" title="5.2.3.2 Cloud Foundry容器应用和PaaS平台双重管理(Ops &amp; Aps Manager)"></a>5.2.3.2 Cloud Foundry容器应用和PaaS平台双重管理(Ops &amp; Aps Manager)</h5><h5 id="5-2-3-3-Cloud-Foundry混合容器云架构和实践"><a href="#5-2-3-3-Cloud-Foundry混合容器云架构和实践" class="headerlink" title="5.2.3.3 Cloud Foundry混合容器云架构和实践"></a>5.2.3.3 Cloud Foundry混合容器云架构和实践</h5><h5 id="5-2-3-4-Cloud-Foundry落地实战，部署微服务"><a href="#5-2-3-4-Cloud-Foundry落地实战，部署微服务" class="headerlink" title="5.2.3.4 Cloud Foundry落地实战，部署微服务"></a>5.2.3.4 Cloud Foundry落地实战，部署微服务</h5><h3 id="5-3-容器编排—Mesos-Marathon"><a href="#5-3-容器编排—Mesos-Marathon" class="headerlink" title="5.3 容器编排—Mesos+Marathon"></a>5.3 容器编排—Mesos+Marathon</h3><h4 id="5-3-1-Mesos-Marathon整体架构解析"><a href="#5-3-1-Mesos-Marathon整体架构解析" class="headerlink" title="5.3.1 Mesos+Marathon整体架构解析"></a>5.3.1 Mesos+Marathon整体架构解析</h4><h5 id="5-3-1-1-Mesos-Marathon环境搭建和小试牛刀"><a href="#5-3-1-1-Mesos-Marathon环境搭建和小试牛刀" class="headerlink" title="5.3.1.1 Mesos+Marathon环境搭建和小试牛刀"></a>5.3.1.1 Mesos+Marathon环境搭建和小试牛刀</h5><h4 id="5-3-2-Mesos资源管理原理剖析与实战"><a href="#5-3-2-Mesos资源管理原理剖析与实战" class="headerlink" title="5.3.2 Mesos资源管理原理剖析与实战"></a>5.3.2 Mesos资源管理原理剖析与实战</h4><h5 id="5-3-2-1-Mesos实现DCOS多类型负载综合管理"><a href="#5-3-2-1-Mesos实现DCOS多类型负载综合管理" class="headerlink" title="5.3.2.1 Mesos实现DCOS多类型负载综合管理"></a>5.3.2.1 Mesos实现DCOS多类型负载综合管理</h5><h5 id="5-3-2-2-Marathon调度器原理剖析与实战-常驻服务生命周期管理"><a href="#5-3-2-2-Marathon调度器原理剖析与实战-常驻服务生命周期管理" class="headerlink" title="5.3.2.2 Marathon调度器原理剖析与实战(常驻服务生命周期管理)"></a>5.3.2.2 Marathon调度器原理剖析与实战(常驻服务生命周期管理)</h5><h5 id="5-3-2-3-Marathon应用隔离和依赖管理"><a href="#5-3-2-3-Marathon应用隔离和依赖管理" class="headerlink" title="5.3.2.3 Marathon应用隔离和依赖管理"></a>5.3.2.3 Marathon应用隔离和依赖管理</h5><h5 id="5-3-2-4-如何实现无单点、大集群容器编排管理"><a href="#5-3-2-4-如何实现无单点、大集群容器编排管理" class="headerlink" title="5.3.2.4 如何实现无单点、大集群容器编排管理"></a>5.3.2.4 如何实现无单点、大集群容器编排管理</h5><h5 id="5-3-2-5-Mesos-Marathon落地实战，部署微服务"><a href="#5-3-2-5-Mesos-Marathon落地实战，部署微服务" class="headerlink" title="5.3.2.5 Mesos+Marathon落地实战，部署微服务"></a>5.3.2.5 Mesos+Marathon落地实战，部署微服务</h5><h3 id="5-4-容器编排—K8S"><a href="#5-4-容器编排—K8S" class="headerlink" title="5.4 容器编排—K8S"></a>5.4 容器编排—K8S</h3><h4 id="5-4-1-K8S整体架构及常用命令"><a href="#5-4-1-K8S整体架构及常用命令" class="headerlink" title="5.4.1 K8S整体架构及常用命令"></a>5.4.1 K8S整体架构及常用命令</h4><h4 id="5-4-2-K8S调度原理剖析与Pod生命周期管理"><a href="#5-4-2-K8S调度原理剖析与Pod生命周期管理" class="headerlink" title="5.4.2 K8S调度原理剖析与Pod生命周期管理"></a>5.4.2 K8S调度原理剖析与Pod生命周期管理</h4><h5 id="5-4-2-1-K8S控制器管理原理剖析与实战"><a href="#5-4-2-1-K8S控制器管理原理剖析与实战" class="headerlink" title="5.4.2.1 K8S控制器管理原理剖析与实战"></a>5.4.2.1 K8S控制器管理原理剖析与实战</h5><h5 id="5-4-2-2-K8S网络模型和服务访问管理"><a href="#5-4-2-2-K8S网络模型和服务访问管理" class="headerlink" title="5.4.2.2 K8S网络模型和服务访问管理"></a>5.4.2.2 K8S网络模型和服务访问管理</h5><h5 id="5-4-2-3-K8S服务发现与负载均衡原理剖析与实战"><a href="#5-4-2-3-K8S服务发现与负载均衡原理剖析与实战" class="headerlink" title="5.4.2.3 K8S服务发现与负载均衡原理剖析与实战"></a>5.4.2.3 K8S服务发现与负载均衡原理剖析与实战</h5><h5 id="5-4-2-4-K8S系统分层架构和故障排除思路"><a href="#5-4-2-4-K8S系统分层架构和故障排除思路" class="headerlink" title="5.4.2.4 K8S系统分层架构和故障排除思路"></a>5.4.2.4 K8S系统分层架构和故障排除思路</h5><h5 id="5-4-2-5-K8S存储原理实战-数据卷和配置管理"><a href="#5-4-2-5-K8S存储原理实战-数据卷和配置管理" class="headerlink" title="5.4.2.5 K8S存储原理实战(数据卷和配置管理)"></a>5.4.2.5 K8S存储原理实战(数据卷和配置管理)</h5><h5 id="5-4-2-6-K8S认证授权原理剖析与实战-安全框架-RBAC"><a href="#5-4-2-6-K8S认证授权原理剖析与实战-安全框架-RBAC" class="headerlink" title="5.4.2.6 K8S认证授权原理剖析与实战(安全框架/RBAC)"></a>5.4.2.6 K8S认证授权原理剖析与实战(安全框架/RBAC)</h5><h5 id="5-4-2-7-K8S集群监控、快速故障排查和业务连续性保障"><a href="#5-4-2-7-K8S集群监控、快速故障排查和业务连续性保障" class="headerlink" title="5.4.2.7 K8S集群监控、快速故障排查和业务连续性保障"></a>5.4.2.7 K8S集群监控、快速故障排查和业务连续性保障</h5><h4 id="5-4-3-如何实现大规模集群？10节点-gt-100节点-gt-1000节点"><a href="#5-4-3-如何实现大规模集群？10节点-gt-100节点-gt-1000节点" class="headerlink" title="5.4.3 如何实现大规模集群？10节点-&gt;100节点-&gt;1000节点"></a>5.4.3 如何实现大规模集群？10节点-&gt;100节点-&gt;1000节点</h4><h5 id="5-4-3-1-全链路高可用架构升级"><a href="#5-4-3-1-全链路高可用架构升级" class="headerlink" title="5.4.3.1 全链路高可用架构升级"></a>5.4.3.1 全链路高可用架构升级</h5><h5 id="5-4-3-2-知识扩展-如何基于容器编排工具实现CI-CD"><a href="#5-4-3-2-知识扩展-如何基于容器编排工具实现CI-CD" class="headerlink" title="5.4.3.2 知识扩展-如何基于容器编排工具实现CI/CD"></a>5.4.3.2 知识扩展-如何基于容器编排工具实现CI/CD</h5><h5 id="5-4-3-3-K8S落地实战，部署微服务"><a href="#5-4-3-3-K8S落地实战，部署微服务" class="headerlink" title="5.4.3.3 K8S落地实战，部署微服务"></a>5.4.3.3 K8S落地实战，部署微服务</h5><h3 id="5-5-容器弹性扩缩容"><a href="#5-5-容器弹性扩缩容" class="headerlink" title="5.5 容器弹性扩缩容"></a>5.5 容器弹性扩缩容</h3><h4 id="5-5-1-资源管理、属性和配额管理"><a href="#5-5-1-资源管理、属性和配额管理" class="headerlink" title="5.5.1 资源管理、属性和配额管理"></a>5.5.1 资源管理、属性和配额管理</h4><h4 id="5-5-2-有状态应用如何实现弹性伸缩和失效重置"><a href="#5-5-2-有状态应用如何实现弹性伸缩和失效重置" class="headerlink" title="5.5.2 有状态应用如何实现弹性伸缩和失效重置"></a>5.5.2 有状态应用如何实现弹性伸缩和失效重置</h4><h4 id="5-5-3-容器弹性扩缩容实现资源触发、简单决策"><a href="#5-5-3-容器弹性扩缩容实现资源触发、简单决策" class="headerlink" title="5.5.3 容器弹性扩缩容实现资源触发、简单决策"></a>5.5.3 容器弹性扩缩容实现资源触发、简单决策</h4><h5 id="5-5-3-1-容器弹性扩缩容实现负载触发、动态扩缩容"><a href="#5-5-3-1-容器弹性扩缩容实现负载触发、动态扩缩容" class="headerlink" title="5.5.3.1 容器弹性扩缩容实现负载触发、动态扩缩容"></a>5.5.3.1 容器弹性扩缩容实现负载触发、动态扩缩容</h5><h5 id="5-5-3-2-容器弹性扩缩容实现更换轮子、自由扩缩容"><a href="#5-5-3-2-容器弹性扩缩容实现更换轮子、自由扩缩容" class="headerlink" title="5.5.3.2 容器弹性扩缩容实现更换轮子、自由扩缩容"></a>5.5.3.2 容器弹性扩缩容实现更换轮子、自由扩缩容</h5><h2 id="6-网络通信和性能调优"><a href="#6-网络通信和性能调优" class="headerlink" title="6. 网络通信和性能调优"></a>6. 网络通信和性能调优</h2><h3 id="6-1-Netty入门"><a href="#6-1-Netty入门" class="headerlink" title="6.1 Netty入门"></a>6.1 Netty入门</h3><h4 id="6-1-1-TCP通信基础"><a href="#6-1-1-TCP通信基础" class="headerlink" title="6.1.1 TCP通信基础"></a>6.1.1 TCP通信基础</h4><h4 id="6-1-2-架构师视角解读Netty技术选型与核心"><a href="#6-1-2-架构师视角解读Netty技术选型与核心" class="headerlink" title="6.1.2 架构师视角解读Netty技术选型与核心"></a>6.1.2 架构师视角解读Netty技术选型与核心</h4><h4 id="6-1-3-架构拆包粘包-Netty-TCP拆包粘包问题的处理"><a href="#6-1-3-架构拆包粘包-Netty-TCP拆包粘包问题的处理" class="headerlink" title="6.1.3 架构拆包粘包 - Netty TCP拆包粘包问题的处理"></a>6.1.3 架构拆包粘包 - Netty TCP拆包粘包问题的处理</h4><h5 id="6-1-3-1-架构序列化-Netty-序列化实战-Marshalling"><a href="#6-1-3-1-架构序列化-Netty-序列化实战-Marshalling" class="headerlink" title="6.1.3.1 架构序列化- Netty 序列化实战 Marshalling"></a>6.1.3.1 架构序列化- Netty 序列化实战 Marshalling</h5><h5 id="6-1-3-2-架构序列化-Netty-序列化实战-Protobuf"><a href="#6-1-3-2-架构序列化-Netty-序列化实战-Protobuf" class="headerlink" title="6.1.3.2 架构序列化 - Netty 序列化实战 Protobuf"></a>6.1.3.2 架构序列化 - Netty 序列化实战 Protobuf</h5><h5 id="6-1-3-3-架构序列化-Netty自定义协议栈实战"><a href="#6-1-3-3-架构序列化-Netty自定义协议栈实战" class="headerlink" title="6.1.3.3 架构序列化 - Netty自定义协议栈实战"></a>6.1.3.3 架构序列化 - Netty自定义协议栈实战</h5><h5 id="6-1-3-4-Netty-HTTP协议栈"><a href="#6-1-3-4-Netty-HTTP协议栈" class="headerlink" title="6.1.3.4 Netty HTTP协议栈"></a>6.1.3.4 Netty HTTP协议栈</h5><h3 id="6-2-Netty高级"><a href="#6-2-Netty高级" class="headerlink" title="6.2 Netty高级"></a>6.2 Netty高级</h3><h4 id="6-2-1-Netty项目最佳实战-数据可靠性通信场景分析与架构设计"><a href="#6-2-1-Netty项目最佳实战-数据可靠性通信场景分析与架构设计" class="headerlink" title="6.2.1 Netty项目最佳实战- 数据可靠性通信场景分析与架构设计"></a>6.2.1 Netty项目最佳实战- 数据可靠性通信场景分析与架构设计</h4><h4 id="6-2-2-Netty项目最佳实战-数据结构定义与分析（-Spring-与-硬编码方式定义）"><a href="#6-2-2-Netty项目最佳实战-数据结构定义与分析（-Spring-与-硬编码方式定义）" class="headerlink" title="6.2.2 Netty项目最佳实战- 数据结构定义与分析（@Spring 与 硬编码方式定义）"></a>6.2.2 Netty项目最佳实战- 数据结构定义与分析（@Spring 与 硬编码方式定义）</h4><h4 id="6-2-3-Netty项目最佳实战-Server端落地"><a href="#6-2-3-Netty项目最佳实战-Server端落地" class="headerlink" title="6.2.3 Netty项目最佳实战- Server端落地"></a>6.2.3 Netty项目最佳实战- Server端落地</h4><h5 id="6-2-3-1-Netty项目最佳实战-Client端落地"><a href="#6-2-3-1-Netty项目最佳实战-Client端落地" class="headerlink" title="6.2.3.1 Netty项目最佳实战- Client端落地"></a>6.2.3.1 Netty项目最佳实战- Client端落地</h5><h5 id="6-2-3-2-Netty项目最佳实战-关于buffer的资源释放问题详解"><a href="#6-2-3-2-Netty项目最佳实战-关于buffer的资源释放问题详解" class="headerlink" title="6.2.3.2 Netty项目最佳实战- 关于buffer的资源释放问题详解"></a>6.2.3.2 Netty项目最佳实战- 关于buffer的资源释放问题详解</h5><h5 id="6-2-3-3-应用程序优化与测试细节点讲解"><a href="#6-2-3-3-应用程序优化与测试细节点讲解" class="headerlink" title="6.2.3.3 应用程序优化与测试细节点讲解"></a>6.2.3.3 应用程序优化与测试细节点讲解</h5><h3 id="6-3-基于Netty实现RPC框架1"><a href="#6-3-基于Netty实现RPC框架1" class="headerlink" title="6.3 基于Netty实现RPC框架1"></a>6.3 基于Netty实现RPC框架1</h3><h4 id="6-3-1-实现一个最简单的RPC通信框架设计思路"><a href="#6-3-1-实现一个最简单的RPC通信框架设计思路" class="headerlink" title="6.3.1 实现一个最简单的RPC通信框架设计思路"></a>6.3.1 实现一个最简单的RPC通信框架设计思路</h4><h5 id="6-3-1-1-实现一个最简单的RPC通信框架落地"><a href="#6-3-1-1-实现一个最简单的RPC通信框架落地" class="headerlink" title="6.3.1.1 实现一个最简单的RPC通信框架落地"></a>6.3.1.1 实现一个最简单的RPC通信框架落地</h5><h4 id="6-3-2-架构设计与落地-RPC框架整体架构设计思路"><a href="#6-3-2-架构设计与落地-RPC框架整体架构设计思路" class="headerlink" title="6.3.2 架构设计与落地-RPC框架整体架构设计思路"></a>6.3.2 架构设计与落地-RPC框架整体架构设计思路</h4><h5 id="6-3-2-1-架构设计与落地-RPC整体框架API抽象与剥离"><a href="#6-3-2-1-架构设计与落地-RPC整体框架API抽象与剥离" class="headerlink" title="6.3.2.1 架构设计与落地-RPC整体框架API抽象与剥离"></a>6.3.2.1 架构设计与落地-RPC整体框架API抽象与剥离</h5><h5 id="6-3-2-2-架构设计与落地-RPC-Client-客户端落地"><a href="#6-3-2-2-架构设计与落地-RPC-Client-客户端落地" class="headerlink" title="6.3.2.2 架构设计与落地-RPC Client 客户端落地"></a>6.3.2.2 架构设计与落地-RPC Client 客户端落地</h5><h5 id="6-3-2-3-架构设计与落地-RPC-Server-服务端落地"><a href="#6-3-2-3-架构设计与落地-RPC-Server-服务端落地" class="headerlink" title="6.3.2.3 架构设计与落地-RPC Server 服务端落地"></a>6.3.2.3 架构设计与落地-RPC Server 服务端落地</h5><h3 id="6-4-基于Netty实现RPC框架2"><a href="#6-4-基于Netty实现RPC框架2" class="headerlink" title="6.4 基于Netty实现RPC框架2"></a>6.4 基于Netty实现RPC框架2</h3><h4 id="6-4-1-架构设计与落地-RPC-Proxy-代理"><a href="#6-4-1-架构设计与落地-RPC-Proxy-代理" class="headerlink" title="6.4.1 架构设计与落地-RPC Proxy 代理"></a>6.4.1 架构设计与落地-RPC Proxy 代理</h4><h4 id="6-4-2-架构设计与落地-RPC-Codec编解码"><a href="#6-4-2-架构设计与落地-RPC-Codec编解码" class="headerlink" title="6.4.2 架构设计与落地-RPC Codec编解码"></a>6.4.2 架构设计与落地-RPC Codec编解码</h4><h4 id="6-4-3-架构设计与落地-RpcCallback与RpcFuture，AQS实现"><a href="#6-4-3-架构设计与落地-RpcCallback与RpcFuture，AQS实现" class="headerlink" title="6.4.3 架构设计与落地- RpcCallback与RpcFuture，AQS实现"></a>6.4.3 架构设计与落地- RpcCallback与RpcFuture，AQS实现</h4><h5 id="6-4-3-1-架构设计与落地-RPC彩蛋功能点扩展之与Spring整合思路"><a href="#6-4-3-1-架构设计与落地-RPC彩蛋功能点扩展之与Spring整合思路" class="headerlink" title="6.4.3.1 架构设计与落地-RPC彩蛋功能点扩展之与Spring整合思路"></a>6.4.3.1 架构设计与落地-RPC彩蛋功能点扩展之与Spring整合思路</h5><h5 id="6-4-3-2-架构设计与落地-RPC彩蛋功能点扩展之注册中心整合思路"><a href="#6-4-3-2-架构设计与落地-RPC彩蛋功能点扩展之注册中心整合思路" class="headerlink" title="6.4.3.2 架构设计与落地-RPC彩蛋功能点扩展之注册中心整合思路"></a>6.4.3.2 架构设计与落地-RPC彩蛋功能点扩展之注册中心整合思路</h5><h3 id="6-5-应用监控和性能调优之工具"><a href="#6-5-应用监控和性能调优之工具" class="headerlink" title="6.5 应用监控和性能调优之工具"></a>6.5 应用监控和性能调优之工具</h3><h4 id="6-5-1-开源的链路跟踪工具及对比"><a href="#6-5-1-开源的链路跟踪工具及对比" class="headerlink" title="6.5.1 开源的链路跟踪工具及对比"></a>6.5.1 开源的链路跟踪工具及对比</h4><h4 id="6-5-2-Skywalking监控Java应用"><a href="#6-5-2-Skywalking监控Java应用" class="headerlink" title="6.5.2 Skywalking监控Java应用"></a>6.5.2 Skywalking监控Java应用</h4><h5 id="6-5-2-1-Skywalking监控数据库"><a href="#6-5-2-1-Skywalking监控数据库" class="headerlink" title="6.5.2.1 Skywalking监控数据库"></a>6.5.2.1 Skywalking监控数据库</h5><h5 id="6-5-2-2-Skywalking高可用"><a href="#6-5-2-2-Skywalking高可用" class="headerlink" title="6.5.2.2 Skywalking高可用"></a>6.5.2.2 Skywalking高可用</h5><h5 id="6-5-2-3-Skywalking存储"><a href="#6-5-2-3-Skywalking存储" class="headerlink" title="6.5.2.3 Skywalking存储"></a>6.5.2.3 Skywalking存储</h5><h4 id="6-5-3-Spring-Boot-Actuator-生产可用的应用监控工具"><a href="#6-5-3-Spring-Boot-Actuator-生产可用的应用监控工具" class="headerlink" title="6.5.3 Spring Boot Actuator - 生产可用的应用监控工具"></a>6.5.3 Spring Boot Actuator - 生产可用的应用监控工具</h4><h5 id="6-5-3-1-Prometheus-监控工具"><a href="#6-5-3-1-Prometheus-监控工具" class="headerlink" title="6.5.3.1 Prometheus - 监控工具"></a>6.5.3.1 Prometheus - 监控工具</h5><h5 id="6-5-3-2-Grafana-监控-告警工具"><a href="#6-5-3-2-Grafana-监控-告警工具" class="headerlink" title="6.5.3.2 Grafana - 监控 + 告警工具"></a>6.5.3.2 Grafana - 监控 + 告警工具</h5><h5 id="6-5-3-3-Tomcat-Manager-Tomcat监控"><a href="#6-5-3-3-Tomcat-Manager-Tomcat监控" class="headerlink" title="6.5.3.3 Tomcat Manager - Tomcat监控"></a>6.5.3.3 Tomcat Manager - Tomcat监控</h5><h5 id="6-5-3-4-psi-probe-Tomcat监控"><a href="#6-5-3-4-psi-probe-Tomcat监控" class="headerlink" title="6.5.3.4 psi-probe - Tomcat监控"></a>6.5.3.4 psi-probe - Tomcat监控</h5><h5 id="6-5-3-5-日志监控，-慢SQL监控"><a href="#6-5-3-5-日志监控，-慢SQL监控" class="headerlink" title="6.5.3.5 日志监控， 慢SQL监控"></a>6.5.3.5 日志监控， 慢SQL监控</h5><h3 id="6-6-应用监控和性能调优之实战"><a href="#6-6-应用监控和性能调优之实战" class="headerlink" title="6.6 应用监控和性能调优之实战"></a>6.6 应用监控和性能调优之实战</h3><h4 id="6-6-1-应用调优常用技巧1-池化对象，本地异步化（3种方式）"><a href="#6-6-1-应用调优常用技巧1-池化对象，本地异步化（3种方式）" class="headerlink" title="6.6.1 应用调优常用技巧1 - 池化对象，本地异步化（3种方式）"></a>6.6.1 应用调优常用技巧1 - 池化对象，本地异步化（3种方式）</h4><h5 id="6-6-1-1-应用调优常用技巧2-远程调用异步化（3种方式），缓存"><a href="#6-6-1-1-应用调优常用技巧2-远程调用异步化（3种方式），缓存" class="headerlink" title="6.6.1.1 应用调优常用技巧2- 远程调用异步化（3种方式），缓存"></a>6.6.1.1 应用调优常用技巧2- 远程调用异步化（3种方式），缓存</h5><h4 id="6-6-2-并发编程4板斧（线程封闭、降低锁粒度、锁粗化、无锁）"><a href="#6-6-2-并发编程4板斧（线程封闭、降低锁粒度、锁粗化、无锁）" class="headerlink" title="6.6.2 并发编程4板斧（线程封闭、降低锁粒度、锁粗化、无锁）"></a>6.6.2 并发编程4板斧（线程封闭、降低锁粒度、锁粗化、无锁）</h4><h5 id="6-6-2-1-应用调优实战1-定位应用层面性能问题的通用思路与步骤"><a href="#6-6-2-1-应用调优实战1-定位应用层面性能问题的通用思路与步骤" class="headerlink" title="6.6.2.1 应用调优实战1 - 定位应用层面性能问题的通用思路与步骤"></a>6.6.2.1 应用调优实战1 - 定位应用层面性能问题的通用思路与步骤</h5><h5 id="6-6-2-2-应用调优实战2-线程池调优"><a href="#6-6-2-2-应用调优实战2-线程池调优" class="headerlink" title="6.6.2.2 应用调优实战2 - 线程池调优"></a>6.6.2.2 应用调优实战2 - 线程池调优</h5><h4 id="6-6-3-Tomcat调优1-原生Tomcat调优配置属性"><a href="#6-6-3-Tomcat调优1-原生Tomcat调优配置属性" class="headerlink" title="6.6.3 Tomcat调优1 - 原生Tomcat调优配置属性"></a>6.6.3 Tomcat调优1 - 原生Tomcat调优配置属性</h4><h5 id="6-6-3-1-Tomcat调优2-Spring-Boot内嵌式Tomcat调优配置属性"><a href="#6-6-3-1-Tomcat调优2-Spring-Boot内嵌式Tomcat调优配置属性" class="headerlink" title="6.6.3.1 Tomcat调优2 - Spring Boot内嵌式Tomcat调优配置属性"></a>6.6.3.1 Tomcat调优2 - Spring Boot内嵌式Tomcat调优配置属性</h5><h5 id="6-6-3-2-Tomcat调优3-Tomcat调优手把手"><a href="#6-6-3-2-Tomcat调优3-Tomcat调优手把手" class="headerlink" title="6.6.3.2 Tomcat调优3 - Tomcat调优手把手"></a>6.6.3.2 Tomcat调优3 - Tomcat调优手把手</h5><h4 id="6-6-4-应用调优案例实战"><a href="#6-6-4-应用调优案例实战" class="headerlink" title="6.6.4 应用调优案例实战"></a>6.6.4 应用调优案例实战</h4><h3 id="6-7-JVM性能调优之工具"><a href="#6-7-JVM性能调优之工具" class="headerlink" title="6.7 JVM性能调优之工具"></a>6.7 JVM性能调优之工具</h3><h4 id="6-7-1-垃圾回收算法-复制，-标记清除，标记整理"><a href="#6-7-1-垃圾回收算法-复制，-标记清除，标记整理" class="headerlink" title="6.7.1 垃圾回收算法 - 复制， 标记清除，标记整理"></a>6.7.1 垃圾回收算法 - 复制， 标记清除，标记整理</h4><h4 id="6-7-2-垃圾回收器-Serial，Parallel，ParNew，CMS，G1，ZGC"><a href="#6-7-2-垃圾回收器-Serial，Parallel，ParNew，CMS，G1，ZGC" class="headerlink" title="6.7.2 垃圾回收器 - Serial，Parallel，ParNew，CMS，G1，ZGC"></a>6.7.2 垃圾回收器 - Serial，Parallel，ParNew，CMS，G1，ZGC</h4><h5 id="6-7-2-1-垃圾回收器-多款回收器如何配合"><a href="#6-7-2-1-垃圾回收器-多款回收器如何配合" class="headerlink" title="6.7.2.1 垃圾回收器 - 多款回收器如何配合"></a>6.7.2.1 垃圾回收器 - 多款回收器如何配合</h5><h4 id="6-7-3-JVM监控工具-jinfo，-jps，jstat，jstack，jmap"><a href="#6-7-3-JVM监控工具-jinfo，-jps，jstat，jstack，jmap" class="headerlink" title="6.7.3 JVM监控工具 - jinfo， jps，jstat，jstack，jmap"></a>6.7.3 JVM监控工具 - jinfo， jps，jstat，jstack，jmap</h4><h5 id="6-7-3-1-JVM监控工具-jconsole，jvisualvm，jmc，mat"><a href="#6-7-3-1-JVM监控工具-jconsole，jvisualvm，jmc，mat" class="headerlink" title="6.7.3.1 JVM监控工具 - jconsole，jvisualvm，jmc，mat"></a>6.7.3.1 JVM监控工具 - jconsole，jvisualvm，jmc，mat</h5><h5 id="6-7-3-2-GC日志分析工具-GCEasy与GCPlot"><a href="#6-7-3-2-GC日志分析工具-GCEasy与GCPlot" class="headerlink" title="6.7.3.2 GC日志分析工具 - GCEasy与GCPlot"></a>6.7.3.2 GC日志分析工具 - GCEasy与GCPlot</h5><h4 id="6-7-4-线程Dump日志分析工具-FastThread"><a href="#6-7-4-线程Dump日志分析工具-FastThread" class="headerlink" title="6.7.4 线程Dump日志分析工具 - FastThread"></a>6.7.4 线程Dump日志分析工具 - FastThread</h4><h5 id="6-7-4-1-堆Dump日志分析工具-HeapHero"><a href="#6-7-4-1-堆Dump日志分析工具-HeapHero" class="headerlink" title="6.7.4.1 堆Dump日志分析工具 - HeapHero"></a>6.7.4.1 堆Dump日志分析工具 - HeapHero</h5><h5 id="6-7-4-2-常用JVM调优参数详解"><a href="#6-7-4-2-常用JVM调优参数详解" class="headerlink" title="6.7.4.2 常用JVM调优参数详解"></a>6.7.4.2 常用JVM调优参数详解</h5><h3 id="6-8-JVM性能调优之实战"><a href="#6-8-JVM性能调优之实战" class="headerlink" title="6.8 JVM性能调优之实战"></a>6.8 JVM性能调优之实战</h3><h4 id="6-8-1-调优实战1-如何确定最小堆内存？"><a href="#6-8-1-调优实战1-如何确定最小堆内存？" class="headerlink" title="6.8.1 调优实战1 - 如何确定最小堆内存？"></a>6.8.1 调优实战1 - 如何确定最小堆内存？</h4><h5 id="6-8-1-1-调优实战2-如何确定最大堆内存？"><a href="#6-8-1-1-调优实战2-如何确定最大堆内存？" class="headerlink" title="6.8.1.1 调优实战2 - 如何确定最大堆内存？"></a>6.8.1.1 调优实战2 - 如何确定最大堆内存？</h5><h4 id="6-8-2-调优实战3-死锁分析"><a href="#6-8-2-调优实战3-死锁分析" class="headerlink" title="6.8.2 调优实战3 - 死锁分析"></a>6.8.2 调优实战3 - 死锁分析</h4><h4 id="6-8-3-调优实战4-内存溢出问题解决方案（堆内存、Metadataspace区）"><a href="#6-8-3-调优实战4-内存溢出问题解决方案（堆内存、Metadataspace区）" class="headerlink" title="6.8.3 调优实战4 - 内存溢出问题解决方案（堆内存、Metadataspace区）"></a>6.8.3 调优实战4 - 内存溢出问题解决方案（堆内存、Metadataspace区）</h4><h5 id="6-8-3-1-调优实战4-内存溢出问题解决方案（栈溢出、直接内存溢出等）"><a href="#6-8-3-1-调优实战4-内存溢出问题解决方案（栈溢出、直接内存溢出等）" class="headerlink" title="6.8.3.1 调优实战4 - 内存溢出问题解决方案（栈溢出、直接内存溢出等）"></a>6.8.3.1 调优实战4 - 内存溢出问题解决方案（栈溢出、直接内存溢出等）</h5><h5 id="6-8-3-2-调优实战5-垃圾回收器调优（吞吐量、STW权衡）"><a href="#6-8-3-2-调优实战5-垃圾回收器调优（吞吐量、STW权衡）" class="headerlink" title="6.8.3.2 调优实战5 - 垃圾回收器调优（吞吐量、STW权衡）"></a>6.8.3.2 调优实战5 - 垃圾回收器调优（吞吐量、STW权衡）</h5><h5 id="6-8-3-3-调优实战6-栈上分配、偏向锁等对系统调优的影响"><a href="#6-8-3-3-调优实战6-栈上分配、偏向锁等对系统调优的影响" class="headerlink" title="6.8.3.3 调优实战6 - 栈上分配、偏向锁等对系统调优的影响"></a>6.8.3.3 调优实战6 - 栈上分配、偏向锁等对系统调优的影响</h5><h5 id="6-8-3-5-调优实战7-升级JDK对系统优化的影响"><a href="#6-8-3-5-调优实战7-升级JDK对系统优化的影响" class="headerlink" title="6.8.3.5 调优实战7 - 升级JDK对系统优化的影响"></a>6.8.3.5 调优实战7 - 升级JDK对系统优化的影响</h5><h4 id="6-8-4-调优实战8-young-GC频繁-Full-GC频繁"><a href="#6-8-4-调优实战8-young-GC频繁-Full-GC频繁" class="headerlink" title="6.8.4 调优实战8 - young GC频繁/Full GC频繁"></a>6.8.4 调优实战8 - young GC频繁/Full GC频繁</h4><h5 id="6-8-4-1-调优实战9-应用CPU占用过高问题分析"><a href="#6-8-4-1-调优实战9-应用CPU占用过高问题分析" class="headerlink" title="6.8.4.1 调优实战9 - 应用CPU占用过高问题分析"></a>6.8.4.1 调优实战9 - 应用CPU占用过高问题分析</h5><h5 id="6-8-4-2-调优实战10-应用无端变得奇慢，而且越来越慢"><a href="#6-8-4-2-调优实战10-应用无端变得奇慢，而且越来越慢" class="headerlink" title="6.8.4.2 调优实战10 - 应用无端变得奇慢，而且越来越慢"></a>6.8.4.2 调优实战10 - 应用无端变得奇慢，而且越来越慢</h5><h3 id="6-9-数据库监控与调优"><a href="#6-9-数据库监控与调优" class="headerlink" title="6.9 数据库监控与调优"></a>6.9 数据库监控与调优</h3><h4 id="6-9-1-数据库监控-Prometheus"><a href="#6-9-1-数据库监控-Prometheus" class="headerlink" title="6.9.1 数据库监控 - Prometheus"></a>6.9.1 数据库监控 - Prometheus</h4><h4 id="6-9-2-慢查询日志"><a href="#6-9-2-慢查询日志" class="headerlink" title="6.9.2 慢查询日志"></a>6.9.2 慢查询日志</h4><h4 id="6-9-3-优化手段"><a href="#6-9-3-优化手段" class="headerlink" title="6.9.3 优化手段"></a>6.9.3 优化手段</h4><h5 id="6-9-3-1-索引分析与优化"><a href="#6-9-3-1-索引分析与优化" class="headerlink" title="6.9.3.1 索引分析与优化"></a>6.9.3.1 索引分析与优化</h5><h5 id="6-9-3-2-锁优化，Query-Profiler"><a href="#6-9-3-2-锁优化，Query-Profiler" class="headerlink" title="6.9.3.2 锁优化，Query Profiler"></a>6.9.3.2 锁优化，Query Profiler</h5><h5 id="6-9-3-3-SQL优化工具"><a href="#6-9-3-3-SQL优化工具" class="headerlink" title="6.9.3.3 SQL优化工具"></a>6.9.3.3 SQL优化工具</h5><h5 id="6-9-3-4-MySQL配置优化"><a href="#6-9-3-4-MySQL配置优化" class="headerlink" title="6.9.3.4 MySQL配置优化"></a>6.9.3.4 MySQL配置优化</h5><h4 id="6-9-4-拓展分享"><a href="#6-9-4-拓展分享" class="headerlink" title="6.9.4 拓展分享"></a>6.9.4 拓展分享</h4><h5 id="6-9-4-1-拓展分享：如何在合适的场景用合适的数据库？"><a href="#6-9-4-1-拓展分享：如何在合适的场景用合适的数据库？" class="headerlink" title="6.9.4.1 拓展分享：如何在合适的场景用合适的数据库？"></a>6.9.4.1 拓展分享：如何在合适的场景用合适的数据库？</h5><h5 id="6-9-4-2-拓展分享：业务妥协会对系统调优造成怎样的影响？"><a href="#6-9-4-2-拓展分享：业务妥协会对系统调优造成怎样的影响？" class="headerlink" title="6.9.4.2 拓展分享：业务妥协会对系统调优造成怎样的影响？"></a>6.9.4.2 拓展分享：业务妥协会对系统调优造成怎样的影响？</h5><h3 id="6-10-Linux调优和架构调优"><a href="#6-10-Linux调优和架构调优" class="headerlink" title="6.10 Linux调优和架构调优"></a>6.10 Linux调优和架构调优</h3><h4 id="6-10-1-Linux常用监控调优命令"><a href="#6-10-1-Linux常用监控调优命令" class="headerlink" title="6.10.1 Linux常用监控调优命令"></a>6.10.1 Linux常用监控调优命令</h4><h4 id="6-10-2-Linux监控可视化"><a href="#6-10-2-Linux监控可视化" class="headerlink" title="6.10.2 Linux监控可视化"></a>6.10.2 Linux监控可视化</h4><h4 id="6-10-3-传统架构存在的问题"><a href="#6-10-3-传统架构存在的问题" class="headerlink" title="6.10.3 传统架构存在的问题"></a>6.10.3 传统架构存在的问题</h4><h4 id="6-10-4-去中心化：微服务，无状态-vs-有状态"><a href="#6-10-4-去中心化：微服务，无状态-vs-有状态" class="headerlink" title="6.10.4 去中心化：微服务，无状态 vs 有状态"></a>6.10.4 去中心化：微服务，无状态 vs 有状态</h4><h4 id="6-10-5-拓展分享：技术方案对业务优化的影响"><a href="#6-10-5-拓展分享：技术方案对业务优化的影响" class="headerlink" title="6.10.5 拓展分享：技术方案对业务优化的影响"></a>6.10.5 拓展分享：技术方案对业务优化的影响</h4>]]></content>
      
      
      <categories>
          
          <category> 项目笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.linux</title>
      <link href="2020/11/21/6-linux/"/>
      <url>2020/11/21/6-linux/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.Git</title>
      <link href="2020/11/21/6-git/"/>
      <url>2020/11/21/6-git/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.leetcode</title>
      <link href="2020/11/21/5-leetcode/"/>
      <url>2020/11/21/5-leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><h2 id="1-算法基础"><a href="#1-算法基础" class="headerlink" title="1. 算法基础"></a>1. 算法基础</h2><h2 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2. 线性表"></a>2. 线性表</h2><h3 id="2-1-类型"><a href="#2-1-类型" class="headerlink" title="2.1 类型"></a>2.1 类型</h3><h3 id="2-2-顺序表示实现"><a href="#2-2-顺序表示实现" class="headerlink" title="2.2 顺序表示实现"></a>2.2 顺序表示实现</h3><h3 id="2-3-链式表示实现"><a href="#2-3-链式表示实现" class="headerlink" title="2.3 链式表示实现"></a>2.3 链式表示实现</h3><h2 id="3-栈与队列"><a href="#3-栈与队列" class="headerlink" title="3. 栈与队列"></a>3. 栈与队列</h2><h3 id="3-1-类型"><a href="#3-1-类型" class="headerlink" title="3.1 类型"></a>3.1 类型</h3><h3 id="3-2-栈的实现"><a href="#3-2-栈的实现" class="headerlink" title="3.2 栈的实现"></a>3.2 栈的实现</h3><h3 id="3-3-队列的实现"><a href="#3-3-队列的实现" class="headerlink" title="3.3 队列的实现"></a>3.3 队列的实现</h3><h4 id="3-3-1-链式表示实现"><a href="#3-3-1-链式表示实现" class="headerlink" title="3.3.1 链式表示实现"></a>3.3.1 链式表示实现</h4><h4 id="3-3-2-顺序表示实现"><a href="#3-3-2-顺序表示实现" class="headerlink" title="3.3.2 顺序表示实现"></a>3.3.2 顺序表示实现</h4><h2 id="4-串"><a href="#4-串" class="headerlink" title="4. 串"></a>4. 串</h2><h3 id="4-1-类型"><a href="#4-1-类型" class="headerlink" title="4.1 类型"></a>4.1 类型</h3><h3 id="4-2-顺序表示实现"><a href="#4-2-顺序表示实现" class="headerlink" title="4.2 顺序表示实现"></a>4.2 顺序表示实现</h3><h3 id="4-3-链式表现实现"><a href="#4-3-链式表现实现" class="headerlink" title="4.3 链式表现实现"></a>4.3 链式表现实现</h3><h2 id="5-数组和广义表"><a href="#5-数组和广义表" class="headerlink" title="5. 数组和广义表"></a>5. 数组和广义表</h2><h3 id="5-1-数组"><a href="#5-1-数组" class="headerlink" title="5.1 数组"></a>5.1 数组</h3><h3 id="5-2-广义表-散列表"><a href="#5-2-广义表-散列表" class="headerlink" title="5.2 广义表(散列表)"></a>5.2 广义表(散列表)</h3><h3 id="5-3-空间表"><a href="#5-3-空间表" class="headerlink" title="5.3 空间表"></a>5.3 空间表</h3><h4 id="5-3-1-分配法之边界标识"><a href="#5-3-1-分配法之边界标识" class="headerlink" title="5.3.1 分配法之边界标识"></a>5.3.1 分配法之边界标识</h4><h4 id="5-3-2-分配法之伙伴系统"><a href="#5-3-2-分配法之伙伴系统" class="headerlink" title="5.3.2 分配法之伙伴系统"></a>5.3.2 分配法之伙伴系统</h4><h2 id="6-树"><a href="#6-树" class="headerlink" title="6. 树"></a>6. 树</h2><h3 id="6-1-基础"><a href="#6-1-基础" class="headerlink" title="6.1 基础"></a>6.1 基础</h3><h3 id="6-2-二叉树"><a href="#6-2-二叉树" class="headerlink" title="6.2 二叉树"></a>6.2 二叉树</h3><h3 id="6-3-其他"><a href="#6-3-其他" class="headerlink" title="6.3 其他"></a>6.3 其他</h3><h2 id="7-图"><a href="#7-图" class="headerlink" title="7. 图"></a>7. 图</h2><h3 id="7-1-基础"><a href="#7-1-基础" class="headerlink" title="7.1 基础"></a>7.1 基础</h3><h3 id="7-2-存储结构"><a href="#7-2-存储结构" class="headerlink" title="7.2 存储结构"></a>7.2 存储结构</h3><h3 id="7-3-遍历方式"><a href="#7-3-遍历方式" class="headerlink" title="7.3 遍历方式"></a>7.3 遍历方式</h3><h3 id="7-4-其他-广度优先搜索"><a href="#7-4-其他-广度优先搜索" class="headerlink" title="7.4 其他(广度优先搜索)"></a>7.4 其他(广度优先搜索)</h3><h2 id="8-查找"><a href="#8-查找" class="headerlink" title="8. 查找"></a>8. 查找</h2><h3 id="8-1-静态查找"><a href="#8-1-静态查找" class="headerlink" title="8.1 静态查找"></a>8.1 静态查找</h3><h3 id="8-2-动态查找"><a href="#8-2-动态查找" class="headerlink" title="8.2 动态查找"></a>8.2 动态查找</h3><h2 id="9-排序"><a href="#9-排序" class="headerlink" title="9. 排序"></a>9. 排序</h2><h3 id="9-1-内部排序"><a href="#9-1-内部排序" class="headerlink" title="9.1 内部排序"></a>9.1 内部排序</h3><h4 id="9-1-1-选择排序"><a href="#9-1-1-选择排序" class="headerlink" title="9.1.1 选择排序"></a>9.1.1 选择排序</h4><h4 id="9-1-2-快速排序"><a href="#9-1-2-快速排序" class="headerlink" title="9.1.2 快速排序"></a>9.1.2 快速排序</h4><h3 id="9-2-外部排序"><a href="#9-2-外部排序" class="headerlink" title="9.2 外部排序"></a>9.2 外部排序</h3><h2 id="10-重要算法"><a href="#10-重要算法" class="headerlink" title="10. 重要算法"></a>10. 重要算法</h2><h3 id="10-1-迪克斯特拉算法"><a href="#10-1-迪克斯特拉算法" class="headerlink" title="10.1 迪克斯特拉算法"></a>10.1 迪克斯特拉算法</h3><h3 id="10-2-贪婪算法"><a href="#10-2-贪婪算法" class="headerlink" title="10.2 贪婪算法"></a>10.2 贪婪算法</h3><h3 id="10-3-动态规划"><a href="#10-3-动态规划" class="headerlink" title="10.3 动态规划"></a>10.3 动态规划</h3><h3 id="10-4-K最近邻算法"><a href="#10-4-K最近邻算法" class="headerlink" title="10.4 K最近邻算法"></a>10.4 K最近邻算法</h3>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.JavaInterview</title>
      <link href="2020/11/21/5-javainterview/"/>
      <url>2020/11/21/5-javainterview/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面试"><a href="#Java面试" class="headerlink" title="Java面试"></a>Java面试</h1><h2 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1. Java基础"></a>1. Java基础</h2><ol><li>抽象类和接口的区别<ol><li>抽象类只能单继承，而接口可以多实现</li><li>接口的方法都是<code>public</code>修饰，而抽象类允许私有方法</li><li><code>jdk8</code>以前接口只能有抽象方法，而抽象类可以有普通和静态方法</li></ol></li><li><code>==</code>和<code>equals</code>的区别<ol><li><code>==</code>是值比较</li><li><code>equals</code>是比较对象内容是否相同</li><li>在比较自定义类是否相同需要重写<code>equals</code>方法，不然是值比较</li></ol></li><li><code>String</code><ol><li>由<code>final</code>修饰的不可改变的量</li><li><code>StingBuffer</code>：多线程环境下拼接效率高，有同步锁，所以线程安全</li><li><code>StringBuilder</code>：单线程环境下拼接效率高，没有同步锁，所以效率最高</li><li><code>new</code>字符串时首先会在常量池中找，没有就创建两个对象，一个在堆中，一个在常量池中；有就只在堆中创建一个对象</li></ol></li><li><code>final/finaly/finalize</code>区别<ol><li><code>final</code>修饰的量不可改变，修饰的方法不能重写，修饰的类不能被继承</li><li><code>finaly</code>是异常捕获用于兜底的操作，一般用于释放资源</li><li><code>finalize</code>是垃圾回收时，被回收对象调用执行的方法</li></ol></li><li><code>Servlet</code>生命周期<ol><li>初始化阶段，调用<code>init</code>方法</li><li>响应请求阶段，处理请求</li><li>终止销毁</li></ol></li><li><code>IO</code><ol><li><code>Block-IO</code><ol><li>字节流<ol><li><code>InputStream</code></li><li><code>OutputStream</code></li></ol></li><li>字符流<ol><li><code>Reader</code></li><li><code>Writer</code></li></ol></li><li>交互方式：同步阻塞式</li></ol></li><li><code>MonBlock-IO</code><ol><li>多路复用式的同步非阻塞式<code>IO</code></li><li>组成<ol><li><code>Channels</code><ol><li><code>FileChannel</code></li><li><code>DatagramChannel</code></li><li><code>SocketChannel</code></li><li><code>ServerSocketChannel</code></li></ol></li><li><code>Buffers</code><ol><li><code>ByteBuffer</code></li></ol></li><li><code>Selectors</code></li></ol></li><li><code>select</code>，<code>poll</code>，<code>epoll</code></li></ol></li><li><code>Asynchronous IO</code><ol><li>基于事件和回调机制的<code>IO</code></li><li>基于回调：实现<code>CompletionHandler</code>接口，调用时触发回调函数</li><li>返回<code>Future</code>：通过<code>isDone</code>方法检查是否准备好，通过<code>get</code>方法等待返回数据</li></ol></li><li>Netty</li></ol></li><li>异常<ol><li><code>Error</code>：程序无法处理的系统错误，编译器不做检查</li><li><code>Exception</code>：程序可以处理的异常，捕获后可能恢复<ol><li><code>!RuntimeException</code>：编译期异常，在编译时必须处理的异常</li><li><code>RuntimeException</code>：运行时异常</li></ol></li><li>抛出异常：创建异常对象交给运行时系统处理</li><li>捕获异常：寻找合适的异常处理器处理异常，否则终止运行</li><li><code>finally</code>优于<code>catch</code>块中的<code>return</code>执行，如果<code>finally</code>和<code>catch</code>都有<code>return</code>，则<code>catch</code>中的<code>return</code>会覆盖掉<code>finally</code>中的<code>return</code>值</li><li>异常处理规则<ol><li>具体明确：抛出的异常应能通过异常类名和<code>message</code>准说明异常的类型和异常产生的原因</li><li>提早抛出：尽可能早的发现并抛出异常，便于精确定位问题</li><li>延迟捕获：异常的捕获和处理尽可能的延迟，让掌握更多信息的作用域来处理异常</li></ol></li><li>异常梳理设计原则<ol><li>创建一个异常类继承自<code>RuntimeException</code>异常来统一处理</li><li>其余异常统一转为<code>AppException</code></li><li>在<code>catch</code>后，抛出自定义异常的子类，并提供足以定位的信息</li><li>由前端接收<code>AppException</code>做统一处理</li></ol></li><li>异常处理消耗性能的地方<ol><li><code>try-catch</code>块影响<code>JVM</code>优化</li><li>异常对象实例需要保存栈快照等信息，开销较大</li></ol></li></ol></li></ol><h2 id="2-Java集合-容器"><a href="#2-Java集合-容器" class="headerlink" title="2. Java集合(容器)"></a>2. Java集合(容器)</h2><ol><li><code>List</code>:<ol><li>特点<ol><li>有序可重复</li><li>可以通过索引值来操作元素</li></ol></li><li>实现类<ol><li><code>ArrayList</code><ol><li>底层是数组，利用数组的下标进行元素访问</li><li>初始大小为10 ，扩容为原来的0.5倍，扩容是基于数组的复制，比较耗费内存</li><li>查询快，增删慢</li></ol></li><li><code>LinkedList</code><ol><li>底层是双向链表，链表存储指向前后节点的引用和元素</li><li>增删快，查询慢</li></ol></li></ol></li></ol></li><li><code>Map</code><ol><li>特点<br>1. </li><li>实现类<ol><li><code>HashMap</code><ol><li>底层原理<ol><li>1.8之前底层是数组+链表，1.8之后是数组+链表+红黑树</li><li>链表的出现就是解决Hash值相同，由HashCode值决定存放的位置</li><li>链表转为红黑树—当数组长度大于64且链表长度大于8时会将链表转为红黑树</li><li>初始值为16，当负载因子达到0.75时，就会扩容为原来的2倍</li><li>一般用于单线程环境</li></ol></li><li><code>put</code>流程<ol><li>如果HashMap未被初始化，则先进行初始化</li><li>对key求hash值，然后通过hashcode方法计算下标值</li><li>如果没有hash碰撞，直接放入桶中</li><li>如果有hash碰撞，以链表的方式链接到后面</li><li>如果链表的长度超过8时，就把链表转为红黑树</li><li>如果链表的长度小于6时，就把红黑树转为链表</li><li>如果节点满了，则进行扩容，扩容为原来的2倍后进行重排</li></ol></li><li>减少hash碰撞<ol><li>扰动函数：使元素分布均匀，减少碰撞几率</li><li>使用final对象，这些对象已经重写equals和hashcode方法</li></ol></li><li>扩容<ol><li>基础容量为16，负载因子达到0.75时扩容为原来的2倍</li><li>多线程环境下，调整大小会存在条件竞争，容易造成死锁</li><li>rehashing是比较耗时的过程</li></ol></li><li>解决线程不安全<ol><li>调用Collections的synchronizedMap为HashMap实例对象加锁</li><li>synchronizedMap方法为hashMap实例对象加synchronized锁，锁是mutex互斥锁</li></ol></li></ol></li><li>LinkedHashMap</li><li>TreeMap</li><li>HashTable：线程安全，有同步锁</li></ol></li></ol></li><li>Queue</li><li>Set<ol><li>特点<ol><li>无序，不可重复，但TreeSet有序</li></ol></li><li>实现类<ol><li>HashSet：底层是HashMap，由Hashcode和equals方法保证元素唯一性</li><li>TreeSet：底层是TreeMap，元素有序<ol><li>自然排序：让所属对象的方法实现comparable接口的无参构造</li><li>比较器排序：comparator带参构造</li></ol></li><li>LinkedHashSet</li></ol></li></ol></li><li>JUC<ol><li>CAS是JUC的基础</li><li>AQS是JUC的locks包的基础</li><li>包的分类<ol><li>线程执行器executor</li><li>锁locks</li><li>原子变量atomic</li><li>并发工具类tools<ol><li>闭锁CountDownLatch：让主线程等待一组事件发生后继续执行</li><li>栅栏CyclicBarrier：阻塞当前线程，等待其他线程</li><li>信号量Semaphore：控制某个资源可被同时访问的线程个数</li><li>交换器Exchanger：两个线程达到同步点后，相互交换数据</li></ol></li><li>并发集合Collections<ol><li>BlockingQueue：提供可阻塞的入队和出队操作(都是线程安全的)<ol><li>主要用于生产者-消费者模式：将任务的生产和消费进行隔离</li><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：一个由链表结构组成的有/无界阻塞队列</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li><li>DealyQueue：一个使用优先级队列实现的无界阻塞队列</li><li>SynchronousQueue：一个不存储元素的阻塞队列</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li><li>ConcurrentHashMap<ol><li>JDK8以前：使用更细粒度的锁，由一个Segment数组和多个HashEntry组成，实现了锁分离，即每个元素的锁是不一样的</li><li>JDK8之后：使用CAS++synchronized使锁更细化</li><li>存在于JUC包下，不允许存储null键值</li><li>put逻辑<ol><li>判断Node[]数组是否初始化，没有就先初始化</li><li>通过hash定位数组的索引坐标，是否有node节点，如果没有则使用CAS进行添加(链表的头结点)，添加失败则进入下次循环</li><li>检查内部正在扩容，就帮助它一块扩容</li><li>如果f!=null，则使用synchronized锁住元素(锁是链表/红黑树的头元素)<ol><li>如果Node(链表结构)则执行链表的添加操作</li><li>如果Node(树结构)则执行树的添加操作</li></ol></li><li>判断链表的长度是否达到临界值8(可修改的默认值)，达到8就将链表转为红黑树</li></ol></li><li>锁<ol><li>首先使用无锁操作CAS插入头节点，失败就循环重试</li><li>若已有头节点，则尝试获取头节点的同步锁，再进行操作</li></ol></li><li>Size方法和MappingCount方法异同</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol><h2 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3. 多线程"></a>3. 多线程</h2><ol><li>进程和线程<ol><li>进程<ol><li>是资源分配时的最小单元(独占一块内存，相互之间互不干扰)</li><li>可以看做是独立应用，线程只是进程的不同执行路径</li></ol></li><li>线程<ol><li>是CPU调度的最小单元(共享进程的内存资源，可以更细粒度的控制任务)</li></ol></li><li>进程和线程的关系<ol><li>运行一个程序会产生一个进程，进程至少包含一个线程</li><li>每个进程对应一个JVM实例，多线程共享JVM里的堆</li><li>Java采用单线程编程模型，程序会自动创建主线程</li><li>主线程可以创建子线程，在子线程之后完成执行</li></ol></li></ol></li><li>start和run方法<ol><li>start用于启动线程，而run用于运行线程</li><li>start方法会创建子线程并启动，而run方法是线程的一个普通方法调用</li></ol></li><li>实现线程<ol><li>继承Thread类，而Thread类底层也是实现了Runnable接口</li><li>直接实现Runnable接口，重写run方法</li><li>实现Callable接口，重写call方法</li><li>处理线程的返回值<ol><li>主线程等待法</li><li>使用线程的join方法用以阻塞等待子线程处理完毕</li><li>实现Callable接口，获取call方法的返回值</li><li>通过线程池来获取返回值</li></ol></li></ol></li><li>线程状态<ol><li>新建：创建后还没有启动的线程</li><li>运行：包含正在运行和等待运行的线程</li><li>无限等待：不会被分配CPU执行，需要显示被唤醒</li><li>限期等待：在一定时间后会由系统自动唤醒</li><li>阻塞：等待获取排他锁</li><li>结束：已终止线程的状态，执行结束</li></ol></li><li>等待线程和唤醒线程<ol><li>等待线程<ol><li>wait<ol><li>是Object类中的方法</li><li>只能在synchronized方法或synchronized块中使用</li><li>不仅释放CPU，而且会释放已经占有的同步资源锁</li></ol></li><li>sleep<ol><li>是线程类特有的方法</li><li>可以在任何地方调用</li><li>只会让出cpu，不会导致锁行为的改变</li></ol></li></ol></li><li>唤醒线程<ol><li>池<ol><li>锁池EntryList：等待获取锁的池</li><li>等待池WaitSet：等待线程的池</li></ol></li><li>notify<ol><li>只会随机选取一个处于等待池中的线程进入锁池中去竞争获取锁</li></ol></li><li>notifyAll<ol><li>会让所有处于等待池中的线程全部进入锁池去竞争获取锁</li></ol></li></ol></li><li>函数<ol><li>yield<ol><li>告知线程调度器当前(调用者)线程愿意让出CPU的暗示，但是线程调度器会忽略这个暗示</li><li>不会影响锁的行为(不会使当前线程让出已经占用的锁)</li></ol></li><li>interrupt<ol><li>停止线程：stop方法，suspend方法，resume方法</li><li>调用interrupt如果线程处于阻塞状态，那么线程立即退出阻塞状态，抛出InterruptedException异常</li><li>调用interrupt如果线程处于正常运行，那么会将其中断标志位设置为true，被中断标识的线程仍可以正常运行</li><li>需要被调用interrupt的线程配合中断</li></ol></li></ol></li><li>锁—解决多线程操作共享数据带来的数据不安全<ol><li>互斥锁<ol><li>互斥性：在同一时刻只允许一个线程持有某个对象锁</li><li>可见性：确保在锁被释放前，对共享变量的修改是对后面线程是可见的</li></ol></li><li>同步锁<ol><li>获取对象锁<ol><li>同步代码块，锁 是this</li><li>同步非静态方法，锁是当前对象的实例对象</li></ol></li><li>获取类锁<ol><li>同步代码块，锁是类的字节码文件</li><li>同步静态方法，锁是当前对象的类对象</li></ol></li><li>原理<ol><li>基于Java对象头和Monitor实现</li><li>对象在内存中的布局<ol><li>对象头：Mark Word和Class Metadata Address组成<ol><li>Mark Word：存储对象的运行时数据，默认存储对象的HashCode，分代年龄，锁类型，锁标志位等</li><li>Class Metadata Address：是指针，指向对象的类元数据</li></ol></li><li>Monitor<ol><li>每个Java对象自身存在的内部锁—java对象可以作为锁的原因</li><li>重入：一个线程试图获取自己持有对象锁的临界资源时</li><li>阻塞：一个线程试图获取由其他线程持有的对象锁的临界资源时</li></ol></li><li>实例数据</li><li>对齐填充</li></ol></li><li>早期的synchronized锁<ol><li>属于重量级锁，依赖于Mutex Lock实现</li><li>线程之间的切换需要从用户态转到核心态，开销大</li></ol></li><li>自旋锁：通过让线程忙于循环等待锁的释放，不让出CPU的执行权；若锁被其他线程长时间占用，则会带来许多性能上的开销</li><li>自适应自旋锁：自旋的次数由前一次在同一个锁上自旋的时间以及锁的拥有者状态来决定</li><li>锁消除：JIT在编译时，对运行上下文进行扫描，消除不可能存在竞争的锁</li><li>状态<ol><li>无锁</li><li>偏向锁：减少同一线程获取锁的代价，不适用于锁竞争比较激烈的情况</li><li>轻量级锁</li><li>重量级锁</li><li>锁升级：无锁—偏向锁—轻量级锁—重量级锁</li></ol></li></ol></li></ol></li><li>ReentranLock(重入锁)<ol><li>位于Java.util.concurrent.locks包下</li><li>和CountDownLatch，FutureTask，Semaphore一样基于AQS实现<ol><li>AQS：AbstractQueueSynchronizer</li></ol></li><li>实现比synchronized更细粒度的控制，如fairness(公平锁)<ol><li>公平锁：获取锁的顺序按先后调用lock方法的顺序</li><li>非公平锁：抢占机制，优先度高的抢到的几率大</li></ol></li><li>调用lock方法后，必须调用unlock释放锁</li><li>区分synchronized锁<ol><li>synchronized是关键字，而ReentranLock是类</li><li>ReentranLock可以对锁的等待时间进行设置，避免死锁</li><li>ReentranLock可以获取各种锁的信息，可以灵活的实现多路通知</li><li>synchronized操作的是Mark Word，lock锁操作的是Unsafe类的park方法</li></ol></li></ol></li><li>JMM—Java Memory Model<ol><li>主内存<ol><li>存储Java实例对象</li><li>包括成员变量，类信息，常量，静态变量等</li><li>属于数据共享区域，多线程并发操作时会引发线程安全问题</li></ol></li><li>工作内存<ol><li>存储的是当前方法的所有本地变量信息，本地变量对其他线程不可见</li><li>字节码行号指示器，Native方法信息</li><li>属于线程私有数据区域，不存在线程安全问题</li></ol></li><li>区分Java内存划分<ol><li>JMM描述的是一组规则，围绕原子性，有序性，可见性展开</li><li>同Java内存相似，都存在共享区和私有区</li><li>方法里的基本数据类型和本地变量直接存储在工作内存的栈帧结构中</li><li>引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中</li><li>成员变量：static变量，类信息均会存储在主内存中</li></ol></li><li>指令重排序<ol><li>在单线程情况下不能改变程序运行的结果</li><li>存在数据依赖关系的不允许重排序</li><li>无法通过Happens-before原则推导出来的，才能进行指令重排序<ol><li>A操作的结果需要对B操作可见，则A和B存在happens-before关系</li><li>happens-before的原则<ol><li>程序次序规则：一个线程内，按照代码顺序，先写的代码先执行</li><li>锁定规则：一个unLock操作优先后面对同一个锁的lock操作</li><li>Volatile变量规则：一个变量的写操作优先于后面对这个变量的读操作</li><li>传递规则：如果A操作优于B操作，B操作优于C操作，那么A操作优于C操作</li><li>线程启动规则：Thread对象的start方法优先执行在该线程的每一个动作之前</li><li>线程中断规则：对线程interrupt方法的调用优于被中断线程的代码检测到中断事件前发生</li><li>线程终结规则：线程中所有的操作都优于线程终止检测事件</li><li>对象终结规则：一个对象的初始化完成优于其finalize方法执行</li></ol></li></ol></li></ol></li><li>Volatile<ol><li>JVM提供轻量级同步机制</li><li>由Volatile修饰的共享变量对所有线程总是可见的</li><li>禁止指令的重排序优化<ol><li>内存屏障<ol><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性</li></ol></li><li>通过插入内存屏障指令来禁止在内存屏障前后的指令执行重排序优化</li><li>强制刷出CPU的缓存数据，因此在cpu上的任何线程都能读取到这些数据的最新版本</li></ol></li><li>可见性分析<ol><li>定义一个Volatile变量时，JMM会把该线程对应的工作内存中的共享变量刷新到主内存中</li><li>读取一个Volatile变量时，JMM会把该线程对应的工作内存置为无效</li></ol></li></ol></li><li>Volatile和synchronized的区别<ol><li>Volatile本质是告知JVM当前变量在寄存器(工作内存)中的值不确定需要从主内存中读取，synchronized只是锁定当前变量</li><li>Volatile仅用于变量级别，synchronized可以用在变量，方法，类上</li><li>Volatile不会造成线程阻塞，synchronized会造成线程阻塞</li><li>Volatile标记的变量不会被编译器优化，synchronized标记的变量会被编译器优化</li></ol></li></ol></li><li>CAS(乐观所锁)—一种高效实现线程安全性的方法<ol><li>支持原子更新操作，适用于计数器，序列发生器等场景</li><li>属于乐观锁机制，号称lock-free</li><li>CAS操作失败 后开发者决定是否继续尝试，还是执行别的操作</li><li>包含三个操作数：内存位置，预期原值和新值</li><li>缺点<ol><li>若循环时间长，则开销大</li><li>只能保证一个共享变量的原子操作</li><li>ABA问题—一个变量A改变到B未被检测出来，导致两次读取的值都是A—通过AtomicStampedReference类改变</li></ol></li></ol></li></ol></li><li>线程池<ol><li>Executor接口<ol><li>Executor：运行新任务的简单接口，将任务提交和任务执行细节解耦</li><li>ExecutorService：具备管理执行器和任务生命周期的方法，提交任务 机制更完善</li><li>SchduledExecutorService：支持Future和定时任务</li></ol></li><li>5种不同场景的线程池创建<ol><li>newFixedThreadPool(int nThread)：指定工作线程数量的线程池</li><li>newCachedThreadPool()：短时间处理大量工作任务的线程池</li><li>newSingleThreadExecutor()：创建唯一的工作线程来执行任务，如果该线程一结束，会有另一个线程取代它</li><li>newSingleThreadScheduledExecutor()和newScheduledThreadExecutor(int corePoolSize)：定时或者周期性的工作调度线程池，两个的区别在于单一工作线程还是多线程</li><li>newWorkStealingPool()：内部构建ForkJoinPool，利用working-stealing算法，并行的执行任务，不保证处理顺序<ol><li>Fork/Join框架<ol><li>把大任务分割为有限的小任务执行，把每个小 任务的执行结果汇总得到大任务结果的框架</li></ol></li><li>work-stealing算法：某个线程从其他队列里窃取任务来执行</li></ol></li><li>确定线程池的大小<ol><li>CPU密集型：线程数=核数+1</li><li>IO密集型：线程数=核数*（1+平均等待时间/平均工作时间）</li></ol></li></ol></li><li>优势<ol><li>降低资源的消耗</li><li>提高线程的可管理性</li></ol></li><li>ThreadPoolExecutor构造函数<ol><li>corePoolSize：核心线程数量</li><li>maximunPoolSize：线程不够用时，最多可创建的线程数</li><li>workQueue：任务等待队列</li><li>keepAliveTime：抢占顺序不一定</li><li>ThreadFactory：创建新线程</li><li>Handler：线程池的饱和策略<ol><li>AbortPolicy：直接抛出异常，默认策略</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务，并执行当前任务</li><li>DiscardOldPolicy：丢弃队列中最靠前的任务，并执行当前任务</li><li>DiscardPolicy：直接丢弃任务</li><li>通过实现RejectedExecutorHandler接口来自定义Handler</li></ol></li></ol></li><li>executor流程<ol><li>如果线程数少于corePoolSize，则直接创建新线程来执行任务，即使线程池中其他线程是空闲的</li><li>如果线程池中的线程数量大于等于corePoolSize而小于maximumPoolSize，只有当workQueue满时才去创建新线程处理任务</li><li>如果corePoolSize和maximumPoolSize值相同，则创建的线程池大小固定的，这是如果有新任务，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取出任务并执行</li><li>如果运行的线程数大于等于maximumPoolSize，这时如果workQueue已满，则通过Handler所指定的策略来处理任务</li></ol></li><li>线程池的状态<ol><li>Runing：能够接受新任务提交，也可以处理阻塞队列中的任务</li><li>Shutdown：不在接受新提交的任务，但可以处理存量任务</li><li>Stop：不在接受新提交的任务，也不处理存量任务</li><li>Tidying：所有任务都已终止</li><li>Terminated：terminated方法执行后进入该状态(仅作标识)</li></ol></li></ol></li></ol></li></ol><h2 id="4-JVM"><a href="#4-JVM" class="headerlink" title="4. JVM"></a>4. JVM</h2><ol><li><p>Java跨平台原理</p><ul><li>基于不同平台的JVM实现，即在不同平台安装对应的JDK就能运行Java程序</li></ul></li><li><p>Java反射</p><ul><li>动态获取任意类，对象的属性和方法</li><li>这种在运行状态中动态获取信息以及调用对象方法的特性称为Java的反射机制</li><li>API：getDeclaredMethod(getMethod)：接收方法名，方法名对应的字节码对象</li><li>本质：把Java类中的方法和属性映射为Java对象</li></ul></li><li><p>类加载机制</p><ul><li>虚拟机将class文件加载进内存的行为</li><li>加载流程<ul><li>通过ClassLoader加载class字节码文件，生成class对象</li><li>检查class的正确性和安全性</li><li>为变量分配内存空间和设置初始值</li><li>JVM常量池中的符号引用转为直接引用</li><li>执行类变量赋值和静态代码块</li></ul></li><li>双亲委派机制<ul><li>一个类收到类加载请求时，会将请求委派给父类，如果父类不能加载才由子类去完成加载</li><li>避免同样的字节码文件被加载多次</li></ul></li><li>四种类加载器<ul><li>启动类加载器：用于加载Java的核心类库</li><li>扩展类加载器：用于加载Java的扩展库</li><li>系统类加载器：根据Java的类路径来加载Java类</li><li>用户自定义类加载器：通过继承Classloader类的方式实现</li></ul></li><li>LoaderClass和forName<ul><li>在运行时都能知道该类的属性和方法</li></ul></li></ul></li><li><p>内存结构 </p><ol><li>线程私有<ol><li>虚拟机栈，本地方法栈，程序计数器<ol><li>虚拟机栈<ol><li>Java方法执行的基础</li><li>包含多个栈帧(栈帧用于存储局部变量表，操作数栈，动态链接，方法出口)</li></ol></li><li>本地方法栈<ol><li>和虚拟机栈类似，主要用于标注native方法</li></ol></li><li>程序计数器<ol><li>当前线程所执行的字节码行号指示器(逻辑指示器)</li><li>改变计数器的值来选取下一条所需执行的字节码指令</li><li>和线程是一对一关系(即线程有)</li><li>对Java方法计数，如果是native方法则计数器值undefined</li></ol></li></ol></li></ol></li><li>线程共享<ol><li>堆<ol><li>对象实例的分配区域</li><li>GC管理的主要区域</li><li>JDK7以后常量池存在于堆中，方便GC(之前存在于永久代中，浪费内存)</li></ol></li><li>元空间(MetaSpace)和永久代(PermGen)—是方法区的实现<ol><li>都是用来存储class的相关信息</li><li>元空间使用的本地内存，而永久代使用的是JVM内存，所以元空间替代了永久代</li><li>字符串常量池存在于永久代中，容易出现性能问题和内存溢出</li><li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li><li>永久代为GC带来不必要的复杂性</li></ol></li><li>堆和栈的区别<ol><li>联系：引用对象，数组时，栈里定义变量保存在堆中的地址</li><li>管理方式：栈可以自动释放，堆需要GC</li><li>空间：栈比堆小</li><li>碎片：栈内存产生的碎片远小于堆</li><li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li><li>效率：栈的效率比堆高</li></ol></li></ol></li></ol></li><li><p>GC机制</p><ol><li>没有被其他对象引用时，就判定为垃圾</li><li>垃圾判定算法<ol><li>引用计数法<ol><li>通过判断对象的引用数量来决定对象是否可以被回收</li><li>为每个对象创建一个引用计数器，被引用的计数器值+1，完成引用后计数器值-1</li><li>当引用计数器值为0时，就认定该对象为垃圾</li><li>优点：执行效率高，程序执行受影响小</li><li>缺点：无法检测出循环引用的情况，导致内存泄漏(子类和父类之间循环引用，计数器值就没有为0的情况)</li></ol></li><li>可达性分析算法—基于图论<ol><li>判断对象的引用链是否可达，不可达就认定为垃圾</li><li>GC Root对象<ol><li>虚拟机栈中引用的对象(栈帧中的本地变量表)</li><li>方法区中常量引用的对象</li><li>方法区中静态属性引用的对象</li><li>本地方法栈中JNI(native方法)引用的对象</li><li>活跃线程引用的对象</li></ol></li></ol></li></ol></li><li>垃圾回收算法<ol><li>标记-清除算法<ol><li>标记：从跟集合进行扫描，对存活的对象进行标记</li><li>清除：对堆内存从到尾进行线程遍历，回收不可达的对象</li><li>缺点：产生碎片块多</li></ol></li><li>复制算法<ol><li>分为对象面和空闲面</li><li>对象在对象面上创建</li><li>将存活的对象从对象面复制到空闲面</li><li>将对象面的所有对象从内存中清除</li><li>优点<ol><li>解决碎片化问题</li><li>顺序分配内存，简单高效</li><li>适用于对象存活率低的场景(如年轻代)</li></ol></li></ol></li><li>标记-整理算法<ol><li>标记：从跟集合进行扫描，对存活的对象进行标记</li><li>整理：移动所有存活的对象，且按照内存地址依次排序，然后将末端内存地址以后的内存全部回收</li></ol></li><li>分代收集算法<ol><li>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法，提高了JVM的回收效率</li><li>JDK8以前分为年轻代，老年代，永久代；JDK8开始取消永久代</li><li>Minor GC发生在年轻代中的收集动作，采用的是复制算法<ol><li>尽可能快速的收集哪些生命周期短的对象</li><li>主要分为Eden区和两个Survivor区(包含一个from区和to区)[Eden:from:to=8:1:1]</li><li>每次触发GC后存活的对象年龄值+1，默认是15岁后进入老年代</li></ol></li><li>Full GC<ol><li>经历一定次数(默认是15次)的Minor GC后依然存活的对象开始进入老年代</li><li>Survivor区存放不下的大对象直接进入老年代</li><li>发生在老年代的收集动作，存放生命周期较长的对象；采用标记-清除算法和标记-整理算法</li><li>触发Full GC<ol><li>老年代和永久代空间不足</li><li>CMS GC时出现promotion failed，concurrent mode failure</li><li>Minor GC升级老年代的平均大小大于老年代的剩余空间</li><li>调用System.gc()方法—只是提醒虚拟机需要在这里进行回收，具体的回收操作由虚拟机自己决定</li><li>通过RMI来进行RPC或管理JDK引用，默认每1小时进行一次Full GC</li></ol></li></ol></li></ol></li><li>调优参数<ol><li>-XX:SurvivorRatio：设置Eden和Survivor的比值，默认是8:1</li><li>-XX:NewRatio：设置老年代和年轻代内存大小的比例</li><li>-XX:MaxTenuringThreshold：对象从年轻代升级为老年代需要出发Minor GC的次数</li></ol></li><li>Stop_the_World<ol><li>JVM由于要执行GC而停止了应用程序的执行</li><li>任何一种GC都会发生</li><li>通过避免减少Stop_the_World的发生时间来提高程序性能</li></ol></li><li>Safepoint(安全点)<ol><li>触发GC的快照点</li><li>分析过程中对象引用关系不会产生变化的点</li><li>Safepoint可能点：方法调用，循环跳转，异常跳转等</li><li>要确保安全点数量适中</li></ol></li></ol></li><li>垃圾收集器<ol><li>新生代垃圾收集器<ol><li>Serial收集器<ol><li>单线程收集，进行垃圾收集时，必须暂停所有的工作线程</li><li>简单高效，Client模式下默认的年轻代收集器</li></ol></li><li>ParNew收集器<ol><li>多线程收集器，其余和Serial相同</li><li>单线程执行效率不如Serial，在多核环境下才有优势</li></ol></li><li>Parallel Scavenge收集器<ol><li>更关注系统的吞吐量</li><li>在多核执行才有优势，Server模式下默认的年轻代收集器</li></ol></li></ol></li><li>老年代垃圾收集器<ol><li>Serial Old收集器<ol><li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li><li>简单高效，Client模式下默认的老年代收集器</li></ol></li><li>Parallel Old收集器<ol><li>多线程，吞吐量优先</li></ol></li><li>CMS收集器<ol><li>初始标记：Stop_the_World</li><li>并发标记：并发追溯标记，程序不会停顿</li><li>并发预清理：查找执行文件并发标记阶段从年轻代晋升老年代的对象</li><li>重新标记：暂停虚拟机，扫描CMS堆中的剩余对象</li><li>并发清理：清理垃圾对象，程序不会停顿</li><li>并发重置：重置CMS收集器的数据结构</li></ol></li><li>Garbage First收集器<ol><li>并发和并行</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li><li>将Java堆内存划分为多个大小相等的Region</li></ol></li><li>finalize方法</li><li>Java中的强引用，软引用，弱引用，虚引用<ol><li>强引用<ol><li>最普遍的引用，抛出OutMemoryError终止程序也不会回收具有强引用的对象</li><li>通过将对象置为null来弱化其引用，使其被回收</li></ol></li><li>软引用<ol><li>对象处于有用但非必须的状态</li><li>只有当空间不足时，GC会回收该引用对象的内存</li><li>用来实现高速缓存</li></ol></li><li>弱引用<ol><li>非必须引用对象，比软引用更弱一些</li><li>GC触发时会被回收</li><li>被回收的几率不大，因为GC线程的优先级比较低</li><li>适用于偶尔使用的对象</li></ol></li><li>虚引用<ol><li>不会决定对象的生命周期</li><li>任何时候都可能会被GC</li><li>用于跟踪垃圾回收器的回收活动，起到哨兵作用</li><li>必须和引用队列联合使用</li></ol></li><li>引用队列<ol><li>没有实际的存储结构，存储逻辑依赖于内部节点之间的关系来表达</li><li>存储关联被GC的软引用，弱引用，以及虚引用</li></ol></li><li>JVM调优<ol><li>调优参数含义<ol><li>-Xss：表示每个虚拟机栈(堆栈)的大小</li><li>-Xms：堆的初始值</li><li>-Xmx：堆能达到的最大值(一般情况下将-Xms和-Xmx值设置相同，避免扩容时的内存抖动而影响程序运行时的稳定性)</li></ol></li><li>内存分配策略<ol><li>静态存储：编译时确定每个数据目标在运行时的存储空间</li><li>栈式存储：数据区在编译时未知，运行时模块入口前确定</li><li>堆式存储：编译时或运行时模块入口都无法确定，动态分配</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li><li><p>内存溢出</p><blockquote><p>程序在申请内存的时候，没有足够的内存供其使用</p></blockquote><ul><li>死循环</li><li>递归</li><li>大对象太多，Java中的大对象是可以直接进入老年代的</li></ul></li><li></li></ol><h2 id="5-MySQL"><a href="#5-MySQL" class="headerlink" title="5. MySQL"></a>5. MySQL</h2><ol><li>关系型数据库<ul><li>数据库模块<ul><li>存储模块—OS文件系统(将数据持久化存储到硬盘，磁盘中)</li><li>程序实例—用逻辑结构来映射物理结构<ul><li>存储管理</li><li>缓存机制</li><li>sql解析模块</li><li>日志管理</li><li>权限划分</li><li>容灾机制</li><li>索引管理</li><li>锁管理</li></ul></li></ul></li></ul></li><li>索引<ul><li>作用：提高查询效率</li><li>实例：主键，唯一键(id)，让数据具备一定区分性的字段等可以作为索引</li><li>数据结构<ul><li>生成索引建立二叉树进行二分查找</li><li>生成索引建立B树结构进行查找</li><li>生成索引建立B+树结构进行查找</li><li>生成索引，建立hash结构进行查找</li></ul></li></ul></li><li>树结构介绍<ul><li>二叉查找树<ul><li>查询效率：O(logn)</li><li>左子树：左子树节点值均小于根节点值</li><li>右子树：右子树节点值均大于根节点值</li><li>注意：二叉树在有限次增删改之后会变成线性结构，此时查询效率为O(n)</li><li>解决：利用树的旋转特性，将二叉树转为平衡二叉树，这样查询效率会维持在O(logn)</li><li>平衡二叉树：大数据量情况下，由于每个节点只能有两个叶子节点，大大增加了树的层级和存储空间；会浪费大量的磁盘IO</li></ul></li><li>B树<ul><li>一种多路平衡查找树，每个节点最多有M个子节点，称为M阶B树，但至少有两个子节点</li><li>查询效率O(logn)</li></ul></li><li>B+树<ul><li>每个叶子节点的指针数和关键字数相同，同阶的B+树比B树能存储更多的关键字</li><li>优势<ul><li>磁盘读写代价更低</li><li>查询效率更为稳定</li><li>更有利于数据库的扫描(B+树只需遍历所有的叶子节点就能对全部的关键字进行扫描)</li></ul></li></ul></li><li>Hash索引<ul><li>根据Hash函数计算一次便能找到所需元素</li><li>仅仅满足=，in等等值查询，不能使用范围查询</li><li>不能进行排序操作，因为经过Hash运算后的值和运算前的键值对应，而查找是Hash索引对应的值，不能匹配到</li><li>不能避免全表 扫描</li></ul></li><li>BitMap<ul><li>仅Oracle支持</li><li>锁的粒度较大，新增和修改操作时，在同一位图的数据操作都会被阻塞</li></ul></li></ul></li><li>密集索引和稀疏索引<ul><li>密集索引：每个搜索码值都对应一个索引值</li><li>稀疏索引：只为索引码的某些值建立索引项</li></ul></li><li>InnoDB<ul><li>若一个主键被定义，则该主键则作为密集索引</li><li>若无主键定义，则该表第一个唯一非空索引值作为密集索引</li><li>若无以上，innodb内部会生成一个隐藏主键(密集索引)</li><li>数据和索引是存储在一起的，MyIsAM数据和索引是分开的</li></ul></li><li>优化步骤<ol><li>根据慢查询日志定位慢查询sql<ol><li>变量<ol><li>慢查询日志：slow_query_log</li><li>慢查询文件路径：slow_query_log_file</li><li>慢查询时间：long_query_time</li><li>开启慢查询日志：set global slow_query_log = on;</li></ol></li><li>状态<ol><li>slow_queries：慢查询数量</li></ol></li></ol></li><li>使用explain等工具分析 sql<ol><li>type：查找数据行的方式，index(索引)&gt;all(全表扫描)</li><li>extra：Using filesort和Using temporary意味着不走索引，应该进行优化</li></ol></li><li>修改sql或者尽量让sql走索引<ol><li>修改sql走索引</li><li>为查询字段添加索引</li></ol></li></ol></li><li>原则<ul><li>最左前缀匹配原则，mysql会一直向右匹配，直到范围限定，如果范围之间有索引，则只有第一个条件会走索引，其他不会走索引</li><li>=和in查询无需考虑索引顺序</li></ul></li></ol><p>索引相当于目录在书中的地位，内容远远多于目录时才适合建立。</p><ol><li><p>锁</p><ul><li><p>MyIsAM和InnoDB锁的区别</p><ul><li>MyIsAM默认使用表级锁，不支持行级锁</li><li>InnoDB默认使用行级锁，也支持表级锁</li></ul></li><li><p>排他锁和共享锁的区别</p><table><thead><tr><th></th><th>排他锁</th><th>共享锁</th></tr></thead><tbody><tr><td>排他锁</td><td>冲突</td><td>冲突</td></tr><tr><td>共享锁</td><td>冲突</td><td>兼容</td></tr></tbody></table></li><li><p>乐观锁和悲观锁</p></li><li><p>MyIsAM和InnoDB使用场景</p><ul><li>MyIsAM<ul><li>频繁的执行全表count语句</li><li>对数据进行增删频率不高，查询频率非常高</li><li>没有事务</li></ul></li><li>InnoDB<ul><li>数据增删改查的频率都非常频繁</li><li>可靠性要求比较高，要求支持事务</li></ul></li></ul></li><li><p>当前读和快照读</p></li><li><p>RC，RR级别下的InnoDB非阻塞读实现</p><ul><li>RR避免幻读，加行锁+Gap锁(gap锁用于非唯一索引和不走索引时)</li></ul></li></ul></li><li><p>事务的四大特性</p><ul><li>ACID</li><li>原子性，一致性，隔离性，持久性</li><li>隔离级别<ul><li>读已提交(RC)—解决脏读：一个事物读到另一个事务未提交的数据</li><li>可重复读(RR)—解决不重复读：一个数据前后两次读到的数据不一致</li><li>串行化—解决幻读：一个事物读到自己未提交的事务</li></ul></li></ul></li><li><p>锁的分类</p><ol><li>读锁又称为共享锁</li><li>写锁又称为排他锁</li><li>共享锁和排他锁，只有两个事务都是共享锁时不冲突</li><li>排他锁：增删改操作</li><li>共享锁：查询操作</li><li>悲观锁：在数据处理过程中将数据锁定，排他锁就是悲观锁的体现；为数据处理的安全性提供保证，同时也增加了产生死锁的机会</li><li>乐观锁：认为一般不会发生冲突，只有在更新数据时才会进行检测，如果冲突就返回错误信息(时间戳或数据版本)</li></ol></li><li><p>RC</p><ol><li>Oracle默认的提交方式</li><li>实现快照读(非阻塞读)<ol><li>数据行必须有DB_TRX_ID，DB_ROLL_PTR，DB_ROW_ID字段</li><li>undo日志</li><li>read view</li></ol></li></ol></li><li><p>RR</p><ol><li>MySQL默认的提交方式</li><li>行锁+gap锁</li><li>gap锁<ol><li>精确查找的时候，所有记录都有对应不会加gap锁</li><li>where条件部分命中，会加gap锁</li><li>用于非唯一索引或不走索引的当前读中</li></ol></li></ol></li><li><p>关键语法</p><ul><li>Group by<ul><li>Select语句中的列名必须为分组用到的列或列函数</li><li>只能是针对同一张表的字段进行分组</li></ul></li><li>having<ul><li>通常和Group By一起使用，where过滤行，having过滤组</li><li>如果省略了where，having的作用和where相同</li></ul></li></ul></li></ol><h2 id="6-Redis"><a href="#6-Redis" class="headerlink" title="6. Redis"></a>6. Redis</h2><ul><li>缓存中间件<ul><li>Memcache：代码层次类似于Hash<ul><li>支持简单的数据类型</li><li>不支持数据持久化存储和主从复制，以及分片</li></ul></li><li>Redis<ul><li>数据类型丰富</li><li>支持数据磁盘持久化和主从复制，以及分片</li><li>每秒100000+QPS，QPS即每秒内查询次数</li></ul></li></ul></li><li>为什么Redis速度快<ul><li>完全基于内存，没有磁盘IO操作，执行效率高</li><li>数据结构简单，对数据操作也简单</li><li>采用单线程也能处理高并发，多核也可以启动多实例</li><li>使用多了IO复用模型，即非阻塞式IO，采用多路复用函数</li></ul></li></ul><ol><li>数据类型<ul><li>String：基本数据类型，二进制安全</li><li>Hash：String组成的字典，适合存储对象</li><li>List：列表，按照String元素插入顺序排序</li><li>Set：String元素组成的无序集合，通过Hash表现，不允许重复</li><li>Sorted Set：通过分数类为集合中的成员进行从小到大的排序</li><li>HyperLogLog：用于支持存储地理位置信息</li></ul></li><li>大数据查询固定前缀的key<ul><li>使用scan count match key*</li></ul></li><li>分布式锁<ul><li>面临问题<ul><li>互斥性</li><li>安全性</li><li>死锁</li><li>容错</li></ul></li><li>解决<ul><li>使用set方法设置键的过期时间并给键添加一个随机字符，避免键集中过期时造成的卡顿</li></ul></li></ul></li><li>异步队列<ul><li>使用List做为队列，RPush产生消息，LPop消费消息<ul><li>缺点：没有等待队列有值就进行消费</li><li>解决<ol><li>通过应用层引入Sleep机制调用LPop重新消费</li><li>阻塞直到队列有消息或者超时；缺点：只能提供一个消费者消费</li><li>主题订阅模式；缺点：无法保证消息可达性</li></ol></li></ul></li></ul></li><li>持久化方式<ul><li>RDB<ul><li>保存某个时间点的全部数据快照方式，文件小，恢复快，数据丢失风险大</li><li>触发<ul><li>redis.conf文件配置的save m n定时触发</li><li>主从复制，主节点自动触发</li><li>执行Debug Reload时</li><li>执行Shutdown时</li></ul></li></ul></li><li>AOF<ul><li>保存到写状态，文件可读，适合保存增量数据；数据丢失风险小，但文件呢体积较大，恢复时间较长</li></ul></li><li>解决：混合模式—RDB做镜像的全量持久化，而AOF做增量的持久化</li></ul></li><li>主从同步<ul><li>Pipeline：批量执行Redis指令，节省多次IO往返的时间</li><li>同步原理 <ul><li>从节点发送同步命令到主节点</li><li>主节点启动一个后台进程，将Redis中的数据快照保存到文件中</li><li>主节点将保存数据快照期间接收到的写命令缓存起来</li><li>主节点完成文件操作后，将该文件发送给从节点</li><li>使用新的AOF文件替换旧的AOF文件</li><li>主节点将这期间收集的增量命令发送给从节点</li></ul></li></ul></li><li>集群<ul><li>哨兵<ul><li>主从复制的基石，由哨兵们监控集群状态，主节点宕机后根据定义规则选举新的主节点，保证系统的运行</li></ul></li><li>流言协议：在杂乱无章中寻求一致；用于主从切换<ul><li>消息节点向其他节点随机发送消息，最终消息会趋于一致性</li></ul></li><li>原理<ul><li>分片：按照一定规则划分数据，分散存储在多个节点上</li><li>获取：一致性哈希算法，对2^32取模，将hash值空间组成虚拟环</li></ul></li></ul></li></ol><h2 id="7-MongoDB"><a href="#7-MongoDB" class="headerlink" title="7. MongoDB"></a>7. MongoDB</h2><h2 id="8-Mybatis"><a href="#8-Mybatis" class="headerlink" title="8. Mybatis"></a>8. Mybatis</h2><h2 id="9-Spring"><a href="#9-Spring" class="headerlink" title="9. Spring"></a>9. Spring</h2><ol><li>IOC<ol><li>控制反转IOC：Spring最核心的部分，主要是用来创建对象</li><li>依赖注入DI：把第层类作为参数传递给上层类，实现上层对下层的”控制”<ol><li>是IOC的一种特殊实现</li><li>Setter</li><li>Interface</li><li>Constructor</li><li>Annotation</li></ol></li><li>依赖查找DL：IOC的另一种实现</li><li>优势<ol><li>避免在各处使用new来创建类，并且可以做到统一维护</li><li>创建实例的时候不需要了解其中的细节</li></ol></li><li>功能<ol><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调方法</li></ol></li><li>核心接口<ol><li>BeanDefinition：主要用来描述Bean的定义</li><li>BeanDefinitionRegistry：提供向IOC容器注册BeanDefinition对象的方法</li><li>BeanFactory：Spring最核心的接口<ol><li>提供IOC的配置机制</li><li>包含Bean的各种定义，便于实例化Bean</li><li>建立Bean之间的依赖关系</li><li>Bean生命周期的控制</li></ol></li><li>ApplicationContext<ol><li>继承BeanFactory接口，能够管理和装配Bean</li></ol></li></ol></li></ol></li><li>AOP</li></ol><h2 id="10-SpringMVC"><a href="#10-SpringMVC" class="headerlink" title="10. SpringMVC"></a>10. SpringMVC</h2><h2 id="11-Dubbo-zookeeper"><a href="#11-Dubbo-zookeeper" class="headerlink" title="11. Dubbo+zookeeper"></a>11. Dubbo+zookeeper</h2><h2 id="12-SpringCloud"><a href="#12-SpringCloud" class="headerlink" title="12. SpringCloud"></a>12. SpringCloud</h2><h2 id="13-网络基础"><a href="#13-网络基础" class="headerlink" title="13. 网络基础"></a>13. 网络基础</h2><ol><li><p>OSI网络基础</p><ul><li><p>七层模型</p><ul><li>物理层：电子接口通信信道上的原始比特流传输</li><li>数据链路层：将原始比特流转为逻辑传输线路</li><li>网络层：控制子网的运行，分组传输，路由选择</li><li>传输层：保证会话层的数据段有效的到达网络层</li><li>会话层：建立和管理应用层的会话</li><li>表示层：</li></ul></li><li><p>TCP</p><ul><li><p>流程</p><ul><li>面向连接的，可靠的，基于字节流的传输层通信协议</li><li>将应用层的数据流分割为报文段并发送给目标节点的TCP层</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和来检验数据在传输过程中是否有误</li></ul></li><li><p>标识</p><ul><li>URG：紧急指针标志</li><li>ACK：确认序号标志</li><li>PSH：push标志</li><li>PST：重置连接标志</li><li>SYN：同步序号，用于建立连接过程</li><li>FIN：finish标志，用于释放连接</li></ul></li><li><p>三次握手</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%8A%B6%E6%80%81.png"></p><ul><li>说明<ul><li>建立连接时，客户端发送syn包到服务器，并进入syn_send状态，等待服务器确认。</li><li>服务器收到syn包，必须确认客户的syn包为接收值+1，同时自己也发送一个syn包，即syn+ack包，此时服务器进入syn_recv状态</li><li>客户端受到服务器的syn+ack包，向服务器发送确认包ack为接收服务的值+1，此时包发送完毕，客户端和服务器端进入restablished状态完成三次握手</li></ul></li></ul></li><li><p>四次挥手</p><p><img src="https://cdn.jsdelivr.net/gh/codeOfMjh/picgo@main/images/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p><ul><li>说明<ul><li>客户端发送fin字段来请求关闭连接到服务器，客户端进入fin_wait_1状态</li><li>服务器端接收到fin字段后，发送ack给客户端，确认序号为收到的序号+1，此时服务器进入close_wait状态</li><li>服务器发送fin字段，用来关闭服务器到客户端的数据传送，服务器进入last_ack状态</li><li>客户端收到fin后，进入time_wait状态，向服务器发送ack确认序号为收到序号+1，服务器进入closed状态，完成四次挥手</li></ul></li><li>服务器出现close_wait状态的原因<ul><li>服务器端未进行释放资源的操作</li><li>处理请求的线程配置不合理</li></ul></li></ul></li></ul></li><li><p>UDP</p><ul><li>特点<ul><li>面向非连接，不维护连接状态，支持同时向多个客户端传输相同的消息</li><li>数据包报头只有8个字节，额外开销小</li><li>吞吐量只受限于数据生成的速率，传输速率以及机器性能</li><li>尽最大努力交付，不保证交付的可靠性，不需要维持复杂的连接状态</li><li>面向报文，不对应用程序提交报文信息进行拆分合并</li></ul></li></ul></li><li><p>TCP和UDP对比</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>TCP</td><td>1. 面向连接<br>2. 传输可靠<br>3. 传输有序</td><td>1. 传输速度慢<br>2. 重量级传输协议</td></tr><tr><td>UDP</td><td>1. 传输速度高<br>2. 轻量级传输协议</td><td>1. 面向无连接<br>2. 不保证可靠性<br>3. 不保证有序性</td></tr></tbody></table></li><li><p>TCP的滑动窗口</p><blockquote><p>TCP使用滑动窗口做流量控制与乱序重排</p></blockquote><ul><li>保证TCP的可靠性</li><li>保证TCP的流控特性</li></ul></li></ul></li><li><p>HTTP</p><ul><li><p>特点</p><ul><li>支持客户和服务器模式</li><li>简单快速灵活</li><li>无连接，无状态</li></ul></li><li><p>步骤</p><ul><li>根据DNS解析的域名地址访问服务器</li><li>和服务器之间建立TCP连接(三次握手)</li><li>客户端发送HTTP请求到web服务器</li><li>服务器接收请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>浏览器释放连接(四次挥手)</li></ul></li><li><p>状态码</p><ul><li>200：请求成功</li><li>401：未授权</li><li>403：服务被拒绝</li><li>404：未找到资源</li><li>500：服务器端错误，代码异常</li><li>503：服务器当前不能处理请求，需要等待，常见于服务启动尚未被注册中心发现。</li></ul></li><li><p>get和post的区别</p><table><thead><tr><th></th><th>get</th><th>post</th></tr></thead><tbody><tr><td>HTTP报文</td><td>将请求信息放在URL地址栏中</td><td>放在报文主体中</td></tr><tr><td>数据库</td><td>符合幂等性和安全性</td><td>不符合</td></tr><tr><td>其他</td><td>可以被缓存，被存储</td><td>不可以被缓存存储</td></tr></tbody></table></li><li><p>cookie和session的区别</p><ul><li>cookie保存在客户端浏览器相对不安全，大小为4k限制 </li><li>session保存在服务器端相对安全，借助于cookie实现，无大小限制</li></ul></li></ul></li><li><p>HTTPS</p><ul><li>加密<ul><li>对称加密：加密和解密都使用同一个密钥</li><li>非对称加密：加密使用的密钥和解密使用的密钥不同</li><li>哈希算法：将任意长度值的信息转换为固定长度的汉字，算法不可逆，常见的是MD5</li><li>数字签名：证明某个消息或者文件是某人发出/认同的</li></ul></li><li>HTTPS流程<ul><li>浏览器将支持的加密算法信息发送给服务器</li><li>服务器选择一套浏览器支持的加密算法，以证书的形式发送给浏览器</li><li>浏览器验证证书的合法性，并结合证书公钥加密信息发送给服务器</li><li>服务器使用私钥解密信息，验证哈希，加密响应消息发送给浏览器</li><li>浏览器解密响应消息，并对消息验证真假，之后进行加密交互数据</li></ul></li></ul></li><li><p>HTTP和HTTPS区别</p><table><thead><tr><th></th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>证书</td><td>不需要CA证书</td><td>需要到CA申请证书</td></tr><tr><td>传输</td><td>明文传输</td><td>密文传输<br>使用HTTP+加密+认证+完整性保护</td></tr><tr><td>端口</td><td>使用80端口</td><td>使用443端口</td></tr></tbody></table></li><li><p>socket</p><blockquote><p>是TCP/IP协议的抽象，是操作系统对外开放的接口</p></blockquote></li><li><p>Linux</p><ol><li>查找指定文件：find path [options] params</li><li>查找符合条件的文本：grep [options] pattern file</li><li>对文件内容进行统计：awk [options] cmd file</li><li>批量替换文档内容：sed [options] ‘sed command’ filename</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.nginx</title>
      <link href="2020/11/21/4-nginx/"/>
      <url>2020/11/21/4-nginx/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 服务器与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.network</title>
      <link href="2020/11/21/4-network/"/>
      <url>2020/11/21/4-network/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 服务器与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.zookeeper</title>
      <link href="2020/11/21/3-zookeeper/"/>
      <url>2020/11/21/3-zookeeper/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.SpringCloud</title>
      <link href="2020/11/21/3-springcloud/"/>
      <url>2020/11/21/3-springcloud/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.Redis</title>
      <link href="2020/11/21/3-redis/"/>
      <url>2020/11/21/3-redis/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.MongoDB</title>
      <link href="2020/11/21/3-mongodb/"/>
      <url>2020/11/21/3-mongodb/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.Dubbo</title>
      <link href="2020/11/21/3-dubbo/"/>
      <url>2020/11/21/3-dubbo/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.SpringMVC</title>
      <link href="2020/11/21/2-springmvc/"/>
      <url>2020/11/21/2-springmvc/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SSM框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.SpringBoot</title>
      <link href="2020/11/21/2-springboot/"/>
      <url>2020/11/21/2-springboot/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SSM框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.Spring</title>
      <link href="2020/11/21/2-spring/"/>
      <url>2020/11/21/2-spring/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SSM框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.Mybatis</title>
      <link href="2020/11/21/2-mybatis/"/>
      <url>2020/11/21/2-mybatis/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SSM框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.Oracle</title>
      <link href="2020/11/21/1-oracle/"/>
      <url>2020/11/21/1-oracle/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.MySQL</title>
      <link href="2020/11/21/1-mysql/"/>
      <url>2020/11/21/1-mysql/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.MyCat</title>
      <link href="2020/11/21/1-mycat/"/>
      <url>2020/11/21/1-mycat/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0.multithreading</title>
      <link href="2020/11/21/0-multithreading/"/>
      <url>2020/11/21/0-multithreading/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0.JVM</title>
      <link href="2020/11/21/0-jvm/"/>
      <url>2020/11/21/0-jvm/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0.JavaSenior</title>
      <link href="2020/11/21/0-javasenior/"/>
      <url>2020/11/21/0-javasenior/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0.JavaBase</title>
      <link href="2020/11/21/0-javabase/"/>
      <url>2020/11/21/0-javabase/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a>1. 基本数据类型</h2><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2019/11/01/hello-world/"/>
      <url>2019/11/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
